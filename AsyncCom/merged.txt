
--- AssemblyInfo.cs ---

﻿using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Permissions;

[assembly: AssemblyTitle("AsyncCom")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("ZENNER")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyFileVersion("1.3.0.0")]
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
[assembly: ComVisible(false)]
[assembly: Guid("c7a7686f-c6d7-4c14-9f08-c828fdc344cc")]
[assembly: AssemblyVersion("1.3.0.0")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]


--- AsyncComConnectionType.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.AsyncComConnectionType
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

#nullable disable
namespace AsyncCom
{
  public enum AsyncComConnectionType
  {
    COM,
    Remote,
    Remote_VPN,
  }
}


--- AsyncComRes.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.AsyncComRes
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.Resources;
using System.Runtime.CompilerServices;

#nullable disable
namespace AsyncCom
{
  [GeneratedCode("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
  [DebuggerNonUserCode]
  [CompilerGenerated]
  internal class AsyncComRes
  {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;

    internal AsyncComRes()
    {
    }

    [EditorBrowsable(EditorBrowsableState.Advanced)]
    internal static ResourceManager ResourceManager
    {
      get
      {
        if (AsyncComRes.resourceMan == null)
          AsyncComRes.resourceMan = new ResourceManager("AsyncCom.AsyncComRes", typeof (AsyncComRes).Assembly);
        return AsyncComRes.resourceMan;
      }
    }

    [EditorBrowsable(EditorBrowsableState.Advanced)]
    internal static CultureInfo Culture
    {
      get => AsyncComRes.resourceCulture;
      set => AsyncComRes.resourceCulture = value;
    }

    internal static Bitmap RefreshButton
    {
      get
      {
        return (Bitmap) AsyncComRes.ResourceManager.GetObject(nameof (RefreshButton), AsyncComRes.resourceCulture);
      }
    }
  }
}


--- AsyncFunctions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.AsyncFunctions
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using MinoConnect;
using NLog;
using StartupLib;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.IO;
using System.IO.Ports;
using System.Resources;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace AsyncCom
{
  public class AsyncFunctions : 
    IAsyncFunctions,
    I_ZR_Component,
    ILockable,
    ICancelable,
    IWindow,
    IReadoutConfig
  {
    private static NLog.Logger logger = LogManager.GetLogger(nameof (AsyncFunctions));
    internal bool IsPluginObject = false;
    internal AsyncFunctionsBase MyComType;
    internal AsyncComConnectionType ConnectionTypeSelected = AsyncComConnectionType.COM;
    internal ResourceManager MyRes = new ResourceManager("AsyncCom.AsyncComRes", typeof (AsyncFunctions).Assembly);
    public EventLogger Logger = new EventLogger();
    internal MeterVPN MyMeterVPN = new MeterVPN();
    internal ZR_AsyncCom ComWindow;
    internal const int AnswerOffsetTime_default = 0;
    internal const int TransTime_GlobalOffset_default = 0;
    internal const int RecTime_GlobalOffset_default = 0;
    internal const int RecTime_BeforFirstByte_default = 400;
    internal const double RecTime_OffsetPerByte_default = 0.0;
    internal const int RecTime_OffsetPerBlock_default = 50;
    internal const int RecTransTime_default = 10;
    internal const int BreakIntervalTime_default = 10000;
    internal const int TransTime_BreakTime_default = 700;
    internal const int TransTime_AfterBreak_default = 50;
    internal const int TransTime_AfterOpen_default = 200;
    internal const int WaitBeforeRepeatTime_default = 200;
    private string ComPortUsed = "COM1";
    private int BaudrateUsed = 0;
    private string ParityUsed = "even";
    internal bool HardwareHandshake = false;
    internal bool ComIsOpen = false;
    internal WakeupSystem Wakeup = WakeupSystem.None;
    internal string transceiverDeviceInfo = "";
    internal bool UseMinoConnect = false;
    internal int MinoConnectAutoPowerOffTime = 1000;
    internal MinoConnectState.BaseStateEnum MinoConnectBaseState = MinoConnectState.BaseStateEnum.off;
    internal bool IgnoreReceiveErrorsOnTransmitTime = false;
    internal bool TestEcho = true;
    internal bool EchoOn = false;
    public bool EchoTestIsActive = false;
    public bool ErrorMessageBox = false;
    internal bool MBusFrameTestWindowOn = false;
    internal bool IrDa = false;
    public bool IrDaDaveTailSide = false;
    internal int MainThreadId;
    internal double ByteTime;
    internal int RecTime_BeforFirstByte;
    internal double RecTime_OffsetPerByte;
    internal int RecTime_OffsetPerBlock;
    internal int RecTime_GlobalOffset;
    internal int TransTime_GlobalOffset;
    internal int RecTransTime;
    internal int TransTime_BreakTime;
    internal int TransTime_AfterBreak;
    internal int TransTime_AfterOpen;
    public int WakeupIntervalTime;
    public int WaitBeforeRepeatTime;
    internal int AnswerOffsetTime;
    private Version ComponentVersion = new Version();
    public DateTime LastWakeupRefreshTime = DateTime.MinValue;
    internal DateTime LastTransmitEndTime = DateTime.MinValue;
    private DateTime EarliestTransmitTimeAbsolut = DateTime.MinValue;
    private static volatile string ownerOfLock;
    private bool readoutConfigByBusFile = false;
    internal StringBuilder LineBuffer = new StringBuilder(210);
    private ConfigList ConfigList;

    public event EventHandler<GMM_EventArgs> OnAsyncComMessage;

    public event System.EventHandler ConnectionLost;

    public event System.EventHandler BatterieLow;

    public bool WakeupTemporaryOff { get; set; }

    public ZR_ClassLibrary.TransceiverDevice Transceiver { get; set; }

    public bool ReadoutConfigByBusFile
    {
      get => this.readoutConfigByBusFile;
      set
      {
        this.readoutConfigByBusFile = value;
        if (!this.readoutConfigByBusFile)
          return;
        this.DisableConfigList();
      }
    }

    public bool BreakRequest { get; set; }

    public long InputBufferLength => this.MyComType.InputBufferLength;

    public int MinoConnectIrDaPulseLength { get; set; }

    internal int Baudrate
    {
      get => this.BaudrateUsed;
      set
      {
        if (value == this.BaudrateUsed)
          return;
        this.BaudrateUsed = value;
        this.ByteTime = 1000.0 / (double) this.Baudrate * 11.0;
        if (this.ComIsOpen && (!(this.MyComType is AsyncSerial) || !(((AsyncSerial) this.MyComType).MySerialPort is MinoConnectSerialPort)))
          this.Close();
      }
    }

    public DateTime FirstCalculatedEarliestTransmitTime { get; set; }

    internal DateTime EarliestTransmitTime
    {
      set
      {
        if (!(value > this.EarliestTransmitTimeAbsolut))
          return;
        this.EarliestTransmitTimeAbsolut = value;
      }
      get => this.EarliestTransmitTimeAbsolut;
    }

    internal string Parity
    {
      get => this.ParityUsed;
      set
      {
        if (!(value != this.ParityUsed))
          return;
        this.ParityUsed = value;
        if (this.ComIsOpen && (!(this.MyComType is AsyncSerial) || !(((AsyncSerial) this.MyComType).MySerialPort is MinoConnectSerialPort)))
          this.Close();
      }
    }

    internal string ComPort
    {
      get => this.ComPortUsed;
      set
      {
        if (!(value != this.ComPortUsed))
          return;
        this.ComPortUsed = value;
        if (this.ComIsOpen)
          this.Close();
        if (this.ConfigList != null && this.ConfigList.Port != this.ComPortUsed)
          this.ConfigList.Port = this.ComPortUsed;
      }
    }

    public AsyncFunctions() => this.BaseConstructor(true);

    public AsyncFunctions(bool noComWindow) => this.BaseConstructor(noComWindow);

    private void BaseConstructor(bool noComWindow)
    {
      this.BreakRequest = false;
      this.Transceiver = ZR_ClassLibrary.TransceiverDevice.None;
      this.MainThreadId = Thread.CurrentThread.ManagedThreadId;
      this.Baudrate = 2400;
      this.SetDefaultTiming(this.Baudrate);
      if (noComWindow)
      {
        this.ComWindow = (ZR_AsyncCom) null;
        this.ComponentVersion = (Version) null;
      }
      else
        this.ComWindow = new ZR_AsyncCom(this);
    }

    public bool IsLocked => !string.IsNullOrEmpty(AsyncFunctions.ownerOfLock);

    public void Lock(string owner) => AsyncFunctions.ownerOfLock = owner;

    public void Unlock() => AsyncFunctions.ownerOfLock = string.Empty;

    public string Owner => AsyncFunctions.ownerOfLock;

    public static bool IsSettingsEqual(
      SortedList<AsyncComSettings, object> settings,
      AsyncComSettings key,
      string value)
    {
      return settings != null && settings.ContainsKey(key) && settings[key] != null && settings[key].ToString() == value;
    }

    internal void AsyncComMessageBox(string Message)
    {
      int num = (int) GMM_MessageBox.ShowMessage("AsyncCom", Message, true);
    }

    public void ShowErrorMessageBox(bool on) => this.ErrorMessageBox = on;

    public void SetAnswerOffsetTime(int NewAnswerOffsetTime)
    {
      this.AnswerOffsetTime = NewAnswerOffsetTime;
    }

    public void ComWriteLoggerEvent(EventLogger.LoggerEvent Event)
    {
      this.Logger.WriteLoggerEvent(Event);
    }

    public void ComWriteLoggerData(EventLogger.LoggerEvent Event, ref ByteField data)
    {
      this.Logger.WriteLoggerData(Event, ref data);
    }

    public string ShowComWindow(string ComponentList)
    {
      if (this.ComWindow == null)
        this.ComWindow = new ZR_AsyncCom(this);
      else
        this.ComWindow.SetComState();
      this.ComWindow.InitStartMenu(ComponentList);
      int num = (int) this.ComWindow.ShowDialog();
      return this.ComWindow.StartComponentName;
    }

    public void ShowComWindow()
    {
      if (this.ComWindow == null)
        this.ComWindow = new ZR_AsyncCom(this);
      else
        this.ComWindow.SetComState();
      int num = (int) this.ComWindow.ShowDialog();
    }

    public bool ShowComWindowChanged()
    {
      if (this.ComWindow == null)
        this.ComWindow = new ZR_AsyncCom(this);
      else
        this.ComWindow.SetComState();
      return this.ComWindow.ShowDialog() == DialogResult.OK;
    }

    public string SingleParameter(CommParameter Parameter, string ParameterValue)
    {
      string str1 = "";
      bool flag = ParameterValue != null && ParameterValue.Length != 0;
      try
      {
        switch (Parameter)
        {
          case CommParameter.Type:
            str1 = this.ConnectionTypeSelected.ToString();
            if (flag && (this.MyComType == null || ParameterValue != str1))
            {
              switch (ParameterValue)
              {
                case "AsynchronSeriell":
                  this.SetType(AsyncComConnectionType.COM);
                  break;
                case "AsynchronIP":
                  this.SetType(AsyncComConnectionType.Remote);
                  break;
                default:
                  this.SetType((AsyncComConnectionType) Enum.Parse(typeof (AsyncComConnectionType), ParameterValue, false));
                  break;
              }
              break;
            }
            break;
          case CommParameter.Baudrate:
            str1 = this.Baudrate.ToString();
            if (flag)
            {
              this.Baudrate = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.COMserver:
            str1 = this.MyMeterVPN.SelectedCOMserver;
            if (flag)
            {
              this.MyMeterVPN.SelectedCOMserver = ParameterValue;
              break;
            }
            break;
          case CommParameter.Port:
            str1 = this.ComPort.ToString();
            if (flag)
            {
              this.ComPort = !char.IsDigit(ParameterValue[0]) ? ParameterValue : "COM" + ParameterValue;
              break;
            }
            break;
          case CommParameter.Parity:
            str1 = this.Parity;
            if (flag)
            {
              this.Parity = ParameterValue;
              break;
            }
            break;
          case CommParameter.UseBreak:
            str1 = this.Wakeup != WakeupSystem.Break ? false.ToString() : true.ToString();
            if (flag)
            {
              this.Wakeup = !bool.Parse(ParameterValue) ? WakeupSystem.None : WakeupSystem.Break;
              break;
            }
            break;
          case CommParameter.EchoOn:
            str1 = this.EchoOn.ToString();
            if (flag)
            {
              this.EchoOn = bool.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.TestEcho:
            str1 = this.TestEcho.ToString();
            if (flag)
            {
              this.TestEcho = bool.Parse(ParameterValue);
              if (this.ComWindow != null)
                this.ComWindow.ShowEcho();
              break;
            }
            break;
          case CommParameter.RecTime_BeforFirstByte:
            str1 = this.RecTime_BeforFirstByte.ToString();
            if (flag)
            {
              this.RecTime_BeforFirstByte = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.RecTime_OffsetPerByte:
            str1 = this.RecTime_OffsetPerByte.ToString((IFormatProvider) FixedFormates.TheFormates);
            if (flag)
            {
              this.RecTime_OffsetPerByte = double.Parse(ParameterValue, (IFormatProvider) FixedFormates.TheFormates);
              break;
            }
            break;
          case CommParameter.RecTime_GlobalOffset:
            str1 = this.RecTime_GlobalOffset.ToString();
            if (flag)
            {
              this.RecTime_GlobalOffset = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.TransTime_GlobalOffset:
            str1 = this.TransTime_GlobalOffset.ToString();
            if (flag)
            {
              this.TransTime_GlobalOffset = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.RecTransTime:
            str1 = this.RecTransTime.ToString();
            if (flag)
            {
              this.RecTransTime = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.TransTime_BreakTime:
            str1 = this.TransTime_BreakTime.ToString();
            if (flag)
            {
              this.TransTime_BreakTime = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.TransTime_AfterOpen:
            str1 = this.TransTime_AfterOpen.ToString();
            if (flag)
            {
              this.TransTime_AfterOpen = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.TransTime_AfterBreak:
            str1 = this.TransTime_AfterBreak.ToString();
            if (flag)
            {
              this.TransTime_AfterBreak = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.WaitBeforeRepeatTime:
            str1 = this.WaitBeforeRepeatTime.ToString();
            if (flag)
            {
              this.WaitBeforeRepeatTime = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.BreakIntervalTime:
            str1 = this.WakeupIntervalTime.ToString();
            if (flag)
            {
              this.WakeupIntervalTime = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.MinoConnectTestFor:
            str1 = this.Transceiver != ZR_ClassLibrary.TransceiverDevice.MinoConnect ? false.ToString() : true.ToString();
            if (flag)
            {
              this.Transceiver = !bool.Parse(ParameterValue) ? ZR_ClassLibrary.TransceiverDevice.None : ZR_ClassLibrary.TransceiverDevice.MinoConnect;
              break;
            }
            break;
          case CommParameter.MinoConnectPowerOffTime:
            str1 = this.MinoConnectAutoPowerOffTime.ToString();
            if (flag)
            {
              this.MinoConnectAutoPowerOffTime = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.Wakeup:
            str1 = this.Wakeup.ToString();
            if (flag)
            {
              this.Wakeup = (WakeupSystem) Enum.Parse(typeof (WakeupSystem), ParameterValue, false);
              break;
            }
            break;
          case CommParameter.TransceiverDevice:
            str1 = this.Transceiver.ToString();
            if (flag)
            {
              this.Transceiver = (ZR_ClassLibrary.TransceiverDevice) Enum.Parse(typeof (ZR_ClassLibrary.TransceiverDevice), ParameterValue, true);
              break;
            }
            break;
          case CommParameter.ForceMinoConnectState:
            str1 = "";
            if (flag)
            {
              this.MinoConnectBaseState = MinoConnectState.GetBaseStateFromPlugState((MinoConnectState.MinoConnectPlugState) Enum.Parse(typeof (MinoConnectState.MinoConnectPlugState), ParameterValue, false));
              break;
            }
            break;
          case CommParameter.IrDaSelection:
            str1 = !this.IrDa ? IrDaSelection.None.ToString() : (!this.IrDaDaveTailSide ? IrDaSelection.RoundSide.ToString() : IrDaSelection.DoveTailSide.ToString());
            if (flag)
            {
              switch ((IrDaSelection) Enum.Parse(typeof (IrDaSelection), ParameterValue, false))
              {
                case IrDaSelection.DoveTailSide:
                  this.IrDa = true;
                  this.IrDaDaveTailSide = true;
                  break;
                case IrDaSelection.RoundSide:
                  this.IrDa = true;
                  this.IrDaDaveTailSide = false;
                  break;
                default:
                  this.IrDa = false;
                  this.IrDaDaveTailSide = false;
                  break;
              }
              break;
            }
            break;
          case CommParameter.HardwareHandshake:
            str1 = this.HardwareHandshake.ToString();
            if (flag)
            {
              if (bool.Parse(ParameterValue) != this.HardwareHandshake)
              {
                this.Close();
                this.HardwareHandshake = bool.Parse(ParameterValue);
              }
              break;
            }
            break;
          case CommParameter.MinoConnectIsUSB:
            str1 = "";
            break;
          case CommParameter.MinoConnectIrDaPulseTime:
            str1 = this.MinoConnectIrDaPulseLength.ToString();
            if (flag)
            {
              this.MinoConnectIrDaPulseLength = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.RecTime_OffsetPerBlock:
            str1 = this.RecTime_OffsetPerBlock.ToString();
            if (flag)
            {
              this.RecTime_OffsetPerBlock = int.Parse(ParameterValue);
              break;
            }
            break;
          case CommParameter.MinoConnectBaseState:
            str1 = this.MinoConnectBaseState.ToString();
            if (flag)
            {
              this.MinoConnectBaseState = (MinoConnectState.BaseStateEnum) Enum.Parse(typeof (MinoConnectState.BaseStateEnum), ParameterValue, false);
              break;
            }
            break;
        }
      }
      catch (Exception ex)
      {
        string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
        AsyncFunctions.logger.Error(ex, message);
        string str2 = "** Parameter value error **\r\n" + "\r\nParameter name: " + Parameter.ToString() + "\r\nParameter value: " + ParameterValue;
        this.AsyncComMessageBox(message + " " + str2);
      }
      return str1;
    }

    public string SingleParameter(string ParameterName, string ParameterValue)
    {
      return !new List<string>((IEnumerable<string>) ZR_ClassLibrary.Util.GetNamesOfEnum(typeof (CommParameter))).Contains(ParameterName) ? string.Empty : this.SingleParameter((CommParameter) Enum.Parse(typeof (CommParameter), ParameterName, true), ParameterValue);
    }

    public void GetCommParameter(ref ArrayList ParameterList)
    {
      ParameterList.Clear();
      for (int Parameter = 0; Parameter != 29; ++Parameter)
      {
        CommParameter commParameter = (CommParameter) Parameter;
        string str1 = commParameter.ToString();
        string str2 = str1;
        commParameter = CommParameter.UseBreak;
        string str3 = commParameter.ToString();
        if (!(str2 == str3))
        {
          string str4 = str1;
          commParameter = CommParameter.MinoConnectTestFor;
          string str5 = commParameter.ToString();
          if (!(str4 == str5))
          {
            string str6 = str1;
            commParameter = CommParameter.MinoConnectIsUSB;
            string str7 = commParameter.ToString();
            if (!(str6 == str7))
            {
              string str8 = this.SingleParameter((CommParameter) Parameter, string.Empty);
              ParameterList.Add((object) str1);
              ParameterList.Add((object) str8);
            }
          }
        }
      }
    }

    public SortedList<AsyncComSettings, object> GetAsyncComSettings()
    {
      ArrayList ParameterList = new ArrayList();
      this.GetCommParameter(ref ParameterList);
      if (ParameterList == null || ParameterList.Count % 2 != 0)
        return (SortedList<AsyncComSettings, object>) null;
      SortedList<AsyncComSettings, object> asyncComSettings = new SortedList<AsyncComSettings, object>();
      for (int index = 0; index < ParameterList.Count; index += 2)
      {
        if (Enum.IsDefined(typeof (AsyncComSettings), ParameterList[index]))
        {
          AsyncComSettings key = (AsyncComSettings) Enum.Parse(typeof (AsyncComSettings), ParameterList[index].ToString(), true);
          object obj = ParameterList[index + 1];
          asyncComSettings.Add(key, obj);
        }
      }
      return asyncComSettings;
    }

    public SortedList<string, string> GetAsyncComSettingsList()
    {
      SortedList<string, string> asyncComSettingsList = new SortedList<string, string>();
      ArrayList ParameterList = new ArrayList();
      this.GetCommParameter(ref ParameterList);
      if (ParameterList == null || ParameterList.Count % 2 != 0)
        return (SortedList<string, string>) null;
      for (int index = 0; index < ParameterList.Count; index += 2)
      {
        if (Enum.IsDefined(typeof (AsyncComSettings), ParameterList[index]))
        {
          string key = ParameterList[index].ToString();
          string str = ParameterList[index + 1].ToString();
          asyncComSettingsList.Add(key, str);
        }
      }
      return asyncComSettingsList;
    }

    public string GetAsyncComSettingsAsString()
    {
      ArrayList ParameterList = new ArrayList();
      this.GetCommParameter(ref ParameterList);
      if (ParameterList == null || ParameterList.Count % 2 != 0)
        throw new Exception("Illegal AsyncCom settings");
      StringBuilder stringBuilder = new StringBuilder();
      for (int index = 0; index < ParameterList.Count; index += 2)
      {
        if (Enum.IsDefined(typeof (AsyncComSettings), ParameterList[index]))
        {
          string str1 = ParameterList[index].ToString();
          string str2 = ParameterList[index + 1].ToString();
          if (stringBuilder.Length > 0)
            stringBuilder.Append(";");
          stringBuilder.Append(str1 + ";" + str2);
        }
      }
      return stringBuilder.ToString();
    }

    public bool SetAsyncComSettings(string asyncComSettings)
    {
      if (string.IsNullOrEmpty(asyncComSettings))
        return false;
      string[] strArray = asyncComSettings.Split(';');
      if (strArray.Length == 0)
        return false;
      SortedList<string, string> asyncComSettings1 = new SortedList<string, string>();
      for (int index = 0; index + 1 < strArray.Length; index += 2)
      {
        if (!asyncComSettings1.ContainsKey(strArray[index]))
          asyncComSettings1.Add(strArray[index], strArray[index + 1]);
      }
      return this.SetAsyncComSettings(asyncComSettings1);
    }

    public bool SetAsyncComSettings(
      SortedList<AsyncComSettings, object> asyncComSettings)
    {
      if (asyncComSettings == null)
        return false;
      SortedList<string, string> asyncComSettings1 = new SortedList<string, string>();
      foreach (KeyValuePair<AsyncComSettings, object> asyncComSetting in asyncComSettings)
        asyncComSettings1.Add(asyncComSetting.Key.ToString(), asyncComSetting.Value.ToString());
      return this.SetAsyncComSettings(asyncComSettings1);
    }

    public bool SetAsyncComSettings(SortedList<string, string> asyncComSettings)
    {
      if (asyncComSettings == null || asyncComSettings.Count == 0)
        return true;
      ArrayList ParameterList = new ArrayList();
      for (int index = 0; index < asyncComSettings.Count; ++index)
      {
        string key = asyncComSettings.Keys[index];
        ParameterList.Add((object) key);
        ParameterList.Add((object) asyncComSettings.Values[index]);
      }
      return this.SetCommParameter(ParameterList);
    }

    public bool SetCommParameter(ArrayList ParameterList)
    {
      if (ParameterList.Count == 0)
        return true;
      if (AsyncFunctions.logger.IsInfoEnabled)
      {
        StringBuilder stringBuilder = new StringBuilder();
        for (int index = 0; index < ParameterList.Count; index += 2)
        {
          stringBuilder.Append(ParameterList[index].ToString());
          stringBuilder.Append(" = ");
          stringBuilder.Append(ParameterList[index + 1].ToString());
          stringBuilder.Append(ZR_Constants.SystemNewLine);
        }
        AsyncFunctions.logger.Info("Set AsyncComSettings: " + stringBuilder.ToString());
      }
      bool flag1 = false;
      bool flag2 = false;
      CommParameter commParameter;
      for (int index = 0; index < ParameterList.Count; index += 2)
      {
        string parameter = (string) ParameterList[index];
        string str1 = parameter;
        commParameter = CommParameter.Wakeup;
        string str2 = commParameter.ToString();
        if (str1 == str2)
          flag1 = true;
        string str3 = parameter;
        commParameter = CommParameter.TransceiverDevice;
        string str4 = commParameter.ToString();
        if (str3 == str4)
          flag2 = true;
      }
      ArrayList ParameterList1 = new ArrayList();
      this.GetCommParameter(ref ParameterList1);
      bool flag3 = false;
      for (int index = 0; index < ParameterList.Count; index += 2)
      {
        string parameter1 = (string) ParameterList[index];
        string parameter2 = (string) ParameterList[index + 1];
        int num1 = ParameterList1.IndexOf((object) parameter1);
        if (num1 <= -1 || num1 + 1 >= ParameterList1.Count || !(ParameterList1[num1 + 1].ToString() == parameter2))
        {
          int num2;
          if (flag1)
          {
            string str5 = parameter1;
            commParameter = CommParameter.UseBreak;
            string str6 = commParameter.ToString();
            num2 = str5 == str6 ? 1 : 0;
          }
          else
            num2 = 0;
          if (num2 == 0)
          {
            int num3;
            if (flag2)
            {
              string str7 = parameter1;
              commParameter = CommParameter.MinoConnectTestFor;
              string str8 = commParameter.ToString();
              num3 = str7 == str8 ? 1 : 0;
            }
            else
              num3 = 0;
            if (num3 == 0)
            {
              flag3 = true;
              this.SingleParameter(parameter1, parameter2);
            }
          }
        }
      }
      if (this.ComWindow != null && this.ComWindow.Focused)
        this.ComWindow.SetComState();
      if (this.MyComType is AsyncSerial && flag3 && this.IsOpen)
        this.ChangeDriverSettings();
      return true;
    }

    public bool SetCommParameter(ArrayList ParameterList, bool ComWindowRefresh)
    {
      bool flag = true;
      int count = ParameterList.Count;
      if (count % 2 == 1)
        --count;
      for (int index = 0; index < count; index += 2)
      {
        if (this.SingleParameter((string) ParameterList[index], (string) ParameterList[index + 1]).Length == 0)
          flag = false;
      }
      if (this.ComWindow != null & ComWindowRefresh)
        this.ComWindow.SetComState();
      return flag;
    }

    public bool ChangeParameterAtList(
      ArrayList ParameterList,
      string ParameterName,
      string NewParameter)
    {
      for (int index = 0; index < ParameterList.Count; index += 2)
      {
        if (ParameterList[index].ToString() == ParameterName)
        {
          ParameterList[index + 1] = (object) NewParameter;
          return true;
        }
      }
      return false;
    }

    public string GetParameterFromList(ArrayList ParameterList, string ParameterName)
    {
      for (int index = 0; index < ParameterList.Count; index += 2)
      {
        if (ParameterList[index].ToString() == ParameterName)
          return ParameterList[index + 1].ToString();
      }
      return "";
    }

    public string CreateParameterString(ArrayList ParameterList)
    {
      StringBuilder stringBuilder = new StringBuilder(300);
      for (int index = 0; index < ParameterList.Count; index += 2)
      {
        if (index != 0)
          stringBuilder.Append(';');
        stringBuilder.Append(ParameterList[index].ToString());
        stringBuilder.Append(';');
        stringBuilder.Append(ParameterList[index + 1].ToString());
      }
      return stringBuilder.ToString();
    }

    public ArrayList CreateParameterList(string ParameterString)
    {
      ArrayList parameterList = new ArrayList();
      char[] separator = new char[2]{ ',', ';' };
      foreach (object obj in ParameterString.Split(separator, 100))
        parameterList.Add((object) obj.ToString());
      return parameterList;
    }

    public bool ChangeDriverSettings()
    {
      if (this.MyComType == null || !(this.MyComType is AsyncSerial) || ((AsyncSerial) this.MyComType).MySerialPort == null)
        return false;
      AsyncFunctions.logger.Trace("Call ChangeDriverSettings");
      return ((AsyncSerial) this.MyComType).MySerialPort.ChangeDriverSettings();
    }

    public bool IsOpen => this.ComIsOpen;

    public bool Open()
    {
      if (this.IsPluginObject)
      {
        try
        {
          if (PlugInLoader.IsPluginLoaded("CommunicationPort"))
          {
            object obj = PlugInLoader.GetPlugIn("CommunicationPort").GetPluginInfo().Interface;
            obj.GetType().GetMethod("Close").Invoke(obj, (object[]) null);
          }
        }
        catch
        {
        }
      }
      if (this.ComIsOpen)
        return true;
      if (this.MyComType == null)
        this.SetType(this.ConnectionTypeSelected);
      this.IgnoreReceiveErrorsOnTransmitTime = false;
      this.HardwareHandshake = false;
      if (this.MyComType is AsyncSerial)
      {
        if (this.Transceiver == ZR_ClassLibrary.TransceiverDevice.MinoIR)
          this.IgnoreReceiveErrorsOnTransmitTime = true;
        if (this.Transceiver == ZR_ClassLibrary.TransceiverDevice.MinoConnect)
          this.HardwareHandshake = true;
      }
      try
      {
        if (!this.MyComType.Open())
        {
          if (this.Transceiver != ZR_ClassLibrary.TransceiverDevice.MinoHead)
            return false;
          int num = 3;
          bool flag = false;
          for (; num > 0; --num)
          {
            this.MyComType.Close();
            if (this.MyComType.Open())
            {
              flag = true;
              break;
            }
            if (!ZR_ClassLibrary.Util.Wait(800L, "while reopen connection to the MinoHead device.", (ICancelable) this, AsyncFunctions.logger))
              return false;
          }
          if (!flag)
            return false;
        }
      }
      catch (Exception ex)
      {
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, "ComOpen error:" + ZR_Constants.SystemNewLine + ex.Message);
        this.ComIsOpen = false;
        return false;
      }
      if (!this.EchoOn && this.TestEcho)
        this.EchoOn = this.IsEchoActiv();
      this.EarliestTransmitTime = SystemValues.DateTimeNow.AddMilliseconds((double) this.WaitBeforeRepeatTime);
      return true;
    }

    private bool IsEchoActiv()
    {
      AsyncFunctions.logger.Debug("Testing for echo");
      ByteField DataBlock1 = new ByteField(6);
      DataBlock1.Add(85);
      DataBlock1.Add(170);
      DataBlock1.Add(90);
      DataBlock1.Add(165);
      DataBlock1.Add(15);
      DataBlock1.Add(240);
      this.TransmitBlock(ref DataBlock1);
      ByteField DataBlock2 = new ByteField(6);
      if (!this.ReceiveBlock(ref DataBlock2, 6, true))
        return false;
      for (int index = 0; index < 6; ++index)
      {
        if ((int) DataBlock2.Data[index] != (int) DataBlock1.Data[index])
          return false;
      }
      return true;
    }

    public void WaitToEarliestTransmitTime()
    {
      if (this.EarliestTransmitTime > SystemValues.DateTimeNow)
      {
        Application.DoEvents();
        if (!(this.EarliestTransmitTime > SystemValues.DateTimeNow))
          return;
        this.ComWriteLoggerEvent(EventLogger.LoggerEvent.ComWaitTransmitTimeS);
        double totalMilliseconds;
        do
        {
          Application.DoEvents();
          totalMilliseconds = this.EarliestTransmitTime.Subtract(SystemValues.DateTimeNow).TotalMilliseconds;
          if (totalMilliseconds >= 0.0)
          {
            if (totalMilliseconds < 100.0)
              goto label_5;
          }
          else
            goto label_10;
        }
        while (ZR_ClassLibrary.Util.Wait(100L, nameof (WaitToEarliestTransmitTime), (ICancelable) this, AsyncFunctions.logger));
        goto label_8;
label_5:
        if (!ZR_ClassLibrary.Util.Wait((long) (int) totalMilliseconds, nameof (WaitToEarliestTransmitTime), (ICancelable) this, AsyncFunctions.logger))
          return;
        goto label_10;
label_8:
        return;
label_10:
        this.ComWriteLoggerEvent(EventLogger.LoggerEvent.ComWaitTransmitTimeE);
      }
      else if (!ZR_ClassLibrary.Util.Wait(0L, nameof (WaitToEarliestTransmitTime), (ICancelable) this, AsyncFunctions.logger))
        ;
    }

    public void ResetEarliestTransmitTime()
    {
      this.EarliestTransmitTimeAbsolut = SystemValues.DateTimeNow.AddMilliseconds((double) this.RecTransTime);
    }

    public void ResetLastTransmitEndTime() => this.MyComType.ResetLastTransmitEndTime();

    public void ClearWakeup()
    {
      this.WakeupTemporaryOff = false;
      this.LastWakeupRefreshTime = DateTime.MinValue;
    }

    public void TriggerWakeup() => this.LastWakeupRefreshTime = SystemValues.DateTimeNow;

    public bool SetHandshakeState(HandshakeStates HandshakeState)
    {
      return this.MyComType.SetHandshakeState(HandshakeState);
    }

    public bool Close()
    {
      bool flag = true;
      if (this.MyComType != null)
        flag = this.MyComType.Close();
      this.ComIsOpen = false;
      return flag;
    }

    public bool SetBreak() => this.MyComType.SetBreak();

    public bool ClearBreak() => this.MyComType.ClearBreak();

    public void ClearCom() => this.MyComType.ClearCom();

    public void TestComState() => this.MyComType.TestComState();

    public bool CallTransceiverFunction(TransceiverDeviceFunction function)
    {
      return this.CallTransceiverFunction(function, (object) null);
    }

    public bool CallTransceiverFunction(TransceiverDeviceFunction function, object param1)
    {
      return this.CallTransceiverFunction(function, param1, (object) null);
    }

    public bool CallTransceiverFunction(
      TransceiverDeviceFunction function,
      object param1,
      object param2)
    {
      return this.Open() && this.MyComType != null && this.MyComType.CallTransceiverDeviceFunction(function, param1, param2);
    }

    public bool SetComTimeouts() => true;

    public bool TransmitString(string DataString)
    {
      if (AsyncFunctions.logger.IsTraceEnabled)
        AsyncFunctions.logger.Trace("Send ASCII data: {0}", DataString);
      return this.MyComType.TransmitString(DataString);
    }

    public bool TransmitBlock(string DataString)
    {
      if (AsyncFunctions.logger.IsTraceEnabled)
        AsyncFunctions.logger.Trace("Send ASCII data: {0}", DataString);
      return this.MyComType.TransmitBlock(DataString);
    }

    public bool TransmitBlock(byte[] buffer)
    {
      ByteField DataBlock = new ByteField(buffer);
      return this.TransmitBlock(ref DataBlock);
    }

    public bool TransmitBlock(ref ByteField DataBlock)
    {
      if (!this.ComIsOpen && !this.Open())
        return false;
      if (AsyncFunctions.logger.IsTraceEnabled)
      {
        AsyncFunctions.logger.Trace("Transmit block: Size: {0}", DataBlock.Count);
        foreach (string message in ParameterService.GetMemoryInfo(DataBlock, 0))
          AsyncFunctions.logger.Trace(message);
      }
      return this.MyComType.TransmitBlock(ref DataBlock);
    }

    public bool SendBlock(ref ByteField DataBlock)
    {
      if (!this.ComIsOpen && !this.Open())
        return false;
      if (AsyncFunctions.logger.IsTraceEnabled)
      {
        AsyncFunctions.logger.Trace("Send data block: Size: {0}", DataBlock.Count);
        foreach (string message in ParameterService.GetMemoryInfo(DataBlock, 0))
          AsyncFunctions.logger.Trace(message);
      }
      return this.MyComType.SendBlock(ref DataBlock);
    }

    public void PureTransmit(byte[] byteList) => this.MyComType.PureTransmit(byteList);

    public bool ReceiveBlock(ref ByteField DataBlock, int MinByteNb, bool first)
    {
      bool block = this.MyComType.ReceiveBlock(ref DataBlock, MinByteNb, first);
      if (AsyncFunctions.logger.IsTraceEnabled && DataBlock.Count > 0)
        AsyncFunctions.logger.Trace<int, string>("Received ({0}): {1}", DataBlock.Count, ZR_ClassLibrary.Util.ByteArrayToHexString(DataBlock.Data, 0, DataBlock.Count));
      return block;
    }

    public bool ReceiveBlock(ref ByteField DataBlock)
    {
      bool block = this.MyComType.ReceiveBlock(ref DataBlock);
      if (AsyncFunctions.logger.IsTraceEnabled && DataBlock.Count > 0)
        AsyncFunctions.logger.Trace<int, string>("Received ({0}): {1}", DataBlock.Count, ZR_ClassLibrary.Util.ByteArrayToHexString(DataBlock.Data, 0, DataBlock.Count));
      return block;
    }

    public bool GetCurrentInputBuffer(out byte[] buffer)
    {
      return this.MyComType.GetCurrentInputBuffer(out buffer);
    }

    public bool TryReceiveBlock(out byte[] buffer)
    {
      bool block = this.MyComType.TryReceiveBlock(out buffer);
      if (AsyncFunctions.logger.IsTraceEnabled & block && buffer != null)
        AsyncFunctions.logger.Trace<int, string>("Received ({0}): {1}", buffer.Length, ZR_ClassLibrary.Util.ByteArrayToHexString(buffer));
      return block;
    }

    public bool TryReceiveBlock(out byte[] buffer, int numberOfBytesToReceive)
    {
      bool block = this.MyComType.TryReceiveBlock(out buffer, numberOfBytesToReceive);
      if (AsyncFunctions.logger.IsTraceEnabled & block && buffer != null)
        AsyncFunctions.logger.Trace<int, string>("Received ({0}): {1}", buffer.Length, ZR_ClassLibrary.Util.ByteArrayToHexString(buffer));
      return block;
    }

    public bool ReceiveString(out string DataString)
    {
      bool flag = this.MyComType.ReceiveString(out DataString);
      if (AsyncFunctions.logger.IsTraceEnabled)
        AsyncFunctions.logger.Trace("Received ASCII data: {0}", DataString);
      return flag;
    }

    public bool ReceiveLine(out string ReceivedData)
    {
      bool line = this.MyComType.ReceiveLine(out ReceivedData);
      if (AsyncFunctions.logger.IsTraceEnabled)
        AsyncFunctions.logger.Trace("Received ASCII data: {0}", ReceivedData);
      return line;
    }

    public bool ReceiveCRLF_Line(out string ReceivedData)
    {
      bool crlfLine = this.MyComType.ReceiveCRLF_Line(out ReceivedData);
      if (AsyncFunctions.logger.IsTraceEnabled)
        AsyncFunctions.logger.Trace("Received ASCII data: {0}", ReceivedData);
      return crlfLine;
    }

    public bool ReceiveLine(out string ReceivedData, char[] EndCharacters, bool GetEmpty_CRLF_Line)
    {
      bool line = this.MyComType.ReceiveLine(out ReceivedData, EndCharacters, GetEmpty_CRLF_Line);
      if (AsyncFunctions.logger.IsTraceEnabled)
        AsyncFunctions.logger.Trace("Received ASCII data: {0}", ReceivedData);
      return line;
    }

    public bool ReceiveBlockToChar(ref ByteField DataBlock, byte EndChar)
    {
      bool blockToChar = this.MyComType.ReceiveBlockToChar(ref DataBlock, EndChar);
      if (AsyncFunctions.logger.IsTraceEnabled)
        AsyncFunctions.logger.Trace<int, string>("Received ({0}): {1}", DataBlock.Count, ZR_ClassLibrary.Util.ByteArrayToHexString(DataBlock.Data, 0, DataBlock.Count));
      return blockToChar;
    }

    public bool GetComPortIds(out string strComPortIds, bool ForceRefresh)
    {
      strComPortIds = string.Empty;
      List<string> stringList = new List<string>();
      StringBuilder stringBuilder = new StringBuilder();
      switch (this.ConnectionTypeSelected)
      {
        case AsyncComConnectionType.Remote:
        case AsyncComConnectionType.Remote_VPN:
          this.MyMeterVPN.Update((AsyncIP) this.MyComType);
          if (!this.MyMeterVPN.COMservers.ContainsKey((object) this.MyMeterVPN.SelectedCOMserver))
            return false;
          COMserver coMserver = (COMserver) this.MyMeterVPN.COMservers[(object) this.MyMeterVPN.SelectedCOMserver];
          if (coMserver == null)
            return false;
          if (ForceRefresh)
            coMserver.Update((AsyncIP) this.MyComType);
          IDictionaryEnumerator enumerator = coMserver.RemoteComs.GetEnumerator();
          try
          {
            while (enumerator.MoveNext())
            {
              DictionaryEntry current = (DictionaryEntry) enumerator.Current;
              stringList.Add("COM" + current.Key.ToString());
            }
            break;
          }
          finally
          {
            if (enumerator is IDisposable disposable)
              disposable.Dispose();
          }
      }
      stringList.Sort();
      stringBuilder.Length = 0;
      for (int index = 0; index < stringList.Count; ++index)
      {
        if (index > 0)
          stringBuilder.Append(",");
        stringBuilder.Append(stringList[index].ToString());
      }
      strComPortIds = stringBuilder.ToString();
      return true;
    }

    internal void SendAsyncComMessage(GMM_EventArgs MessageEventArgs)
    {
      if (this.OnAsyncComMessage == null)
        return;
      this.OnAsyncComMessage((object) this, MessageEventArgs);
    }

    public bool SendMinoConnectCommand(string cmd)
    {
      if (this.MyComType == null)
        throw new ArgumentNullException("MyComType can not be null!");
      if (!this.MyComType.Open())
        return false;
      if (!(this.MyComType is AsyncSerial comType))
        throw new ArgumentException("Wrong AsyncCom settings! It's supported only serial port.");
      if (!(comType.MySerialPort is MinoConnectSerialPort serialPort))
        throw new ArgumentException("Wrong AsyncCom trancseiver settings! MinoConnect is not chosen.");
      serialPort.WriteCommand(cmd);
      return true;
    }

    internal bool SetType(AsyncComConnectionType NewType)
    {
      if (this.MyComType != null)
        this.MyComType.Close();
      this.ConnectionTypeSelected = NewType;
      switch (NewType)
      {
        case AsyncComConnectionType.COM:
          this.MyComType = (AsyncFunctionsBase) new AsyncSerial(this);
          this.MyComType.ConnectionLost += new System.EventHandler(this.MyComType_ConnectionLost);
          this.MyComType.BatterieLow += new System.EventHandler(this.MyComType_BatterieLow);
          return true;
        case AsyncComConnectionType.Remote:
        case AsyncComConnectionType.Remote_VPN:
          this.MyComType = (AsyncFunctionsBase) new AsyncIP(this);
          return true;
        default:
          return false;
      }
    }

    private void MyComType_ConnectionLost(object sender, EventArgs e)
    {
      if (this.ConnectionLost == null)
        return;
      this.ConnectionLost(sender, e);
    }

    private void MyComType_BatterieLow(object sender, EventArgs e)
    {
      if (this.BatterieLow == null)
        return;
      this.BatterieLow(sender, e);
    }

    public void GMM_Dispose()
    {
      this.Close();
      if (this.ComWindow == null)
        return;
      this.ComWindow.Dispose();
    }

    public string GetTranceiverDeviceInfo()
    {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.Append(this.transceiverDeviceInfo);
      if (this.ComIsOpen)
      {
        if (this.Transceiver == ZR_ClassLibrary.TransceiverDevice.MinoConnect)
          stringBuilder.Append(ZR_Constants.SystemNewLine);
      }
      else
        stringBuilder.Append("Com is closed");
      return stringBuilder.ToString();
    }

    public bool UpdateTransceiverFirmware(string pathToFirmware)
    {
      if (!File.Exists(pathToFirmware))
        throw new FileNotFoundException("File does not exist! Path: " + pathToFirmware);
      if (!this.Open())
        return false;
      if (this.Transceiver != ZR_ClassLibrary.TransceiverDevice.MinoConnect)
        throw new ArgumentException(this.Transceiver.ToString() + " is not supported for firmware update!");
      if (!(this.MyComType.GetChannel() is SerialPort channel))
        return false;
      if (!this.CallTransceiverFunction(TransceiverDeviceFunction.DisableMinoConnectPolling))
        throw new Exception("Can not disable MinoConnect polling!");
      FlashMinoConnect flashMinoConnect = new FlashMinoConnect(channel);
      flashMinoConnect.ProgressChanged += new EventHandler<MinoConnect.ProgressChangedEventArgs>(this.Flasher_ProgressChanged);
      try
      {
        if (!flashMinoConnect.Upgrade(pathToFirmware))
          throw new Exception(flashMinoConnect.LastError);
      }
      finally
      {
        flashMinoConnect.ProgressChanged -= new EventHandler<MinoConnect.ProgressChangedEventArgs>(this.Flasher_ProgressChanged);
        flashMinoConnect.Dispose();
        this.RaiseProgressEvent(0);
        this.Close();
      }
      return true;
    }

    private void Flasher_ProgressChanged(object sender, MinoConnect.ProgressChangedEventArgs e)
    {
      this.RaiseProgressEvent(e.ProgressPercentage);
    }

    public void RaiseProgressEvent(int progressPercentage)
    {
      this.RaiseProgressEvent(progressPercentage, string.Empty);
    }

    public void RaiseProgressEvent(int progressPercentage, string status)
    {
      if (this.OnAsyncComMessage == null)
        return;
      this.OnAsyncComMessage((object) this, new GMM_EventArgs(status)
      {
        TheMessageType = GMM_EventArgs.MessageType.MessageAndProgressPercentage,
        ProgressPercentage = progressPercentage
      });
    }

    internal void SetDefaultTiming(int Baudrate)
    {
      this.AnswerOffsetTime = 0;
      this.TransTime_GlobalOffset = 0;
      this.RecTime_GlobalOffset = 0;
      this.RecTime_BeforFirstByte = this.TimeBevorFirstByteDefaultFromBaudrate(Baudrate);
      this.RecTime_OffsetPerByte = 0.0;
      this.RecTime_OffsetPerBlock = 50;
      this.RecTransTime = 10;
      this.WakeupIntervalTime = 10000;
      this.TransTime_BreakTime = 700;
      this.TransTime_AfterBreak = 50;
      this.TransTime_AfterOpen = 200;
      this.WaitBeforeRepeatTime = 200;
    }

    internal int TimeBevorFirstByteDefaultFromBaudrate(int Baudrate)
    {
      int num1 = (int) (1000.0 / (double) Baudrate * 330.0);
      int num2 = 263;
      if (num2 < 0)
        num2 = 0;
      return num1 + num2;
    }

    internal void RefreshComPorts()
    {
      if (this.ConnectionTypeSelected != AsyncComConnectionType.Remote_VPN)
        return;
      if (this.MyComType is AsyncIP)
      {
        this.MyMeterVPN.COMservers.Clear();
        this.MyMeterVPN.Update((AsyncIP) this.MyComType);
      }
      else
      {
        this.MyMeterVPN.COMservers.Clear();
        this.MyMeterVPN.Update(new AsyncIP(this));
      }
    }

    public Dictionary<string, string> LoadAvailableCOMservers()
    {
      if (this.MyMeterVPN.COMservers == null || this.MyMeterVPN.COMservers.Count == 0)
        this.RefreshComPorts();
      Dictionary<string, string> dictionary = new Dictionary<string, string>();
      for (int index = 0; index < this.MyMeterVPN.COMservers.Count; ++index)
        dictionary.Add(this.MyMeterVPN.COMservers.GetKey(index).ToString(), ((COMserver) this.MyMeterVPN.COMservers.GetByIndex(index)).Name);
      return dictionary;
    }

    public object ShowWindow(object parameters)
    {
      switch (parameters)
      {
        case null:
          this.ShowComWindow();
          return (object) this.GetAsyncComSettings();
        case string _:
          this.SetAsyncComSettings(parameters.ToString());
          goto default;
        case SortedList<AsyncComSettings, object> _:
          this.SetAsyncComSettings(parameters as SortedList<AsyncComSettings, object>);
          goto default;
        case SortedList<string, string> _:
          this.SetAsyncComSettings(parameters as SortedList<string, string>);
          goto default;
        default:
          goto case null;
      }
    }

    public void SetReadoutConfiguration(ConfigList configList)
    {
      if (this.ReadoutConfigByBusFile)
      {
        this.DisableConfigList();
      }
      else
      {
        if (configList == null)
          throw new ArgumentNullException(nameof (configList));
        if (this.ConfigList == null)
        {
          this.ConfigList = configList;
          this.SetAsyncComSettings(configList.GetSortedList());
          this.ConfigList.PropertyChanged += new PropertyChangedEventHandler(this.ConfigList_PropertyChanged);
          this.ConfigList.CollectionChanged += new NotifyCollectionChangedEventHandler(this.ConfigList_CollectionChanged);
        }
        else if (this.ConfigList != configList)
          throw new ArgumentException("this.configList != configList");
      }
    }

    private void ConfigList_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      this.configValuesChanged();
    }

    private void ConfigList_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
    {
      this.configValuesChanged();
    }

    private void DisableConfigList()
    {
      if (this.ConfigList == null)
        return;
      this.ConfigList.PropertyChanged -= new PropertyChangedEventHandler(this.ConfigList_PropertyChanged);
      this.ConfigList.CollectionChanged -= new NotifyCollectionChangedEventHandler(this.ConfigList_CollectionChanged);
      this.ConfigList = (ConfigList) null;
    }

    private void configValuesChanged()
    {
      SortedList<string, string> asyncComSettings = new SortedList<string, string>();
      foreach (KeyValuePair<string, string> sorted in this.ConfigList.GetSortedList())
      {
        CommParameter result;
        if (Enum.TryParse<CommParameter>(sorted.Key, out result) && this.SingleParameter(result, (string) null) != sorted.Value)
          asyncComSettings.Add(sorted.Key, sorted.Value);
      }
      if (asyncComSettings.Count <= 0)
        return;
      this.SetAsyncComSettings(asyncComSettings);
    }

    public ConfigList GetReadoutConfiguration() => this.ConfigList;
  }
}


--- AsyncFunctionsBase.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.AsyncFunctionsBase
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using NLog;
using System;
using ZR_ClassLibrary;

#nullable disable
namespace AsyncCom
{
  public abstract class AsyncFunctionsBase
  {
    private static Logger logger = LogManager.GetLogger(nameof (AsyncFunctionsBase));
    protected AsyncFunctions MyAsyncFunctions;

    public virtual event System.EventHandler ConnectionLost;

    public virtual event System.EventHandler BatterieLow;

    protected AsyncFunctionsBase(AsyncFunctions MyParent) => this.MyAsyncFunctions = MyParent;

    public abstract bool Open();

    public abstract bool Close();

    public abstract void ClearCom();

    public abstract void ClearComErrors();

    public abstract bool ClearBreak();

    public abstract bool SetBreak();

    public abstract void TestComState();

    public abstract bool SetHandshakeState(HandshakeStates HandshakeState);

    public virtual bool TransmitString(string DataString) => false;

    public virtual bool ReceiveString(out string DataString)
    {
      DataString = (string) null;
      return false;
    }

    public abstract bool TransmitBlock(string DataString);

    public abstract bool TransmitBlock(ref ByteField DataBlock);

    public abstract bool SendBlock(ref ByteField DataBlock);

    public abstract void PureTransmit(byte[] byteList);

    public abstract bool ReceiveBlock(ref ByteField DataBlock, int MinByteNb, bool first);

    public abstract bool ReceiveBlock(ref ByteField DataBlock);

    public abstract bool TryReceiveBlock(out byte[] buffer);

    public abstract bool TryReceiveBlock(out byte[] buffer, int numberOfBytesToReceive);

    public abstract bool ReceiveLine(out string ReceivedData);

    public abstract bool ReceiveCRLF_Line(out string ReceivedData);

    public abstract bool ReceiveBlockToChar(ref ByteField DataBlock, byte EndChar);

    public abstract bool ReceiveLine(
      out string ReceivedData,
      char[] EndCharacters,
      bool GetEmpty_CRLF_Line);

    public abstract bool TransmitControlCommand(string strSendData);

    public abstract bool ReceiveControlBlock(
      out string ReceivedData,
      string startTag,
      string endTag);

    public abstract bool CallTransceiverDeviceFunction(
      TransceiverDeviceFunction function,
      object param1,
      object param2);

    public abstract object GetChannel();

    public abstract long InputBufferLength { get; }

    public void ResetLastTransmitEndTime()
    {
      this.MyAsyncFunctions.LastTransmitEndTime = SystemValues.DateTimeNow;
    }

    protected void GetReceiveBlockTiming(
      int NumberOfBytes,
      bool first,
      out DateTime EndTime,
      out int ActualTimeout)
    {
      EndTime = SystemValues.DateTimeNow;
      ActualTimeout = 0;
      if (first)
      {
        if (first && this.MyAsyncFunctions.IgnoreReceiveErrorsOnTransmitTime)
        {
          while (SystemValues.DateTimeNow < this.MyAsyncFunctions.LastTransmitEndTime)
          {
            if (!Util.Wait(50L, nameof (GetReceiveBlockTiming), (ICancelable) this.MyAsyncFunctions, AsyncFunctionsBase.logger))
              return;
          }
          this.MyAsyncFunctions.MyComType.ClearComErrors();
        }
        ActualTimeout = this.MyAsyncFunctions.RecTime_OffsetPerBlock + this.MyAsyncFunctions.RecTime_GlobalOffset + this.MyAsyncFunctions.AnswerOffsetTime + this.MyAsyncFunctions.RecTime_BeforFirstByte + (int) ((double) NumberOfBytes * (this.MyAsyncFunctions.ByteTime + this.MyAsyncFunctions.RecTime_OffsetPerByte) + 1.0);
        this.MyAsyncFunctions.EarliestTransmitTime = SystemValues.DateTimeNow.AddMilliseconds((double) (this.MyAsyncFunctions.RecTime_OffsetPerBlock + this.MyAsyncFunctions.RecTime_GlobalOffset + this.MyAsyncFunctions.AnswerOffsetTime + this.MyAsyncFunctions.RecTime_BeforFirstByte + (int) (280.0 * (this.MyAsyncFunctions.ByteTime + this.MyAsyncFunctions.RecTime_OffsetPerByte) + 1.0) + this.MyAsyncFunctions.WaitBeforeRepeatTime));
        this.MyAsyncFunctions.FirstCalculatedEarliestTransmitTime = this.MyAsyncFunctions.EarliestTransmitTime;
        EndTime = this.MyAsyncFunctions.LastTransmitEndTime.AddMilliseconds((double) ActualTimeout);
      }
      else
      {
        ActualTimeout = this.MyAsyncFunctions.RecTime_OffsetPerBlock + this.MyAsyncFunctions.RecTime_GlobalOffset + (int) ((double) NumberOfBytes * (this.MyAsyncFunctions.ByteTime + this.MyAsyncFunctions.RecTime_OffsetPerByte) + 1.0);
        EndTime = SystemValues.DateTimeNow.AddMilliseconds((double) ActualTimeout);
        this.MyAsyncFunctions.EarliestTransmitTime = SystemValues.DateTimeNow.AddMilliseconds((double) (ActualTimeout + this.MyAsyncFunctions.WaitBeforeRepeatTime));
      }
      if (!(SystemValues.DateTimeNow > EndTime))
        return;
      AsyncFunctionsBase.logger.Fatal("Timing was calculated at {0}. NumberOfBytes={1}, First={2}, EndTime={3}, ActualTimeout={4}", new object[5]
      {
        (object) SystemValues.DateTimeNow.ToString("HH:mm:ss.fff"),
        (object) NumberOfBytes,
        (object) first,
        (object) EndTime.ToString("HH:mm:ss.fff"),
        (object) ActualTimeout
      });
      AsyncFunctionsBase.logger.Fatal("Calculated timeout is in the past!");
    }

    public virtual bool GetCurrentInputBuffer(out byte[] buffer)
    {
      throw new NotImplementedException();
    }
  }
}


--- AsyncIP.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.AsyncIP
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using AsyncCom.MeterVPNServer;
using NLog;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using ZR_ClassLibrary;

#nullable disable
namespace AsyncCom
{
  public sealed class AsyncIP(AsyncFunctions MyParent) : AsyncFunctionsBase(MyParent)
  {
    private const int DATA_PORT = 2000;
    private const int CONTROL_PORT = 3000;
    private static Logger logger = LogManager.GetLogger(nameof (AsyncIP));
    private TcpClient controlTcpClient;
    private NetworkStream controlNetworkStream;
    private TcpClient dataTcpClient;
    private NetworkStream dataNetworkStream;
    private MeterVPNService MyMeterVPNServer;

    public override long InputBufferLength
    {
      get
      {
        try
        {
          return this.dataNetworkStream.Length;
        }
        catch (NotSupportedException ex)
        {
          return 0;
        }
      }
    }

    public override bool Open()
    {
      if (this.OpenDataConnection())
        return true;
      if (this.MyAsyncFunctions.ErrorMessageBox)
        this.MyAsyncFunctions.AsyncComMessageBox(this.GetResString("TCPOpenError") + "\r\n" + ZR_ClassLibMessages.GetLastErrorStringTranslated());
      return false;
    }

    private string GetResString(string name) => this.MyAsyncFunctions.MyRes.GetString(name);

    public override bool Close()
    {
      AsyncIP.logger.Trace("Close called...");
      this.MyAsyncFunctions.ComIsOpen = false;
      this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComClose);
      if (this.controlTcpClient != null)
        this.controlTcpClient.Close();
      if (this.controlNetworkStream != null)
        this.controlNetworkStream.Close();
      if (this.dataTcpClient != null)
        this.dataTcpClient.Close();
      if (this.dataNetworkStream != null)
        this.dataNetworkStream.Close();
      if (this.MyAsyncFunctions.ComWindow != null)
        this.MyAsyncFunctions.ComWindow.SetComOpenState();
      return true;
    }

    public override void ClearCom()
    {
      if (this.dataNetworkStream != null && this.dataNetworkStream.CanRead && this.dataNetworkStream.DataAvailable)
      {
        List<byte> byteList = new List<byte>();
        while (this.dataNetworkStream.DataAvailable && !this.MyAsyncFunctions.BreakRequest)
          byteList.Add((byte) this.dataNetworkStream.ReadByte());
        AsyncIP.logger.Error("DATA-channel has disposed following bytes: " + Util.ByteArrayToHexString(byteList.ToArray()));
      }
      if (this.controlNetworkStream == null || !this.controlNetworkStream.CanRead || !this.controlNetworkStream.DataAvailable)
        return;
      List<byte> byteList1 = new List<byte>();
      while (this.controlNetworkStream.DataAvailable && !this.MyAsyncFunctions.BreakRequest)
        byteList1.Add((byte) this.controlNetworkStream.ReadByte());
      AsyncIP.logger.Error("CONTROL-channel has disposed following bytes: " + Util.ByteArrayToHexString(byteList1.ToArray()));
    }

    private bool OpenControlConnection()
    {
      if (string.IsNullOrEmpty(this.MyAsyncFunctions.MyMeterVPN.SelectedCOMserver))
        return false;
      if (this.controlTcpClient != null && this.controlTcpClient.Client != null && this.controlTcpClient.Client.Connected)
      {
        if (this.controlNetworkStream == null)
        {
          this.controlNetworkStream = this.controlTcpClient.GetStream();
          this.controlNetworkStream.WriteTimeout = 500;
          this.controlNetworkStream.ReadTimeout = 500;
        }
        return true;
      }
      COMserver comServer = this.GetCOMServer();
      AsyncIP.logger.Info<string, int>("Try connect to the COMServer CONTROL ({0}:{1})", comServer.IPAddress, 3000);
      try
      {
        if (this.controlTcpClient != null)
          this.controlTcpClient.Close();
        if (this.controlNetworkStream != null)
          this.controlNetworkStream.Close();
        ZR_ClassLibMessages.ClearErrors();
        this.controlTcpClient = new TcpClient();
        this.controlTcpClient.NoDelay = true;
        this.controlNetworkStream = (NetworkStream) null;
        this.controlTcpClient.ReceiveTimeout = this.MyAsyncFunctions.RecTime_BeforFirstByte;
        try
        {
          this.controlTcpClient.Connect(comServer.IPAddress, 3000);
        }
        catch (Exception ex)
        {
          string str = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
          AsyncIP.logger.Error(ex, str);
          this.Close();
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, str);
          return false;
        }
        if (!Util.Wait(3000L, "after create TCP/IP connection", (ICancelable) this.MyAsyncFunctions, AsyncIP.logger))
          return false;
        if (this.controlTcpClient.Client.Available > 0)
        {
          byte[] numArray = new byte[this.controlTcpClient.Client.Available];
          this.controlTcpClient.Client.Receive(numArray);
          string str1 = Encoding.ASCII.GetString(numArray, 0, numArray.Length);
          if (str1.StartsWith("Too many controller ports"))
          {
            string str2 = string.Format("{0}! Please try again later!", (object) str1);
            AsyncIP.logger.Error(str2);
            this.Close();
            ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.ComOpenError, str2);
            return false;
          }
          AsyncIP.logger.Info("Message from COM Server(CONTROL) Buffer: {0}", Util.ByteArrayToHexString(numArray));
        }
        this.controlNetworkStream = this.controlTcpClient.GetStream();
        this.controlNetworkStream.WriteTimeout = 5000;
        this.controlNetworkStream.ReadTimeout = 5000;
        AsyncIP.logger.Info("Successfully connected!");
        return true;
      }
      catch (Exception ex)
      {
        string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
        AsyncIP.logger.Error(ex, message);
        this.Close();
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, "Failed estabilish the CONTROL connection with COMServer. " + message);
        return false;
      }
    }

    public override bool TransmitControlCommand(string cmd)
    {
      if (!this.OpenControlConnection())
        return false;
      AsyncIP.logger.Trace("Send control command: {0}", cmd);
      try
      {
        byte[] bytes = Encoding.ASCII.GetBytes(cmd + "\n\r");
        if (!this.controlNetworkStream.CanWrite)
          return false;
        this.controlNetworkStream.Write(bytes, 0, bytes.Length);
        this.controlNetworkStream.Flush();
        return true;
      }
      catch (Exception ex)
      {
        string str = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
        AsyncIP.logger.Error(ex, str);
        this.Close();
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, str);
        return false;
      }
    }

    public override bool ReceiveControlBlock(
      out string ReceivedData,
      string startTag,
      string endTag)
    {
      ReceivedData = string.Empty;
      if (!this.OpenControlConnection())
        return false;
      StringBuilder stringBuilder = new StringBuilder();
      int tickCount = Environment.TickCount;
      while (this.controlNetworkStream.CanRead)
      {
        if (Environment.TickCount > tickCount + this.controlNetworkStream.ReadTimeout)
        {
          AsyncIP.logger.Trace("Timeout. " + this.controlNetworkStream.ReadTimeout.ToString());
          break;
        }
        if (this.controlNetworkStream.DataAvailable)
        {
          byte[] numArray = new byte[this.controlTcpClient.ReceiveBufferSize];
          try
          {
            int count = this.controlNetworkStream.Read(numArray, 0, numArray.Length);
            string str = Encoding.ASCII.GetString(numArray, 0, count);
            stringBuilder.Append(str);
            if (str.IndexOf(startTag) >= 0 && str.IndexOf(endTag) > 0)
              break;
          }
          catch (Exception ex)
          {
            string str = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
            AsyncIP.logger.Error(ex, str);
            this.Close();
            ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, str);
            return false;
          }
          tickCount = Environment.TickCount;
        }
        else if (!Util.Wait(100L, "while receive input buffer.", (ICancelable) this.MyAsyncFunctions, AsyncIP.logger))
          return false;
      }
      ReceivedData = stringBuilder.ToString();
      AsyncIP.logger.Trace<int, string>("Received CONTROL block. Size: {0}, Buffer: {1}", ReceivedData.Length, ReceivedData);
      return true;
    }

    private bool OpenDataConnection()
    {
      this.MyAsyncFunctions.ComIsOpen = false;
      COMserver comServer = this.GetCOMServer();
      if (comServer == null)
        return false;
      if (this.dataTcpClient != null && this.dataTcpClient.Client != null && this.dataTcpClient.Client.Connected)
      {
        string ipAddress = comServer.IPAddress;
        if (!(((IPEndPoint) this.dataTcpClient.Client.RemoteEndPoint).Address.ToString() != ipAddress))
        {
          if (this.dataNetworkStream == null)
          {
            this.dataNetworkStream = this.controlTcpClient.GetStream();
            this.dataNetworkStream.WriteTimeout = 5000;
            this.dataNetworkStream.ReadTimeout = 5000;
          }
          this.MyAsyncFunctions.ComIsOpen = true;
          return true;
        }
      }
      int port = 2000;
      if (this.MyAsyncFunctions.ComPort.ToUpper() == "COM2")
        port = 2003;
      AsyncIP.logger.Info<string, int>("Try connect to the COMServer DATA ({0}:{1})", comServer.IPAddress, port);
      try
      {
        if (this.dataTcpClient != null)
          this.dataTcpClient.Close();
        if (this.dataNetworkStream != null)
          this.dataNetworkStream.Close();
        ZR_ClassLibMessages.ClearErrors();
        this.dataTcpClient = new TcpClient();
        this.dataTcpClient.NoDelay = true;
        this.dataNetworkStream = (NetworkStream) null;
        int timeBeforFirstByte = this.MyAsyncFunctions.RecTime_BeforFirstByte;
        try
        {
          this.dataTcpClient.Connect(comServer.IPAddress, port);
        }
        catch (Exception ex)
        {
          string str = string.Format("Error: {0}", (object) ex.Message);
          AsyncIP.logger.Error(ex, str);
          this.Close();
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.ComOpenError, str);
          return false;
        }
        if (!Util.Wait(3000L, "after create TCP/IP connection", (ICancelable) this.MyAsyncFunctions, AsyncIP.logger))
          return false;
        if (this.dataTcpClient.Client == null)
        {
          this.dataTcpClient.Close();
          return false;
        }
        if (this.dataTcpClient.Client.Available > 0)
        {
          byte[] numArray = new byte[this.dataTcpClient.Client.Available];
          int num = this.dataTcpClient.Client.Receive(numArray);
          string str1 = Encoding.ASCII.GetString(numArray, 0, numArray.Length);
          if (str1.StartsWith("Port already in use"))
          {
            if (comServer.Update(this) && comServer.RemoteComs.Count > 0)
            {
              string connectedTo = ((RemoteCom) comServer.RemoteComs[(object) 1]).ConnectedTo;
              string str2 = string.Format("{0} from: {1}", (object) str1, (object) connectedTo);
              AsyncIP.logger.Error(str2);
              try
              {
                string str3 = "?";
                foreach (IPAddress address in Dns.GetHostEntry(Dns.GetHostName()).AddressList)
                {
                  if (address.AddressFamily == AddressFamily.InterNetwork && address.ToString().StartsWith("1."))
                  {
                    str3 = address.ToString();
                    break;
                  }
                }
                AsyncIP.logger.Trace("My OpenVPN IP: " + str3);
                if (str3 == connectedTo)
                {
                  AsyncIP.logger.Trace("I have last used this COM Server! Try resolve this problem...");
                  this.TransmitControlCommand("disconnect " + 2000.ToString());
                  if (this.ReceiveControlBlock(out string _, "disconnect", "->"))
                    str2 += " Please try again!";
                }
              }
              catch (Exception ex)
              {
                string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
                AsyncIP.logger.Error(ex, message);
              }
              ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.ComOpenError, str2);
            }
            this.Close();
            return false;
          }
          AsyncIP.logger.Info<int, string>("Message from COM Server(DATA): Size:{0}, Buffer:{1}", num, Util.ByteArrayToHexString(numArray));
        }
        this.dataNetworkStream = this.dataTcpClient.GetStream();
        this.dataNetworkStream.WriteTimeout = 5000;
        this.dataNetworkStream.ReadTimeout = 5000;
        this.MyAsyncFunctions.ComIsOpen = true;
        AsyncIP.logger.Info("Successfully connected!");
        this.MyAsyncFunctions.SendAsyncComMessage(new GMM_EventArgs(GMM_EventArgs.MessageType.StatusChanged)
        {
          EventMessage = "Com opened"
        });
        return true;
      }
      catch (Exception ex)
      {
        string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
        AsyncIP.logger.Error(ex, message);
        this.Close();
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.ComOpenError, "Failed estabilish the DATA connection with COMServer. " + message);
        return false;
      }
    }

    public override bool TransmitBlock(string DataString)
    {
      ByteField DataBlock = new ByteField(DataString.Length);
      for (int index = 0; index < DataString.Length; ++index)
        DataBlock.Add((byte) DataString[index]);
      return this.TransmitBlock(ref DataBlock);
    }

    public override bool TransmitBlock(ref ByteField DataBlock)
    {
      if (DataBlock == null || DataBlock.Count < 1)
        throw new ArgumentException(nameof (DataBlock));
      if (!this.OpenDataConnection())
        return false;
      this.MyAsyncFunctions.WaitToEarliestTransmitTime();
      this.ClearCom();
      this.MyAsyncFunctions.LastTransmitEndTime = SystemValues.DateTimeNow.AddMilliseconds(this.MyAsyncFunctions.ByteTime * (double) DataBlock.Count);
      this.MyAsyncFunctions.Logger.WriteLoggerData(EventLogger.LoggerEvent.ComTransmitData, ref DataBlock);
      byte[] numArray = new byte[DataBlock.Count];
      Array.Copy((Array) DataBlock.Data, (Array) numArray, numArray.Length);
      try
      {
        if (!this.dataNetworkStream.CanWrite)
          return false;
        this.dataNetworkStream.Write(numArray, 0, numArray.Length);
        this.dataNetworkStream.Flush();
      }
      catch (Exception ex)
      {
        string str = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
        AsyncIP.logger.Error(ex, str);
        this.Close();
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, str);
        return false;
      }
      if (this.MyAsyncFunctions.EchoOn)
      {
        ByteField byteField = new ByteField(DataBlock.Count);
        bool flag = this.ReceiveBlock(ref byteField, DataBlock.Count, true);
        if (flag)
        {
          for (int index = 0; index < DataBlock.Count; ++index)
          {
            if ((int) DataBlock.Data[index] != (int) byteField.Data[index])
              flag = false;
          }
        }
        if (!flag)
        {
          this.MyAsyncFunctions.Logger.WriteLoggerData(EventLogger.LoggerEvent.ComEchoError, ref byteField);
          return false;
        }
        this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComEchoOk);
      }
      return true;
    }

    public override bool ReceiveBlock(ref ByteField DataBlock)
    {
      DataBlock.Count = 0;
      if (!this.OpenDataConnection())
        return false;
      int timeBeforFirstByte = this.MyAsyncFunctions.RecTime_BeforFirstByte;
      List<byte> byteList = new List<byte>();
      int tickCount = Environment.TickCount;
      while (this.dataNetworkStream.CanRead && !this.MyAsyncFunctions.BreakRequest)
      {
        if (Environment.TickCount > tickCount + timeBeforFirstByte)
        {
          AsyncIP.logger.Trace("Timeout while receive DATA block!");
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout);
          break;
        }
        if (this.dataNetworkStream.DataAvailable)
        {
          try
          {
            byte num = (byte) this.dataNetworkStream.ReadByte();
            byteList.Add(num);
          }
          catch (ObjectDisposedException ex)
          {
            string str = "The connection was closed unexpectedly! Error: " + ex.Message;
            AsyncIP.logger.Error((Exception) ex, str);
            ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, str);
            return false;
          }
          tickCount = Environment.TickCount;
        }
        else if (!Util.Wait(200L, "while receive input buffer.", (ICancelable) this.MyAsyncFunctions, AsyncIP.logger))
          return false;
      }
      byte[] array = byteList.ToArray();
      DataBlock.Data = array;
      DataBlock.Count = array.Length;
      this.MyAsyncFunctions.Logger.WriteLoggerData(EventLogger.LoggerEvent.ComReceiveData, ref DataBlock);
      this.MyAsyncFunctions.EarliestTransmitTime = SystemValues.DateTimeNow.AddMilliseconds((double) this.MyAsyncFunctions.RecTransTime);
      return DataBlock.Count != 0;
    }

    public override bool ReceiveBlock(ref ByteField DataBlock, int MinByteNb, bool first)
    {
      if (MinByteNb <= 0)
        throw new ArgumentException(nameof (MinByteNb));
      DataBlock.Count = 0;
      if (!this.OpenDataConnection())
        return false;
      int ActualTimeout;
      this.GetReceiveBlockTiming(MinByteNb, first, out DateTime _, out ActualTimeout);
      AsyncIP.logger.Trace<int, bool, int>("Calculated timing (MinByteNb: {0}, first: {1}, Timeout {2})", MinByteNb, first, ActualTimeout);
      List<byte> byteList = new List<byte>();
      int tickCount = Environment.TickCount;
      while (byteList.Count < MinByteNb && !this.MyAsyncFunctions.BreakRequest && this.dataNetworkStream.CanRead)
      {
        if (Environment.TickCount > tickCount + ActualTimeout)
        {
          AsyncIP.logger.Trace("Timeout while receive DATA block!");
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout);
          break;
        }
        if (this.dataNetworkStream.DataAvailable)
        {
          try
          {
            byte num = (byte) this.dataNetworkStream.ReadByte();
            byteList.Add(num);
          }
          catch (ObjectDisposedException ex)
          {
            string str = "The connection was closed unexpectedly! Error: " + ex.Message;
            AsyncIP.logger.Error((Exception) ex, str);
            ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, str);
            return false;
          }
          tickCount = Environment.TickCount;
        }
        else if (!Util.Wait(200L, "while receive input buffer.", (ICancelable) this.MyAsyncFunctions, AsyncIP.logger))
          return false;
      }
      byte[] array = byteList.ToArray();
      string hexString = Util.ByteArrayToHexString(array);
      DataBlock.Data = array;
      DataBlock.Count = array.Length;
      this.MyAsyncFunctions.Logger.WriteLoggerData(EventLogger.LoggerEvent.ComReceiveData, ref DataBlock);
      this.MyAsyncFunctions.ResetEarliestTransmitTime();
      if (array.Length == MinByteNb)
      {
        ZR_ClassLibMessages.ClearErrors();
        return true;
      }
      if (array.Length != 0)
      {
        string str = string.Format("Received unexpected DATA block. Is it perhaps the collision? Size: {0}, Buffer: {1}", (object) array.Length, (object) hexString);
        AsyncIP.logger.Error(str);
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.IllegalData, str);
      }
      return false;
    }

    public override bool GetCurrentInputBuffer(out byte[] buffer)
    {
      buffer = (byte[]) null;
      if (!this.OpenDataConnection())
        return false;
      int timeBeforFirstByte = this.MyAsyncFunctions.RecTime_BeforFirstByte;
      List<byte> byteList = new List<byte>();
      int tickCount = Environment.TickCount;
      while (this.dataNetworkStream.CanRead && !this.MyAsyncFunctions.BreakRequest && Environment.TickCount <= tickCount + timeBeforFirstByte)
      {
        if (this.dataNetworkStream.DataAvailable)
        {
          try
          {
            while (this.dataNetworkStream.DataAvailable && !this.MyAsyncFunctions.BreakRequest)
              byteList.Add((byte) this.dataNetworkStream.ReadByte());
          }
          catch (ObjectDisposedException ex)
          {
            string str = "The connection was closed unexpectedly! Error: " + ex.Message;
            AsyncIP.logger.Error((Exception) ex, str);
            ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, str);
            return false;
          }
          tickCount = Environment.TickCount;
        }
        else if (!Util.Wait(500L, "while receive input buffer.", (ICancelable) this.MyAsyncFunctions, AsyncIP.logger))
          return false;
      }
      buffer = byteList.ToArray();
      this.MyAsyncFunctions.EarliestTransmitTime = SystemValues.DateTimeNow.AddMilliseconds((double) this.MyAsyncFunctions.RecTransTime);
      return true;
    }

    public override bool SendBlock(ref ByteField DataBlock) => this.TransmitBlock(ref DataBlock);

    public override void PureTransmit(byte[] byteList) => throw new NotImplementedException();

    public override bool ReceiveLine(out string ReceivedData)
    {
      char[] EndCharacters = new char[2]{ '\r', '\n' };
      return this.ReceiveLine(out ReceivedData, EndCharacters, false);
    }

    public override bool ReceiveCRLF_Line(out string ReceivedData)
    {
      char[] EndCharacters = new char[2]{ '\r', '\n' };
      return this.ReceiveLine(out ReceivedData, EndCharacters, true);
    }

    public override bool ReceiveLine(
      out string ReceivedData,
      char[] EndCharacters,
      bool GetEmpty_CRLF_Line)
    {
      throw new NotImplementedException();
    }

    public override bool ReceiveBlockToChar(ref ByteField DataBlock, byte EndChar)
    {
      if (!this.MyAsyncFunctions.ComIsOpen)
        return false;
      ByteField byteField = new ByteField(DataBlock.Count);
      int count = DataBlock.Count;
      DataBlock.Count = 0;
      bool flag = false;
      int Timeout = this.MyAsyncFunctions.RecTime_BeforFirstByte + this.MyAsyncFunctions.AnswerOffsetTime;
      this.MyAsyncFunctions.Logger.GetTimeTicks();
      do
      {
        this.dataNetworkStream.ReadTimeout = Timeout;
        this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComReceiverPoll);
        try
        {
          int num = this.ReadStream(DataBlock.Data, DataBlock.Count, 1, this.dataNetworkStream, Timeout);
          count -= num;
          DataBlock.Count += num;
          this.MyAsyncFunctions.Logger.WriteLoggerData(EventLogger.LoggerEvent.ComReceiveData, ref DataBlock);
          if ((int) DataBlock.Data[DataBlock.Count - 1] == (int) EndChar)
          {
            this.MyAsyncFunctions.EarliestTransmitTime = SystemValues.DateTimeNow.AddMilliseconds((double) this.MyAsyncFunctions.RecTransTime);
            return true;
          }
        }
        catch (Exception ex)
        {
          flag = true;
          this.WorkException(ex);
        }
      }
      while (count > 0 && !flag);
      return false;
    }

    private int ReadStream(
      byte[] buffer,
      int Position,
      int Count,
      NetworkStream Stream,
      int Timeout)
    {
      int num1 = 0;
      long timeTicks = this.MyAsyncFunctions.Logger.GetTimeTicks();
      while (num1 < Count)
      {
        if (this.MyAsyncFunctions.Logger.GetTimeDifferenc(this.MyAsyncFunctions.Logger.GetTimeTicks() - timeTicks) > (long) Timeout)
          return num1 > 0 ? num1 : throw new TimeoutException();
        if (Stream.DataAvailable)
        {
          int num2 = Stream.Read(buffer, Position, Count);
          Position += num2;
          Count -= num2;
          num1 += num2;
        }
      }
      return num1;
    }

    public bool GetCOMServersFromMeterVPN(out AsyncCom.MeterVPNServer.COMserver[] COMservers)
    {
      AsyncIP.logger.Trace("Call GetCOMServersFromMeterVPN");
      COMservers = (AsyncCom.MeterVPNServer.COMserver[]) null;
      try
      {
        AsyncIP.logger.Trace("Try create MeterVPNService");
        if (this.MyMeterVPNServer == null)
          this.MyMeterVPNServer = new MeterVPNService();
        if (this.MyAsyncFunctions.ConnectionTypeSelected == AsyncComConnectionType.Remote)
        {
          AsyncIP.logger.Trace("MyAsyncFunctions.ConnectionTypeSelected == AsyncComConnectionType.Remote");
          AsyncIP.LANVPN lanvpn = new AsyncIP.LANVPN();
          COMservers = lanvpn.GetLocalCOMservers();
        }
        else
        {
          using (Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))
          {
            IPEndPoint remoteEP = new IPEndPoint(IPAddress.Parse("1.0.0.1"), 80);
            AsyncIP.logger.Trace("Load COMServer list from 1.0.0.1:80");
            if (!socket.BeginConnect((EndPoint) remoteEP, (AsyncCallback) null, (object) null).AsyncWaitHandle.WaitOne(this.MyAsyncFunctions.RecTime_BeforFirstByte, false))
            {
              ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout, "Timeout in GetCOMServersFromMeterVPN (...)");
              return false;
            }
          }
          this.MyMeterVPNServer.Proxy = GlobalProxySelection.GetEmptyWebProxy();
          COMservers = this.MyMeterVPNServer.GetCOMservers("test");
          if (COMservers != null)
          {
            foreach (AsyncCom.MeterVPNServer.COMserver coMserver in COMservers)
              AsyncIP.logger.Trace("{0}, IP: {1}, Name: {2}, Online: {3}", new object[4]
              {
                (object) coMserver.Cert,
                (object) coMserver.IP,
                (object) coMserver.Name,
                (object) coMserver.Online
              });
          }
        }
        if (COMservers == null)
          return false;
      }
      catch (WebException ex)
      {
        string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
        AsyncIP.logger.Error((Exception) ex, message);
        if (this.MyAsyncFunctions.ErrorMessageBox)
          this.MyAsyncFunctions.AsyncComMessageBox(this.GetResString("NetworkProxyError") + "\r\n" + ZR_ClassLibMessages.GetLastErrorStringTranslated());
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, "Proxy error. " + message);
        COMservers = (AsyncCom.MeterVPNServer.COMserver[]) null;
        return false;
      }
      catch (Exception ex)
      {
        string str = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
        AsyncIP.logger.Error(ex, str);
        if (this.MyAsyncFunctions.ErrorMessageBox)
          this.MyAsyncFunctions.AsyncComMessageBox(this.GetResString("TCPOpenError") + "\r\n" + ZR_ClassLibMessages.GetLastErrorStringTranslated());
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, str);
        COMservers = (AsyncCom.MeterVPNServer.COMserver[]) null;
        return false;
      }
      return true;
    }

    public bool AddCOMserverToCustomer(string Cert, string Name, string Password)
    {
      try
      {
        if (this.MyMeterVPNServer == null)
          this.MyMeterVPNServer = new MeterVPNService();
        using (Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))
        {
          IPEndPoint remoteEP = new IPEndPoint(IPAddress.Parse("1.0.0.1"), 80);
          if (!socket.BeginConnect((EndPoint) remoteEP, (AsyncCallback) null, (object) null).AsyncWaitHandle.WaitOne(this.MyAsyncFunctions.RecTime_BeforFirstByte, false))
          {
            ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout, "Timeout in AddCOMserverToCustomer(...)");
            throw new ApplicationException("Failed to connect server.");
          }
        }
        return this.MyMeterVPNServer.AddCOMserverToCustomer(Cert, Name, Password) == "ok";
      }
      catch (Exception ex)
      {
        string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
        AsyncIP.logger.Error(ex, message);
        if (this.MyAsyncFunctions.ErrorMessageBox)
          this.MyAsyncFunctions.AsyncComMessageBox(this.GetResString("TCPOpenError") + "\r\n" + ZR_ClassLibMessages.GetLastErrorStringTranslated());
        return false;
      }
    }

    public bool DelCOMserverFromCustomer(string Cert)
    {
      try
      {
        if (this.MyMeterVPNServer == null)
          this.MyMeterVPNServer = new MeterVPNService();
        Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        IPEndPoint remoteEP = new IPEndPoint(IPAddress.Parse("1.0.0.1"), 80);
        if (!socket.BeginConnect((EndPoint) remoteEP, (AsyncCallback) null, (object) null).AsyncWaitHandle.WaitOne(this.MyAsyncFunctions.RecTime_BeforFirstByte, false))
        {
          socket.Close();
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout, "Timeout in DelCOMserverFromCustomer(...).");
          throw new ApplicationException("Failed to connect server.");
        }
        socket.Close();
        return this.MyMeterVPNServer.DelCOMserverFromCustomer(Cert) == "ok";
      }
      catch
      {
        if (this.MyAsyncFunctions.ErrorMessageBox)
          this.MyAsyncFunctions.AsyncComMessageBox(this.GetResString("TCPOpenError") + "\r\n" + ZR_ClassLibMessages.GetLastErrorStringTranslated());
        return false;
      }
    }

    public bool ModCOMserver(string Cert, string Name)
    {
      try
      {
        if (this.MyMeterVPNServer == null)
          this.MyMeterVPNServer = new MeterVPNService();
        Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
        IPEndPoint remoteEP = new IPEndPoint(IPAddress.Parse("1.0.0.1"), 80);
        if (!socket.BeginConnect((EndPoint) remoteEP, (AsyncCallback) null, (object) null).AsyncWaitHandle.WaitOne(this.MyAsyncFunctions.RecTime_BeforFirstByte, false))
        {
          socket.Close();
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout, "Timeout in ModCOMserver(...).");
          throw new ApplicationException("Failed to connect server.");
        }
        socket.Close();
        return this.MyMeterVPNServer.ModCOMserver(Cert, Name) == "ok";
      }
      catch
      {
        if (this.MyAsyncFunctions.ErrorMessageBox)
          this.MyAsyncFunctions.AsyncComMessageBox(this.GetResString("TCPOpenError") + "\r\n" + ZR_ClassLibMessages.GetLastErrorStringTranslated());
        return false;
      }
    }

    private bool WorkException(Exception Ex)
    {
      switch (Ex)
      {
        case TimeoutException _:
          this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComReceiveTimeout);
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout, "Timeout.");
          return false;
        case IOException _:
          this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComIOException);
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, "IOException.");
          break;
        default:
          this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComUnknownError);
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, "Unknown error.");
          break;
      }
      this.MyAsyncFunctions.ComIsOpen = false;
      return false;
    }

    private COMserver GetCOMServer()
    {
      string selectedCoMserver = this.MyAsyncFunctions.MyMeterVPN.SelectedCOMserver;
      if (string.IsNullOrEmpty(selectedCoMserver))
      {
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.ComOpenError, "Remote end point is not set!");
        return (COMserver) null;
      }
      if (Util.IsIP(selectedCoMserver))
        return new COMserver()
        {
          IPAddress = selectedCoMserver,
          Name = selectedCoMserver,
          Online = true,
          LastSeen = SystemValues.DateTimeNow.ToString()
        };
      if (!this.MyAsyncFunctions.MyMeterVPN.COMservers.ContainsKey((object) selectedCoMserver) && !this.MyAsyncFunctions.MyMeterVPN.Update(this))
        return (COMserver) null;
      if (this.MyAsyncFunctions.MyMeterVPN.COMservers.ContainsKey((object) selectedCoMserver))
        return (COMserver) this.MyAsyncFunctions.MyMeterVPN.COMservers[(object) selectedCoMserver];
      string str = selectedCoMserver + " is a unknown COM server!";
      AsyncIP.logger.Error(str);
      ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.ComOpenError, str);
      return (COMserver) null;
    }

    public override void ClearComErrors()
    {
    }

    public override bool ClearBreak() => false;

    public override bool SetBreak() => false;

    public override void TestComState()
    {
    }

    public override bool SetHandshakeState(HandshakeStates HandshakeState) => false;

    public override bool CallTransceiverDeviceFunction(
      TransceiverDeviceFunction function,
      object param1,
      object param2)
    {
      return true;
    }

    public override bool TryReceiveBlock(out byte[] buffer)
    {
      buffer = (byte[]) null;
      if (this.dataNetworkStream == null || !this.dataNetworkStream.CanRead || !this.dataNetworkStream.DataAvailable)
        return false;
      List<byte> byteList = new List<byte>();
      while (this.dataNetworkStream.DataAvailable)
      {
        byte[] numArray1 = new byte[1024];
        int length = this.dataNetworkStream.Read(numArray1, 0, numArray1.Length);
        if (length > 0)
        {
          byte[] numArray2 = new byte[length];
          Array.Copy((Array) numArray1, (Array) numArray2, numArray2.Length);
          byteList.AddRange((IEnumerable<byte>) numArray2);
          if (AsyncIP.logger.IsTraceEnabled)
            AsyncIP.logger.Trace("Data available: " + Util.ByteArrayToHexString(numArray2));
        }
        if (!Util.Wait(100L, nameof (TryReceiveBlock), (ICancelable) this.MyAsyncFunctions, AsyncIP.logger))
          return false;
      }
      buffer = byteList.ToArray();
      return true;
    }

    public override bool TryReceiveBlock(out byte[] buffer, int numberOfBytesToReceive)
    {
      throw new NotImplementedException();
    }

    public override object GetChannel() => (object) null;

    internal class LANVPN
    {
      private Socket UDPSocket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);
      private string Target_IP = "224.0.0.1";
      private int Target_Port = 9000;
      private int Listen_Port = 9050;
      private SortedList MessageQueue = new SortedList();
      private SortedList MyCOMservers = new SortedList();
      private string LastCommand = "";

      internal AsyncCom.MeterVPNServer.COMserver[] GetLocalCOMservers()
      {
        try
        {
          this.InitMulticastSocket();
          this.Send("*", AsyncIP.LANVPN.COMserverCommands.GetIPConfig, "");
          Thread.Sleep(1000);
          this.ParseAvailableMessages();
        }
        catch
        {
          return new AsyncCom.MeterVPNServer.COMserver[0];
        }
        AsyncCom.MeterVPNServer.COMserver[] localCoMservers = new AsyncCom.MeterVPNServer.COMserver[this.MyCOMservers.Count];
        int index = 0;
        foreach (DictionaryEntry coMserver1 in this.MyCOMservers)
        {
          AsyncIP.LANVPN.COMserver coMserver2 = (AsyncIP.LANVPN.COMserver) coMserver1.Value;
          localCoMservers[index] = new AsyncCom.MeterVPNServer.COMserver();
          localCoMservers[index].Name = coMserver2.Name;
          localCoMservers[index].Cert = coMserver2.Name;
          localCoMservers[index].IP = coMserver2.IP;
          localCoMservers[index].LastSeen = SystemValues.DateTimeNow.ToString();
          localCoMservers[index].Traffic = "";
          localCoMservers[index].Online = true;
          ++index;
        }
        return localCoMservers;
      }

      private bool InitMulticastSocket()
      {
        try
        {
          IPEndPoint localEP = new IPEndPoint(IPAddress.Any, this.Listen_Port);
          this.UDPSocket.SetSocketOption(SocketOptionLevel.Udp, SocketOptionName.Debug, 1);
          this.UDPSocket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, 1);
          this.UDPSocket.Bind((EndPoint) localEP);
          this.UDPSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.MulticastTimeToLive, 1);
          this.UDPSocket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.AddMembership, (object) new MulticastOption(IPAddress.Parse(this.Target_IP), IPAddress.Any));
          this.Receive();
        }
        catch
        {
          return false;
        }
        return true;
      }

      private void Send(
        string COMserver,
        AsyncIP.LANVPN.COMserverCommands Command,
        string Parameter)
      {
        Parameter += ",";
        byte[] bytes = Encoding.ASCII.GetBytes(COMserver + " " + Command.ToString() + " " + Parameter);
        this.LastCommand = Command.ToString();
        EndPoint remoteEP = (EndPoint) new IPEndPoint(IPAddress.Parse(this.Target_IP), this.Target_Port);
        this.UDPSocket.BeginSendTo(bytes, 0, bytes.Length, SocketFlags.None, remoteEP, new AsyncCallback(this.SendCallback), (object) this.UDPSocket);
      }

      private void SendCallback(IAsyncResult ar)
      {
        try
        {
          ((Socket) ar.AsyncState).EndSendTo(ar);
        }
        catch
        {
        }
      }

      private void Receive()
      {
        try
        {
          EndPoint remoteEP = (EndPoint) new IPEndPoint(IPAddress.Any, this.Listen_Port);
          AsyncIP.LANVPN.StateObject state = new AsyncIP.LANVPN.StateObject();
          state.workSocket = this.UDPSocket;
          this.UDPSocket.BeginReceiveFrom(state.buffer, 0, 1024, SocketFlags.None, ref remoteEP, new AsyncCallback(this.ReceiveCallback), (object) state);
        }
        catch
        {
        }
      }

      private void ReceiveCallback(IAsyncResult ar)
      {
        try
        {
          EndPoint endPoint = (EndPoint) new IPEndPoint(IPAddress.Any, this.Listen_Port);
          AsyncIP.LANVPN.StateObject asyncState = (AsyncIP.LANVPN.StateObject) ar.AsyncState;
          Socket workSocket = asyncState.workSocket;
          int from = workSocket.EndReceiveFrom(ar, ref endPoint);
          workSocket.BeginReceiveFrom(asyncState.buffer, 0, 1024, SocketFlags.None, ref endPoint, new AsyncCallback(this.ReceiveCallback), (object) asyncState);
          string[] strArray = Encoding.ASCII.GetString(asyncState.buffer, 0, from).Split(' ');
          if (strArray.Length < 3)
            return;
          this.MessageQueue.Add((object) strArray[0], (object) new AsyncIP.LANVPN.ReceivedMessage()
          {
            COMserver = strArray[0],
            Command = strArray[1],
            Parameters = strArray[2]
          });
        }
        catch
        {
        }
      }

      private void ParseAvailableMessages()
      {
        foreach (DictionaryEntry message in this.MessageQueue)
        {
          AsyncIP.LANVPN.ReceivedMessage receivedMessage = (AsyncIP.LANVPN.ReceivedMessage) message.Value;
          if (receivedMessage.Command == AsyncIP.LANVPN.COMserverCommands.GetIPConfig.ToString())
          {
            AsyncIP.LANVPN.COMserver coMserver = new AsyncIP.LANVPN.COMserver();
            coMserver.Name = receivedMessage.COMserver;
            string[] strArray = receivedMessage.Parameters.ToString().Split(',');
            coMserver.Version = strArray[0];
            for (int index = 1; index < strArray.Length; ++index)
            {
              if (strArray[index].Contains("addr"))
                coMserver.IP = strArray[index].Substring(strArray[index].IndexOf(':') + 1);
              if (strArray[index].Contains("Mask"))
                coMserver.Subnet = strArray[index].Substring(strArray[index].IndexOf(':') + 1);
              if (strArray[index].Contains("0.0.0.0") && coMserver.Gateway == "")
                coMserver.Gateway = strArray[index + 1];
              if (strArray[index].Contains("DHCP"))
                coMserver.IPConfig = strArray[index];
              if (strArray[index].Contains("STATIC"))
                coMserver.IPConfig = strArray[index];
              if (strArray[index].Contains("nameserver") && coMserver.DNS == "")
                coMserver.DNS = strArray[index + 1];
              if (strArray[index].Contains("http-proxy") && coMserver.DNS == "")
              {
                if (strArray[index][0] == ';')
                {
                  coMserver.ProxyType = "none";
                }
                else
                {
                  coMserver.ProxyIP = strArray[index + 1];
                  coMserver.ProxyPort = strArray[index + 2];
                  coMserver.ProxyType = strArray[index + 4];
                }
              }
            }
            this.MyCOMservers.Add((object) coMserver.Name, (object) coMserver);
          }
        }
        this.MessageQueue.Clear();
      }

      private class StateObject
      {
        public Socket workSocket = (Socket) null;
        public const int BufferSize = 1024;
        public byte[] buffer = new byte[1024];
      }

      private class ReceivedMessage
      {
        public string COMserver;
        public string Command;
        public string Parameters;
      }

      private class COMserver
      {
        public string Name = "";
        public string Version = "";
        public string IPConfig = "";
        public string IP = "";
        public string Subnet = "";
        public string Gateway = "";
        public string DNS = "";
        public string ProxyType = "";
        public string ProxyIP = "";
        public string ProxyPort = "";
        public string ProxyUser = "";
        public string ProxyPass = "";
      }

      private enum COMserverCommands
      {
        GetIPConfig,
        SetIPConfig,
        GetVPNConfig,
        SetVPNConfig,
        Reboot,
      }
    }
  }
}


--- AsyncSerial.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.AsyncSerial
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using GmmDbLib;
using NLog;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Ports;
using System.Threading;
using System.Windows.Forms;
using ZENNER.CommonLibrary.Exceptions;
using ZR_ClassLibrary;

#nullable disable
namespace AsyncCom
{
  internal class AsyncSerial(AsyncFunctions MyParent) : AsyncFunctionsBase(MyParent)
  {
    internal Port MySerialPort;
    private static Logger AsyncSerialLogger = LogManager.GetLogger(nameof (AsyncSerial));
    private Queue<byte> MinoHeadReceiverQueue = new Queue<byte>();
    private bool MinoHeadIsTransparent = false;

    public override event System.EventHandler ConnectionLost;

    public override event System.EventHandler BatterieLow;

    public override long InputBufferLength => (long) this.MySerialPort.BytesToRead;

    public override bool Open()
    {
      if (this.local_Open())
        return true;
      if (this.MyAsyncFunctions.ErrorMessageBox)
        this.MyAsyncFunctions.AsyncComMessageBox(ZR_ClassLibMessages.GetLastErrorMessageAndClearError());
      return false;
    }

    private string GetResString(string name) => this.MyAsyncFunctions.MyRes.GetString(name);

    private bool local_Open()
    {
      Parity parity;
      switch (this.MyAsyncFunctions.Parity)
      {
        case "no":
          parity = Parity.None;
          break;
        case "odd":
          parity = Parity.Odd;
          break;
        case "even":
          parity = Parity.Even;
          break;
        default:
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.InternalError, "Wrong parity.");
          return false;
      }
      if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoConnect)
      {
        if (this.MySerialPort == null || !(this.MySerialPort is MinoConnectSerialPort))
        {
          this.MySerialPort = (Port) new MinoConnectSerialPort(this.MyAsyncFunctions);
          this.MySerialPort.ConnectionLost += new System.EventHandler(this.MySerialPort_ConnectionLost);
          this.MySerialPort.BatterieLow += new System.EventHandler(this.MySerialPort_BatterieLow);
        }
      }
      else
        this.MySerialPort = (Port) new StandardSerialPort(this.MyAsyncFunctions.Baudrate, parity, this.MyAsyncFunctions);
      if (this.MySerialPort == null)
      {
        AsyncSerial.AsyncSerialLogger.Debug("Can not create com object.");
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.InternalError, "Can not create com object.");
        this.MyAsyncFunctions.ComIsOpen = false;
        return false;
      }
      try
      {
        this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComOpen);
        this.MyAsyncFunctions.transceiverDeviceInfo = "";
        this.MySerialPort.ReadTimeout = this.MyAsyncFunctions.WaitBeforeRepeatTime;
        this.MySerialPort.WriteTimeout = 3000;
        if (!this.MySerialPort.Open())
          return false;
        if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoHead)
        {
          AsyncSerial.AsyncSerialLogger.Info("Connecting MinoHead ...");
          this.MyAsyncFunctions.SendAsyncComMessage(new GMM_EventArgs(GMM_EventArgs.MessageType.StatusChanged)
          {
            EventMessage = "Connecting MinoHead ..."
          });
          int num1 = 0;
          short num2 = 0;
          short num3 = 0;
          short num4 = 0;
          do
          {
            this.SendMinoHeadWakeup();
            int num5;
            try
            {
              num2 = this.getHeadVersion();
              num5 = 0;
            }
            catch (TimeoutException ex)
            {
              AsyncSerial.AsyncSerialLogger.Error("Can not get MinoHead version Error: {0}", ex.Message);
              num5 = num1 + 1;
              if (num5 > 5)
              {
                ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout, this.GetResString("MinoHeadNotFound"));
                this.MySerialPort.Close();
                return false;
              }
            }
            catch (Exception ex)
            {
              AsyncSerial.AsyncSerialLogger.Error("Can not get MinoHead version Error: {0}", ex.Message);
              ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, this.GetResString("MinoHeadNotFound") + ZR_Constants.SystemNewLine + ZR_Constants.SystemNewLine + ex.ToString());
              this.MySerialPort.Close();
              return false;
            }
            int num6;
            try
            {
              num3 = this.getEchoIrDa();
              num6 = 0;
            }
            catch (TimeoutException ex)
            {
              AsyncSerial.AsyncSerialLogger.Error("Can not getEchoIrDa Error: {0}", ex.Message);
              num6 = num5 + 1;
              if (num6 > 5)
              {
                ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout, this.GetResString("MinoHeadNotFound"));
                this.MySerialPort.Close();
                return false;
              }
            }
            catch (Exception ex)
            {
              AsyncSerial.AsyncSerialLogger.Error("Can not getEchoIrDa Error: {0}", ex.Message);
              ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, this.GetResString("MinoHeadNotFound") + ZR_Constants.SystemNewLine + ZR_Constants.SystemNewLine + ex.ToString());
              this.MySerialPort.Close();
              return false;
            }
            try
            {
              num4 = this.getRFModul();
              num1 = 0;
            }
            catch (TimeoutException ex)
            {
              AsyncSerial.AsyncSerialLogger.Error("Can not getRFModul Error: {0}", ex.Message);
              num1 = num6 + 1;
              if (num1 > 5)
              {
                ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout, this.GetResString("MinoHeadNotFound"));
                this.MySerialPort.Close();
                return false;
              }
            }
            catch (Exception ex)
            {
              AsyncSerial.AsyncSerialLogger.Error("Can not getRFModul Error: {0}", ex.Message);
              ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, this.GetResString("MinoHeadNotFound") + ZR_Constants.SystemNewLine + ZR_Constants.SystemNewLine + ex.ToString());
              this.MySerialPort.Close();
              return false;
            }
          }
          while (num1 > 0);
          if (num2 < (short) 6)
          {
            ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.IllegalData, this.GetResString("MinoHeadNotFound") + ZR_Constants.SystemNewLine + ZR_Constants.SystemNewLine + "Wrong version: " + num2.ToString());
            AsyncSerial.AsyncSerialLogger.Debug("MinoHeadNotFound: wrong Version: " + num2.ToString());
            this.MySerialPort.Close();
            return false;
          }
          if (this.MyAsyncFunctions.transceiverDeviceInfo.Length > 0)
          {
            AsyncFunctions asyncFunctions = this.MyAsyncFunctions;
            asyncFunctions.transceiverDeviceInfo = asyncFunctions.transceiverDeviceInfo + ZR_Constants.SystemNewLine + ZR_Constants.SystemNewLine + "------------------------" + ZR_Constants.SystemNewLine;
          }
          AsyncFunctions asyncFunctions1 = this.MyAsyncFunctions;
          asyncFunctions1.transceiverDeviceInfo = asyncFunctions1.transceiverDeviceInfo + "Minohead" + ZR_Constants.SystemNewLine + "HeadVersion: " + num2.ToString() + ZR_Constants.SystemNewLine + "IrdaVersion: " + num3.ToString() + ZR_Constants.SystemNewLine + "RFVersion: " + num4.ToString();
          if (AsyncSerial.AsyncSerialLogger.IsDebugEnabled)
            AsyncSerial.AsyncSerialLogger.Debug("Minohead found: " + ZR_Constants.SystemNewLine + "HeadVersion: " + num2.ToString() + ZR_Constants.SystemNewLine + "IrdaVersion: " + num3.ToString() + ZR_Constants.SystemNewLine + "RFVersion: " + num4.ToString());
        }
      }
      catch (IOException ex)
      {
        this.MyAsyncFunctions.ComIsOpen = false;
        if (this.MySerialPort.IsOpen)
          this.MySerialPort.Close();
        this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComIOException);
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.ComOpenError, this.MyAsyncFunctions.MyRes.GetString("ComOpenError"));
        AsyncSerial.AsyncSerialLogger.Error(ex.InnerException, this.GetResString("ComOpenError"));
        return false;
      }
      catch (Exception ex)
      {
        if (this.MySerialPort.IsOpen)
          this.MySerialPort.Close();
        this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComUnknownError);
        this.MyAsyncFunctions.ComIsOpen = false;
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.ComOpenError, this.GetResString("ComOpenError"));
        AsyncSerial.AsyncSerialLogger.Error(ex.InnerException, this.GetResString("ComOpenError"));
        return false;
      }
      this.MyAsyncFunctions.ComIsOpen = true;
      if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoIR)
      {
        if (this.MySerialPort is StandardSerialPort)
        {
          this.MySerialPort.SetRTS(true);
          this.MySerialPort.SetDTR(false);
          if (!ZR_ClassLibrary.Util.Wait((long) this.MyAsyncFunctions.TransTime_AfterOpen, "MinoIR->TransTime_AfterOpen", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
            return false;
          this.MySerialPort.SetDTR(true);
          if (!ZR_ClassLibrary.Util.Wait(200L, "MinoIR->SetDTR(true)", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
            return false;
          this.MySerialPort.SetDTR(false);
          if (!ZR_ClassLibrary.Util.Wait(400L, "MinoIR->SetDTR(false)", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
            return false;
        }
        else
        {
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.FunctionNotImplemented, "MinoIR handshaking not yet supported");
          AsyncSerial.AsyncSerialLogger.Error("MinoIR handshaking not yet supported");
          this.MySerialPort.Close();
          return false;
        }
      }
      else if (!ZR_ClassLibrary.Util.Wait((long) this.MyAsyncFunctions.TransTime_AfterOpen, "TransTime_AfterOpen", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
        return false;
      if (this.MyAsyncFunctions.TestEcho && !this.MyAsyncFunctions.EchoTestIsActive)
      {
        AsyncSerial.AsyncSerialLogger.Debug("Testing for echo");
        this.MyAsyncFunctions.EchoTestIsActive = true;
        ByteField DataBlock1 = new ByteField(6);
        DataBlock1.Add(85);
        DataBlock1.Add(170);
        DataBlock1.Add(90);
        DataBlock1.Add(165);
        DataBlock1.Add(15);
        DataBlock1.Add(240);
        this.MyAsyncFunctions.EchoOn = false;
        this.TransmitBlock(ref DataBlock1);
        if (!ZR_ClassLibrary.Util.Wait((long) (int) (this.MyAsyncFunctions.ByteTime * 6.0 + 100.0), "local_Open->TestEcho", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
          return false;
        this.MyAsyncFunctions.EchoOn = true;
        ByteField DataBlock2 = new ByteField(6);
        if (this.ReceiveBlock(ref DataBlock2, 6, true))
        {
          for (int index = 0; index < 6; ++index)
          {
            if ((int) DataBlock2.Data[index] != (int) DataBlock1.Data[index])
            {
              this.MyAsyncFunctions.EchoOn = false;
              break;
            }
          }
        }
        else
          this.MyAsyncFunctions.EchoOn = false;
        AsyncSerial.AsyncSerialLogger.Debug("EchoOn is " + this.MyAsyncFunctions.EchoOn.ToString());
        if (this.MyAsyncFunctions.ComWindow != null)
          this.MyAsyncFunctions.ComWindow.ShowEcho();
        this.MyAsyncFunctions.EchoTestIsActive = false;
      }
      if (this.MyAsyncFunctions.ComWindow != null)
        this.MyAsyncFunctions.ComWindow.SetComState();
      this.MyAsyncFunctions.LastWakeupRefreshTime = DateTime.MinValue;
      this.MyAsyncFunctions.SendAsyncComMessage(new GMM_EventArgs(GMM_EventArgs.MessageType.StatusChanged)
      {
        EventMessage = "Com opened"
      });
      return true;
    }

    private void MySerialPort_ConnectionLost(object sender, EventArgs e)
    {
      if (this.ConnectionLost == null)
        return;
      this.ConnectionLost(sender, e);
    }

    private void MySerialPort_BatterieLow(object sender, EventArgs e)
    {
      if (this.BatterieLow == null)
        return;
      this.BatterieLow(sender, e);
    }

    public override bool Close()
    {
      this.MyAsyncFunctions.ComIsOpen = false;
      this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComClose);
      if (this.MySerialPort == null)
        return false;
      try
      {
        this.MySerialPort.Close();
      }
      catch (IOException ex)
      {
        AsyncSerial.AsyncSerialLogger.Error((Exception) ex, "Failed close the port!");
        this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComIOException);
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, "ComIOException");
        return false;
      }
      catch (Exception ex)
      {
        AsyncSerial.AsyncSerialLogger.Error(ex, "Failed close the port!");
        this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComUnknownError);
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, "ComUnknownError");
        return false;
      }
      this.MyAsyncFunctions.SendAsyncComMessage(new GMM_EventArgs(GMM_EventArgs.MessageType.StatusChanged)
      {
        EventMessage = "Com closed"
      });
      return true;
    }

    public override void ClearCom()
    {
      this.MyAsyncFunctions.LineBuffer.Length = 0;
      this.MySerialPort.FramingError = false;
      this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComClearReceiver);
      if (!this.MySerialPort.IsOpen)
        return;
      try
      {
        if (this.MinoHeadReceiverQueue != null && this.MinoHeadReceiverQueue.Count > 0)
        {
          AsyncSerial.AsyncSerialLogger.Error<int, string>("Clear MinoHeadReceiverQueue SIZE: {0}, BUFFER: {1}", this.MinoHeadReceiverQueue.Count, ZR_ClassLibrary.Util.ByteArrayToHexString(this.MinoHeadReceiverQueue.ToArray()));
          this.MinoHeadReceiverQueue.Clear();
        }
        if (this.MySerialPort.BytesToWrite > 0)
        {
          AsyncSerial.AsyncSerialLogger.Error("DiscardOutBuffer {0} bytes", this.MySerialPort.BytesToWrite);
          this.MySerialPort.DiscardOutBuffer();
        }
        if (this.MySerialPort.BytesToRead > 0)
        {
          byte[] buffer = new byte[this.MySerialPort.BytesToRead];
          this.MySerialPort.Read(buffer, 0, buffer.Length);
          if (AsyncSerial.AsyncSerialLogger.IsTraceEnabled)
            AsyncSerial.AsyncSerialLogger.Trace<int, string>("DiscardInBuffer {0} bytes: {1}", buffer.Length, ZR_ClassLibrary.Util.ByteArrayToHexString(buffer));
          this.MySerialPort.DiscardInBuffer();
        }
        Thread.Sleep(0);
      }
      catch (Exception ex)
      {
        this.WorkException(ex, (ByteField) null, this.MySerialPort.WriteTimeout);
      }
    }

    public override void ClearComErrors() => this.MySerialPort.FramingError = false;

    public override bool ClearBreak()
    {
      if (!this.MySerialPort.IsOpen)
        return false;
      try
      {
        this.ClearCom();
        this.MySerialPort.BreakState = false;
        this.ClearCom();
      }
      catch (Exception ex)
      {
        this.WorkException(ex, (ByteField) null, this.MySerialPort.WriteTimeout);
        return false;
      }
      this.MyAsyncFunctions.LastWakeupRefreshTime = SystemValues.DateTimeNow;
      return true;
    }

    public override bool SetBreak()
    {
      if (!this.MySerialPort.IsOpen)
        return false;
      try
      {
        this.ClearCom();
        this.MySerialPort.BreakState = true;
      }
      catch (Exception ex)
      {
        this.WorkException(ex, (ByteField) null, this.MySerialPort.WriteTimeout);
        return false;
      }
      return true;
    }

    public override void TestComState()
    {
    }

    public override bool SetHandshakeState(HandshakeStates HandshakeState)
    {
      if (!this.MySerialPort.IsOpen)
        return false;
      try
      {
        this.MySerialPort.Handshake = (Handshake) HandshakeState;
      }
      catch (Exception ex)
      {
        this.WorkException(ex, (ByteField) null, this.MySerialPort.WriteTimeout);
        return false;
      }
      return true;
    }

    internal void ManageWakeup()
    {
      if (!this.MySerialPort.IsOpen || this.MyAsyncFunctions.Wakeup == WakeupSystem.None || this.MyAsyncFunctions.WakeupTemporaryOff)
        return;
      double totalMilliseconds = SystemValues.DateTimeNow.Subtract(this.MyAsyncFunctions.LastWakeupRefreshTime).TotalMilliseconds;
      double wakeupIntervalTime = (double) this.MyAsyncFunctions.WakeupIntervalTime;
      bool flag1 = totalMilliseconds > wakeupIntervalTime || totalMilliseconds == wakeupIntervalTime;
      if (this.MySerialPort.WriteTimeout < this.MyAsyncFunctions.TransTime_BreakTime)
        this.MySerialPort.WriteTimeout = this.MyAsyncFunctions.TransTime_BreakTime;
      if (!flag1)
        return;
      if (this.MyAsyncFunctions.Wakeup == WakeupSystem.MinoHead)
      {
        try
        {
          this.SendMinoHeadWakeup();
        }
        catch (Exception ex)
        {
          AsyncSerial.AsyncSerialLogger.Error("Failed SendMinoHeadWakeup! Error: " + ex.Message);
        }
      }
      else
      {
        this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComTransmitBreak);
        if (this.MyAsyncFunctions.Wakeup == WakeupSystem.Break)
        {
          try
          {
            Application.DoEvents();
            AsyncSerial.AsyncSerialLogger.Info("Break signal on");
            this.MySerialPort.BreakState = true;
            if (!ZR_ClassLibrary.Util.Wait((long) this.MyAsyncFunctions.TransTime_BreakTime, "ManageWakeup->TransTime_BreakTime: send break", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
              return;
            this.MySerialPort.BreakState = false;
            AsyncSerial.AsyncSerialLogger.Info("... break signal off");
          }
          catch (Exception ex)
          {
            this.WorkException(ex, (ByteField) null, this.MySerialPort.WriteTimeout);
          }
        }
        else if (this.MyAsyncFunctions.Wakeup == WakeupSystem.BaudrateCarrier)
        {
          int numberOfBytes = !(this.MyAsyncFunctions.Parity != "no") ? (int) ((double) this.MyAsyncFunctions.Baudrate / 10.0 * ((double) this.MyAsyncFunctions.TransTime_BreakTime / 1000.0)) : (int) ((double) this.MyAsyncFunctions.Baudrate / 11.0 * ((double) this.MyAsyncFunctions.TransTime_BreakTime / 1000.0));
          AsyncSerial.AsyncSerialLogger.Info("Start transmit baudrate carrier. " + numberOfBytes.ToString() + " bytes");
          bool flag2 = true;
          if (this.MySerialPort is MinoConnectSerialPort)
          {
            double millisecondsTimeout = !(this.MyAsyncFunctions.Parity != "no") ? (double) numberOfBytes * 1000.0 / ((double) this.MyAsyncFunctions.Baudrate / 10.0) : (double) numberOfBytes * 1000.0 / ((double) this.MyAsyncFunctions.Baudrate / 11.0);
            MinoConnectSerialPort serialPort = (MinoConnectSerialPort) this.MySerialPort;
            serialPort.PollingErrorTime = SystemValues.DateTimeNow.AddMilliseconds(millisecondsTimeout + (double) this.MyAsyncFunctions.TransTime_BreakTime + (double) serialPort.PollingErrorTime_ms);
            if (serialPort._base is MiConBLE_SerialPort)
            {
              ((MiConBLE_SerialPort) serialPort._base).BLE_Channel.WriteBaudrateCarrier(numberOfBytes);
              Thread.Sleep((int) millisecondsTimeout);
              flag2 = false;
            }
          }
          if (flag2)
          {
            byte[] buffer = new byte[numberOfBytes];
            for (int index = 0; index < buffer.Length; ++index)
              buffer[index] = (byte) 85;
            this.Write(buffer, 0, buffer.Length);
          }
          AsyncSerial.AsyncSerialLogger.Info("... transmit baudrate carrier done");
        }
        this.MyAsyncFunctions.LastWakeupRefreshTime = SystemValues.DateTimeNow;
        if (AsyncSerial.AsyncSerialLogger.IsTraceEnabled)
          AsyncSerial.AsyncSerialLogger.Trace("Start TransTime_AfterBreak: " + this.MyAsyncFunctions.TransTime_AfterBreak.ToString() + " ms");
        Thread.Sleep(this.MyAsyncFunctions.TransTime_AfterBreak);
        AsyncSerial.AsyncSerialLogger.Trace("TransTime_AfterBreak time finished.");
      }
    }

    public override bool CallTransceiverDeviceFunction(
      TransceiverDeviceFunction function,
      object param1,
      object param2)
    {
      switch (function)
      {
        case TransceiverDeviceFunction.TransparentModeOn:
          switch (this.MyAsyncFunctions.Transceiver)
          {
            case TransceiverDevice.None:
            case TransceiverDevice.MinoIR:
              break;
            case TransceiverDevice.MinoConnect:
              if (!(this.MySerialPort is MinoConnectSerialPort))
                throw new ArgumentException("MySerialPort");
              ((MinoConnectSerialPort) this.MySerialPort).SetTransparentMode(true);
              break;
            case TransceiverDevice.MinoHead:
              this.setHeadTransparent();
              break;
            default:
              throw new NotImplementedException();
          }
          break;
        case TransceiverDeviceFunction.TransparentModeV3On:
          switch (this.MyAsyncFunctions.Transceiver)
          {
            case TransceiverDevice.None:
            case TransceiverDevice.MinoConnect:
            case TransceiverDevice.MinoIR:
              break;
            case TransceiverDevice.MinoHead:
              this.setHeadTransparentV3();
              break;
            default:
              throw new NotImplementedException();
          }
          break;
        case TransceiverDeviceFunction.TransparentModeOff:
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoConnect)
            return this.MySerialPort is MinoConnectSerialPort ? ((MinoConnectSerialPort) this.MySerialPort).SetTransparentMode(false) : throw new ArgumentException("MySerialPort");
          break;
        case TransceiverDeviceFunction.EnableMinoConnectPolling:
          if (this.MySerialPort is MinoConnectSerialPort)
          {
            ((MinoConnectSerialPort) this.MySerialPort).ResumePolling();
            break;
          }
          break;
        case TransceiverDeviceFunction.DisableMinoConnectPolling:
          if (this.MySerialPort is MinoConnectSerialPort)
            ((MinoConnectSerialPort) this.MySerialPort).SuspendPolling();
          if (!ZR_ClassLibrary.Util.Wait(300L, "Wait after DisableMinoConnectPolling", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
            return false;
          this.MySerialPort.DiscardInBuffer();
          break;
        case TransceiverDeviceFunction.StopRadio:
          AsyncSerial.AsyncSerialLogger.Info("Stop radio");
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoHead)
          {
            this.SendMinoHeadWakeup();
            break;
          }
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoConnect)
          {
            if (!(this.MySerialPort is MinoConnectSerialPort))
              throw new ArgumentException();
            ((MinoConnectSerialPort) this.MySerialPort).StopWalkBy();
            break;
          }
          break;
        case TransceiverDeviceFunction.StartRadio2:
          AsyncSerial.AsyncSerialLogger.Info("StartWalkByRadio2");
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoHead)
          {
            if (!this.MinoHeadSendData((byte) 105, (byte[]) null, 0) || !ZR_ClassLibrary.Util.Wait(1000L, "after turn on the radio 2", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
              return false;
            this.ClearCom();
            return true;
          }
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoConnect)
          {
            if (!(this.MySerialPort is MinoConnectSerialPort))
              throw new ArgumentException();
            ((MinoConnectSerialPort) this.MySerialPort).StartRadio2();
            break;
          }
          break;
        case TransceiverDeviceFunction.StartRadio3:
          AsyncSerial.AsyncSerialLogger.Info("StartWalkByRadio3");
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoHead)
          {
            if (!this.MinoHeadSendData((byte) 106, (byte[]) null, 0) || !ZR_ClassLibrary.Util.Wait(1000L, "after turn on the radio 2", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
              return false;
            this.ClearCom();
            return true;
          }
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoConnect)
          {
            if (!(this.MySerialPort is MinoConnectSerialPort))
              throw new ArgumentException();
            ((MinoConnectSerialPort) this.MySerialPort).StartRadio3();
            break;
          }
          break;
        case TransceiverDeviceFunction.StartRadio4:
          AsyncSerial.AsyncSerialLogger.Info("StartWalkByRadio4");
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoConnect)
          {
            if (!(this.MySerialPort is MinoConnectSerialPort))
              throw new ArgumentException();
            ((MinoConnectSerialPort) this.MySerialPort).StartRadio4();
            break;
          }
          break;
        case TransceiverDeviceFunction.StartMinomatradioTest:
        case TransceiverDeviceFunction.Start_wMBusS1:
        case TransceiverDeviceFunction.Start_wMBusS1M:
        case TransceiverDeviceFunction.Start_wMBusS2:
        case TransceiverDeviceFunction.Start_wMBusT1:
        case TransceiverDeviceFunction.Start_wMBusT2_meter:
        case TransceiverDeviceFunction.Start_wMBusT2_other:
        case TransceiverDeviceFunction.Start_wMBusC1A:
        case TransceiverDeviceFunction.Start_wMBusC1B:
        case TransceiverDeviceFunction.Start_RadioMS:
        case TransceiverDeviceFunction.StartRadio3_868_95_RUSSIA:
          AsyncSerial.AsyncSerialLogger.Info(function.ToString());
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoConnect)
          {
            MinoConnectSerialPort connectSerialPort = this.MySerialPort is MinoConnectSerialPort ? this.MySerialPort as MinoConnectSerialPort : throw new ArgumentException();
            switch (function)
            {
              case TransceiverDeviceFunction.StartMinomatradioTest:
                return connectSerialPort.StartMinomatRadioTest(Convert.ToByte(param1));
              case TransceiverDeviceFunction.Start_wMBusS1:
                return connectSerialPort.Start_wMBusS1();
              case TransceiverDeviceFunction.Start_wMBusS1M:
                return connectSerialPort.Start_wMBusS1M();
              case TransceiverDeviceFunction.Start_wMBusS2:
                return connectSerialPort.Start_wMBusS2();
              case TransceiverDeviceFunction.Start_wMBusT1:
                return connectSerialPort.Start_wMBusT1();
              case TransceiverDeviceFunction.Start_wMBusT2_meter:
                return connectSerialPort.Start_wMBusT2_meter();
              case TransceiverDeviceFunction.Start_wMBusT2_other:
                return connectSerialPort.Start_wMBusT2_other();
              case TransceiverDeviceFunction.Start_wMBusC1A:
                return connectSerialPort.Start_wMBusC1A();
              case TransceiverDeviceFunction.Start_wMBusC1B:
                return connectSerialPort.Start_wMBusC1B();
              case TransceiverDeviceFunction.Start_RadioMS:
                return connectSerialPort.Start_RadioMS();
              case TransceiverDeviceFunction.StartRadio3_868_95_RUSSIA:
                return connectSerialPort.StartRadio3_868_95_RUSSIA();
            }
          }
          else
            break;
          break;
        case TransceiverDeviceFunction.StartSendTestPacket:
          AsyncSerial.AsyncSerialLogger.Info("Start send test packet");
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoConnect)
          {
            if (param1 == null)
              throw new ArgumentException();
            if (this.MySerialPort is MinoConnectSerialPort)
              return ((MinoConnectSerialPort) this.MySerialPort).StartSendTestPacket((RadioMode) param1, (byte) param2);
            throw new ArgumentException();
          }
          break;
        case TransceiverDeviceFunction.StopSendTestPacket:
          AsyncSerial.AsyncSerialLogger.Info("Stop send test packet");
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoConnect)
            return this.MySerialPort is MinoConnectSerialPort ? ((MinoConnectSerialPort) this.MySerialPort).StopSendTestPacket() : throw new ArgumentException();
          break;
        case TransceiverDeviceFunction.SendTestPacket:
          AsyncSerial.AsyncSerialLogger.Info("SendTestPacket " + param1?.ToString() + " " + param2?.ToString());
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoConnect)
          {
            if (param1 == null)
              throw new ArgumentException(nameof (param1));
            if (param2 == null)
              throw new ArgumentException(nameof (param2));
            if (this.MySerialPort is MinoConnectSerialPort)
              return ((MinoConnectSerialPort) this.MySerialPort).SendTestPacket((BusMode) param1, (byte[]) param2);
            throw new ArgumentException();
          }
          break;
        default:
          throw new NotImplementedException();
      }
      return true;
    }

    public override bool TransmitString(string DataString)
    {
      if (!this.MySerialPort.IsOpen)
        return false;
      try
      {
        this.MySerialPort.Write(DataString);
      }
      catch (Exception ex)
      {
        this.WorkException(ex, (ByteField) null, this.MySerialPort.WriteTimeout);
        return false;
      }
      return true;
    }

    public override bool TransmitBlock(string DataString)
    {
      ByteField DataBlock = new ByteField(DataString.Length);
      for (int index = 0; index < DataString.Length; ++index)
        DataBlock.Add((byte) DataString[index]);
      return this.TransmitBlock(ref DataBlock);
    }

    public override bool TransmitBlock(ref ByteField DataBlock)
    {
      if (!this.MySerialPort.IsOpen)
        return false;
      this.MyAsyncFunctions.WaitToEarliestTransmitTime();
      this.ManageWakeup();
      this.ClearCom();
      this.MyAsyncFunctions.Logger.WriteLoggerData(EventLogger.LoggerEvent.ComTransmitData, ref DataBlock);
      try
      {
        this.Write(DataBlock.Data, 0, DataBlock.Count);
      }
      catch (Exception ex)
      {
        this.ResetLastTransmitEndTime();
        this.WorkException(ex, DataBlock, this.MySerialPort.WriteTimeout);
        return false;
      }
      this.ResetLastTransmitEndTime();
      if (this.MyAsyncFunctions.EchoOn)
      {
        ByteField byteField = new ByteField(DataBlock.Count);
        bool flag = this.ReceiveBlock(ref byteField, DataBlock.Count, false);
        if (AsyncSerial.AsyncSerialLogger.IsDebugEnabled)
          AsyncSerial.AsyncSerialLogger.Debug("<TransEcho." + byteField.GetTraceString());
        if (flag)
        {
          for (int index = 0; index < DataBlock.Count; ++index)
          {
            if ((int) DataBlock.Data[index] != (int) byteField.Data[index])
              flag = false;
          }
        }
        if (!flag)
        {
          this.MyAsyncFunctions.Logger.WriteLoggerData(EventLogger.LoggerEvent.ComEchoError, ref byteField);
          AsyncSerial.AsyncSerialLogger.Debug("EchoError");
          return false;
        }
        this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComEchoOk);
        AsyncSerial.AsyncSerialLogger.Debug("EchoOk");
      }
      return true;
    }

    public override bool SendBlock(ref ByteField DataBlock)
    {
      if (!this.MySerialPort.IsOpen)
        return false;
      try
      {
        this.MyAsyncFunctions.LastTransmitEndTime = SystemValues.DateTimeNow.AddMilliseconds(this.MyAsyncFunctions.ByteTime * (double) DataBlock.Count);
        this.Write(DataBlock.Data, 0, DataBlock.Count);
        if (this.MyAsyncFunctions.EchoOn)
        {
          ByteField byteField = new ByteField(DataBlock.Count);
          bool flag = this.ReceiveBlock(ref byteField, DataBlock.Count, false);
          if (flag)
          {
            for (int index = 0; index < DataBlock.Count; ++index)
            {
              if ((int) DataBlock.Data[index] != (int) byteField.Data[index])
                flag = false;
            }
          }
          if (!flag)
          {
            this.MyAsyncFunctions.Logger.WriteLoggerData(EventLogger.LoggerEvent.ComEchoError, ref byteField);
            return false;
          }
          this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComEchoOk);
        }
      }
      catch (Exception ex)
      {
        this.WorkException(ex, DataBlock, this.MySerialPort.WriteTimeout);
        return false;
      }
      return true;
    }

    public override void PureTransmit(byte[] byteList)
    {
      this.MySerialPort.Write(byteList, 0, byteList.Length);
    }

    public override bool ReceiveString(out string DataString)
    {
      DataString = (string) null;
      if (!this.MySerialPort.IsOpen)
        return false;
      try
      {
        DataString = this.MySerialPort.ReadExisting();
      }
      catch (Exception ex)
      {
        this.WorkException(ex, (ByteField) null, this.MySerialPort.ReadTimeout);
        return false;
      }
      return true;
    }

    public override bool GetCurrentInputBuffer(out byte[] buffer)
    {
      if (this.MySerialPort != null)
        return this.MySerialPort.ReadExistingBytes(out buffer);
      buffer = (byte[]) null;
      return false;
    }

    public override bool TryReceiveBlock(out byte[] buffer)
    {
      if (this.MySerialPort == null)
        throw new ArgumentNullException("MySerialPort");
      buffer = (byte[]) null;
      if (!this.MySerialPort.IsOpen)
      {
        AsyncSerial.AsyncSerialLogger.Error("The serial port is closed! Try reopen it...");
        this.MySerialPort.Close();
        if (!ZR_ClassLibrary.Util.Wait(1000L, " before reopen the connection.", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
          return false;
        if (!this.MySerialPort.Open())
        {
          if (this.ConnectionLost != null)
            this.ConnectionLost((object) this, (EventArgs) null);
          throw new IOException("Can not open the serial port!");
        }
      }
      int bytesToRead = this.MySerialPort.BytesToRead;
      if (bytesToRead <= 0)
        return false;
      buffer = new byte[bytesToRead];
      for (int index = 0; index < bytesToRead; ++index)
        buffer[index] = (byte) this.MySerialPort.ReadByte();
      return true;
    }

    public override bool TryReceiveBlock(out byte[] buffer, int numberOfBytesToReceive)
    {
      if (this.MySerialPort == null)
        throw new ArgumentNullException("MySerialPort");
      buffer = (byte[]) null;
      if (!this.MySerialPort.IsOpen)
      {
        AsyncSerial.AsyncSerialLogger.Error("The serial port is closed! Try reopen it...");
        this.MySerialPort.Close();
        if (!ZR_ClassLibrary.Util.Wait(1000L, " before reopen the connection.", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
          return false;
        if (!this.MySerialPort.Open())
        {
          if (this.ConnectionLost != null)
            this.ConnectionLost((object) this, (EventArgs) null);
          throw new IOException("Can not open the serial port!");
        }
      }
      if (this.MySerialPort.BytesToRead <= 0 || this.MySerialPort.BytesToRead < numberOfBytesToReceive)
        return false;
      buffer = new byte[numberOfBytesToReceive];
      for (int index = 0; index < numberOfBytesToReceive; ++index)
        buffer[index] = (byte) this.MySerialPort.ReadByte();
      return true;
    }

    public override bool ReceiveBlock(ref ByteField DataBlock)
    {
      if (!this.MySerialPort.IsOpen)
        return false;
      try
      {
        DataBlock.Count = this.Read(DataBlock.Data, 0, DataBlock.Data.Length);
      }
      catch (Exception ex)
      {
        this.WorkException(ex, DataBlock, this.MySerialPort.ReadTimeout);
        return false;
      }
      return DataBlock.Count != 0;
    }

    private bool WorkException(Exception Ex, ByteField inputBuffer, int actualTimeout)
    {
      switch (Ex)
      {
        case TimeoutException _:
          this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComReceiveTimeout);
          if (inputBuffer != null && inputBuffer.Count > 0 && inputBuffer.Data != null && inputBuffer.Data.Length != 0 && inputBuffer.Data.Length >= inputBuffer.Count)
            ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.TimeoutReceiveIncomplete, "Timeout " + actualTimeout.ToString() + " ms Input buffer: " + ZR_ClassLibrary.Util.ByteArrayToHexString(inputBuffer.Data, 0, inputBuffer.Count));
          else
            ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout, Ex.Message);
          AsyncSerial.AsyncSerialLogger.Error(Ex.Message);
          return true;
        case FramingErrorException _:
          this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComIOException);
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.FramingError, Ex.Message);
          this.Close();
          this.Open();
          return false;
        default:
          AsyncSerial.AsyncSerialLogger.Error(Ex, Ex.Message + " " + Ex.StackTrace);
          if (Ex is IOException)
          {
            if (Ex.Message == "Framing error")
            {
              this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComIOException);
              ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.FramingError, Ex.Message);
            }
            else
            {
              this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComIOException);
              ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, Ex.Message);
            }
          }
          else
          {
            this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComUnknownError);
            ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, Ex.Message);
          }
          this.Close();
          this.Open();
          return false;
      }
    }

    public override bool ReceiveBlock(ref ByteField DataBlock, int NumberOfBytes, bool first)
    {
      if (NumberOfBytes < 0 || !this.MySerialPort.IsOpen)
        return false;
      DataBlock.Count = 0;
      DateTime dateTimeNow1 = SystemValues.DateTimeNow;
      DateTime EndTime;
      int ActualTimeout;
      this.GetReceiveBlockTiming(NumberOfBytes, first, out EndTime, out ActualTimeout);
      int count = NumberOfBytes;
      DateTime dateTimeNow2;
      while (true)
      {
        try
        {
          if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoConnect)
          {
            double totalMilliseconds = EndTime.Subtract(SystemValues.DateTimeNow).TotalMilliseconds;
            int num = 0;
            if (totalMilliseconds > 0.0 && totalMilliseconds < (double) int.MaxValue)
              num = Convert.ToInt32(totalMilliseconds);
            if (num > 100)
              num = 100;
            this.MySerialPort.ReadTimeout = num;
          }
          else
            this.MySerialPort.ReadTimeout = ActualTimeout;
          int num1 = this.MyAsyncFunctions.MBusFrameTestWindowOn ? this.MySerialPort.ReadFromTestWindow(DataBlock.Data, DataBlock.Count, count) : this.Read(DataBlock.Data, DataBlock.Count, count);
          count -= num1;
          DataBlock.Count += num1;
          if (count == 0)
          {
            this.MyAsyncFunctions.Logger.WriteLoggerData(EventLogger.LoggerEvent.ComReceiveData, ref DataBlock);
            this.MyAsyncFunctions.ResetEarliestTransmitTime();
            this.MyAsyncFunctions.TriggerWakeup();
            return true;
          }
          Thread.Sleep(50);
        }
        catch (Exception ex)
        {
          string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
          AsyncSerial.AsyncSerialLogger.Error(ex, message);
          this.MyAsyncFunctions.ResetEarliestTransmitTime();
          if (!(ex is TimeoutException))
          {
            this.WorkException(ex, DataBlock, this.MySerialPort.ReadTimeout);
            Application.DoEvents();
            dateTimeNow2 = SystemValues.DateTimeNow;
            return false;
          }
        }
        if (!(SystemValues.DateTimeNow >= EndTime))
          this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComReceiverPoll);
        else
          break;
      }
      dateTimeNow2 = SystemValues.DateTimeNow;
      if (DataBlock.Count > 0)
      {
        this.MyAsyncFunctions.Logger.WriteLoggerData(EventLogger.LoggerEvent.ComReceiveData, ref DataBlock);
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.TimeoutReceiveIncomplete, "Timeout " + ActualTimeout.ToString() + " ms Input buffer: " + ZR_ClassLibrary.Util.ByteArrayToHexString(DataBlock.Data, 0, DataBlock.Count));
      }
      else
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout, Ot.Gtm(Tg.CommunicationLogic, "Timeout", "Timeout") + " " + ActualTimeout.ToString() + " ms");
      this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComReceiveTimeout);
      return false;
    }

    public override bool ReceiveLine(out string ReceivedData)
    {
      char[] EndCharacters = new char[2]{ '\r', '\n' };
      return this.ReceiveLine(out ReceivedData, EndCharacters, false);
    }

    public override bool ReceiveCRLF_Line(out string ReceivedData)
    {
      char[] EndCharacters = new char[2]{ '\r', '\n' };
      return this.ReceiveLine(out ReceivedData, EndCharacters, true);
    }

    public override bool ReceiveLine(
      out string ReceivedData,
      char[] EndCharacters,
      bool GetEmpty_CRLF_Line)
    {
      ReceivedData = "";
      if (!this.MySerialPort.IsOpen)
        return false;
      int num1 = 0;
      this.MyAsyncFunctions.LineBuffer.Length = 0;
      this.MySerialPort.ReadTimeout = 0;
      long timeTicks = this.MyAsyncFunctions.Logger.GetTimeTicks();
      while (true)
      {
        try
        {
          if (this.MySerialPort.BytesToRead > 0)
          {
            int num2 = this.MySerialPort.ReadChar();
            this.MyAsyncFunctions.LineBuffer.Append((char) num2);
            ++num1;
            if (GetEmpty_CRLF_Line && this.MyAsyncFunctions.LineBuffer[0] == '\r')
            {
              if (this.MyAsyncFunctions.LineBuffer.Length != 1)
              {
                if (this.MyAsyncFunctions.LineBuffer[1] == '\n')
                  return true;
                this.MyAsyncFunctions.LineBuffer.Remove(0, 1);
              }
              else
                continue;
            }
            foreach (int endCharacter in EndCharacters)
            {
              if (endCharacter == num2)
              {
                if (this.MyAsyncFunctions.LineBuffer.Length == 1)
                {
                  this.MyAsyncFunctions.LineBuffer.Length = 0;
                }
                else
                {
                  --this.MyAsyncFunctions.LineBuffer.Length;
                  ReceivedData = this.MyAsyncFunctions.LineBuffer.ToString();
                  return true;
                }
              }
            }
          }
          else
          {
            int num3 = (int) ((double) (this.MyAsyncFunctions.RecTime_BeforFirstByte + this.MyAsyncFunctions.AnswerOffsetTime) + (double) num1 * (this.MyAsyncFunctions.ByteTime + this.MyAsyncFunctions.RecTime_OffsetPerByte));
            if (this.MyAsyncFunctions.Logger.GetTimeDifferenc(this.MyAsyncFunctions.Logger.GetTimeTicks() - timeTicks) < (long) num3)
            {
              if (!ZR_ClassLibrary.Util.Wait(30L, nameof (ReceiveLine), (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
                return false;
              this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComReceiverPoll);
            }
            else
              break;
          }
        }
        catch (Exception ex)
        {
          this.WorkException(ex, (ByteField) null, this.MySerialPort.ReadTimeout);
          return false;
        }
      }
      this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComReceiveTimeout);
      ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout, "ComReceiveTimeout");
      ReceivedData = this.MyAsyncFunctions.LineBuffer.ToString();
      return false;
    }

    public override bool ReceiveBlockToChar(ref ByteField DataBlock, byte EndChar)
    {
      if (!this.MySerialPort.IsOpen)
        return false;
      ByteField data = new ByteField(DataBlock.Data.Length);
      int length = DataBlock.Data.Length;
      int WaitMilliSecounds = this.MyAsyncFunctions.RecTime_BeforFirstByte + this.MyAsyncFunctions.AnswerOffsetTime + (int) (this.MyAsyncFunctions.ByteTime * (double) DataBlock.Data.Length);
      long endTicks = this.MyAsyncFunctions.Logger.GetEndTicks((long) WaitMilliSecounds);
      do
      {
        try
        {
          this.MySerialPort.ReadTimeout = WaitMilliSecounds;
          this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComReceiverPoll);
          int IntToByte = this.MySerialPort.ReadByte();
          DataBlock.Add(IntToByte);
          data.Add(IntToByte);
          --length;
          if (IntToByte == (int) EndChar)
          {
            this.MyAsyncFunctions.Logger.WriteLoggerData(EventLogger.LoggerEvent.ComReceiveData, ref data);
            return true;
          }
        }
        catch (TimeoutException ex)
        {
          if (data.Count > 0)
          {
            this.MyAsyncFunctions.Logger.WriteLoggerData(EventLogger.LoggerEvent.ComReceiveData, ref data);
            data.Count = 0;
          }
          else
            this.MyAsyncFunctions.Logger.WriteLoggerEvent(EventLogger.LoggerEvent.ComReceiverPoll);
        }
        catch (Exception ex)
        {
          this.WorkException(ex, DataBlock, this.MySerialPort.ReadTimeout);
          return false;
        }
      }
      while (this.MyAsyncFunctions.Logger.GetTimeTicks() <= endTicks);
      return false;
    }

    public override bool TransmitControlCommand(string strSendData) => false;

    public override bool ReceiveControlBlock(
      out string ReceivedData,
      string startTag,
      string endTag)
    {
      ReceivedData = "";
      return false;
    }

    private int Read(byte[] buffer, int offset, int count)
    {
      return this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoHead && !this.MinoHeadIsTransparent ? this.MinoHeadReadData(buffer, offset, count) : this.MySerialPort.Read(buffer, offset, count);
    }

    internal void Write(byte[] buffer, int offset, int count)
    {
      DateTime dateTime = SystemValues.DateTimeNow.AddMilliseconds(!(this.MyAsyncFunctions.Parity != "no") ? (double) count * 1000.0 / ((double) this.MyAsyncFunctions.Baudrate / 10.0) : (double) count * 1000.0 / ((double) this.MyAsyncFunctions.Baudrate / 11.0));
      if (this.MyAsyncFunctions.Transceiver == TransceiverDevice.MinoHead && !this.MinoHeadIsTransparent)
      {
        byte[] outData = new byte[buffer.Length - 2];
        for (int index = 0; index < buffer.Length - 2; ++index)
          outData[index] = buffer[index + 2];
        this.MinoHeadSendData(buffer[1], outData, count - 2);
        if (!ZR_ClassLibrary.Util.Wait((long) (buffer.Length * 2), "after send request to MinoHead", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
          return;
      }
      else
        this.MySerialPort.Write(buffer, offset, count);
      double totalMilliseconds = dateTime.Subtract(SystemValues.DateTimeNow).TotalMilliseconds;
      if (totalMilliseconds < 0.0 || totalMilliseconds > (double) int.MaxValue || ZR_ClassLibrary.Util.Wait((long) (int) totalMilliseconds, "Wait transmit finished", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
        ;
    }

    internal short getHeadVersion()
    {
      byte[] buffer = new byte[50];
      this.MinoHeadSendData((byte) 1, (byte[]) null, 0);
      this.MinoHeadReadData(buffer, 0, 2, true);
      return (short) ((int) buffer[0] | (int) buffer[1] << 8);
    }

    internal short getEchoIrDa()
    {
      byte[] buffer = new byte[50];
      this.MinoHeadSendData((byte) 162, (byte[]) null, 0);
      this.MinoHeadReadData(buffer, 0, 1, true);
      return (short) buffer[0];
    }

    internal short getRFModul()
    {
      byte[] buffer = new byte[50];
      this.MinoHeadSendData((byte) 163, (byte[]) null, 0);
      this.MinoHeadReadData(buffer, 0, 1, true);
      return (short) buffer[0];
    }

    internal void SendMinoHeadWakeup()
    {
      if (!this.MySerialPort.IsOpen)
        throw new Exception("Failed send MinoHead wake up! The com port is closed.");
      this.MySerialPort.SetDTR(true);
      if (!ZR_ClassLibrary.Util.Wait(50L, "after set DTR=true", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
        return;
      this.MySerialPort.SetDTR(false);
      if (!ZR_ClassLibrary.Util.Wait(1000L, "after set DTR=false", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
        return;
      this.MinoHeadIsTransparent = false;
      AsyncSerial.AsyncSerialLogger.Debug("Wake up MinoHead. Send wake up sequence...");
      if (!ZR_ClassLibrary.Util.Wait(200L, "before send wake up to MinoHead", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
        return;
      this.Write(new byte[4]
      {
        (byte) 0,
        (byte) 4,
        (byte) 64,
        (byte) 0
      }, 0, 4);
      if (ZR_ClassLibrary.Util.Wait(200L, "after send wake up to MinoHead", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
        ;
    }

    protected void setHeadTransparent()
    {
      if (!ZR_ClassLibrary.Util.Wait(600L, "befor set transparent mode on MinoHead", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
        return;
      AsyncSerial.AsyncSerialLogger.Debug("Send command to MinoHead => TLP2Commands.lp2Transparent");
      this.MinoHeadSendData((byte) 150, (byte[]) null, 0);
      if (!ZR_ClassLibrary.Util.Wait(800L, "after set transparent mode on MinoHead", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
        return;
      this.MinoHeadIsTransparent = true;
    }

    protected void setHeadTransparentV3()
    {
      AsyncSerial.AsyncSerialLogger.Debug("setHeadTransparentV3()");
      this.MinoHeadSendData((byte) 164, (byte[]) null, 0);
      if (!ZR_ClassLibrary.Util.Wait(800L, "after set transparent mode on MinoHead", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger))
        return;
      this.MinoHeadIsTransparent = true;
    }

    private bool MinoHeadSendData(byte command, byte[] outData, int outCount)
    {
      if (!this.MySerialPort.IsOpen)
        return false;
      if (AsyncSerial.AsyncSerialLogger.IsTraceEnabled)
        AsyncSerial.AsyncSerialLogger.Trace("MinoHeadSendData() Command: 0x" + command.ToString("X"));
      this.ClearCom();
      byte[] numArray = new byte[outCount + 6];
      numArray[0] = (byte) 77;
      numArray[1] = (byte) 1;
      numArray[2] = command;
      numArray[3] = (byte) ((outCount & 65280) >> 8);
      numArray[4] = (byte) outCount;
      for (int index = 0; index < outCount; ++index)
        numArray[5 + index] = outData[index];
      numArray[5 + outCount] = this.cs(numArray, 5 + outCount);
      if (AsyncSerial.AsyncSerialLogger.IsTraceEnabled)
        AsyncSerial.AsyncSerialLogger.Trace("Send to MINO HEAD: {0}", ZR_ClassLibrary.Util.ByteArrayToHexString(numArray));
      this.MySerialPort.Write(numArray, 0, 5 + outCount + 1);
      return true;
    }

    private int MinoHeadReadData(byte[] buffer, int offset, int count)
    {
      return this.MinoHeadReadData(buffer, offset, count, false);
    }

    private int MinoHeadReadData(byte[] buffer, int offset, int count, bool includeStartbyte)
    {
      AsyncSerial.AsyncSerialLogger.Debug("MinoHeadReadData ({0} bytes expected).", count);
      int num1 = 0;
      int num2 = 0;
      byte[] numArray = new byte[1024];
      if (count > this.MinoHeadReceiverQueue.Count)
      {
        DateTime dateTime = SystemValues.DateTimeNow.AddMilliseconds((double) this.MySerialPort.ReadTimeout);
        do
        {
          if (this.MySerialPort.BytesToRead <= 1024)
          {
            if (this.MySerialPort.BytesToRead < 6)
            {
              if (dateTime < SystemValues.DateTimeNow)
                goto label_5;
            }
            else
              goto label_9;
          }
          else
            goto label_2;
        }
        while (ZR_ClassLibrary.Util.Wait(200L, "while read data from MinoHead", (ICancelable) this.MyAsyncFunctions, AsyncSerial.AsyncSerialLogger));
        goto label_7;
label_2:
        return 0;
label_5:
        AsyncSerial.AsyncSerialLogger.Error("MinoHeadReadData: No answer (only {0} bytes available) throw new TimeoutException()", this.MySerialPort.BytesToRead);
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.MissingData, "MinoHead: No answer!");
        throw new TimeoutException();
label_7:
        return 0;
label_9:
        AsyncSerial.AsyncSerialLogger.Debug("MinoHeadReadData: {0} bytes available.", this.MySerialPort.BytesToRead);
        for (int index = 0; index < 5; ++index)
          numArray[index] = (byte) this.MySerialPort.ReadByte();
        num1 = (int) numArray[3] << 8 | (int) numArray[4];
        AsyncSerial.AsyncSerialLogger.Debug("MinoHeadReadData: Expecting {0} bytes.", num1);
        if (num1 == 0)
        {
          int num3 = this.MySerialPort.ReadByte();
          AsyncSerial.AsyncSerialLogger.Error<string, string>("Received empty packet from MinoHead! Buffer: {0}{1}", ZR_ClassLibrary.Util.ByteArrayToHexString(numArray, 0, 4), num3.ToString("X2"));
          return this.MinoHeadReadData(buffer, offset, count, includeStartbyte);
        }
        int count1 = num1 + 1;
        int offset1 = 5;
        int num4;
        for (; count1 > 0 && !this.MyAsyncFunctions.BreakRequest; count1 -= num4)
        {
          num4 = this.MySerialPort.Read(numArray, offset1, count1);
          offset1 += num4;
        }
        num2 = num1 + 6;
        if ((int) this.cs(numArray, num1 + 5) != (int) numArray[5 + num1])
        {
          string str = "MinoHead: Answer checksum error!";
          AsyncSerial.AsyncSerialLogger.Error(str);
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.MissingData, str);
          throw new IOException();
        }
        if (includeStartbyte)
        {
          for (int index = 0; index < num1; ++index)
            this.MinoHeadReceiverQueue.Enqueue(numArray[5 + index]);
        }
        else
        {
          for (int index = 1; index < num1; ++index)
            this.MinoHeadReceiverQueue.Enqueue(numArray[5 + index]);
        }
      }
      for (int index = 0; index < count; ++index)
      {
        if (this.MinoHeadReceiverQueue.Count > 0)
        {
          buffer[index + offset] = this.MinoHeadReceiverQueue.Dequeue();
        }
        else
        {
          if (num2 == 7 && num1 == 1 && numArray[5] == (byte) 0)
            return 0;
          string str = "MinoHead: Illegal answer size! throw new IOException()";
          AsyncSerial.AsyncSerialLogger.Error(str);
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.MissingData, str);
          throw new IOException();
        }
      }
      AsyncSerial.AsyncSerialLogger.Debug("MinoHeadReadData: Read {0} bytes", num2);
      return count;
    }

    private byte cs(byte[] buf, int count)
    {
      uint num = 0;
      for (int index = 0; index < count; ++index)
        num += (uint) buf[index];
      return (byte) (num & (uint) byte.MaxValue);
    }

    public override object GetChannel() => (object) this.MySerialPort.GetPort();
  }
}


--- ComComparer.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.ComComparer
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using System;
using System.Collections;

#nullable disable
namespace AsyncCom
{
  internal class ComComparer : IComparer
  {
    public int Compare(object x, object y)
    {
      string str1 = x as string;
      string str2 = y as string;
      if (str1 == null || str2 == null)
        throw new ArgumentException("Object is not of type ManagementObject");
      int num1;
      int num2;
      try
      {
        num1 = int.Parse(str1.Substring(3, str1.Length - 3));
        num2 = int.Parse(str2.Substring(3, str2.Length - 3));
      }
      catch
      {
        return 0;
      }
      return num1.CompareTo(num2);
    }
  }
}


--- CommParameter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.CommParameter
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

#nullable disable
namespace AsyncCom
{
  public enum CommParameter
  {
    Type,
    Baudrate,
    COMserver,
    Port,
    Parity,
    UseBreak,
    EchoOn,
    TestEcho,
    RecTime_BeforFirstByte,
    RecTime_OffsetPerByte,
    RecTime_GlobalOffset,
    TransTime_GlobalOffset,
    RecTransTime,
    TransTime_BreakTime,
    TransTime_AfterOpen,
    TransTime_AfterBreak,
    WaitBeforeRepeatTime,
    BreakIntervalTime,
    MinoConnectTestFor,
    MinoConnectPowerOffTime,
    Wakeup,
    TransceiverDevice,
    ForceMinoConnectState,
    IrDaSelection,
    HardwareHandshake,
    MinoConnectIsUSB,
    MinoConnectIrDaPulseTime,
    RecTime_OffsetPerBlock,
    MinoConnectBaseState,
    ENUM_END,
  }
}


--- COMserver.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.COMserver
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using NLog;
using System;
using System.Collections;

#nullable disable
namespace AsyncCom
{
  public sealed class COMserver
  {
    private static Logger logger = LogManager.GetLogger(nameof (COMserver));
    public SortedList RemoteComs = new SortedList();
    public string IPAddress = "";
    public bool Online = false;
    public string Name = "";
    public string LastSeen = "";
    public string Traffic = "";

    public bool Update(AsyncIP MyAsyncIP)
    {
      if (MyAsyncIP == null)
        return false;
      COMserver.logger.Trace("Update COMServer called...");
      this.RemoteComs.Clear();
      string ReceivedData;
      if (!MyAsyncIP.TransmitControlCommand("showport") || !MyAsyncIP.ReceiveControlBlock(out ReceivedData, "showport", "->") || string.IsNullOrEmpty(ReceivedData))
        return false;
      string[] strArray1 = ReceivedData.Split('\r');
      if (strArray1.Length > 1)
      {
        int key = 0;
        RemoteCom remoteCom = (RemoteCom) null;
        foreach (string str1 in strArray1)
        {
          if (str1.StartsWith("TCP Port"))
          {
            remoteCom = new RemoteCom();
            ++key;
            remoteCom.Port = Convert.ToInt32(str1.Remove(0, 8));
          }
          if (str1 == "-")
            break;
          if (remoteCom != null)
          {
            string[] strArray2 = str1.Split(':');
            string str2 = strArray2[0];
            if (str2 != null)
            {
              switch (str2.Length)
              {
                case 1:
                  if (str2 == "-")
                    break;
                  break;
                case 8:
                  if (str2 == "  device")
                  {
                    remoteCom.LinuxDevice = strArray2[1].TrimEnd('\n');
                    if (!this.RemoteComs.ContainsKey((object) key))
                      this.RemoteComs.Add((object) key, (object) remoteCom);
                    remoteCom = (RemoteCom) null;
                    break;
                  }
                  break;
                case 9:
                  if (str2 == "  timeout")
                  {
                    remoteCom.Timeout = Convert.ToInt32(strArray2[1]);
                    break;
                  }
                  break;
                case 14:
                  if (str2 == "  enable state")
                    break;
                  break;
                case 15:
                  if (str2 == "  device config")
                  {
                    remoteCom.PortConfig = strArray2[1].TrimEnd('\n');
                    break;
                  }
                  break;
                case 17:
                  if (str2 == "  device controls")
                    break;
                  break;
                case 21:
                  switch (str2[2])
                  {
                    case 'b':
                      if (str2 == "  bytes read from TCP")
                      {
                        remoteCom.BytesTCP_IN = (long) Convert.ToInt32(strArray2[1]);
                        break;
                      }
                      break;
                    case 'd':
                      if (str2 == "  device to tcp state")
                        break;
                      break;
                    case 't':
                      if (str2 == "  tcp to device state")
                        break;
                      break;
                  }
                  break;
                case 22:
                  if (str2 == "  bytes written to TCP")
                  {
                    remoteCom.BytesTCP_IN = (long) Convert.ToInt32(strArray2[1]);
                    break;
                  }
                  break;
                case 24:
                  if (str2 == "  bytes read from device")
                  {
                    remoteCom.BytesTCP_IN = (long) Convert.ToInt32(strArray2[1]);
                    break;
                  }
                  break;
                case 25:
                  if (str2 == "  bytes written to device")
                  {
                    remoteCom.BytesTCP_IN = (long) Convert.ToInt32(strArray2[1]);
                    break;
                  }
                  break;
                case 35:
                  if (str2 == "  connected to (or last connection)" && strArray2.Length == 3)
                  {
                    remoteCom.ConnectedTo = strArray2[1].Trim();
                    break;
                  }
                  break;
              }
            }
          }
        }
      }
      return this.RemoteComs.Count != 0;
    }
  }
}


--- HandshakeStates.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.HandshakeStates
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

#nullable disable
namespace AsyncCom
{
  public enum HandshakeStates
  {
    RTS_ON_DTR_ON,
    RTS_OFF_DTR_OFF,
    RTS_ON_DTR_OFF,
    RTS_OFF_DTR_ON,
  }
}


--- IAsyncFunctions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.IAsyncFunctions
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using System;
using System.Collections;
using System.Collections.Generic;
using ZR_ClassLibrary;

#nullable disable
namespace AsyncCom
{
  public interface IAsyncFunctions : I_ZR_Component, ILockable, ICancelable
  {
    event System.EventHandler ConnectionLost;

    event System.EventHandler BatterieLow;

    string ShowComWindow(string ComponentList);

    void ShowComWindow();

    bool ShowComWindowChanged();

    bool IsOpen { get; }

    bool Open();

    bool Close();

    void ClearCom();

    bool SetBreak();

    bool ClearBreak();

    bool CallTransceiverFunction(TransceiverDeviceFunction function);

    bool CallTransceiverFunction(TransceiverDeviceFunction function, object param1);

    bool CallTransceiverFunction(TransceiverDeviceFunction function, object param1, object param2);

    bool GetComPortIds(out string strComPortIds, bool ForceRefresh);

    string GetTranceiverDeviceInfo();

    void ShowErrorMessageBox(bool on);

    string SingleParameter(string ParameterName, string ParameterValue);

    string SingleParameter(CommParameter Parameter, string ParameterValue);

    void GetCommParameter(ref ArrayList ParameterList);

    SortedList<AsyncComSettings, object> GetAsyncComSettings();

    string GetAsyncComSettingsAsString();

    bool SetCommParameter(ArrayList ParameterList);

    bool SetCommParameter(ArrayList ParameterList, bool ComWindowRefresh);

    void WaitToEarliestTransmitTime();

    void ResetEarliestTransmitTime();

    void ResetLastTransmitEndTime();

    void ClearWakeup();

    void TriggerWakeup();

    bool WakeupTemporaryOff { get; set; }

    bool SetHandshakeState(HandshakeStates HandshakeState);

    void SetAnswerOffsetTime(int NewAnswerOffsetTime);

    bool TransmitBlock(string DataString);

    bool TransmitBlock(ref ByteField DataBlock);

    bool TransmitBlock(byte[] buffer);

    bool SendBlock(ref ByteField DataBlock);

    bool TransmitString(string DataString);

    bool ReceiveString(out string DataString);

    bool ReceiveBlock(ref ByteField DataBlock, int MinByteNb, bool first);

    bool ReceiveBlock(ref ByteField DataBlock);

    bool TryReceiveBlock(out byte[] buffer);

    bool TryReceiveBlock(out byte[] buffer, int numberOfBytesToReceive);

    bool ReceiveLine(out string ReceivedData);

    bool ReceiveCRLF_Line(out string ReceivedData);

    bool ReceiveBlockToChar(ref ByteField DataBlock, byte EndChar);

    void ComWriteLoggerEvent(EventLogger.LoggerEvent Event);

    void ComWriteLoggerData(EventLogger.LoggerEvent Event, ref ByteField data);

    event EventHandler<GMM_EventArgs> OnAsyncComMessage;

    bool ChangeParameterAtList(ArrayList ParameterList, string ParameterName, string NewParameter);

    string GetParameterFromList(ArrayList ParameterList, string ParameterName);

    string CreateParameterString(ArrayList ParameterList);

    ArrayList CreateParameterList(string ParameterString);

    bool ChangeDriverSettings();

    int MinoConnectIrDaPulseLength { get; set; }

    TransceiverDevice Transceiver { get; set; }

    DateTime FirstCalculatedEarliestTransmitTime { get; set; }

    bool UpdateTransceiverFirmware(string pathToFirmware);

    Dictionary<string, string> LoadAvailableCOMservers();

    bool SendMinoConnectCommand(string cmd);

    long InputBufferLength { get; }

    bool GetCurrentInputBuffer(out byte[] buffer);

    bool SetAsyncComSettings(SortedList<string, string> asyncComSettings);
  }
}


--- IrDaSelection.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.IrDaSelection
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

#nullable disable
namespace AsyncCom
{
  public enum IrDaSelection
  {
    None,
    DoveTailSide,
    RoundSide,
  }
}


--- ManageCOMservers.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.ManageCOMservers
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using CorporateDesign;
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Windows.Forms;

#nullable disable
namespace AsyncCom
{
  public class ManageCOMservers : Form
  {
    private AsyncFunctions ComX;
    private IContainer components = (IContainer) null;
    private ZennerCoroprateDesign zennerCoroprateDesign1;
    private Panel panel1;
    private Button buttonClose;
    private TextBox textBoxSerialNumber;
    private Label label2;
    private Button buttonAdd;
    private Button buttonRefresh;
    private Label label1;
    private TextBox textBoxPassword;
    private Label label3;
    private DataGridView dataGridViewCOMservers;
    private GroupBox groupBox1;
    private Button buttonDelete;
    private GroupBox groupBox2;
    private Label label4;
    private Label label5;
    private Button buttonModify;
    private TextBox textBoxNameModify;
    private TextBox textBoxSerialNumberModify;
    private TextBox textBoxName;
    private Label label6;

    public ManageCOMservers(AsyncFunctions ComX)
    {
      this.InitializeComponent();
      this.ComX = ComX;
      this.UpdateCOMserverList();
    }

    private void buttonClose_Click(object sender, EventArgs e) => this.Close();

    private void UpdateCOMserverList()
    {
      DataTable dataTable = new DataTable("COMservers");
      dataTable.Rows.Clear();
      dataTable.Columns.Add("Nr.", typeof (int));
      dataTable.Columns.Add("Name", typeof (string));
      dataTable.Columns.Add("Serialnumber", typeof (string));
      dataTable.Columns.Add("Online", typeof (string));
      dataTable.Columns.Add("Last Seen", typeof (string));
      dataTable.Columns.Add("Traffic", typeof (long));
      this.dataGridViewCOMservers.DataSource = (object) dataTable;
      this.dataGridViewCOMservers.Columns["Traffic"].HeaderText = "Traffic (In+Out, kBytes)";
      int num = 1;
      this.ComX.MyMeterVPN.Update((AsyncIP) this.ComX.MyComType);
      foreach (DictionaryEntry coMserver1 in this.ComX.MyMeterVPN.COMservers)
      {
        COMserver coMserver2 = (COMserver) coMserver1.Value;
        object[] objArray = new object[6]
        {
          (object) num.ToString(),
          (object) coMserver2.Name,
          (object) coMserver1.Key.ToString(),
          (object) coMserver2.Online,
          (object) coMserver2.LastSeen,
          (object) (Convert.ToInt64(coMserver2.Traffic) / 1024L)
        };
        dataTable.Rows.Add(objArray);
        ++num;
      }
      this.textBoxSerialNumberModify.Text = "";
      this.textBoxPassword.Text = "";
      this.textBoxSerialNumber.Text = "";
      this.textBoxNameModify.Text = "";
      this.textBoxName.Text = "";
    }

    private void buttonRefresh_Click(object sender, EventArgs e) => this.UpdateCOMserverList();

    private void buttonAdd_Click(object sender, EventArgs e)
    {
      if (this.ComX.MyMeterVPN.AddCOMserver((AsyncIP) this.ComX.MyComType, "COMserver" + this.textBoxSerialNumber.Text, this.textBoxName.Text, this.textBoxPassword.Text))
      {
        this.UpdateCOMserverList();
      }
      else
      {
        int num = (int) MessageBox.Show("Bitte überprüfen Sie die Seriennummer und das Passwort");
      }
    }

    private void buttonDelete_Click(object sender, EventArgs e)
    {
      if (this.dataGridViewCOMservers.SelectedRows.Count != 1)
        return;
      if (this.ComX.MyMeterVPN.DelCOMserver((AsyncIP) this.ComX.MyComType, (string) this.dataGridViewCOMservers.SelectedCells[2].Value))
      {
        this.UpdateCOMserverList();
      }
      else
      {
        int num = (int) MessageBox.Show("COMserver konnte nicht gelöscht werden");
      }
    }

    private void buttonModify_Click(object sender, EventArgs e)
    {
      if (this.dataGridViewCOMservers.SelectedRows.Count != 1)
        return;
      if (this.ComX.MyMeterVPN.ModCOMserver((AsyncIP) this.ComX.MyComType, (string) this.dataGridViewCOMservers.SelectedCells[2].Value, this.textBoxNameModify.Text))
      {
        this.UpdateCOMserverList();
      }
      else
      {
        int num = (int) MessageBox.Show("COMserver konnte nicht gelöscht werden");
      }
    }

    private void dataGridViewCOMservers_CellClick(object sender, DataGridViewCellEventArgs e)
    {
      if (this.dataGridViewCOMservers.SelectedRows.Count != 1)
        return;
      this.textBoxSerialNumberModify.Text = (string) this.dataGridViewCOMservers.SelectedCells[2].Value;
      this.textBoxNameModify.Text = (string) this.dataGridViewCOMservers.SelectedCells[1].Value;
    }

    protected override void Dispose(bool disposing)
    {
      if (disposing && this.components != null)
        this.components.Dispose();
      base.Dispose(disposing);
    }

    private void InitializeComponent()
    {
      ComponentResourceManager componentResourceManager = new ComponentResourceManager(typeof (ManageCOMservers));
      this.zennerCoroprateDesign1 = new ZennerCoroprateDesign();
      this.panel1 = new Panel();
      this.groupBox2 = new GroupBox();
      this.label4 = new Label();
      this.label5 = new Label();
      this.buttonModify = new Button();
      this.textBoxNameModify = new TextBox();
      this.textBoxSerialNumberModify = new TextBox();
      this.buttonDelete = new Button();
      this.groupBox1 = new GroupBox();
      this.label6 = new Label();
      this.textBoxName = new TextBox();
      this.label3 = new Label();
      this.label2 = new Label();
      this.buttonAdd = new Button();
      this.textBoxPassword = new TextBox();
      this.textBoxSerialNumber = new TextBox();
      this.dataGridViewCOMservers = new DataGridView();
      this.buttonRefresh = new Button();
      this.label1 = new Label();
      this.buttonClose = new Button();
      this.panel1.SuspendLayout();
      this.groupBox2.SuspendLayout();
      this.groupBox1.SuspendLayout();
      ((ISupportInitialize) this.dataGridViewCOMservers).BeginInit();
      this.SuspendLayout();
      this.zennerCoroprateDesign1.AccessibleDescription = (string) null;
      this.zennerCoroprateDesign1.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.zennerCoroprateDesign1, "zennerCoroprateDesign1");
      this.zennerCoroprateDesign1.BackgroundImage = (Image) null;
      this.zennerCoroprateDesign1.Font = (Font) null;
      this.zennerCoroprateDesign1.Name = "zennerCoroprateDesign1";
      this.panel1.AccessibleDescription = (string) null;
      this.panel1.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.panel1, "panel1");
      this.panel1.BackgroundImage = (Image) null;
      this.panel1.Controls.Add((Control) this.groupBox2);
      this.panel1.Controls.Add((Control) this.buttonDelete);
      this.panel1.Controls.Add((Control) this.groupBox1);
      this.panel1.Controls.Add((Control) this.dataGridViewCOMservers);
      this.panel1.Controls.Add((Control) this.buttonRefresh);
      this.panel1.Controls.Add((Control) this.label1);
      this.panel1.Controls.Add((Control) this.buttonClose);
      this.panel1.Font = (Font) null;
      this.panel1.Name = "panel1";
      this.groupBox2.AccessibleDescription = (string) null;
      this.groupBox2.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.groupBox2, "groupBox2");
      this.groupBox2.BackgroundImage = (Image) null;
      this.groupBox2.Controls.Add((Control) this.label4);
      this.groupBox2.Controls.Add((Control) this.label5);
      this.groupBox2.Controls.Add((Control) this.buttonModify);
      this.groupBox2.Controls.Add((Control) this.textBoxNameModify);
      this.groupBox2.Controls.Add((Control) this.textBoxSerialNumberModify);
      this.groupBox2.Font = (Font) null;
      this.groupBox2.Name = "groupBox2";
      this.groupBox2.TabStop = false;
      this.label4.AccessibleDescription = (string) null;
      this.label4.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.label4, "label4");
      this.label4.Font = (Font) null;
      this.label4.Name = "label4";
      this.label5.AccessibleDescription = (string) null;
      this.label5.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.label5, "label5");
      this.label5.Font = (Font) null;
      this.label5.Name = "label5";
      this.buttonModify.AccessibleDescription = (string) null;
      this.buttonModify.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.buttonModify, "buttonModify");
      this.buttonModify.BackgroundImage = (Image) null;
      this.buttonModify.Font = (Font) null;
      this.buttonModify.Name = "buttonModify";
      this.buttonModify.UseVisualStyleBackColor = true;
      this.buttonModify.Click += new EventHandler(this.buttonModify_Click);
      this.textBoxNameModify.AccessibleDescription = (string) null;
      this.textBoxNameModify.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.textBoxNameModify, "textBoxNameModify");
      this.textBoxNameModify.BackgroundImage = (Image) null;
      this.textBoxNameModify.Font = (Font) null;
      this.textBoxNameModify.Name = "textBoxNameModify";
      this.textBoxSerialNumberModify.AccessibleDescription = (string) null;
      this.textBoxSerialNumberModify.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.textBoxSerialNumberModify, "textBoxSerialNumberModify");
      this.textBoxSerialNumberModify.BackgroundImage = (Image) null;
      this.textBoxSerialNumberModify.Font = (Font) null;
      this.textBoxSerialNumberModify.Name = "textBoxSerialNumberModify";
      this.buttonDelete.AccessibleDescription = (string) null;
      this.buttonDelete.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.buttonDelete, "buttonDelete");
      this.buttonDelete.BackgroundImage = (Image) null;
      this.buttonDelete.Font = (Font) null;
      this.buttonDelete.Name = "buttonDelete";
      this.buttonDelete.UseVisualStyleBackColor = true;
      this.buttonDelete.Click += new EventHandler(this.buttonDelete_Click);
      this.groupBox1.AccessibleDescription = (string) null;
      this.groupBox1.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.groupBox1, "groupBox1");
      this.groupBox1.BackgroundImage = (Image) null;
      this.groupBox1.Controls.Add((Control) this.label6);
      this.groupBox1.Controls.Add((Control) this.textBoxName);
      this.groupBox1.Controls.Add((Control) this.label3);
      this.groupBox1.Controls.Add((Control) this.label2);
      this.groupBox1.Controls.Add((Control) this.buttonAdd);
      this.groupBox1.Controls.Add((Control) this.textBoxPassword);
      this.groupBox1.Controls.Add((Control) this.textBoxSerialNumber);
      this.groupBox1.Font = (Font) null;
      this.groupBox1.Name = "groupBox1";
      this.groupBox1.TabStop = false;
      this.label6.AccessibleDescription = (string) null;
      this.label6.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.label6, "label6");
      this.label6.Font = (Font) null;
      this.label6.Name = "label6";
      this.textBoxName.AccessibleDescription = (string) null;
      this.textBoxName.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.textBoxName, "textBoxName");
      this.textBoxName.BackgroundImage = (Image) null;
      this.textBoxName.Font = (Font) null;
      this.textBoxName.Name = "textBoxName";
      this.label3.AccessibleDescription = (string) null;
      this.label3.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.label3, "label3");
      this.label3.Font = (Font) null;
      this.label3.Name = "label3";
      this.label2.AccessibleDescription = (string) null;
      this.label2.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.label2, "label2");
      this.label2.Font = (Font) null;
      this.label2.Name = "label2";
      this.buttonAdd.AccessibleDescription = (string) null;
      this.buttonAdd.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.buttonAdd, "buttonAdd");
      this.buttonAdd.BackgroundImage = (Image) null;
      this.buttonAdd.Font = (Font) null;
      this.buttonAdd.Name = "buttonAdd";
      this.buttonAdd.UseVisualStyleBackColor = true;
      this.buttonAdd.Click += new EventHandler(this.buttonAdd_Click);
      this.textBoxPassword.AccessibleDescription = (string) null;
      this.textBoxPassword.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.textBoxPassword, "textBoxPassword");
      this.textBoxPassword.BackgroundImage = (Image) null;
      this.textBoxPassword.Font = (Font) null;
      this.textBoxPassword.Name = "textBoxPassword";
      this.textBoxSerialNumber.AccessibleDescription = (string) null;
      this.textBoxSerialNumber.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.textBoxSerialNumber, "textBoxSerialNumber");
      this.textBoxSerialNumber.BackgroundImage = (Image) null;
      this.textBoxSerialNumber.Font = (Font) null;
      this.textBoxSerialNumber.Name = "textBoxSerialNumber";
      this.dataGridViewCOMservers.AccessibleDescription = (string) null;
      this.dataGridViewCOMservers.AccessibleName = (string) null;
      this.dataGridViewCOMservers.AllowUserToAddRows = false;
      this.dataGridViewCOMservers.AllowUserToDeleteRows = false;
      this.dataGridViewCOMservers.AllowUserToOrderColumns = true;
      this.dataGridViewCOMservers.AllowUserToResizeColumns = false;
      this.dataGridViewCOMservers.AllowUserToResizeRows = false;
      componentResourceManager.ApplyResources((object) this.dataGridViewCOMservers, "dataGridViewCOMservers");
      this.dataGridViewCOMservers.AutoSizeColumnsMode = DataGridViewAutoSizeColumnsMode.AllCells;
      this.dataGridViewCOMservers.BackgroundImage = (Image) null;
      this.dataGridViewCOMservers.ColumnHeadersHeightSizeMode = DataGridViewColumnHeadersHeightSizeMode.AutoSize;
      this.dataGridViewCOMservers.Font = (Font) null;
      this.dataGridViewCOMservers.MultiSelect = false;
      this.dataGridViewCOMservers.Name = "dataGridViewCOMservers";
      this.dataGridViewCOMservers.ReadOnly = true;
      this.dataGridViewCOMservers.SelectionMode = DataGridViewSelectionMode.FullRowSelect;
      this.dataGridViewCOMservers.CellClick += new DataGridViewCellEventHandler(this.dataGridViewCOMservers_CellClick);
      this.buttonRefresh.AccessibleDescription = (string) null;
      this.buttonRefresh.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.buttonRefresh, "buttonRefresh");
      this.buttonRefresh.BackgroundImage = (Image) null;
      this.buttonRefresh.Font = (Font) null;
      this.buttonRefresh.Name = "buttonRefresh";
      this.buttonRefresh.UseVisualStyleBackColor = true;
      this.buttonRefresh.Click += new EventHandler(this.buttonRefresh_Click);
      this.label1.AccessibleDescription = (string) null;
      this.label1.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.label1, "label1");
      this.label1.Font = (Font) null;
      this.label1.Name = "label1";
      this.buttonClose.AccessibleDescription = (string) null;
      this.buttonClose.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this.buttonClose, "buttonClose");
      this.buttonClose.BackgroundImage = (Image) null;
      this.buttonClose.Font = (Font) null;
      this.buttonClose.Name = "buttonClose";
      this.buttonClose.UseVisualStyleBackColor = true;
      this.buttonClose.Click += new EventHandler(this.buttonClose_Click);
      this.AccessibleDescription = (string) null;
      this.AccessibleName = (string) null;
      componentResourceManager.ApplyResources((object) this, "$this");
      this.AutoScaleMode = AutoScaleMode.Font;
      this.BackgroundImage = (Image) null;
      this.Controls.Add((Control) this.panel1);
      this.Controls.Add((Control) this.zennerCoroprateDesign1);
      this.Font = (Font) null;
      this.Name = nameof (ManageCOMservers);
      this.panel1.ResumeLayout(false);
      this.panel1.PerformLayout();
      this.groupBox2.ResumeLayout(false);
      this.groupBox2.PerformLayout();
      this.groupBox1.ResumeLayout(false);
      this.groupBox1.PerformLayout();
      ((ISupportInitialize) this.dataGridViewCOMservers).EndInit();
      this.ResumeLayout(false);
    }
  }
}


--- MBusFrameTestWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.MBusFrameTestWindow
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Globalization;
using System.Windows.Forms;

#nullable disable
namespace AsyncCom
{
  public class MBusFrameTestWindow : Form
  {
    private Queue<byte> ByteList;
    private IContainer components = (IContainer) null;
    private TextBox textBoxReceiveFrame;
    private Button buttonOk;

    public MBusFrameTestWindow()
    {
      this.InitializeComponent();
      this.ByteList = new Queue<byte>();
    }

    internal int Read(byte[] buffer, int offset, int count)
    {
      if (this.ByteList.Count < count)
      {
        this.ByteList.Clear();
        this.DialogResult = DialogResult.Cancel;
        if (this.ShowDialog() != DialogResult.OK)
          throw new Exception("Not enough bytes");
        string[] strArray1 = this.textBoxReceiveFrame.Text.Split(new string[1]
        {
          Environment.NewLine
        }, StringSplitOptions.RemoveEmptyEntries);
        for (int index1 = 0; index1 < strArray1.Length; ++index1)
        {
          string empty = string.Empty;
          int startIndex = strArray1[index1].IndexOf('|') + 1;
          string[] strArray2 = (startIndex < 1 || strArray1[index1].Length <= startIndex ? strArray1[index1] : strArray1[index1].Substring(startIndex)).Replace('.', ' ').Split(' ');
          for (int index2 = 0; index2 < strArray2.Length; ++index2)
          {
            if (strArray2[index2].Length > 0)
              this.ByteList.Enqueue(byte.Parse(strArray2[index2], NumberStyles.HexNumber));
          }
        }
        this.textBoxReceiveFrame.Clear();
      }
      for (int index = 0; index < count; ++index)
      {
        if (this.ByteList.Count == 0)
          return index;
        buffer[offset++] = this.ByteList.Dequeue();
      }
      return count;
    }

    protected override void Dispose(bool disposing)
    {
      if (disposing && this.components != null)
        this.components.Dispose();
      base.Dispose(disposing);
    }

    private void InitializeComponent()
    {
      this.textBoxReceiveFrame = new TextBox();
      this.buttonOk = new Button();
      this.SuspendLayout();
      this.textBoxReceiveFrame.Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;
      this.textBoxReceiveFrame.Font = new Font("Courier New", 9.75f, FontStyle.Regular, GraphicsUnit.Point, (byte) 0);
      this.textBoxReceiveFrame.Location = new Point(12, 12);
      this.textBoxReceiveFrame.Multiline = true;
      this.textBoxReceiveFrame.Name = "textBoxReceiveFrame";
      this.textBoxReceiveFrame.Size = new Size(569, 286);
      this.textBoxReceiveFrame.TabIndex = 0;
      this.buttonOk.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
      this.buttonOk.DialogResult = DialogResult.OK;
      this.buttonOk.Location = new Point(506, 329);
      this.buttonOk.Name = "buttonOk";
      this.buttonOk.Size = new Size(75, 23);
      this.buttonOk.TabIndex = 1;
      this.buttonOk.Text = "Ok";
      this.buttonOk.UseVisualStyleBackColor = true;
      this.AutoScaleDimensions = new SizeF(6f, 13f);
      this.AutoScaleMode = AutoScaleMode.Font;
      this.ClientSize = new Size(593, 374);
      this.Controls.Add((Control) this.buttonOk);
      this.Controls.Add((Control) this.textBoxReceiveFrame);
      this.Name = nameof (MBusFrameTestWindow);
      this.Text = nameof (MBusFrameTestWindow);
      this.ResumeLayout(false);
      this.PerformLayout();
    }
  }
}


--- MeterVPN.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.MeterVPN
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using AsyncCom.MeterVPNServer;
using NLog;
using System;
using System.Collections;
using System.Net;
using System.Net.Sockets;

#nullable disable
namespace AsyncCom
{
  public class MeterVPN
  {
    private static Logger logger = LogManager.GetLogger(nameof (MeterVPN));
    internal SortedList COMservers = new SortedList();
    internal string SelectedCOMserver = "";

    public bool Update(AsyncIP MyAsyncIP)
    {
      MeterVPN.logger.Info("Update COMServer list");
      AsyncCom.MeterVPNServer.COMserver[] COMservers;
      if (!MyAsyncIP.GetCOMServersFromMeterVPN(out COMservers))
      {
        MeterVPN.logger.Error("MyAsyncIP.GetCOMServersFromMeterVPN(out AvailableCOMservers)) == false");
        return false;
      }
      SortedList sortedList = new SortedList();
      for (int index = 0; index < this.COMservers.Count; ++index)
      {
        if (IPAddress.TryParse(((COMserver) this.COMservers.GetByIndex(index)).Name, out IPAddress _))
          sortedList.Add((object) ((COMserver) this.COMservers.GetByIndex(index)).Name, (object) (COMserver) this.COMservers.GetByIndex(index));
      }
      this.COMservers = sortedList;
      foreach (AsyncCom.MeterVPNServer.COMserver coMserver1 in COMservers)
      {
        COMserver coMserver2 = new COMserver();
        coMserver2.IPAddress = coMserver1.IP;
        coMserver2.Online = coMserver1.Online;
        coMserver2.Name = coMserver1.Name;
        coMserver2.LastSeen = coMserver1.LastSeen;
        coMserver2.Traffic = coMserver1.Traffic;
        if (!this.COMservers.ContainsKey((object) coMserver1.Cert))
          this.COMservers.Add((object) coMserver1.Cert, (object) coMserver2);
      }
      return true;
    }

    public bool AddCOMserver(AsyncIP MyAsyncIP, string Cert, string Name, string Password)
    {
      return MyAsyncIP.AddCOMserverToCustomer(Cert, Name, Password);
    }

    public bool DelCOMserver(AsyncIP MyAsyncIP, string Cert)
    {
      return MyAsyncIP.DelCOMserverFromCustomer(Cert);
    }

    public bool ModCOMserver(AsyncIP MyAsyncIP, string Cert, string Name)
    {
      return MyAsyncIP.ModCOMserver(Cert, Name);
    }

    public static AsyncCom.MeterVPNServer.COMserver[] ReadListOfCOMserver()
    {
      using (Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))
      {
        IPEndPoint remoteEP = new IPEndPoint(IPAddress.Parse("1.0.0.1"), 80);
        if (!socket.BeginConnect((EndPoint) remoteEP, (AsyncCallback) null, (object) null).AsyncWaitHandle.WaitOne(500, false))
          return (AsyncCom.MeterVPNServer.COMserver[]) null;
      }
      MeterVPNService meterVpnService = new MeterVPNService();
      meterVpnService.Proxy = GlobalProxySelection.GetEmptyWebProxy();
      return meterVpnService.GetCOMservers("test");
    }
  }
}


--- MiConBLE_SerialPort.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.MiConBLE_SerialPort
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using CommunicationPort;
using GmmDbLib;
using NLog;
using System;
using System.IO.Ports;
using ZR_ClassLibrary;

#nullable disable
namespace AsyncCom
{
  internal class MiConBLE_SerialPort : Port
  {
    private static Logger logger = LogManager.GetLogger(nameof (MiConBLE_SerialPort));
    internal BluetoothChannel_LE BLE_Channel;
    private int readTimeout;
    private int writeTimeout;

    internal override int ReadTimeout
    {
      get => this.readTimeout;
      set => this.readTimeout = value;
    }

    internal override int WriteTimeout
    {
      get => this.writeTimeout;
      set => this.writeTimeout = value;
    }

    internal override int BytesToRead => this.BLE_Channel.BytesToRead;

    internal MiConBLE_SerialPort(string BLE_Port)
    {
      this.BLE_Channel = new BluetoothChannel_LE(BLE_Port);
    }

    internal override bool Open()
    {
      try
      {
        this.BLE_Channel.Open();
      }
      catch (Exception ex)
      {
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.ComOpenError, Ot.Gtm(Tg.CommunicationLogic, "ComOpenError", "Failed to open") + " " + this.BLE_Channel.PortName);
        MiConBLE_SerialPort.logger.Error(ex.Message);
        return false;
      }
      this.FramingError = false;
      return true;
    }

    internal override bool IsOpen => this.BLE_Channel.IsOpen;

    internal override void Close()
    {
      try
      {
        this.BLE_Channel.Close();
      }
      catch (Exception ex)
      {
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, Ot.Gtm(Tg.CommunicationLogic, "ComCloseError", "Failed to close") + " " + this.BLE_Channel.PortName);
        MiConBLE_SerialPort.logger.Error(ex.Message);
      }
    }

    internal override int ReadByte()
    {
      int num = 0;
      Exception exception = (Exception) null;
      try
      {
        num = this.BLE_Channel.ReadByte();
      }
      catch (Exception ex)
      {
        string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
        MiConBLE_SerialPort.logger.Error(ex, message);
        exception = ex;
      }
      if (exception != null)
        throw exception;
      return num;
    }

    internal override int ReadChar() => this.ReadByte();

    internal override int Read(byte[] buffer, int offset, int count)
    {
      int num = 0;
      Exception exception = (Exception) null;
      try
      {
        num = this.BLE_Channel.Read(buffer, offset, count);
      }
      catch (TimeoutException ex)
      {
        MiConBLE_SerialPort.logger.Warn((Exception) ex, "Timeout while read the buffer!");
        throw ex;
      }
      catch (Exception ex)
      {
        MiConBLE_SerialPort.logger.Warn(ex, ex.Message);
        exception = ex;
      }
      if (exception != null)
        throw exception;
      return num;
    }

    internal override void Write(string text) => this.BLE_Channel.Write(text);

    internal override void Write(byte[] buffer, int offset, int count)
    {
      try
      {
        this.BLE_Channel.Write(buffer, offset, count);
      }
      catch (TimeoutException ex)
      {
        MiConBLE_SerialPort.logger.Error("Timeout while write the buffer!");
        throw ex;
      }
      catch (Exception ex)
      {
        string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
        MiConBLE_SerialPort.logger.Error(ex, message);
      }
    }

    internal override void DiscardInBuffer()
    {
      if (this.IsOpen)
      {
        MiConBLE_SerialPort.logger.Trace("Clear input buffer");
        this.BLE_Channel.DiscardInBuffer();
      }
      this.FramingError = false;
    }

    internal override void DiscardOutBuffer()
    {
      if (!this.IsOpen)
        return;
      MiConBLE_SerialPort.logger.Trace("Clear output buffer");
      this.BLE_Channel.DiscardOutBuffer();
    }

    internal override SerialPort GetPort() => throw new Exception("Port not available");
  }
}


--- MiConPollingThread.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.MiConPollingThread
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using GmmDbLib;
using NLog;
using System;
using ZR_ClassLibrary;

#nullable disable
namespace AsyncCom
{
  internal class MiConPollingThread
  {
    internal MinoConnectSerialPort MyMinoConnectSerialPort;
    internal bool StopThread = false;
    internal bool doPolling = true;
    private int PollingFastCounter = 0;
    private string StatusRequestCommand = string.Empty;
    private static Logger logger = LogManager.GetLogger("MinoConnectPollingThread");
    private const string StateRequestString = "#s\r\n";

    public event System.EventHandler ConnectionLost;

    internal void PollingThreadMain()
    {
      MiConPollingThread.logger.Trace("PollingThreadStarts");
      int num = 10;
      this.MyMinoConnectSerialPort.PollingErrorTime = SystemValues.DateTimeNow.AddMilliseconds((double) this.MyMinoConnectSerialPort.PollingErrorTime_ms);
      this.MyMinoConnectSerialPort.MinoConnectStateError = false;
      DateTime dateTimeNow1 = SystemValues.DateTimeNow;
      DateTime dateTimeNow2;
      while (!this.StopThread && this.MyMinoConnectSerialPort.IsOpen)
      {
        if (this.doPolling)
        {
          try
          {
            this.MyMinoConnectSerialPort.ReceiveQueueData();
            TimeSpan timeSpan = SystemValues.DateTimeNow - this.MyMinoConnectSerialPort.PollingErrorTime;
            if (timeSpan.TotalMilliseconds > 0.0)
            {
              this.MyMinoConnectSerialPort.IsAlive = false;
              if (num < 1)
              {
                ZR_ClassLibMessages.AddErrorDescription(this.MyMinoConnectSerialPort.MyFunctions.MainThreadId, ZR_ClassLibMessages.LastErrors.CommunicationError, Ot.Gtm(Tg.CommunicationLogic, "MiConPollingTimeout", "MinoConnect polling thread timeout"));
                break;
              }
              MinoConnectSerialPort connectSerialPort = this.MyMinoConnectSerialPort;
              dateTimeNow2 = SystemValues.DateTimeNow;
              DateTime dateTime = dateTimeNow2.AddMilliseconds((double) this.MyMinoConnectSerialPort.PollingErrorTime_ms);
              connectSerialPort.PollingErrorTime = dateTime;
              MiConPollingThread.logger.Error<int, double>("Polling thread was interrupted! Try-counter: {0} Diff time: {1} ms", num, timeSpan.TotalMilliseconds);
              --num;
            }
            else if (num < 10 && this.MyMinoConnectSerialPort.IsAlive)
            {
              MiConPollingThread.logger.Error("Reset polling timeout counter");
              num = 10;
            }
            lock (this.MyMinoConnectSerialPort)
            {
              if (this.MyMinoConnectSerialPort.CommandStringForPollingThread == null)
              {
                this.StatusRequestCommand = "#s\r\n";
              }
              else
              {
                if (MiConPollingThread.logger.IsTraceEnabled)
                  MiConPollingThread.logger.Trace("CommandStringForPollingThread: " + ZR_Constants.SystemNewLine + this.MyMinoConnectSerialPort.CommandStringForPollingThread.Trim());
                this.MyMinoConnectSerialPort.UpdateIrDaFilterBy9600RoundSite();
                this.StatusRequestCommand = this.MyMinoConnectSerialPort.CommandStringForPollingThread + "#s\r\n";
                this.MyMinoConnectSerialPort.CommandStringForPollingThread = (string) null;
              }
            }
            lock (this.MyMinoConnectSerialPort.TransmitQueue)
            {
              for (int index = 0; index < this.StatusRequestCommand.Length; ++index)
                this.MyMinoConnectSerialPort.TransmitQueue.Enqueue((byte) this.StatusRequestCommand[index]);
              this.MyMinoConnectSerialPort.TransmitQueueData();
              this.MyMinoConnectSerialPort.MyFunctions.ComWriteLoggerEvent(EventLogger.LoggerEvent.ComSendMinoConnectStatusRequest);
            }
          }
          catch (Exception ex)
          {
            string str = Ot.Gtm(Tg.CommunicationLogic, "MiConPollingError", "MinoConnect polling thread error") + " " + ex.ToString();
            MiConPollingThread.logger.Error(str);
            ZR_ClassLibMessages.AddErrorDescription(this.MyMinoConnectSerialPort.MyFunctions.MainThreadId, ZR_ClassLibMessages.LastErrors.CommunicationError, str);
            break;
          }
          this.MyMinoConnectSerialPort.PollingThreadWorkEvent.WaitOne(this.MyMinoConnectSerialPort.Polling_ms, false);
          if (this.MyMinoConnectSerialPort.Polling_ms != 500)
          {
            --this.PollingFastCounter;
            if (this.PollingFastCounter < 0)
              this.PollingFastCounter = 5;
            if (this.PollingFastCounter == 0)
              this.MyMinoConnectSerialPort.Polling_ms = 500;
          }
        }
        else
        {
          dateTimeNow2 = SystemValues.DateTimeNow;
          DateTime dateTime = dateTimeNow2.AddMilliseconds((double) this.MyMinoConnectSerialPort.PollingErrorTime_ms);
          if (this.MyMinoConnectSerialPort.PollingErrorTime < dateTime)
            this.MyMinoConnectSerialPort.PollingErrorTime = dateTime;
        }
      }
      if (!this.StopThread)
      {
        if (this.ConnectionLost != null)
          this.ConnectionLost((object) this, (EventArgs) null);
        MiConPollingThread.logger.Error("MinoConnect polling thread is stoped!");
        this.MyMinoConnectSerialPort.Close();
      }
      else
        MiConPollingThread.logger.Debug("MinoConnect polling thread was successfully stopped!");
      this.MyMinoConnectSerialPort.MinoConnectStateError = true;
      this.MyMinoConnectSerialPort.MyFunctions.SendAsyncComMessage(new GMM_EventArgs(GMM_EventArgs.MessageType.StatusThreadStopped));
      this.MyMinoConnectSerialPort.Close();
    }

    internal delegate void Start();
  }
}


--- MinoConnectSerialPort.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.MinoConnectSerialPort
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using GmmDbLib;
using MinoConnect;
using NLog;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.IO.Ports;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using ZENNER.CommonLibrary.Exceptions;
using ZR_ClassLibrary;

#nullable disable
namespace AsyncCom
{
  internal class MinoConnectSerialPort : Port
  {
    internal MiConPollingThread PollingThreadObj;
    private Thread PollThread;
    private static Logger logger = LogManager.GetLogger(nameof (MinoConnectSerialPort));
    internal Decimal VersionValue;
    private string Version;
    private MinoConnectVersions MiConVersion;
    private bool isTransparent;
    private bool ESC_Reseived = false;
    private bool AnswerActive = false;
    private bool RequiredBreakState = false;
    internal bool MinoConnectStateError;
    internal bool MiConSupplyOverload = false;
    internal bool MiConBatteryLow = false;
    public bool IsAlive = false;
    private ByteField ReceiveLine = new ByteField(20);
    private byte[] LastStatusLine = new byte[7];
    private int StatusAliveCounter = 0;
    private short OutState = 0;
    private byte[] ReadByteBuffer = new byte[1];
    internal Queue<byte> TransmitQueue = new Queue<byte>(300);
    internal Queue<byte> ReceiveQueue = new Queue<byte>(300);
    internal Queue<byte> StatusQueue = new Queue<byte>(100);
    internal int PollingErrorTime_ms = 3000;
    internal DateTime PollingErrorTime;
    internal Port _base;
    internal MinoConnectState StateRequired;
    internal MinoConnectState StateSet;
    internal MinoConnectState StateLastReceived;
    internal AsyncFunctions MyFunctions;
    internal AutoResetEvent PollingThreadWorkEvent = new AutoResetEvent(false);
    internal string CommandStringForPollingThread;
    internal const int Polling_ms_Default = 500;
    internal const int Polling_ms_Fast = 50;
    internal int Polling_ms = 500;
    private AsyncOperation asyncOperation = (AsyncOperation) null;

    public override event System.EventHandler ConnectionLost;

    public override event System.EventHandler BatterieLow;

    public MinoConnectSerialPort(AsyncFunctions MyFunctionsIn)
    {
      this.MyFunctions = MyFunctionsIn;
      this.isTransparent = false;
      this.StateRequired = new MinoConnectState(this);
      this.StateSet = new MinoConnectState(this);
      MinoConnectSerialPort.logger.Trace("MinoConnectSerialPort -> Constructor");
      if (!this.MyFunctions.ComPort.StartsWith("Mi"))
      {
        this._base = (Port) new StandardSerialPort(115200, Parity.None, MyFunctionsIn);
        this._base.IgnoreFramingError = true;
      }
      else
      {
        this._base = (Port) new MiConBLE_SerialPort(MyFunctionsIn.ComPort);
        MyFunctionsIn.RecTime_GlobalOffset += 200;
      }
      if (MyFunctionsIn.Baudrate > 115200)
      {
        MinoConnectSerialPort.logger.Debug("MyFunctionsIn.Baudrate exceeds 115200.");
        throw new ArgumentException("Value to high", "Baudrate");
      }
    }

    internal override bool Open()
    {
      if (MinoConnectSerialPort.logger.IsDebugEnabled)
        MinoConnectSerialPort.logger.Debug("Open calling. IsOpen={0}, ExistPollingThread={1}, PollingThread.StopThread={2}, PollingThread.doPolling={3}, IsTransparent={4}", new object[5]
        {
          (object) this._base.IsOpen,
          (object) (this.PollingThreadObj != null),
          this.PollingThreadObj != null ? (object) Convert.ToString(this.PollingThreadObj.StopThread) : (object) "",
          this.PollingThreadObj != null ? (object) Convert.ToString(this.PollingThreadObj.doPolling) : (object) "",
          (object) this.isTransparent
        });
      if (this._base.IsOpen & (this.PollingThreadObj != null && !this.PollingThreadObj.StopThread && this.PollingThreadObj.doPolling) || this._base.IsOpen && this.isTransparent)
        return true;
      this.MiConSupplyOverload = false;
      this.MiConBatteryLow = false;
      this._base.FramingError = false;
      this.MinoConnectStateError = true;
      this.MyFunctions.SendAsyncComMessage(new GMM_EventArgs(GMM_EventArgs.MessageType.Wait)
      {
        EventMessage = Ot.Gtt(Tg.CommunicationLogic, "MiConOpen", "Open MinoConnect com port ...")
      });
      if (this._base.IsOpen)
        this._base.Close();
      try
      {
        if (!this._base.Open())
          return false;
        if (this.isTransparent)
          return true;
        this.WriteCommand("#com off\r\n");
        this.WriteCommand("#comcl\r\n");
        this.WriteCommand("#broff\r\n");
        if (!this.ReadMinoConnectVersion())
          return false;
        this.StateRequired.SetFromAsyncCom(this.MyFunctions);
        this.UpdateIrDaFilterBy9600RoundSite();
        this.WriteCommand(new MinoConnectState(this).GetChangeCommand(this.StateRequired));
        this.StateSet = new MinoConnectState(this.StateRequired);
        this.StateLastReceived = new MinoConnectState(this);
        this.StateLastReceived.SetFromAsyncCom(this.MyFunctions);
        if (this.asyncOperation == null)
          this.asyncOperation = AsyncOperationManager.CreateOperation((object) null);
        this.StartPolling();
        this._base.DiscardInBuffer();
        this._base.IgnoreFramingError = false;
        this._base.FramingError = false;
        return true;
      }
      catch (Exception ex)
      {
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, Ot.Gtm(Tg.CommunicationLogic, "MiConOpenError", "MinoConnect open error") + " " + this.MyFunctions.ComPort);
        MinoConnectSerialPort.logger.Error("MiConOpenError: " + ex.ToString());
        this.Close();
      }
      return false;
    }

    internal void UpdateIrDaFilterBy9600RoundSite()
    {
      string empty = string.Empty;
      string text = !(this.VersionValue < 2.405M) ? "#irf1\r\n" : (!this.StateRequired.IsRequiredIrDaFilter ? "#irf1\r\n" : "#irf0\r\n");
      if (string.IsNullOrEmpty(text))
        return;
      this.WriteCommand(text);
      this.CheckAnswerOfIrDaFilterCommand();
    }

    internal void CheckAnswerOfIrDaFilterCommand()
    {
      try
      {
        string answer = this.ReceiveAnswer();
        if (string.IsNullOrEmpty(answer))
          return;
        MinoConnectSerialPort.logger.Info(answer);
      }
      catch
      {
      }
    }

    internal override void Close()
    {
      MinoConnectSerialPort.logger.Trace("Close called.");
      this.StopPolling();
      this.StateLastReceived = (MinoConnectState) null;
      this._base.Close();
      this.MyFunctions.ComIsOpen = false;
    }

    internal override bool ChangeDriverSettings()
    {
      MinoConnectSerialPort.logger.Trace("Call MinoConnect ChangeDriverSettings");
      if (!this.IsOpen)
      {
        MinoConnectSerialPort.logger.Error("Can't change the MinoConnect settings! The port is closed.");
        return false;
      }
      bool flag = this.PollingThreadObj != null && this.PollingThreadObj.doPolling && !this.PollingThreadObj.StopThread;
      if (!flag)
      {
        MinoConnectSerialPort.logger.Error("Can't change the MinoConnect settings! The polling thread is not running.");
        return false;
      }
      this.StateRequired.SetFromAsyncCom(this.MyFunctions);
      string changeCommand = (this.StateLastReceived ?? new MinoConnectState(this)).GetChangeCommand(this.StateRequired);
      if (string.IsNullOrEmpty(changeCommand))
        MinoConnectSerialPort.logger.Info("The MinoConenct has the same settings!");
      else
        MinoConnectSerialPort.logger.Info("Try change the MinoConnect settings. CMD: {0}", changeCommand);
      lock (this)
        this.CommandStringForPollingThread = changeCommand;
      this.Polling_ms = 50;
      this.PollingThreadWorkEvent.Set();
      this.StateSet = new MinoConnectState(this.StateRequired);
      this.StateLastReceived = new MinoConnectState(this);
      this.StateLastReceived.SetFromAsyncCom(this.MyFunctions);
      for (int index = 30000; flag && this.CommandStringForPollingThread != null && index > 0; index -= 50)
      {
        if (!ZR_ClassLibrary.Util.Wait(50L, "after sends new settings to MinoConnect", (ICancelable) this.MyFunctions, MinoConnectSerialPort.logger))
          return false;
        flag = this.PollingThreadObj != null && this.PollingThreadObj.doPolling && !this.PollingThreadObj.StopThread;
      }
      if (this.CommandStringForPollingThread == null)
        return true;
      MinoConnectSerialPort.logger.Error("Can not sends new settings to MinoConnect!");
      return false;
    }

    internal override bool BreakState
    {
      set
      {
        if (value)
        {
          string text = "#bron\r\n";
          MinoConnectSerialPort.logger.Trace("SetBrakeOn CMD: {0}", text);
          this.WriteCommand(text);
          this.RequiredBreakState = true;
        }
        else
        {
          string text = "#broff\r\n";
          MinoConnectSerialPort.logger.Trace("SetBrakeOff CMD: {0}", text);
          this.WriteCommand(text);
          this.RequiredBreakState = false;
        }
      }
      get => this.RequiredBreakState;
    }

    internal override bool IsOpen => this._base.IsOpen;

    internal override int ReadTimeout
    {
      get => this._base.ReadTimeout;
      set => this._base.ReadTimeout = value;
    }

    internal override int WriteTimeout
    {
      get => this._base.WriteTimeout;
      set => this._base.WriteTimeout = value;
    }

    internal override int BytesToRead
    {
      get
      {
        this.ReceiveQueueData();
        lock (this.ReceiveQueue)
          return this.ReceiveQueue.Count;
      }
    }

    internal override int BytesToWrite
    {
      get
      {
        lock (this.TransmitQueue)
          return this.TransmitQueue.Count;
      }
    }

    internal override void SetRTS(bool state)
    {
      if (state)
        this.OutState |= (short) 1;
      else
        this.OutState &= (short) -2;
      string text = "#out" + this.OutState.ToString() + "\r\n";
      this.WriteCommand(text);
      MinoConnectSerialPort.logger.Trace(" SetOutRTS: " + text);
    }

    internal override void SetDTR(bool state)
    {
      if (state)
        this.OutState |= (short) 2;
      else
        this.OutState &= (short) -3;
      this.WriteCommand("#out" + this.OutState.ToString() + "\r\n");
    }

    internal override void Write(string text)
    {
      if (this.isTransparent)
      {
        this._base.Write(text);
      }
      else
      {
        Exception exception = (Exception) null;
        if (this.PollThread == null)
          throw new Exception(Ot.Gtm(Tg.CommunicationLogic, "MiConPollingError", "MinoConnect polling thread error"));
        if (this.PollThread.Join(0))
          throw new Exception(Ot.Gtm(Tg.CommunicationLogic, "MiConPollingError", "MinoConnect polling thread error"));
        lock (this.TransmitQueue)
        {
          try
          {
            for (int index = 0; index < text.Length; ++index)
            {
              this.TransmitQueue.Enqueue((byte) text[index]);
              if (text[index] == '#')
                this.TransmitQueue.Enqueue((byte) text[index]);
            }
            this.TransmitQueueData();
          }
          catch (Exception ex)
          {
            MinoConnectSerialPort.logger.Error(ex, "Write()->" + ex.Message);
            exception = ex;
          }
        }
        if (exception != null)
          throw exception;
      }
    }

    internal override void Write(byte[] buffer, int offset, int count)
    {
      if (this.isTransparent)
      {
        this._base.Write(buffer, offset, count);
      }
      else
      {
        Exception exception = (Exception) null;
        if (this.PollThread == null)
          throw new Exception(Ot.Gtm(Tg.CommunicationLogic, "MiConPollingError", "MinoConnect polling thread error"));
        if (this.PollThread.Join(0))
          throw new Exception(Ot.Gtm(Tg.CommunicationLogic, "MiConPollingError", "MinoConnect polling thread error"));
        if (this.MinoConnectStateError)
        {
          MinoConnectSerialPort.logger.Error("Read()->MinoConnect state error");
          throw new IOException(Ot.Gtm(Tg.CommunicationLogic, "MiConStateError", "MinoConnect state error"));
        }
        lock (this.TransmitQueue)
        {
          try
          {
            for (int index = 0; index < count; ++index)
            {
              this.TransmitQueue.Enqueue(buffer[offset + index]);
              if (buffer[offset + index] == (byte) 35)
                this.TransmitQueue.Enqueue(buffer[offset + index]);
            }
            this.TransmitQueueData();
          }
          catch (Exception ex)
          {
            MinoConnectSerialPort.logger.Error(ex, "Write error->" + ex.Message);
            exception = ex;
          }
        }
        if (exception != null)
          throw exception;
      }
    }

    internal override bool ReadExistingBytes(out byte[] buffer)
    {
      buffer = (byte[]) null;
      lock (this.ReceiveQueue)
      {
        if (this.ReceiveQueue.Count > 0)
        {
          int count = this.ReceiveQueue.Count;
          buffer = new byte[count];
          for (int index = 0; index < count; ++index)
            buffer[index] = this.ReceiveQueue.Dequeue();
        }
      }
      return true;
    }

    internal override int Read(byte[] buffer, int offset, int count)
    {
      if (this.isTransparent)
        return this._base.Read(buffer, offset, count);
      if (!this.IsOpen)
        throw new InvalidOperationException("MinoConnect port is not open!");
      if (buffer == null)
        throw new ArgumentNullException(nameof (buffer), "The buffer should not be empty!");
      if (offset < 0)
        throw new ArgumentOutOfRangeException(nameof (offset), "The offset is negative!");
      if (count < 0)
        throw new ArgumentOutOfRangeException(nameof (count), "The count is negative!");
      if (buffer.Length - offset < count)
        throw new ArgumentException("The length is invalid!");
      if (this.FramingError)
      {
        this.FramingError = false;
        MinoConnectSerialPort.logger.Error("Read()->Framing error");
        throw new FramingErrorException(Ot.Gtm(Tg.CommunicationLogic, "MiConFramingError", "MinoConnect framing error"));
      }
      if (this.MinoConnectStateError)
      {
        MinoConnectSerialPort.logger.Error("Read()->MinoConnect state error");
        throw new IOException(Ot.Gtm(Tg.CommunicationLogic, "MiConStateError", "MinoConnect state error"));
      }
      this.ReceiveQueueData();
      lock (this.ReceiveQueue)
      {
        if (this.ReceiveQueue.Count < 1)
          return 0;
        int num = Math.Min(this.ReceiveQueue.Count, count);
        for (int index = 0; index < num; ++index)
          buffer[index + offset] = this.ReceiveQueue.Dequeue();
        return num;
      }
    }

    internal override int ReadChar() => this.ReadByte();

    internal override int ReadByte()
    {
      this.Read(this.ReadByteBuffer, 0, 1);
      return (int) this.ReadByteBuffer[0];
    }

    internal override void DiscardOutBuffer()
    {
    }

    internal override void DiscardInBuffer()
    {
      if (!this._base.IsOpen)
        return;
      this.ClearInputBuffer();
    }

    internal override SerialPort GetPort() => this._base.GetPort();

    internal void StartRadio2()
    {
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio radio2\r\n");
    }

    internal void StartRadio3()
    {
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio radio3\r\n");
    }

    internal void StartRadio4()
    {
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio radio4\r\n");
    }

    internal void StopWalkBy() => this.WriteCommand("#com rsoff\r\n");

    internal bool StartMinomatRadioTest(byte networkID)
    {
      if (this.VersionValue < 2.4M)
        return ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.OperationCancelled, Ot.Gtm(Tg.CommunicationLogic, "YouAreUsingOldFirmwareOnMinoConnect", "You are using an MinoConnect with old firmware, this command is not supported by this firmware."));
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#rtest sndinq " + networkID.ToString() + "\r\n");
      return true;
    }

    internal bool StartRadio3_868_95_RUSSIA()
    {
      if (this.VersionValue < 2.4M)
        return ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.OperationCancelled, Ot.Gtm(Tg.CommunicationLogic, "YouAreUsingOldFirmwareOnMinoConnect", "You are using an MinoConnect with old firmware, this command is not supported by this firmware."));
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio radio3_868.95\r\n");
      return true;
    }

    internal bool Start_RadioMS()
    {
      if (this.VersionValue < 2.4M)
        return ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.OperationCancelled, Ot.Gtm(Tg.CommunicationLogic, "YouAreUsingOldFirmwareOnMinoConnect", "You are using an MinoConnect with old firmware, this command is not supported by this firmware."));
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio radio_ms\r\n");
      return true;
    }

    internal bool Start_wMBusS1()
    {
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio wmbus_s1\r\n");
      return true;
    }

    internal bool Start_wMBusS1M()
    {
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio wmbus_s1m\r\n");
      return true;
    }

    internal bool Start_wMBusS2()
    {
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio wmbus_s2\r\n");
      return true;
    }

    internal bool Start_wMBusT1()
    {
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio wmbus_t1\r\n");
      return true;
    }

    internal bool Start_wMBusT2_meter()
    {
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio wmbus_t2_m\r\n");
      return true;
    }

    internal bool Start_wMBusT2_other()
    {
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio wmbus_t2_o\r\n");
      return true;
    }

    internal bool Start_wMBusC1A()
    {
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio wmbus_c1a\r\n");
      return true;
    }

    internal bool Start_wMBusC1B()
    {
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#com radio wmbus_c1b\r\n");
      return true;
    }

    internal bool StartSendTestPacket(RadioMode radioMode, byte power)
    {
      if (power < (byte) 0 || power > (byte) 7)
        return false;
      string str;
      switch (radioMode)
      {
        case RadioMode.Radio2:
          str = "radio2";
          break;
        case RadioMode.Radio3:
          str = "radio3";
          break;
        case RadioMode.wMBusS1:
          str = "wmbus_s1";
          break;
        case RadioMode.wMBusS1M:
          str = "wmbus_s1m";
          break;
        case RadioMode.wMBusS2:
          str = "wmbus_s2";
          break;
        case RadioMode.wMBusT1:
          str = "wmbus_t1";
          break;
        case RadioMode.wMBusT2_meter:
          str = "wmbus_t2_m";
          break;
        case RadioMode.wMBusT2_other:
          str = "wmbus_t2_o";
          break;
        case RadioMode.wMBusC1A:
          str = "wmbus_c1a";
          break;
        case RadioMode.wMBusC1B:
          str = "wmbus_c1b";
          break;
        default:
          return false;
      }
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#rtest loop " + str + " " + power.ToString() + "\r\n");
      return true;
    }

    internal bool StopSendTestPacket()
    {
      this.WriteCommand("#comcl\r\n");
      this.WriteCommand("#rtest stop\r\n");
      return true;
    }

    private string ReceiveAnswer()
    {
      DateTime dateTime = SystemValues.DateTimeNow.AddMilliseconds((double) this.MyFunctions.RecTime_BeforFirstByte);
      StringBuilder stringBuilder = new StringBuilder(200);
      while (true)
      {
        char ch;
        do
        {
          do
          {
            do
            {
              if (this._base.BytesToRead != 0)
              {
                if (stringBuilder.Length <= 200)
                {
                  Thread.Sleep(1);
                  try
                  {
                    ch = (char) this._base.ReadByte();
                    if (ch == char.MinValue)
                      ;
                  }
                  catch (TimeoutException ex)
                  {
                    if (dateTime < SystemValues.DateTimeNow)
                    {
                      if (stringBuilder.Length == 0)
                        throw new TimeoutException("No data from MinoConnect!");
                      throw new TimeoutException("Wrong 'RecTime_BeforFirstByte' parameter! Not all data received from MinoConnect.");
                    }
                  }
                }
                else
                  goto label_6;
              }
              else
                goto label_1;
            }
            while (ch == '\r');
            if (ch != '\n')
              goto label_16;
          }
          while (stringBuilder.Length == 0);
          goto label_18;
label_1:;
        }
        while (!(dateTime < SystemValues.DateTimeNow));
        break;
label_16:
        stringBuilder.Append(ch);
      }
      if (stringBuilder.Length == 0)
        throw new TimeoutException("No data from MinoConnect!");
      throw new TimeoutException("Wrong 'RecTime_BeforFirstByte' parameter! Not all data received from MinoConnect.");
label_6:
      throw new ArgumentOutOfRangeException("Too many received bytes");
label_18:
      return stringBuilder.ToString();
    }

    public void WriteCommand(string text)
    {
      if (MinoConnectSerialPort.logger.IsTraceEnabled)
        MinoConnectSerialPort.logger.Trace(text.Trim());
      Exception exception = (Exception) null;
      lock (this.TransmitQueue)
      {
        try
        {
          for (int index = 0; index < text.Length; ++index)
            this.TransmitQueue.Enqueue((byte) text[index]);
          this.TransmitQueueData();
        }
        catch (Exception ex)
        {
          string message = string.Format("Can not transmit command! Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
          MinoConnectSerialPort.logger.Error(ex, message);
          exception = ex;
        }
      }
      if (exception != null)
        throw exception;
    }

    internal void TransmitQueueData()
    {
      int count = this.TransmitQueue.Count;
      byte[] buffer = new byte[count];
      for (int index = 0; index < count; ++index)
        buffer[index] = this.TransmitQueue.Dequeue();
      this._base.Write(buffer, 0, count);
    }

    internal void ReceiveQueueData()
    {
      byte[] numArray = (byte[]) null;
      lock (this.ReceiveQueue)
      {
        try
        {
          int bytesToRead = this._base.BytesToRead;
          if (bytesToRead != 0)
          {
            byte[] buffer = new byte[bytesToRead];
            int num = this._base.Read(buffer, 0, bytesToRead);
            for (int index = 0; index < num; ++index)
            {
              if (this.AnswerActive)
              {
                this.StatusQueue.Enqueue(buffer[index]);
                if (buffer[index] == (byte) 10)
                  this.AnswerActive = false;
              }
              else if (this.ESC_Reseived)
              {
                if (buffer[index] == (byte) 35)
                {
                  this.ReceiveQueue.Enqueue(buffer[index]);
                }
                else
                {
                  this.StatusQueue.Enqueue((byte) 35);
                  this.StatusQueue.Enqueue(buffer[index]);
                  this.AnswerActive = true;
                }
                this.ESC_Reseived = false;
              }
              else if (buffer[index] == (byte) 35)
                this.ESC_Reseived = true;
              else
                this.ReceiveQueue.Enqueue(buffer[index]);
            }
          }
          numArray = this.ScanReceiveLine();
        }
        catch (Exception ex)
        {
          string message = string.Format("Error in ReceiveQueueData (StatusQueue.Count = {0}, ReceiveQueue.Count = {1}) Error: {2}, Trace: {3}", (object) this.StatusQueue.Count, (object) this.ReceiveQueue.Count, (object) ex.Message, (object) ex.StackTrace);
          MinoConnectSerialPort.logger.Error(ex, message);
        }
      }
      if (numArray == null)
        return;
      if (numArray.Length > 1)
      {
        if (numArray[1] == (byte) 115)
        {
          this.IsAlive = true;
          this.MyFunctions.ComWriteLoggerEvent(EventLogger.LoggerEvent.ComReceiveMinoConnectStatus);
          if (this.StateLastReceived != null && this.StateLastReceived.SetFromReceivedState(numArray))
          {
            if (this.StateLastReceived.StateChanged)
            {
              if (this.StateLastReceived.KeyReceived)
              {
                MinoConnectSerialPort.logger.Info("MinoConnect key event received. KeyReceived!");
                this.SendAsyncComMessageAsynchronously(new GMM_EventArgs(GMM_EventArgs.MessageType.KeyReceived));
              }
              if (this.StateLastReceived.FramingError)
                this.FramingError = true;
              if (!this.MiConSupplyOverload && this.StateLastReceived.Overload)
              {
                this.MiConSupplyOverload = true;
                this.SendAsyncComMessageAsynchronously(new GMM_EventArgs("MinoConnect supply", GMM_EventArgs.MessageType.Overload));
              }
              if (!this.MiConBatteryLow && this.StateLastReceived.BatteryLow)
              {
                if (!this.MiConBatteryLow)
                  this.OnBatterieLow();
                this.MiConBatteryLow = true;
                this.SendAsyncComMessageAsynchronously(new GMM_EventArgs("MinoConnect battery", GMM_EventArgs.MessageType.BatteryLow));
              }
              this.SendAsyncComMessageAsynchronously(new GMM_EventArgs(GMM_EventArgs.MessageType.StatusChanged));
            }
            if (this.StatusAliveCounter > 0)
            {
              this.StatusAliveCounter = 0;
              this.SendAsyncComMessageAsynchronously(new GMM_EventArgs(GMM_EventArgs.MessageType.Alive));
            }
            else
              ++this.StatusAliveCounter;
          }
        }
      }
      else
        this.WorkResponseLine(numArray);
    }

    private void OnBatterieLow()
    {
      System.EventHandler batterieLow = this.BatterieLow;
      if (batterieLow == null)
        return;
      batterieLow((object) this, new EventArgs());
    }

    private void SendAsyncComMessageAsynchronously(GMM_EventArgs msg)
    {
      this.asyncOperation.Post((SendOrPostCallback) (state =>
      {
        try
        {
          this.MyFunctions.SendAsyncComMessage(msg);
        }
        catch (Exception ex)
        {
          string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
          MinoConnectSerialPort.logger.Error(ex, message);
        }
      }), (object) null);
    }

    private byte[] ScanReceiveLine()
    {
      byte[] line = (byte[]) null;
      while (this.StatusQueue.Count > 0)
      {
        if (this.ReceiveLine.Count == this.ReceiveLine.Data.Length)
          this.ReceiveLine.Count = 0;
        byte Byte = this.StatusQueue.Dequeue();
        if (this.ReceiveLine.Count != 0 || Byte == (byte) 35)
        {
          this.ReceiveLine.Add(Byte);
          if (Byte == (byte) 10)
          {
            DateTime dateTime = SystemValues.DateTimeNow.AddMilliseconds((double) this.PollingErrorTime_ms);
            if (this.PollingErrorTime < dateTime)
              this.PollingErrorTime = dateTime;
            line = this.ReceiveLine.GetByteArray();
            this.ReceiveLine.Count = 0;
          }
        }
      }
      return line;
    }

    private void WorkResponseLine(byte[] StatusLine)
    {
      if (StatusLine.Length != 8 || StatusLine[1] != (byte) 70 || StatusLine[2] != (byte) 95 || StatusLine[3] != (byte) 69 || StatusLine[4] != (byte) 82 || StatusLine[5] != (byte) 82)
        return;
      this.FramingError = true;
    }

    private void StartPolling()
    {
      MinoConnectSerialPort.logger.Trace("StartPolling() called.");
      if (this._base.IsOpen && this.PollThread != null && this.PollingThreadObj != null && this.PollingThreadObj.StopThread && this.PollingThreadObj.doPolling)
        MinoConnectSerialPort.logger.Fatal("INTERNAL ERROR: PollingThread already runs!");
      if (this.PollingThreadObj == null)
      {
        this.PollingThreadObj = new MiConPollingThread();
        this.PollingThreadObj.ConnectionLost += new System.EventHandler(this.PollingThreadObj_ConnectionLost);
        this.PollingThreadObj.MyMinoConnectSerialPort = this;
      }
      this.PollingThreadObj.StopThread = false;
      this.PollingThreadObj.doPolling = true;
      if (this.PollThread == null)
      {
        this.PollThread = new Thread(new ThreadStart(new MiConPollingThread.Start(this.PollingThreadObj.PollingThreadMain).Invoke));
        this.PollThread.Name = "MinoConnectPolling";
        this.PollThread.IsBackground = true;
      }
      this.PollThread.Start();
      if (ZR_ClassLibrary.Util.Wait(100L, "after start PollingThread", (ICancelable) this.MyFunctions, MinoConnectSerialPort.logger))
        ;
    }

    private void PollingThreadObj_ConnectionLost(object sender, EventArgs e)
    {
      if (this.ConnectionLost == null)
        return;
      this.ConnectionLost(sender, e);
    }

    private void StopPolling()
    {
      if (this.PollThread == null || this.PollingThreadObj == null)
        return;
      MinoConnectSerialPort.logger.Trace("Stop MinoConnect polling thread.");
      this.PollingThreadObj.StopThread = true;
      this.PollingThreadObj.ConnectionLost -= new System.EventHandler(this.PollingThreadObj_ConnectionLost);
      Application.DoEvents();
      int num = 0;
      while (num < 20 && (this.PollThread == null || !this.PollThread.Join(100)))
        ++num;
      this.PollingThreadObj = (MiConPollingThread) null;
      this.PollThread = (Thread) null;
    }

    internal void SuspendPolling()
    {
      if (this.PollingThreadObj == null)
        return;
      this.PollingThreadObj.doPolling = false;
    }

    internal void ResumePolling()
    {
      if (this.PollingThreadObj == null)
        return;
      this.PollingThreadObj.doPolling = true;
    }

    private bool ReadMinoConnectVersion()
    {
      if (!this._base.IsOpen)
        return false;
      try
      {
        this.MyFunctions.SendAsyncComMessage(new GMM_EventArgs(GMM_EventArgs.MessageType.StatusChanged)
        {
          EventMessage = "Read MinoConnect version..."
        });
        if (!ZR_ClassLibrary.Util.Wait(300L, "before read version of MinoConnect", (ICancelable) this.MyFunctions, MinoConnectSerialPort.logger))
          return false;
        this.ClearInputBuffer();
        this.WriteCommand("#ver\r\n");
        if (!ZR_ClassLibrary.Util.Wait(200L, "after sends '#ver' command to MinoConnect", (ICancelable) this.MyFunctions, MinoConnectSerialPort.logger))
          return false;
        this.Version = this.ReceiveAnswer();
        if (this.Version.Length < 12)
        {
          string str = "MinoConnect: No Answer!";
          ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, str);
          MinoConnectSerialPort.logger.Error(str);
          this.Close();
          return false;
        }
        MinoConnectSerialPort.logger.Trace(this.Version);
        this.VersionValue = (Decimal) int.Parse(this.Version.Substring(6, 1)) + (Decimal) int.Parse(this.Version.Substring(8, 1)) / 10M + (Decimal) int.Parse(this.Version.Substring(10, 1)) / 1000M;
        try
        {
          this.MiConVersion = new MinoConnectVersions(this.Version);
        }
        catch
        {
        }
        this.Version.Split('|');
        this.MyFunctions.transceiverDeviceInfo = this.Version.Replace("#Ver", "MinoConnect" + ZR_Constants.SystemNewLine + "Firmware version").Replace("|", ZR_Constants.SystemNewLine);
        return true;
      }
      catch (TimeoutException ex)
      {
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.Timeout, Ot.Gtm(Tg.CommunicationLogic, "MiConOpenError", "MinoConnect open error") + " " + this.MyFunctions.ComPort);
        MinoConnectSerialPort.logger.Error("MiConOpenError: " + ex.ToString());
        this.Close();
        return false;
      }
      catch (Exception ex)
      {
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, Ot.Gtm(Tg.CommunicationLogic, "MiConOpenError", "MinoConnect open error") + " " + this.MyFunctions.ComPort + " " + ex.ToString());
        MinoConnectSerialPort.logger.Error("MiConOpenError: " + ex.ToString());
        this.Close();
        return false;
      }
    }

    private void MinoConnectCommunicationTest()
    {
      string str1 = "#s\r\n";
      string empty = string.Empty;
      string str2 = "Send:'" + ParameterService.GetExpandesString(str1) + "';Receive:'";
      while (true)
      {
        this._base.Write(str1);
        string answer = this.ReceiveAnswer();
        Application.DoEvents();
        MinoConnectSerialPort.logger.Trace(str2 + answer + "'");
      }
    }

    private void ClearInputBuffer()
    {
      lock (this.ReceiveQueue)
      {
        do
        {
          this.ReceiveQueueData();
          if (this.ReceiveQueue.Count > 0)
          {
            byte[] array = this.ReceiveQueue.ToArray();
            if (array != null && array.Length != 0 && MinoConnectSerialPort.logger.IsTraceEnabled)
              MinoConnectSerialPort.logger.Trace("Clear input buffer: " + ZR_ClassLibrary.Util.ByteArrayToHexString(array));
            this.ReceiveQueue.Clear();
            this.ReceiveQueueData();
          }
        }
        while (this.ReceiveQueue.Count > 0);
      }
    }

    internal bool SetTransparentMode(bool enable)
    {
      if (!this._base.IsOpen && !this._base.Open())
        return false;
      if (enable)
      {
        this.WriteCommand("#apo 0\r\n");
        this.WriteCommand("#coff\r\n");
        this.isTransparent = true;
        this.StopPolling();
        return true;
      }
      this._base.Write("aaafTzhuZl5c39zUNdWq105bmysloncwalnNIK783BH89kirEWmIkPl(!56)bfrtg984!?eV&29IkoPmt!$ymncSrtIopQ'+*bg%ad279vRzOp;-_4y78JI08NJde6HjiOx");
      this.isTransparent = false;
      this.Close();
      return this.Open();
    }

    internal bool SendTestPacket(BusMode busMode, byte[] buffer)
    {
      throw new NotImplementedException();
    }
  }
}


--- MinoConnectState.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.MinoConnectState
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using System;
using System.Text;
using ZR_ClassLibrary;

#nullable disable
namespace AsyncCom
{
  internal class MinoConnectState
  {
    private MinoConnectSerialPort MyMiConPort;
    private MinoConnectState.MinoConnectPlugState DetectedDevice;
    private MinoConnectState.BaseStateEnum MinoConnectBaseState;
    private MinoConnectState.RadioModes ActiveRadioMode;
    private MinoConnectState.RadioCommands ActiveRadioCommand;
    private int RadioPacketErrorCounter;
    private bool RadioError;
    private MinoConnectState.ReceivedState LastReseicedState = MinoConnectState.ReceivedState.None;
    private int Baudrate;
    private string ByteFrame;
    private MinoConnectState.IrCombiHeadFunctionEnum IrCombiHeadFunction;
    private int IrDaPulseLength;
    private int AutoPowerOffTime;
    private DateTime StateTime;
    internal bool KeyReceived;
    internal bool FramingError;
    internal bool Overload;
    internal bool BatteryLow;
    internal bool StateChanged;
    private byte[] LastStateLine;
    private static string[] StateCommands;

    internal MinoConnectState(MinoConnectState minoConnectState)
    {
      this.AutoPowerOffTime = minoConnectState.AutoPowerOffTime;
      this.Baudrate = minoConnectState.Baudrate;
      this.ByteFrame = minoConnectState.ByteFrame;
      this.DetectedDevice = minoConnectState.DetectedDevice;
      this.FramingError = minoConnectState.FramingError;
      this.IrCombiHeadFunction = minoConnectState.IrCombiHeadFunction;
      this.IrDaPulseLength = minoConnectState.IrDaPulseLength;
      this.KeyReceived = minoConnectState.KeyReceived;
      this.LastStateLine = minoConnectState.LastStateLine;
      this.MinoConnectBaseState = minoConnectState.MinoConnectBaseState;
      this.MyMiConPort = minoConnectState.MyMiConPort;
      this.StateChanged = minoConnectState.StateChanged;
      this.StateTime = minoConnectState.StateTime;
    }

    internal MinoConnectState(MinoConnectSerialPort MyMiConPort)
    {
      this.MyMiConPort = MyMiConPort;
      if (MinoConnectState.StateCommands == null)
      {
        MinoConnectState.StateCommands = new string[Util.GetNamesOfEnum(typeof (MinoConnectState.BaseStateEnum)).Length];
        MinoConnectState.StateCommands[0] = "#com rsoff";
        MinoConnectState.StateCommands[1] = "#com rs232 BAUD FRAME\r\n#7von\r\n";
        MinoConnectState.StateCommands[2] = "#com rs232 BAUD FRAME\r\n#7voff\r\n";
        MinoConnectState.StateCommands[3] = "#com rs232 BAUD FRAME\r\n#3von\r\n";
        MinoConnectState.StateCommands[4] = "#com rs232 BAUD FRAME\r\n#7von\r\n";
        MinoConnectState.StateCommands[5] = "#com rs485 BAUD FRAME\r\n#7voff\r\n";
        MinoConnectState.StateCommands[6] = "#com rs485 BAUD FRAME\r\n#3von\r\n";
        MinoConnectState.StateCommands[7] = "#com rs485 BAUD FRAME\r\n#7von\r\n";
        MinoConnectState.StateCommands[8] = "#com radio radio2";
        MinoConnectState.StateCommands[9] = "#com radio radio3";
        MinoConnectState.StateCommands[11] = "#com rsoff";
      }
      this.ClearState();
    }

    internal void ClearState()
    {
      this.MinoConnectBaseState = MinoConnectState.BaseStateEnum.undefined;
      this.Baudrate = 0;
      this.ByteFrame = string.Empty;
      this.IrCombiHeadFunction = MinoConnectState.IrCombiHeadFunctionEnum.undefined;
      this.IrDaPulseLength = -1;
      this.KeyReceived = false;
      this.FramingError = false;
      this.Overload = false;
      this.BatteryLow = false;
      this.StateChanged = true;
      this.StateTime = DateTime.MinValue;
      this.AutoPowerOffTime = -1;
    }

    internal void SetFromAsyncCom(AsyncFunctions TheFunctions)
    {
      this.LastStateLine = (byte[]) null;
      this.LastReseicedState = MinoConnectState.ReceivedState.None;
      this.MinoConnectBaseState = TheFunctions.MinoConnectBaseState;
      this.AutoPowerOffTime = TheFunctions.MinoConnectAutoPowerOffTime;
      this.IrDaPulseLength = TheFunctions.MinoConnectIrDaPulseLength;
      this.Baudrate = TheFunctions.Baudrate;
      this.IrCombiHeadFunction = !TheFunctions.IrDa ? MinoConnectState.IrCombiHeadFunctionEnum.RoundUART : (!TheFunctions.IrDaDaveTailSide ? MinoConnectState.IrCombiHeadFunctionEnum.RoundIrDa : MinoConnectState.IrCombiHeadFunctionEnum.DoveTailIrDa);
      if (TheFunctions.Parity == "no")
      {
        if (TheFunctions.IrDa)
          this.ByteFrame = "i8n1";
        else
          this.ByteFrame = "8n1";
      }
      else if (TheFunctions.Parity == "even")
      {
        if (TheFunctions.IrDa)
          this.ByteFrame = "i8e1";
        else
          this.ByteFrame = "8e1";
      }
      else
      {
        if (!(TheFunctions.Parity == "odd"))
          return;
        this.ByteFrame = !TheFunctions.IrDa ? "8o1" : "i8o1";
      }
    }

    internal bool SetFromReceivedState(byte[] StateLine)
    {
      this.StateChanged = true;
      if (this.LastStateLine != null)
      {
        if (this.LastStateLine.Length == StateLine.Length)
        {
          for (int index = 0; index != StateLine.Length; ++index)
          {
            if ((int) this.LastStateLine[index] != (int) StateLine[index])
            {
              this.LastStateLine = StateLine;
              goto label_9;
            }
          }
          this.StateChanged = false;
          return true;
        }
      }
      else
      {
        this.StateChanged = true;
        this.LastStateLine = StateLine;
      }
label_9:
      switch (StateLine.Length)
      {
        case 7:
          this.DetectedDevice = (MinoConnectState.MinoConnectPlugState) this.HexFromChar(StateLine[2]);
          this.MinoConnectBaseState = MinoConnectState.GetBaseStateFromPlugState((MinoConnectState.MinoConnectPlugState) this.HexFromChar(StateLine[3]));
          int num1 = this.HexFromChar(StateLine[4]);
          this.KeyReceived = (num1 & 1) > 0;
          this.FramingError = (num1 & 2) > 0;
          this.Overload = (num1 & 4) > 0;
          this.BatteryLow = (num1 & 8) > 0;
          this.LastReseicedState = MinoConnectState.ReceivedState.OldRSxxxState;
          break;
        case 9:
          this.ActiveRadioMode = (MinoConnectState.RadioModes) this.HexFromChar(StateLine[2]);
          this.MinoConnectBaseState = this.ActiveRadioMode != MinoConnectState.RadioModes.RADIO2 ? (this.ActiveRadioMode != MinoConnectState.RadioModes.RADIO3 ? MinoConnectState.BaseStateEnum.WirelessMBus : MinoConnectState.BaseStateEnum.Radio3Receive) : MinoConnectState.BaseStateEnum.Radio2Receive;
          this.ActiveRadioCommand = (MinoConnectState.RadioCommands) this.HexFromChar(StateLine[3]);
          int packetErrorCounter = this.RadioPacketErrorCounter;
          this.RadioPacketErrorCounter &= -256;
          this.RadioPacketErrorCounter |= (this.HexFromChar(StateLine[4]) << 4) + this.HexFromChar(StateLine[5]);
          if (this.RadioPacketErrorCounter < packetErrorCounter)
            this.RadioPacketErrorCounter += 256;
          int num2 = this.HexFromChar(StateLine[6]);
          this.KeyReceived = (num2 & 1) > 0;
          this.RadioError = (num2 & 2) > 0;
          this.Overload = (num2 & 4) > 0;
          this.BatteryLow = (num2 & 8) > 0;
          this.LastReseicedState = MinoConnectState.ReceivedState.RadioState;
          break;
        default:
          return false;
      }
      return true;
    }

    internal bool IsEqual(MinoConnectState CompareState)
    {
      return this.MinoConnectBaseState == CompareState.MinoConnectBaseState && this.Baudrate == CompareState.Baudrate && !(this.ByteFrame != CompareState.ByteFrame) && this.IrCombiHeadFunction == CompareState.IrCombiHeadFunction && this.IrDaPulseLength == CompareState.IrDaPulseLength && this.KeyReceived == CompareState.KeyReceived && this.FramingError == CompareState.FramingError && this.Overload == CompareState.Overload && this.BatteryLow == CompareState.BatteryLow;
    }

    internal string GetChangeCommand(MinoConnectState RequiredState)
    {
      StringBuilder stringBuilder = new StringBuilder(500);
      bool flag = this.MyMiConPort.VersionValue >= 1.3M && this.IrDaPulseLength != RequiredState.IrDaPulseLength;
      if (((this.MinoConnectBaseState != RequiredState.MinoConnectBaseState || this.Baudrate != RequiredState.Baudrate ? 1 : (this.ByteFrame != RequiredState.ByteFrame ? 1 : 0)) | (flag ? 1 : 0)) != 0)
      {
        if (flag)
          stringBuilder.Append("#irp " + RequiredState.IrDaPulseLength.ToString() + "\r\n");
        string str = MinoConnectState.StateCommands[(int) RequiredState.MinoConnectBaseState].Replace("BAUD", RequiredState.Baudrate.ToString()).Replace("FRAME", RequiredState.ByteFrame);
        stringBuilder.Append(str);
      }
      if (this.AutoPowerOffTime != RequiredState.AutoPowerOffTime)
        stringBuilder.Append("#apo " + RequiredState.AutoPowerOffTime.ToString() + "\r\n");
      if (this.IrCombiHeadFunction != RequiredState.IrCombiHeadFunction)
      {
        switch (RequiredState.IrCombiHeadFunction)
        {
          case MinoConnectState.IrCombiHeadFunctionEnum.DoveTailIrDa:
            stringBuilder.Append("#out 0\r\n");
            break;
          case MinoConnectState.IrCombiHeadFunctionEnum.RoundIrDa:
            stringBuilder.Append("#out 2\r\n");
            break;
          case MinoConnectState.IrCombiHeadFunctionEnum.RoundUART:
            stringBuilder.Append("#out 1\r\n");
            break;
          default:
            stringBuilder.Append("#out 1\r\n");
            break;
        }
      }
      return stringBuilder.Length == 0 ? (string) null : stringBuilder.ToString();
    }

    public bool IsRequiredIrDaFilter
    {
      get
      {
        return this.Baudrate == 9600 && this.IrCombiHeadFunction == MinoConnectState.IrCombiHeadFunctionEnum.RoundIrDa;
      }
    }

    internal string GetStateString(MinoConnectState RequiredState)
    {
      if (RequiredState == null)
        RequiredState = this;
      StringBuilder stringBuilder = new StringBuilder(300);
      stringBuilder.Append("State: " + this.MinoConnectBaseState.ToString());
      if (this.MinoConnectBaseState != RequiredState.MinoConnectBaseState)
      {
        if (this.MinoConnectBaseState == MinoConnectState.BaseStateEnum.RS232_7V && RequiredState.MinoConnectBaseState == MinoConnectState.BaseStateEnum.IrCombiHead)
        {
          stringBuilder.Length = 0;
          stringBuilder.Append("State: " + RequiredState.MinoConnectBaseState.ToString());
        }
        else
          stringBuilder.Append(" <- " + RequiredState.MinoConnectBaseState.ToString());
      }
      stringBuilder.Append(ZR_Constants.SystemNewLine);
      if (this.LastReseicedState == MinoConnectState.ReceivedState.OldRSxxxState)
      {
        if (this.MinoConnectBaseState >= MinoConnectState.BaseStateEnum.IrCombiHead && this.MinoConnectBaseState <= MinoConnectState.BaseStateEnum.RS485_7V)
        {
          stringBuilder.Append("Baudrate:" + this.Baudrate.ToString());
          if (this.Baudrate != RequiredState.Baudrate)
            stringBuilder.Append(" <- " + RequiredState.Baudrate.ToString());
          stringBuilder.Append(ZR_Constants.SystemNewLine);
          stringBuilder.Append("Frame: " + this.ByteFrame);
          if (this.ByteFrame != RequiredState.ByteFrame)
            stringBuilder.Append(" <- " + RequiredState.ByteFrame);
          stringBuilder.Append(ZR_Constants.SystemNewLine);
          stringBuilder.Append("IrCombiHead: " + this.IrCombiHeadFunction.ToString());
          if (this.IrCombiHeadFunction != RequiredState.IrCombiHeadFunction)
            stringBuilder.Append(" <- " + RequiredState.IrCombiHeadFunction.ToString());
          stringBuilder.Append(ZR_Constants.SystemNewLine);
          if (this.ByteFrame[0] == 'i')
          {
            stringBuilder.Append("IrDaPulsLen: " + this.IrDaPulseLength.ToString());
            if (this.IrDaPulseLength != RequiredState.IrDaPulseLength)
              stringBuilder.Append(" <- " + RequiredState.IrDaPulseLength.ToString());
            stringBuilder.Append(ZR_Constants.SystemNewLine);
          }
        }
        if (this.FramingError)
          stringBuilder.Append("!!! Framing error !!!" + ZR_Constants.SystemNewLine);
        if (this.Overload)
          stringBuilder.Append("!!! Overload !!!" + ZR_Constants.SystemNewLine);
        if (this.BatteryLow)
          stringBuilder.Append("!!! Battery low !!!" + ZR_Constants.SystemNewLine);
      }
      else if (this.LastReseicedState == MinoConnectState.ReceivedState.RadioState)
      {
        if (this.RadioError)
          stringBuilder.Append("!!! Radio error !!!" + ZR_Constants.SystemNewLine);
        stringBuilder.Append("Packet error counts: " + this.RadioPacketErrorCounter.ToString() + ZR_Constants.SystemNewLine);
      }
      return stringBuilder.ToString();
    }

    private int HexFromChar(byte Char)
    {
      if (Char <= (byte) 57)
        return (int) Char - 48;
      return Char > (byte) 70 ? (int) Char - 97 + 10 : (int) Char - 65 + 10;
    }

    internal static MinoConnectState.BaseStateEnum GetBaseStateFromPlugState(
      MinoConnectState.MinoConnectPlugState PlugState)
    {
      switch (PlugState)
      {
        case MinoConnectState.MinoConnectPlugState.RS232:
          return MinoConnectState.BaseStateEnum.RS232;
        case MinoConnectState.MinoConnectPlugState.RS485:
          return MinoConnectState.BaseStateEnum.RS485;
        case MinoConnectState.MinoConnectPlugState.RS485_7V:
          return MinoConnectState.BaseStateEnum.RS485_7V;
        case MinoConnectState.MinoConnectPlugState.RS232_7V:
          return MinoConnectState.BaseStateEnum.RS232_7V;
        case MinoConnectState.MinoConnectPlugState.RS232_3V:
          return MinoConnectState.BaseStateEnum.RS232_3V;
        case MinoConnectState.MinoConnectPlugState.RS485_3V:
          return MinoConnectState.BaseStateEnum.RS485_3V;
        default:
          return MinoConnectState.BaseStateEnum.IrCombiHead;
      }
    }

    public enum MinoConnectPlugState
    {
      Auto,
      _SHORT_CIRCUIT,
      RS232,
      RS485,
      RS485_7V,
      RS232_7V,
      RS232_3V,
      IrCombiHead,
      RS485_3V,
      _UNDEF_1,
      AUTO_7V,
      _DISCONNECTED,
      _Overload,
      _NoInfo,
      undefined,
    }

    public enum BaseStateEnum
    {
      off,
      IrCombiHead,
      RS232,
      RS232_3V,
      RS232_7V,
      RS485,
      RS485_3V,
      RS485_7V,
      Radio2Receive,
      Radio3Receive,
      WirelessMBus,
      undefined,
    }

    private enum IrCombiHeadFunctionEnum
    {
      DoveTailIrDa,
      RoundIrDa,
      RoundUART,
      undefined,
    }

    private enum RadioModes
    {
      RADIO2,
      RADIO3,
      WMBUS_S1,
      WMBUS_S1M,
      WMBUS_S2,
      WMBUS_T1,
      WMBUS_T2_METER,
      WMBUS_T2_OTHER,
    }

    private enum RadioCommands
    {
      LOOP,
      RECEIVE,
      CAL_OOK,
      CAL_PN9,
      NULL,
    }

    private enum ReceivedState
    {
      None,
      OldRSxxxState,
      RadioState,
    }
  }
}


--- PlugInAnchor.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.PlugInAnchor
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using PlugInLib;
using StartupLib;
using ZENNER.CommonLibrary;

#nullable disable
namespace AsyncCom
{
  [ComponentPath("Reading")]
  public class PlugInAnchor : GmmPlugIn, IReadoutConfig
  {
    private AsyncFunctions MyFunctions;
    internal static string[] UsedRights = new string[4]
    {
      "DeviceCollector",
      "Designer",
      "Configurator",
      "Developer"
    };

    public PlugInAnchor()
    {
      if (!PlugInLoader.IsPluginLoaderInitialised())
        return;
      this.MyFunctions = new AsyncFunctions();
      this.MyFunctions.IsPluginObject = true;
    }

    public override void Dispose() => this.MyFunctions.GMM_Dispose();

    public override string ShowMainWindow() => this.MyFunctions.ShowComWindow("");

    public override PlugInInfo GetPluginInfo()
    {
      return new PlugInInfo("AsyncCom", "Communication", "Byteübertragung", "Grundeinstellung der Schnittstelle und der Übertragungskanäle", new string[0], PlugInAnchor.UsedRights, (object) this.MyFunctions);
    }

    public void SetReadoutConfiguration(ConfigList configList)
    {
      this.MyFunctions.SetReadoutConfiguration(configList);
    }

    public ConfigList GetReadoutConfiguration() => this.MyFunctions.GetReadoutConfiguration();
  }
}


--- Port.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.Port
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using System;
using System.IO.Ports;

#nullable disable
namespace AsyncCom
{
  internal abstract class Port
  {
    internal bool FramingError;
    internal bool IgnoreFramingError;
    private MBusFrameTestWindow FrameTestWindow;

    internal abstract SerialPort GetPort();

    public virtual event EventHandler ConnectionLost;

    public virtual event EventHandler BatterieLow;

    internal abstract bool Open();

    internal abstract void Close();

    internal virtual int ReadFromTestWindow(byte[] buffer, int offset, int count)
    {
      if (this.FrameTestWindow == null)
        this.FrameTestWindow = new MBusFrameTestWindow();
      return this.FrameTestWindow.Read(buffer, offset, count);
    }

    internal virtual void SetRTS(bool state) => throw new NotImplementedException();

    internal virtual void SetDTR(bool state) => throw new NotImplementedException();

    protected virtual void ErrorReceived(object o, SerialErrorReceivedEventArgs ErrorType)
    {
      throw new NotImplementedException();
    }

    internal abstract void Write(string text);

    internal abstract void Write(byte[] buffer, int offset, int count);

    internal abstract int ReadByte();

    internal abstract int ReadChar();

    internal abstract int Read(byte[] buffer, int offset, int count);

    internal virtual string ReadExisting() => throw new NotImplementedException();

    internal virtual bool ReadExistingBytes(out byte[] buffer)
    {
      throw new NotImplementedException();
    }

    internal virtual void DiscardInBuffer() => throw new NotImplementedException();

    internal virtual void DiscardOutBuffer() => throw new NotImplementedException();

    internal virtual bool IsOpen => throw new NotImplementedException();

    internal virtual int BytesToRead => throw new NotImplementedException();

    internal virtual int BytesToWrite => throw new NotImplementedException();

    internal virtual int ReadTimeout
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    internal virtual int WriteTimeout
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    internal virtual int WriteBufferSize
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    internal virtual int ReadBufferSize
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    internal virtual bool BreakState
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    internal virtual Handshake Handshake
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    internal virtual bool DtrEnable
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    internal virtual bool RtsEnable
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    internal virtual bool DiscardNull
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    internal virtual byte ParityReplace
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    internal virtual int ReceivedBytesThreshold
    {
      get => throw new NotImplementedException();
      set => throw new NotImplementedException();
    }

    internal virtual bool ChangeDriverSettings() => false;
  }
}


--- RemoteCom.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.RemoteCom
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

#nullable disable
namespace AsyncCom
{
  internal class RemoteCom
  {
    public int Port;
    public long BytesTCP_IN;
    public int Timeout;
    public string PortConfig;
    public string LinuxDevice;
    public string ConnectedTo;
  }
}


--- StandardSerialPort.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.StandardSerialPort
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using GmmDbLib;
using NLog;
using System;
using System.IO;
using System.IO.Ports;
using ZENNER.CommonLibrary.Exceptions;
using ZR_ClassLibrary;

#nullable disable
namespace AsyncCom
{
  internal class StandardSerialPort : Port
  {
    protected SerialPort MySerialPort;
    internal AsyncFunctions MyFunctions;
    private static Logger logger = LogManager.GetLogger(nameof (StandardSerialPort));

    internal StandardSerialPort(int baudRate, Parity parity, AsyncFunctions MyFunctionsIn)
    {
      this.MyFunctions = MyFunctionsIn;
      this.InitializeSerialPort(baudRate, parity);
    }

    private void InitializeSerialPort(int baudRate, Parity parity)
    {
      this.MySerialPort = new SerialPort(this.MyFunctions.ComPort, baudRate, parity, 8, StopBits.One);
      this.MySerialPort.DtrEnable = true;
      this.MySerialPort.DiscardNull = false;
      this.MySerialPort.ParityReplace = (byte) 0;
      this.MySerialPort.WriteTimeout = 5000;
      this.MySerialPort.ReadTimeout = 5000;
    }

    internal override bool Open()
    {
      if (this.IsOpen)
      {
        StandardSerialPort.logger.Trace("Com is already open.");
        return true;
      }
      StandardSerialPort.logger.Trace("Open() called.");
      try
      {
        if (this.MyFunctions.HardwareHandshake)
          this.MySerialPort.Handshake = Handshake.RequestToSend;
        else
          this.MySerialPort.RtsEnable = true;
        this.MySerialPort.PortName = this.MyFunctions.ComPort;
        this.MySerialPort.Open();
      }
      catch (Exception ex)
      {
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.ComOpenError, Ot.Gtm(Tg.CommunicationLogic, "ComOpenError", "Failed to open") + " " + this.MySerialPort.PortName);
        StandardSerialPort.logger.Error(ex.Message);
        return false;
      }
      this.FramingError = false;
      this.MySerialPort.ErrorReceived += new SerialErrorReceivedEventHandler(((Port) this).ErrorReceived);
      return true;
    }

    internal override void Close()
    {
      try
      {
        StandardSerialPort.logger.Trace("Close()");
        this.MySerialPort.ErrorReceived -= new SerialErrorReceivedEventHandler(((Port) this).ErrorReceived);
        this.MySerialPort.Close();
      }
      catch (Exception ex)
      {
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, Ot.Gtm(Tg.CommunicationLogic, "ComCloseError", "Failed to close") + " " + this.MySerialPort.PortName);
        StandardSerialPort.logger.Error(ex.Message);
      }
      finally
      {
        this.MyFunctions.ComIsOpen = false;
      }
    }

    internal override void SetRTS(bool state)
    {
      StandardSerialPort.logger.Trace("SetRTS = {0}", state);
      this.MySerialPort.RtsEnable = state;
    }

    internal override void SetDTR(bool state)
    {
      StandardSerialPort.logger.Trace("SetDTR = {0}", state);
      this.MySerialPort.DtrEnable = state;
    }

    protected override void ErrorReceived(object o, SerialErrorReceivedEventArgs ErrorType)
    {
      StandardSerialPort.logger.Error<SerialError>(ErrorType.EventType);
      this.FramingError = true;
    }

    internal override void Write(string text)
    {
      if (!this.IsOpen)
        StandardSerialPort.logger.Error("Error: The serial port is closed!");
      else
        this.MySerialPort.Write(text);
    }

    internal override void Write(byte[] buffer, int offset, int count)
    {
      if (!this.IsOpen)
      {
        StandardSerialPort.logger.Error("Error: The serial port is closed!");
      }
      else
      {
        try
        {
          this.MySerialPort.Write(buffer, offset, count);
        }
        catch (TimeoutException ex)
        {
          StandardSerialPort.logger.Error("Timeout while write the buffer!");
          throw ex;
        }
        catch (IOException ex)
        {
          string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
          StandardSerialPort.logger.Error((Exception) ex, message);
          throw ex;
        }
        catch (Exception ex)
        {
          string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
          StandardSerialPort.logger.Error(ex, message);
        }
      }
    }

    internal override int ReadByte()
    {
      if (!this.IsOpen)
        throw new Exception("Failed to read! Com port is closed.");
      int num = 0;
      Exception exception = (Exception) null;
      try
      {
        num = this.MySerialPort.ReadByte();
      }
      catch (Exception ex)
      {
        string message = string.Format("Error: {0}, Trace: {1}", (object) ex.Message, (object) ex.StackTrace);
        StandardSerialPort.logger.Error(ex, message);
        exception = ex;
      }
      if (this.FramingError && !this.IgnoreFramingError)
      {
        this.FramingError = false;
        StandardSerialPort.logger.Error("Framing error");
        throw new FramingErrorException(Ot.Gtm(Tg.CommunicationLogic, "MiConFramingError", "MinoConnect framing error"));
      }
      if (exception != null)
        throw exception;
      return num;
    }

    internal override int ReadChar() => this.ReadByte();

    internal override int Read(byte[] buffer, int offset, int count)
    {
      if (!this.IsOpen)
        throw new Exception("Failed to read! Com port is closed.");
      int num = 0;
      Exception exception = (Exception) null;
      try
      {
        num = this.MySerialPort.Read(buffer, offset, count);
      }
      catch (TimeoutException ex)
      {
        string message = string.Format("Timeout while read the buffer! ReadTimeout: {0}, Expected bytes: {1}, Error: {2}", (object) this.MySerialPort.ReadTimeout, (object) count, (object) ex.Message);
        StandardSerialPort.logger.Warn((Exception) ex, message);
        throw ex;
      }
      catch (Exception ex)
      {
        StandardSerialPort.logger.Warn(ex, ex.Message);
        exception = ex;
      }
      if (this.FramingError && !this.IgnoreFramingError)
      {
        this.FramingError = false;
        StandardSerialPort.logger.Error("Framing error");
        throw new FramingErrorException(Ot.Gtm(Tg.CommunicationLogic, "MiConFramingError", "MinoConnect framing error"));
      }
      if (exception != null)
        throw exception;
      return num;
    }

    internal override string ReadExisting()
    {
      if (!this.IsOpen)
        return string.Empty;
      string str = string.Empty;
      Exception exception = (Exception) null;
      try
      {
        str = this.MySerialPort.ReadExisting();
      }
      catch (Exception ex)
      {
        StandardSerialPort.logger.Error(ex, ex.Message);
        exception = ex;
      }
      if (this.FramingError && !this.IgnoreFramingError)
      {
        this.FramingError = false;
        StandardSerialPort.logger.Error("Framing error");
        throw new FramingErrorException(Ot.Gtm(Tg.CommunicationLogic, "MiConFramingError", "MinoConnect framing error"));
      }
      if (exception != null)
        throw exception;
      return str;
    }

    internal override void DiscardInBuffer()
    {
      if (this.IsOpen)
      {
        StandardSerialPort.logger.Trace("Clear input buffer");
        this.MySerialPort.DiscardInBuffer();
      }
      this.FramingError = false;
    }

    internal override void DiscardOutBuffer()
    {
      if (!this.IsOpen)
        return;
      StandardSerialPort.logger.Trace("Clear output buffer");
      this.MySerialPort.DiscardOutBuffer();
    }

    internal override SerialPort GetPort() => this.MySerialPort;

    internal override bool IsOpen
    {
      get
      {
        bool isOpen;
        try
        {
          isOpen = this.MySerialPort != null && this.MySerialPort.IsOpen && this.MySerialPort.BaseStream != null && this.MySerialPort.BaseStream.CanRead && this.MySerialPort.BaseStream.CanWrite;
          if (!isOpen)
            return false;
        }
        catch (IOException ex)
        {
          this.HandleExceptionByNotAvailablePort(ex);
          return false;
        }
        return isOpen;
      }
    }

    internal override int BytesToRead
    {
      get
      {
        try
        {
          return this.MySerialPort.BytesToRead;
        }
        catch (IOException ex)
        {
          this.HandleExceptionByNotAvailablePort(ex);
          return 0;
        }
      }
    }

    internal override int BytesToWrite
    {
      get
      {
        try
        {
          return this.MySerialPort.BytesToWrite;
        }
        catch (IOException ex)
        {
          this.HandleExceptionByNotAvailablePort(ex);
          return 0;
        }
      }
    }

    internal override int ReadTimeout
    {
      set => this.MySerialPort.ReadTimeout = value;
      get => this.MySerialPort.ReadTimeout;
    }

    internal override int WriteTimeout
    {
      set => this.MySerialPort.WriteTimeout = value;
      get => this.MySerialPort.WriteTimeout;
    }

    internal override int WriteBufferSize
    {
      set => this.MySerialPort.WriteBufferSize = value;
      get => this.MySerialPort.WriteBufferSize;
    }

    internal override int ReadBufferSize
    {
      set => this.MySerialPort.ReadBufferSize = value;
      get => this.MySerialPort.ReadBufferSize;
    }

    internal override bool BreakState
    {
      set => this.MySerialPort.BreakState = value;
      get => this.MySerialPort.BreakState;
    }

    internal override Handshake Handshake
    {
      set => this.MySerialPort.Handshake = value;
      get => this.MySerialPort.Handshake;
    }

    internal override bool DtrEnable
    {
      set => this.MySerialPort.DtrEnable = value;
      get => this.MySerialPort.DtrEnable;
    }

    internal override bool RtsEnable
    {
      set => this.MySerialPort.RtsEnable = value;
      get => this.MySerialPort.RtsEnable;
    }

    internal override bool DiscardNull
    {
      set => this.MySerialPort.DiscardNull = value;
      get => this.MySerialPort.DiscardNull;
    }

    internal override byte ParityReplace
    {
      set => this.MySerialPort.ParityReplace = value;
      get => this.MySerialPort.ParityReplace;
    }

    internal override int ReceivedBytesThreshold
    {
      set => this.MySerialPort.ReceivedBytesThreshold = value;
      get => this.MySerialPort.ReceivedBytesThreshold;
    }

    private void HandleExceptionByNotAvailablePort(IOException exc)
    {
      StandardSerialPort.logger.Fatal("The actual serial port is not more available! Reason: {0}", exc.Message);
      this.MySerialPort.ErrorReceived -= new SerialErrorReceivedEventHandler(((Port) this).ErrorReceived);
      this.MyFunctions.ComIsOpen = false;
      int baudRate = this.MySerialPort.BaudRate;
      Parity parity = this.MySerialPort.Parity;
      StandardSerialPort.logger.Trace("Try MySerialPort.BaseStream.Close();");
      try
      {
        this.MySerialPort.BaseStream.Close();
      }
      catch (Exception ex)
      {
        StandardSerialPort.logger.Fatal("Failed MySerialPort.BaseStream.Close(); Reason: {0}", ex.Message);
      }
      StandardSerialPort.logger.Trace("Try MySerialPort.Close();");
      try
      {
        this.MySerialPort.Close();
      }
      catch (Exception ex)
      {
        StandardSerialPort.logger.Fatal("Failed MySerialPort.Close(); Reason: {0}", ex.Message);
      }
      StandardSerialPort.logger.Trace("Try MySerialPort.Dispose();");
      try
      {
        this.MySerialPort.Dispose();
      }
      catch (Exception ex)
      {
        StandardSerialPort.logger.Fatal("Failed MySerialPort.Dispose(); Reason: {0}", ex.Message);
      }
      this.MySerialPort = (SerialPort) null;
      StandardSerialPort.logger.Trace("Try GC.WaitForPendingFinalizers();");
      GC.WaitForPendingFinalizers();
      this.InitializeSerialPort(baudRate, parity);
    }
  }
}


--- TLP2Commands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.TLP2Commands
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

#nullable disable
namespace AsyncCom
{
  public enum TLP2Commands
  {
    lp2Alive = 0,
    lp2Ver = 1,
    lp2SetComParams = 2,
    lp2GSetComParams = 3,
    lp2SetWakeupParams = 4,
    lp2GetWakeupParams = 5,
    lp2WakeUp = 6,
    lp2ReqUD2 = 7,
    lp2SendData = 8,
    lp2ResetTemic = 9,
    lp2ReqUD2_Flash = 10, // 0x0000000A
    lp2SendData_Flash = 11, // 0x0000000B
    lp2ReqUD2_x = 12, // 0x0000000C
    lp2SendChipconParams1 = 101, // 0x00000065
    lp2SendChipconParams2 = 102, // 0x00000066
    lp2SetRF2Mode = 105, // 0x00000069
    lp2SetRF3Mode = 106, // 0x0000006A
    lp2Transparent = 150, // 0x00000096
    lp2LPM1 = 151, // 0x00000097
    lp2LPM2 = 152, // 0x00000098
    lp2LPM3 = 153, // 0x00000099
    lp2LPM4 = 154, // 0x0000009A
    lp2SetPWRTicker = 155, // 0x0000009B
    lp2GetPWRTicker = 156, // 0x0000009C
    lp2SetBooster = 157, // 0x0000009D
    lp2SleepOFF = 158, // 0x0000009E
    lp2PortBit = 159, // 0x0000009F
    lp2GetImpulse = 160, // 0x000000A0
    lp2ClearImpulse = 161, // 0x000000A1
    lp2EchoIrDa = 162, // 0x000000A2
    lp2RFModul = 163, // 0x000000A3
    lp2TransparentSD = 164, // 0x000000A4
    lpUnknownCommand = 255, // 0x000000FF
  }
}


--- TransceiverDeviceFunction.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.TransceiverDeviceFunction
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

#nullable disable
namespace AsyncCom
{
  public enum TransceiverDeviceFunction
  {
    TransparentModeOn,
    TransparentModeV3On,
    TransparentModeOff,
    EnableMinoConnectPolling,
    DisableMinoConnectPolling,
    StopRadio,
    StartRadio2,
    StartRadio3,
    StartRadio4,
    StartMinomatradioTest,
    Start_wMBusS1,
    Start_wMBusS1M,
    Start_wMBusS2,
    Start_wMBusT1,
    Start_wMBusT2_meter,
    Start_wMBusT2_other,
    Start_wMBusC1A,
    Start_wMBusC1B,
    Start_RadioMS,
    StartRadio3_868_95_RUSSIA,
    StartSendTestPacket,
    StopSendTestPacket,
    SendTestPacket,
  }
}


--- WakeupSystem.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.WakeupSystem
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

#nullable disable
namespace AsyncCom
{
  public enum WakeupSystem
  {
    None,
    Break,
    BaudrateCarrier,
    MinoHead,
  }
}


--- YModem.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.YModem
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using NLog;
using System;
using System.IO;
using System.Text;
using System.Windows.Forms;
using ZR_ClassLibrary;

#nullable disable
namespace AsyncCom
{
  public sealed class YModem
  {
    private static Logger logger = LogManager.GetLogger(nameof (YModem));
    private IAsyncFunctions bus;
    private byte SOH = 1;
    private byte STX = 2;
    private byte EOT = 4;
    private byte ACK = 6;
    private byte NAK = 21;
    private byte CAN = 24;
    private byte C = 67;
    private byte[] xbuff = new byte[1030];
    private int bufsz = -1;

    public event System.EventHandler PacketReceived;

    public YModem(IAsyncFunctions bus)
    {
      this.bus = bus;
      this.IsCanceled = false;
    }

    public int ActualPacketNumber { get; private set; }

    public byte[] ActualPacketData { get; private set; }

    public long ExpectedPackets { get; private set; }

    public bool IsCanceled { get; set; }

    public byte[] Receive(bool useCRC)
    {
      this.ActualPacketNumber = 0;
      long expectedSize;
      if (!this.ReceiveHeader(useCRC, out string _, out expectedSize) || expectedSize == 0L)
        return (byte[]) null;
      byte[] file = this.ReceiveFile(useCRC, expectedSize);
      if (file == null)
      {
        this.HandleException("Can not receive the file!");
        return (byte[]) null;
      }
      if ((long) file.Length != expectedSize)
      {
        string str = string.Format("The size of file is wrong! Expected: {0}, actual: {1}", (object) expectedSize, (object) file.Length);
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.IllegalData, str);
        YModem.logger.Error(str);
        return file;
      }
      YModem.logger.Debug("A file was successfully received.");
      return file;
    }

    private bool ReceiveHeader(bool useCRC, out string filename, out long expectedSize)
    {
      YModem.logger.Debug("Try receive file-header...");
      filename = string.Empty;
      expectedSize = 0L;
      int num1 = 0;
      bool flag = false;
      ByteField DataBlock = new ByteField(133);
      for (; num1 < 6 && !this.IsCanceled; ++num1)
      {
        if (useCRC)
          this.WriteByte(this.C);
        else
          this.WriteByte(this.NAK);
        if (!ZR_ClassLibrary.Util.Wait(100L, nameof (ReceiveHeader), (ICancelable) this.bus, YModem.logger))
          return false;
        if (this.bus.ReceiveBlock(ref DataBlock, 133, false))
        {
          this.WriteByte(this.ACK);
          flag = true;
          break;
        }
        YModem.logger.Debug("Failed to receive header of the file!");
        YModem.logger.Debug("Try again. Number of tests: " + num1.ToString());
      }
      if (!flag)
        return false;
      int num2 = 3;
      int positionOfFirstNil1 = this.GetPositionOfFirstNil(DataBlock.Data, num2);
      if (positionOfFirstNil1 == num2)
        return false;
      filename = Encoding.ASCII.GetString(DataBlock.Data, num2, positionOfFirstNil1 - num2);
      int num3 = positionOfFirstNil1 + 1;
      int positionOfFirstNil2 = this.GetPositionOfFirstNil(DataBlock.Data, num3);
      expectedSize = long.Parse(Encoding.ASCII.GetString(DataBlock.Data, num3, positionOfFirstNil2 - num3));
      YModem.logger.Debug(string.Format("The file-header was successfully received. Expected file: {0} {1} bytes", (object) filename, (object) expectedSize));
      Application.DoEvents();
      return true;
    }

    private byte[] ReceiveFile(bool useCRC, long expectedSize)
    {
      MemoryStream memoryStream = new MemoryStream();
      int num1 = 1;
      int num2 = 0;
      double num3 = 0.0;
      if (useCRC)
        this.WriteByte(this.C);
      else
        this.WriteByte(this.NAK);
      while (num2 < 16)
      {
        if (this.IsCanceled)
        {
          YModem.logger.Debug("Read process was canceled!");
          break;
        }
        int num4;
        try
        {
          num4 = (int) this.ReadByte();
        }
        catch
        {
          num4 = 0;
        }
        if (num4 == (int) this.SOH || num4 == (int) this.STX)
        {
          num2 = 0;
          this.bufsz = 128;
          if (num4 == (int) this.STX)
            this.bufsz = 1024;
          int num5 = this.bufsz + (useCRC ? 1 : 0) + 3;
          ByteField DataBlock = new ByteField(num5);
          if (this.bus.ReceiveBlock(ref DataBlock, num5, false))
            this.xbuff = DataBlock.Data;
          else
            YModem.logger.Debug("Receive block failed!");
          this.ExpectedPackets = expectedSize / (long) this.bufsz;
          ++this.ActualPacketNumber;
          this.ActualPacketData = this.xbuff;
          if (YModem.logger.IsDebugEnabled)
          {
            YModem.logger.Debug("Response: " + ZR_ClassLibrary.Util.ByteArrayToHexString(this.xbuff));
            YModem.logger.Debug("Packet number: " + this.ActualPacketNumber.ToString());
          }
          if ((int) this.xbuff[0] == (int) ~this.xbuff[1] && (int) this.xbuff[0] == num1 && this.Check(useCRC, this.xbuff, 4, this.bufsz - 2))
          {
            memoryStream.Write(this.xbuff, 2, this.bufsz);
            this.WriteByte(this.ACK);
            if (YModem.logger.IsDebugEnabled)
              YModem.logger.Debug("Checksum is OK");
            double num6 = (double) this.bufsz / 1024.0;
            num3 += num6;
            if (this.PacketReceived != null)
              this.PacketReceived((object) this, (EventArgs) null);
            ++num1;
            if (num1 >= 256)
              num1 = 0;
          }
          else
          {
            this.WriteByte(this.NAK);
            if (YModem.logger.IsDebugEnabled)
              YModem.logger.Debug("Checksum is not OK");
          }
        }
        else
        {
          if (num4 == (int) this.EOT)
          {
            if (YModem.logger.IsDebugEnabled)
              YModem.logger.Debug("End of transmit");
            this.bus.ClearCom();
            this.WriteByte(this.ACK);
            return memoryStream.ToArray();
          }
          if (num4 == (int) this.CAN)
          {
            if ((int) this.ReadByte() == (int) this.CAN)
            {
              if (YModem.logger.IsDebugEnabled)
                YModem.logger.Debug("Canceled by remote!");
              this.bus.ClearCom();
              this.WriteByte(this.ACK);
              return (byte[]) null;
            }
          }
          else
          {
            if (YModem.logger.IsDebugEnabled)
              YModem.logger.Debug("Received a wrong response! Byte: " + num4.ToString("x"));
            ++num2;
            this.bus.ClearCom();
            if (!ZR_ClassLibrary.Util.Wait(100L, nameof (ReceiveFile), (ICancelable) this.bus, YModem.logger))
              return (byte[]) null;
            this.WriteByte(this.NAK);
          }
        }
      }
      this.WriteByte(this.CAN);
      this.WriteByte(this.CAN);
      this.WriteByte(this.CAN);
      this.bus.ClearCom();
      return (byte[]) null;
    }

    private bool Check(bool isCRC, byte[] buf, int index, int sz)
    {
      if (isCRC)
      {
        if ((int) YModem.CRC16.CalculateCRC(buf, index - 2, sz + 2) == (int) (ushort) (((uint) buf[sz + index] << 8) + (uint) buf[sz + index + 1]))
          return true;
      }
      else
      {
        byte num = 0;
        for (int index1 = 0; index1 < sz; ++index1)
          num += buf[index1 + index];
        if ((int) num == (int) buf[sz + index])
          return true;
      }
      return false;
    }

    private void WriteByte(byte b)
    {
      ByteField DataBlock = new ByteField(new byte[1]{ b });
      this.bus.TransmitBlock(ref DataBlock);
    }

    private byte ReadByte()
    {
      ByteField DataBlock = new ByteField(1);
      if (this.bus.ReceiveBlock(ref DataBlock, 1, true))
        return DataBlock.Data[0];
      YModem.logger.Debug("Failed to receive a byte!");
      return 0;
    }

    private byte[] Memset(byte[] xbuff, int index, byte c, int num)
    {
      for (int index1 = 0; index1 < num; ++index1)
        xbuff[index1 + index] = c;
      return xbuff;
    }

    private byte[] Memcpy(byte[] dest, int d_i, byte[] src, int d_s, int num)
    {
      for (int index = 0; index < num; ++index)
        dest[index + d_i] = src[index + d_s];
      return dest;
    }

    private int GetPositionOfFirstNil(byte[] buffer, int offset)
    {
      for (int positionOfFirstNil = offset; positionOfFirstNil < buffer.Length; ++positionOfFirstNil)
      {
        if (buffer[positionOfFirstNil] == (byte) 0)
          return positionOfFirstNil;
      }
      return -1;
    }

    private void HandleException(string error)
    {
      YModem.logger.Debug(error);
      ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.CommunicationError, error);
    }

    internal sealed class CRC16
    {
      private static ushort[] crc16tab = new ushort[256]
      {
        (ushort) 0,
        (ushort) 4129,
        (ushort) 8258,
        (ushort) 12387,
        (ushort) 16516,
        (ushort) 20645,
        (ushort) 24774,
        (ushort) 28903,
        (ushort) 33032,
        (ushort) 37161,
        (ushort) 41290,
        (ushort) 45419,
        (ushort) 49548,
        (ushort) 53677,
        (ushort) 57806,
        (ushort) 61935,
        (ushort) 4657,
        (ushort) 528,
        (ushort) 12915,
        (ushort) 8786,
        (ushort) 21173,
        (ushort) 17044,
        (ushort) 29431,
        (ushort) 25302,
        (ushort) 37689,
        (ushort) 33560,
        (ushort) 45947,
        (ushort) 41818,
        (ushort) 54205,
        (ushort) 50076,
        (ushort) 62463,
        (ushort) 58334,
        (ushort) 9314,
        (ushort) 13379,
        (ushort) 1056,
        (ushort) 5121,
        (ushort) 25830,
        (ushort) 29895,
        (ushort) 17572,
        (ushort) 21637,
        (ushort) 42346,
        (ushort) 46411,
        (ushort) 34088,
        (ushort) 38153,
        (ushort) 58862,
        (ushort) 62927,
        (ushort) 50604,
        (ushort) 54669,
        (ushort) 13907,
        (ushort) 9842,
        (ushort) 5649,
        (ushort) 1584,
        (ushort) 30423,
        (ushort) 26358,
        (ushort) 22165,
        (ushort) 18100,
        (ushort) 46939,
        (ushort) 42874,
        (ushort) 38681,
        (ushort) 34616,
        (ushort) 63455,
        (ushort) 59390,
        (ushort) 55197,
        (ushort) 51132,
        (ushort) 18628,
        (ushort) 22757,
        (ushort) 26758,
        (ushort) 30887,
        (ushort) 2112,
        (ushort) 6241,
        (ushort) 10242,
        (ushort) 14371,
        (ushort) 51660,
        (ushort) 55789,
        (ushort) 59790,
        (ushort) 63919,
        (ushort) 35144,
        (ushort) 39273,
        (ushort) 43274,
        (ushort) 47403,
        (ushort) 23285,
        (ushort) 19156,
        (ushort) 31415,
        (ushort) 27286,
        (ushort) 6769,
        (ushort) 2640,
        (ushort) 14899,
        (ushort) 10770,
        (ushort) 56317,
        (ushort) 52188,
        (ushort) 64447,
        (ushort) 60318,
        (ushort) 39801,
        (ushort) 35672,
        (ushort) 47931,
        (ushort) 43802,
        (ushort) 27814,
        (ushort) 31879,
        (ushort) 19684,
        (ushort) 23749,
        (ushort) 11298,
        (ushort) 15363,
        (ushort) 3168,
        (ushort) 7233,
        (ushort) 60846,
        (ushort) 64911,
        (ushort) 52716,
        (ushort) 56781,
        (ushort) 44330,
        (ushort) 48395,
        (ushort) 36200,
        (ushort) 40265,
        (ushort) 32407,
        (ushort) 28342,
        (ushort) 24277,
        (ushort) 20212,
        (ushort) 15891,
        (ushort) 11826,
        (ushort) 7761,
        (ushort) 3696,
        (ushort) 65439,
        (ushort) 61374,
        (ushort) 57309,
        (ushort) 53244,
        (ushort) 48923,
        (ushort) 44858,
        (ushort) 40793,
        (ushort) 36728,
        (ushort) 37256,
        (ushort) 33193,
        (ushort) 45514,
        (ushort) 41451,
        (ushort) 53516,
        (ushort) 49453,
        (ushort) 61774,
        (ushort) 57711,
        (ushort) 4224,
        (ushort) 161,
        (ushort) 12482,
        (ushort) 8419,
        (ushort) 20484,
        (ushort) 16421,
        (ushort) 28742,
        (ushort) 24679,
        (ushort) 33721,
        (ushort) 37784,
        (ushort) 41979,
        (ushort) 46042,
        (ushort) 49981,
        (ushort) 54044,
        (ushort) 58239,
        (ushort) 62302,
        (ushort) 689,
        (ushort) 4752,
        (ushort) 8947,
        (ushort) 13010,
        (ushort) 16949,
        (ushort) 21012,
        (ushort) 25207,
        (ushort) 29270,
        (ushort) 46570,
        (ushort) 42443,
        (ushort) 38312,
        (ushort) 34185,
        (ushort) 62830,
        (ushort) 58703,
        (ushort) 54572,
        (ushort) 50445,
        (ushort) 13538,
        (ushort) 9411,
        (ushort) 5280,
        (ushort) 1153,
        (ushort) 29798,
        (ushort) 25671,
        (ushort) 21540,
        (ushort) 17413,
        (ushort) 42971,
        (ushort) 47098,
        (ushort) 34713,
        (ushort) 38840,
        (ushort) 59231,
        (ushort) 63358,
        (ushort) 50973,
        (ushort) 55100,
        (ushort) 9939,
        (ushort) 14066,
        (ushort) 1681,
        (ushort) 5808,
        (ushort) 26199,
        (ushort) 30326,
        (ushort) 17941,
        (ushort) 22068,
        (ushort) 55628,
        (ushort) 51565,
        (ushort) 63758,
        (ushort) 59695,
        (ushort) 39368,
        (ushort) 35305,
        (ushort) 47498,
        (ushort) 43435,
        (ushort) 22596,
        (ushort) 18533,
        (ushort) 30726,
        (ushort) 26663,
        (ushort) 6336,
        (ushort) 2273,
        (ushort) 14466,
        (ushort) 10403,
        (ushort) 52093,
        (ushort) 56156,
        (ushort) 60223,
        (ushort) 64286,
        (ushort) 35833,
        (ushort) 39896,
        (ushort) 43963,
        (ushort) 48026,
        (ushort) 19061,
        (ushort) 23124,
        (ushort) 27191,
        (ushort) 31254,
        (ushort) 2801,
        (ushort) 6864,
        (ushort) 10931,
        (ushort) 14994,
        (ushort) 64814,
        (ushort) 60687,
        (ushort) 56684,
        (ushort) 52557,
        (ushort) 48554,
        (ushort) 44427,
        (ushort) 40424,
        (ushort) 36297,
        (ushort) 31782,
        (ushort) 27655,
        (ushort) 23652,
        (ushort) 19525,
        (ushort) 15522,
        (ushort) 11395,
        (ushort) 7392,
        (ushort) 3265,
        (ushort) 61215,
        (ushort) 65342,
        (ushort) 53085,
        (ushort) 57212,
        (ushort) 44955,
        (ushort) 49082,
        (ushort) 36825,
        (ushort) 40952,
        (ushort) 28183,
        (ushort) 32310,
        (ushort) 20053,
        (ushort) 24180,
        (ushort) 11923,
        (ushort) 16050,
        (ushort) 3793,
        (ushort) 7920
      };

      public static ushort CalculateCRC(byte[] buffer, int index, int len)
      {
        ushort crc = 0;
        for (int index1 = 0; index1 < len; ++index1)
          crc = (ushort) ((uint) crc << 8 ^ (uint) YModem.CRC16.crc16tab[((int) crc >> 8 ^ (int) buffer[index + index1]) & (int) byte.MaxValue]);
        return crc;
      }
    }
  }
}


--- ZR_AsyncCom.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AsyncCom.ZR_AsyncCom
// Assembly: AsyncCom, Version=1.3.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: D6F4F79A-8F4B-4BF8-A607-52E7B777C135
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AsyncCom.dll

using CorporateDesign;
using MinoConnect;
using NLog;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Globalization;
using System.IO.Ports;
using System.Reflection;
using System.Text;
using System.Threading;
using System.Windows.Forms;
using ZENNER.CommonLibrary;
using ZENNER.CommonLibrary.Entities;
using ZR_ClassLibrary;

#nullable disable
namespace AsyncCom
{
  public class ZR_AsyncCom : Form
  {
    private int ComStringLength = 10;
    private static int[] BaudrateTable = new int[10]
    {
      300,
      600,
      1200,
      2400,
      4800,
      9600,
      19200,
      38400,
      57600,
      115200
    };
    private static string[] ParityTable = new string[3]
    {
      "no",
      "even",
      "odd"
    };
    private static Logger logger = LogManager.GetLogger(nameof (ZR_AsyncCom));
    private AsyncFunctions ComX;
    private bool LoggerIsOn;
    private bool EventsEnabled = true;
    private Size StartWindowSize;
    internal string StartComponentName;
    private string[] MinoConnectModesList;
    private Color DefaultEnabledBackColor;
    private MainMenu mainMenu1;
    private MenuItem menuItem1;
    private MenuItem ComOpen;
    private MenuItem TestHalloWorld;
    private MenuItem menuLesen;
    private TextBox LoggerBox;
    private MenuItem ComClose;
    private MenuItem TestTimeout;
    private MenuItem DefaultTimeout;
    private ListBox Baudrate;
    private Label label1;
    private Label label2;
    private Button ok;
    private Button cancel;
    private CheckBox SelectEchoOn;
    private TextBox textBoxWaitBeforeRepeatTime;
    private Label label4;
    private Label label3;
    private Label label6;
    private Label label7;
    private Label label8;
    private Label label9;
    private TextBox textBoxRecTransTime;
    private Label label10;
    private Label label11;
    private TextBox textBoxTransTime_AfterBreak;
    private TextBox textBoxRecTime_BeforFirstByte;
    private TextBox textBoxRecTime_OffsetPerByte;
    private TextBox textBoxRecTime_GlobalOffset;
    private TextBox textBoxTransTime_BreakTime;
    private TextBox textBoxBreakIntervalTime;
    private IContainer components;
    private CheckBox checkBoxComOpenClose;
    private CheckBox checkBoxComData;
    private CheckBox checkBoxComState;
    private CheckBox checkBoxComErrors;
    private CheckBox checkBoxComPolling;
    private CheckBox checkBoxBusFunctions;
    private CheckBox checkBoxBusStatus;
    private MenuItem menuItemHelpMenu;
    private MenuItem menuItemAbout;
    private MenuItem menuStarten;
    private MenuItem menuStartGlobalMeterManager;
    private ListBox listBoxParity;
    private Label label12;
    private MenuItem menuItemSetBreak;
    private MenuItem menuItemClearBreak;
    private ZennerCoroprateDesign zennerCoroprateDesign1;
    private MenuItem menuBack;
    private MenuItem menuQuit;
    private CheckBox checkBoxTestEcho;
    private ToolTip toolTip1;
    private Button buttonSet;
    private MenuItem menuItemTests;
    private GroupBox groupBoxLoggerSetup;
    private Label labelComServer;
    private ListBox listBoxAvailableComPorts;
    private TabControl tabControl1;
    private TabPage tabPageBasic;
    private TabPage tabPageLogger;
    private TabPage tabPageTiming;
    private TabPage tabPageTerminal;
    private TextBox textBoxTerminal;
    private TabPage tabPageEquipment;
    private GroupBox groupBoxMinoConnect;
    private GroupBox groupBoxDeviceEcho;
    private GroupBox groupBoxWakeUp;
    private System.Windows.Forms.Timer timerTerminal;
    private Label label5;
    private TextBox textBoxType;
    private ComboBox comboBoxSelectedMiConMode;
    private TextBox textBoxTransceiverDeviceInfo;
    private TextBox textBoxAutoPowerOff;
    private Label label13;
    private TextBox textBoxKeyCounter;
    private Label label14;
    private TextBox textBoxMinoConnectRequests;
    private TextBox textBoxActiveComPort;
    private ComboBox comboBoxAvailableCOMservers;
    private Label labelModeState;
    private Button buttonCOMserverAdmin;
    private Label label19;
    private MenuItem menuItemHelp;
    private Label label20;
    private TextBox textBoxCOMserverIP;
    private TextBox textBoxLoggerEntries;
    private Label label21;
    private MenuItem menuItemStartWindow;
    private MenuItem menuItem2;
    private MenuItem menuItemDeviceCollector;
    private Label label23;
    private ComboBox comboBoxTransceiverDevice;
    private Label label24;
    private ComboBox comboBoxDeviceWakeup;
    private GroupBox groupBoxCombiOptoHead;
    private CheckBox checkBoxIrDa;
    private CheckBox checkBoxDoveTailSide;
    private Panel panelBasic;
    private Panel panelEquipment;
    private Panel panelTiming;
    private Button buttonOpenClose;
    private TextBox textBoxOverloadCounter;
    private Label label22;
    private ComboBox comboBoxComType;
    private Label label25;
    private GroupBox groupBoxRemoteCom;
    private Button buttonRefreshPortList;
    private MenuItem menuItemSearchUSB;
    private SplitContainer splitContainer1;
    private RadioButton radioButtonHex;
    private Label label27;
    private Label label26;
    private RadioButton radioButtonASCIdirect;
    private RadioButton radioButtonASCI;
    private Button buttonTransmit;
    private MenuItem menuItemDesigner;
    private TextBox textBoxIrDaPulseLength;
    private Label label28;
    private Button btnUpgradeMinoConnectFirmware;
    private Label label29;
    private TextBox textBoxRecTime_OffsetPerBlock;
    private TextBox textBoxMinoConnectState;
    private CheckBox checkBoxLoggerOn;
    private Button buttonClearLogger;
    private Button buttonRefreshLogger;
    private MenuItem menuItemFrameTestWindowActive;
    private Button buttonDefaultTiming;
    private MenuItem menuItemSendWakeup;
    private MenuItem menuItemWakeupLoopOn;
    private Button btnUpdateComServers;
    private MenuItem menuItemConfigurator;
    private TextBox textBoxTransTime_AfterOpen;
    private Label label15;
    private CheckBox checkBoxBusErrors;

    public ZR_AsyncCom(AsyncFunctions MyCom)
    {
      this.InitializeComponent();
      if (Thread.CurrentThread.Name != "GMM main")
        this.Text = this.Text + " [" + Thread.CurrentThread.Name + "]";
      this.ComX = MyCom;
      this.LoggerIsOn = false;
      this.StartWindowSize = this.ClientSize;
      this.textBoxMinoConnectState.Size = new Size(this.textBoxMinoConnectState.Size.Width, this.textBoxMinoConnectState.Size.Height + (this.textBoxMinoConnectState.Location.Y - this.comboBoxSelectedMiConMode.Location.Y));
      this.textBoxMinoConnectState.Location = this.comboBoxSelectedMiConMode.Location;
      if (!UserRights.GlobalUserRights.CheckRight(UserRights.Rights.Developer))
      {
        this.menuItemTests.Visible = false;
        this.groupBoxLoggerSetup.Visible = false;
        this.tabControl1.TabPages.Remove(this.tabPageLogger);
        this.tabControl1.TabPages.Remove(this.tabPageTerminal);
      }
      if (this.ComX.ConnectionTypeSelected == AsyncComConnectionType.COM)
        this.ComUpdateComPortList();
      else
        this.UpdateComPortList(true);
      for (int index = 0; index < ZR_AsyncCom.BaudrateTable.Length; ++index)
        this.Baudrate.Items.Add((object) ZR_AsyncCom.BaudrateTable[index].ToString());
      this.comboBoxDeviceWakeup.DataSource = (object) Enum.GetNames(typeof (WakeupSystem));
      this.comboBoxTransceiverDevice.DataSource = (object) Enum.GetNames(typeof (ZR_ClassLibrary.TransceiverDevice));
      this.DefaultEnabledBackColor = this.comboBoxSelectedMiConMode.BackColor;
      this.MinoConnectModesList = Enum.GetNames(typeof (MinoConnectState.BaseStateEnum));
      for (int index = 0; index < this.MinoConnectModesList.Length - 1; ++index)
      {
        if (!this.MinoConnectModesList[index].Contains("Radio") && !this.MinoConnectModesList[index].Contains("WirelessMBus"))
          this.comboBoxSelectedMiConMode.Items.Add((object) this.MinoConnectModesList[index]);
      }
      string[] names = Enum.GetNames(typeof (AsyncComConnectionType));
      int num = 0;
      for (int index = 0; index < names.Length; ++index)
      {
        this.comboBoxComType.Items.Add((object) names[index]);
        if (MyCom.ConnectionTypeSelected.ToString() == names[index])
          num = index;
      }
      this.comboBoxComType.SelectedIndex = num;
      this.SetLoggerEvents();
      this.textBoxActiveComPort.BackColor = Control.DefaultBackColor;
      this.ComX.RefreshComPorts();
      this.SetComState();
      MyCom.OnAsyncComMessage += new EventHandler<GMM_EventArgs>(this.TheStatusChangedMessage);
      this.SetEnabledFunctions();
    }

    protected override void Dispose(bool disposing)
    {
      if (disposing && this.components != null)
        this.components.Dispose();
      if (this.ComX != null)
        this.ComX.OnAsyncComMessage -= new EventHandler<GMM_EventArgs>(this.TheStatusChangedMessage);
      base.Dispose(disposing);
    }

    private void InitializeComponent()
    {
      this.components = (IContainer) new System.ComponentModel.Container();
      ComponentResourceManager componentResourceManager = new ComponentResourceManager(typeof (ZR_AsyncCom));
      this.splitContainer1 = new SplitContainer();
      this.label26 = new Label();
      this.textBoxTerminal = new TextBox();
      this.label5 = new Label();
      this.textBoxType = new TextBox();
      this.mainMenu1 = new MainMenu(this.components);
      this.menuItem1 = new MenuItem();
      this.ComOpen = new MenuItem();
      this.ComClose = new MenuItem();
      this.menuItemSetBreak = new MenuItem();
      this.menuItemClearBreak = new MenuItem();
      this.menuItemTests = new MenuItem();
      this.TestHalloWorld = new MenuItem();
      this.menuLesen = new MenuItem();
      this.TestTimeout = new MenuItem();
      this.DefaultTimeout = new MenuItem();
      this.menuItemSearchUSB = new MenuItem();
      this.menuItemFrameTestWindowActive = new MenuItem();
      this.menuItemSendWakeup = new MenuItem();
      this.menuItemWakeupLoopOn = new MenuItem();
      this.menuStarten = new MenuItem();
      this.menuItemStartWindow = new MenuItem();
      this.menuStartGlobalMeterManager = new MenuItem();
      this.menuBack = new MenuItem();
      this.menuQuit = new MenuItem();
      this.menuItem2 = new MenuItem();
      this.menuItemDeviceCollector = new MenuItem();
      this.menuItemDesigner = new MenuItem();
      this.menuItemConfigurator = new MenuItem();
      this.menuItemHelpMenu = new MenuItem();
      this.menuItemHelp = new MenuItem();
      this.menuItemAbout = new MenuItem();
      this.LoggerBox = new TextBox();
      this.Baudrate = new ListBox();
      this.label1 = new Label();
      this.label2 = new Label();
      this.ok = new Button();
      this.cancel = new Button();
      this.SelectEchoOn = new CheckBox();
      this.textBoxWaitBeforeRepeatTime = new TextBox();
      this.label4 = new Label();
      this.label3 = new Label();
      this.textBoxRecTransTime = new TextBox();
      this.label6 = new Label();
      this.textBoxTransTime_AfterBreak = new TextBox();
      this.label7 = new Label();
      this.textBoxRecTime_BeforFirstByte = new TextBox();
      this.label8 = new Label();
      this.textBoxRecTime_OffsetPerByte = new TextBox();
      this.label9 = new Label();
      this.textBoxRecTime_GlobalOffset = new TextBox();
      this.label10 = new Label();
      this.textBoxTransTime_BreakTime = new TextBox();
      this.label11 = new Label();
      this.textBoxBreakIntervalTime = new TextBox();
      this.groupBoxLoggerSetup = new GroupBox();
      this.buttonRefreshLogger = new Button();
      this.buttonClearLogger = new Button();
      this.checkBoxLoggerOn = new CheckBox();
      this.textBoxLoggerEntries = new TextBox();
      this.label21 = new Label();
      this.checkBoxComOpenClose = new CheckBox();
      this.checkBoxComData = new CheckBox();
      this.checkBoxComState = new CheckBox();
      this.checkBoxComErrors = new CheckBox();
      this.checkBoxComPolling = new CheckBox();
      this.checkBoxBusFunctions = new CheckBox();
      this.checkBoxBusErrors = new CheckBox();
      this.checkBoxBusStatus = new CheckBox();
      this.listBoxParity = new ListBox();
      this.label12 = new Label();
      this.checkBoxTestEcho = new CheckBox();
      this.toolTip1 = new ToolTip(this.components);
      this.buttonOpenClose = new Button();
      this.textBoxRecTime_OffsetPerBlock = new TextBox();
      this.textBoxTransTime_AfterOpen = new TextBox();
      this.listBoxAvailableComPorts = new ListBox();
      this.buttonSet = new Button();
      this.labelComServer = new Label();
      this.tabControl1 = new TabControl();
      this.tabPageBasic = new TabPage();
      this.panelBasic = new Panel();
      this.buttonRefreshPortList = new Button();
      this.groupBoxRemoteCom = new GroupBox();
      this.btnUpdateComServers = new Button();
      this.comboBoxAvailableCOMservers = new ComboBox();
      this.buttonCOMserverAdmin = new Button();
      this.textBoxCOMserverIP = new TextBox();
      this.label20 = new Label();
      this.comboBoxComType = new ComboBox();
      this.label25 = new Label();
      this.textBoxActiveComPort = new TextBox();
      this.tabPageEquipment = new TabPage();
      this.panelEquipment = new Panel();
      this.btnUpgradeMinoConnectFirmware = new Button();
      this.label23 = new Label();
      this.textBoxTransceiverDeviceInfo = new TextBox();
      this.groupBoxMinoConnect = new GroupBox();
      this.textBoxMinoConnectState = new TextBox();
      this.labelModeState = new Label();
      this.groupBoxCombiOptoHead = new GroupBox();
      this.checkBoxIrDa = new CheckBox();
      this.checkBoxDoveTailSide = new CheckBox();
      this.textBoxOverloadCounter = new TextBox();
      this.textBoxMinoConnectRequests = new TextBox();
      this.textBoxKeyCounter = new TextBox();
      this.comboBoxSelectedMiConMode = new ComboBox();
      this.textBoxIrDaPulseLength = new TextBox();
      this.textBoxAutoPowerOff = new TextBox();
      this.label22 = new Label();
      this.label19 = new Label();
      this.label14 = new Label();
      this.label28 = new Label();
      this.label13 = new Label();
      this.label24 = new Label();
      this.groupBoxDeviceEcho = new GroupBox();
      this.groupBoxWakeUp = new GroupBox();
      this.comboBoxDeviceWakeup = new ComboBox();
      this.comboBoxTransceiverDevice = new ComboBox();
      this.tabPageTiming = new TabPage();
      this.panelTiming = new Panel();
      this.buttonDefaultTiming = new Button();
      this.label29 = new Label();
      this.label15 = new Label();
      this.tabPageLogger = new TabPage();
      this.tabPageTerminal = new TabPage();
      this.radioButtonASCIdirect = new RadioButton();
      this.radioButtonASCI = new RadioButton();
      this.radioButtonHex = new RadioButton();
      this.label27 = new Label();
      this.buttonTransmit = new Button();
      this.timerTerminal = new System.Windows.Forms.Timer(this.components);
      this.zennerCoroprateDesign1 = new ZennerCoroprateDesign();
      this.splitContainer1.BeginInit();
      this.splitContainer1.Panel1.SuspendLayout();
      this.splitContainer1.Panel2.SuspendLayout();
      this.splitContainer1.SuspendLayout();
      this.groupBoxLoggerSetup.SuspendLayout();
      this.tabControl1.SuspendLayout();
      this.tabPageBasic.SuspendLayout();
      this.panelBasic.SuspendLayout();
      this.groupBoxRemoteCom.SuspendLayout();
      this.tabPageEquipment.SuspendLayout();
      this.panelEquipment.SuspendLayout();
      this.groupBoxMinoConnect.SuspendLayout();
      this.groupBoxCombiOptoHead.SuspendLayout();
      this.groupBoxDeviceEcho.SuspendLayout();
      this.groupBoxWakeUp.SuspendLayout();
      this.tabPageTiming.SuspendLayout();
      this.panelTiming.SuspendLayout();
      this.tabPageLogger.SuspendLayout();
      this.tabPageTerminal.SuspendLayout();
      this.SuspendLayout();
      componentResourceManager.ApplyResources((object) this.splitContainer1, "splitContainer1");
      this.splitContainer1.Name = "splitContainer1";
      this.splitContainer1.Panel1.Controls.Add((Control) this.label26);
      this.splitContainer1.Panel1.Controls.Add((Control) this.textBoxTerminal);
      this.splitContainer1.Panel2.Controls.Add((Control) this.label5);
      this.splitContainer1.Panel2.Controls.Add((Control) this.textBoxType);
      componentResourceManager.ApplyResources((object) this.label26, "label26");
      this.label26.Name = "label26";
      componentResourceManager.ApplyResources((object) this.textBoxTerminal, "textBoxTerminal");
      this.textBoxTerminal.BackColor = Color.White;
      this.textBoxTerminal.ForeColor = Color.Black;
      this.textBoxTerminal.Name = "textBoxTerminal";
      this.textBoxTerminal.ReadOnly = true;
      componentResourceManager.ApplyResources((object) this.label5, "label5");
      this.label5.Name = "label5";
      componentResourceManager.ApplyResources((object) this.textBoxType, "textBoxType");
      this.textBoxType.Name = "textBoxType";
      this.textBoxType.TextChanged += new System.EventHandler(this.textBoxType_TextChanged);
      this.textBoxType.Enter += new System.EventHandler(this.textBoxType_Enter);
      this.textBoxType.Leave += new System.EventHandler(this.textBoxType_Leave);
      this.mainMenu1.MenuItems.AddRange(new MenuItem[4]
      {
        this.menuItem1,
        this.menuItemTests,
        this.menuStarten,
        this.menuItemHelpMenu
      });
      this.menuItem1.Index = 0;
      this.menuItem1.MenuItems.AddRange(new MenuItem[4]
      {
        this.ComOpen,
        this.ComClose,
        this.menuItemSetBreak,
        this.menuItemClearBreak
      });
      componentResourceManager.ApplyResources((object) this.menuItem1, "menuItem1");
      this.ComOpen.Index = 0;
      componentResourceManager.ApplyResources((object) this.ComOpen, "ComOpen");
      this.ComOpen.Click += new System.EventHandler(this.ComOpen_Click);
      this.ComClose.Index = 1;
      componentResourceManager.ApplyResources((object) this.ComClose, "ComClose");
      this.ComClose.Click += new System.EventHandler(this.ComClose_Click);
      this.menuItemSetBreak.Index = 2;
      componentResourceManager.ApplyResources((object) this.menuItemSetBreak, "menuItemSetBreak");
      this.menuItemSetBreak.Click += new System.EventHandler(this.menuItemSetBreak_Click);
      this.menuItemClearBreak.Index = 3;
      componentResourceManager.ApplyResources((object) this.menuItemClearBreak, "menuItemClearBreak");
      this.menuItemClearBreak.Click += new System.EventHandler(this.menuItemClearBreak_Click);
      this.menuItemTests.Index = 1;
      this.menuItemTests.MenuItems.AddRange(new MenuItem[8]
      {
        this.TestHalloWorld,
        this.menuLesen,
        this.TestTimeout,
        this.DefaultTimeout,
        this.menuItemSearchUSB,
        this.menuItemFrameTestWindowActive,
        this.menuItemSendWakeup,
        this.menuItemWakeupLoopOn
      });
      componentResourceManager.ApplyResources((object) this.menuItemTests, "menuItemTests");
      this.TestHalloWorld.Index = 0;
      componentResourceManager.ApplyResources((object) this.TestHalloWorld, "TestHalloWorld");
      this.TestHalloWorld.Click += new System.EventHandler(this.TestHalloWorld_Click);
      this.menuLesen.Index = 1;
      componentResourceManager.ApplyResources((object) this.menuLesen, "menuLesen");
      this.menuLesen.Click += new System.EventHandler(this.menuLesen_Click);
      this.TestTimeout.Index = 2;
      componentResourceManager.ApplyResources((object) this.TestTimeout, "TestTimeout");
      this.DefaultTimeout.Index = 3;
      componentResourceManager.ApplyResources((object) this.DefaultTimeout, "DefaultTimeout");
      this.menuItemSearchUSB.Index = 4;
      componentResourceManager.ApplyResources((object) this.menuItemSearchUSB, "menuItemSearchUSB");
      this.menuItemSearchUSB.Click += new System.EventHandler(this.menuItemSearchUSB_Click);
      this.menuItemFrameTestWindowActive.Index = 5;
      this.menuItemFrameTestWindowActive.RadioCheck = true;
      componentResourceManager.ApplyResources((object) this.menuItemFrameTestWindowActive, "menuItemFrameTestWindowActive");
      this.menuItemFrameTestWindowActive.Click += new System.EventHandler(this.menuItemFrameTestWindowActive_Click);
      this.menuItemSendWakeup.Index = 6;
      componentResourceManager.ApplyResources((object) this.menuItemSendWakeup, "menuItemSendWakeup");
      this.menuItemSendWakeup.Click += new System.EventHandler(this.menuItemSendWakeup_Click);
      this.menuItemWakeupLoopOn.Index = 7;
      this.menuItemWakeupLoopOn.RadioCheck = true;
      componentResourceManager.ApplyResources((object) this.menuItemWakeupLoopOn, "menuItemWakeupLoopOn");
      this.menuItemWakeupLoopOn.Click += new System.EventHandler(this.menuItemWakeupLoopOn_Click);
      this.menuStarten.Index = 2;
      this.menuStarten.MenuItems.AddRange(new MenuItem[8]
      {
        this.menuItemStartWindow,
        this.menuStartGlobalMeterManager,
        this.menuBack,
        this.menuQuit,
        this.menuItem2,
        this.menuItemDeviceCollector,
        this.menuItemDesigner,
        this.menuItemConfigurator
      });
      componentResourceManager.ApplyResources((object) this.menuStarten, "menuStarten");
      this.menuItemStartWindow.Index = 0;
      componentResourceManager.ApplyResources((object) this.menuItemStartWindow, "menuItemStartWindow");
      this.menuItemStartWindow.Click += new System.EventHandler(this.menuItemStartWindow_Click);
      this.menuStartGlobalMeterManager.Index = 1;
      componentResourceManager.ApplyResources((object) this.menuStartGlobalMeterManager, "menuStartGlobalMeterManager");
      this.menuStartGlobalMeterManager.Click += new System.EventHandler(this.menuStartGlobalMeterManager_Click);
      this.menuBack.Index = 2;
      componentResourceManager.ApplyResources((object) this.menuBack, "menuBack");
      this.menuBack.Click += new System.EventHandler(this.menuBack_Click);
      this.menuQuit.Index = 3;
      componentResourceManager.ApplyResources((object) this.menuQuit, "menuQuit");
      this.menuQuit.Click += new System.EventHandler(this.menuQuit_Click);
      this.menuItem2.Index = 4;
      componentResourceManager.ApplyResources((object) this.menuItem2, "menuItem2");
      this.menuItemDeviceCollector.Index = 5;
      componentResourceManager.ApplyResources((object) this.menuItemDeviceCollector, "menuItemDeviceCollector");
      this.menuItemDeviceCollector.Click += new System.EventHandler(this.menuItemSerialBus_Click);
      this.menuItemDesigner.Index = 6;
      componentResourceManager.ApplyResources((object) this.menuItemDesigner, "menuItemDesigner");
      this.menuItemDesigner.Click += new System.EventHandler(this.menuItemDesigner_Click);
      this.menuItemConfigurator.Index = 7;
      componentResourceManager.ApplyResources((object) this.menuItemConfigurator, "menuItemConfigurator");
      this.menuItemConfigurator.Click += new System.EventHandler(this.menuItemConfigurator_Click);
      this.menuItemHelpMenu.Index = 3;
      this.menuItemHelpMenu.MenuItems.AddRange(new MenuItem[2]
      {
        this.menuItemHelp,
        this.menuItemAbout
      });
      componentResourceManager.ApplyResources((object) this.menuItemHelpMenu, "menuItemHelpMenu");
      this.menuItemHelp.Index = 0;
      componentResourceManager.ApplyResources((object) this.menuItemHelp, "menuItemHelp");
      this.menuItemHelp.Click += new System.EventHandler(this.menuItemHelp_Click);
      this.menuItemAbout.Index = 1;
      componentResourceManager.ApplyResources((object) this.menuItemAbout, "menuItemAbout");
      this.menuItemAbout.Click += new System.EventHandler(this.menuItem7_Click);
      componentResourceManager.ApplyResources((object) this.LoggerBox, "LoggerBox");
      this.LoggerBox.Name = "LoggerBox";
      componentResourceManager.ApplyResources((object) this.Baudrate, "Baudrate");
      this.Baudrate.Name = "Baudrate";
      this.Baudrate.SelectedIndexChanged += new System.EventHandler(this.Baudrate_SelectedIndexChanged);
      componentResourceManager.ApplyResources((object) this.label1, "label1");
      this.label1.Name = "label1";
      componentResourceManager.ApplyResources((object) this.label2, "label2");
      this.label2.Name = "label2";
      componentResourceManager.ApplyResources((object) this.ok, "ok");
      this.ok.DialogResult = DialogResult.OK;
      this.ok.Name = "ok";
      this.ok.Click += new System.EventHandler(this.ok_Click);
      componentResourceManager.ApplyResources((object) this.cancel, "cancel");
      this.cancel.DialogResult = DialogResult.Cancel;
      this.cancel.Name = "cancel";
      this.cancel.Click += new System.EventHandler(this.cancel_Click);
      componentResourceManager.ApplyResources((object) this.SelectEchoOn, "SelectEchoOn");
      this.SelectEchoOn.Name = "SelectEchoOn";
      this.SelectEchoOn.CheckedChanged += new System.EventHandler(this.SelectEchoOn_CheckedChanged);
      componentResourceManager.ApplyResources((object) this.textBoxWaitBeforeRepeatTime, "textBoxWaitBeforeRepeatTime");
      this.textBoxWaitBeforeRepeatTime.Name = "textBoxWaitBeforeRepeatTime";
      this.toolTip1.SetToolTip((Control) this.textBoxWaitBeforeRepeatTime, componentResourceManager.GetString("textBoxWaitBeforeRepeatTime.ToolTip"));
      this.textBoxWaitBeforeRepeatTime.TextChanged += new System.EventHandler(this.TimeChanged);
      componentResourceManager.ApplyResources((object) this.label4, "label4");
      this.label4.Name = "label4";
      componentResourceManager.ApplyResources((object) this.label3, "label3");
      this.label3.Name = "label3";
      componentResourceManager.ApplyResources((object) this.textBoxRecTransTime, "textBoxRecTransTime");
      this.textBoxRecTransTime.Name = "textBoxRecTransTime";
      this.toolTip1.SetToolTip((Control) this.textBoxRecTransTime, componentResourceManager.GetString("textBoxRecTransTime.ToolTip"));
      this.textBoxRecTransTime.TextChanged += new System.EventHandler(this.TimeChanged);
      componentResourceManager.ApplyResources((object) this.label6, "label6");
      this.label6.Name = "label6";
      componentResourceManager.ApplyResources((object) this.textBoxTransTime_AfterBreak, "textBoxTransTime_AfterBreak");
      this.textBoxTransTime_AfterBreak.Name = "textBoxTransTime_AfterBreak";
      this.toolTip1.SetToolTip((Control) this.textBoxTransTime_AfterBreak, componentResourceManager.GetString("textBoxTransTime_AfterBreak.ToolTip"));
      this.textBoxTransTime_AfterBreak.TextChanged += new System.EventHandler(this.TimeChanged);
      componentResourceManager.ApplyResources((object) this.label7, "label7");
      this.label7.Name = "label7";
      componentResourceManager.ApplyResources((object) this.textBoxRecTime_BeforFirstByte, "textBoxRecTime_BeforFirstByte");
      this.textBoxRecTime_BeforFirstByte.Name = "textBoxRecTime_BeforFirstByte";
      this.toolTip1.SetToolTip((Control) this.textBoxRecTime_BeforFirstByte, componentResourceManager.GetString("textBoxRecTime_BeforFirstByte.ToolTip"));
      this.textBoxRecTime_BeforFirstByte.TextChanged += new System.EventHandler(this.TimeChanged);
      componentResourceManager.ApplyResources((object) this.label8, "label8");
      this.label8.Name = "label8";
      componentResourceManager.ApplyResources((object) this.textBoxRecTime_OffsetPerByte, "textBoxRecTime_OffsetPerByte");
      this.textBoxRecTime_OffsetPerByte.Name = "textBoxRecTime_OffsetPerByte";
      this.toolTip1.SetToolTip((Control) this.textBoxRecTime_OffsetPerByte, componentResourceManager.GetString("textBoxRecTime_OffsetPerByte.ToolTip"));
      this.textBoxRecTime_OffsetPerByte.TextChanged += new System.EventHandler(this.TimeChanged);
      componentResourceManager.ApplyResources((object) this.label9, "label9");
      this.label9.Name = "label9";
      componentResourceManager.ApplyResources((object) this.textBoxRecTime_GlobalOffset, "textBoxRecTime_GlobalOffset");
      this.textBoxRecTime_GlobalOffset.Name = "textBoxRecTime_GlobalOffset";
      this.toolTip1.SetToolTip((Control) this.textBoxRecTime_GlobalOffset, componentResourceManager.GetString("textBoxRecTime_GlobalOffset.ToolTip"));
      this.textBoxRecTime_GlobalOffset.TextChanged += new System.EventHandler(this.TimeChanged);
      componentResourceManager.ApplyResources((object) this.label10, "label10");
      this.label10.Name = "label10";
      componentResourceManager.ApplyResources((object) this.textBoxTransTime_BreakTime, "textBoxTransTime_BreakTime");
      this.textBoxTransTime_BreakTime.Name = "textBoxTransTime_BreakTime";
      this.toolTip1.SetToolTip((Control) this.textBoxTransTime_BreakTime, componentResourceManager.GetString("textBoxTransTime_BreakTime.ToolTip"));
      this.textBoxTransTime_BreakTime.TextChanged += new System.EventHandler(this.TimeChanged);
      componentResourceManager.ApplyResources((object) this.label11, "label11");
      this.label11.Name = "label11";
      componentResourceManager.ApplyResources((object) this.textBoxBreakIntervalTime, "textBoxBreakIntervalTime");
      this.textBoxBreakIntervalTime.Name = "textBoxBreakIntervalTime";
      this.toolTip1.SetToolTip((Control) this.textBoxBreakIntervalTime, componentResourceManager.GetString("textBoxBreakIntervalTime.ToolTip"));
      this.textBoxBreakIntervalTime.TextChanged += new System.EventHandler(this.TimeChanged);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.buttonRefreshLogger);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.buttonClearLogger);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.checkBoxLoggerOn);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.textBoxLoggerEntries);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.label21);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.checkBoxComOpenClose);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.checkBoxComData);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.checkBoxComState);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.checkBoxComErrors);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.checkBoxComPolling);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.checkBoxBusFunctions);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.checkBoxBusErrors);
      this.groupBoxLoggerSetup.Controls.Add((Control) this.checkBoxBusStatus);
      componentResourceManager.ApplyResources((object) this.groupBoxLoggerSetup, "groupBoxLoggerSetup");
      this.groupBoxLoggerSetup.Name = "groupBoxLoggerSetup";
      this.groupBoxLoggerSetup.TabStop = false;
      componentResourceManager.ApplyResources((object) this.buttonRefreshLogger, "buttonRefreshLogger");
      this.buttonRefreshLogger.Name = "buttonRefreshLogger";
      this.buttonRefreshLogger.UseVisualStyleBackColor = true;
      this.buttonRefreshLogger.Click += new System.EventHandler(this.buttonRefreshLogger_Click);
      componentResourceManager.ApplyResources((object) this.buttonClearLogger, "buttonClearLogger");
      this.buttonClearLogger.Name = "buttonClearLogger";
      this.buttonClearLogger.UseVisualStyleBackColor = true;
      this.buttonClearLogger.Click += new System.EventHandler(this.buttonClearLogger_Click);
      componentResourceManager.ApplyResources((object) this.checkBoxLoggerOn, "checkBoxLoggerOn");
      this.checkBoxLoggerOn.Name = "checkBoxLoggerOn";
      this.checkBoxLoggerOn.UseVisualStyleBackColor = true;
      this.checkBoxLoggerOn.CheckedChanged += new System.EventHandler(this.checkBoxLoggerOn_CheckedChanged);
      componentResourceManager.ApplyResources((object) this.textBoxLoggerEntries, "textBoxLoggerEntries");
      this.textBoxLoggerEntries.Name = "textBoxLoggerEntries";
      componentResourceManager.ApplyResources((object) this.label21, "label21");
      this.label21.Name = "label21";
      this.checkBoxComOpenClose.Checked = true;
      this.checkBoxComOpenClose.CheckState = CheckState.Checked;
      componentResourceManager.ApplyResources((object) this.checkBoxComOpenClose, "checkBoxComOpenClose");
      this.checkBoxComOpenClose.Name = "checkBoxComOpenClose";
      this.checkBoxComData.Checked = true;
      this.checkBoxComData.CheckState = CheckState.Checked;
      componentResourceManager.ApplyResources((object) this.checkBoxComData, "checkBoxComData");
      this.checkBoxComData.Name = "checkBoxComData";
      this.checkBoxComState.Checked = true;
      this.checkBoxComState.CheckState = CheckState.Checked;
      componentResourceManager.ApplyResources((object) this.checkBoxComState, "checkBoxComState");
      this.checkBoxComState.Name = "checkBoxComState";
      this.checkBoxComErrors.Checked = true;
      this.checkBoxComErrors.CheckState = CheckState.Checked;
      componentResourceManager.ApplyResources((object) this.checkBoxComErrors, "checkBoxComErrors");
      this.checkBoxComErrors.Name = "checkBoxComErrors";
      componentResourceManager.ApplyResources((object) this.checkBoxComPolling, "checkBoxComPolling");
      this.checkBoxComPolling.Name = "checkBoxComPolling";
      this.checkBoxBusFunctions.Checked = true;
      this.checkBoxBusFunctions.CheckState = CheckState.Checked;
      componentResourceManager.ApplyResources((object) this.checkBoxBusFunctions, "checkBoxBusFunctions");
      this.checkBoxBusFunctions.Name = "checkBoxBusFunctions";
      this.checkBoxBusErrors.Checked = true;
      this.checkBoxBusErrors.CheckState = CheckState.Checked;
      componentResourceManager.ApplyResources((object) this.checkBoxBusErrors, "checkBoxBusErrors");
      this.checkBoxBusErrors.Name = "checkBoxBusErrors";
      this.checkBoxBusStatus.Checked = true;
      this.checkBoxBusStatus.CheckState = CheckState.Checked;
      componentResourceManager.ApplyResources((object) this.checkBoxBusStatus, "checkBoxBusStatus");
      this.checkBoxBusStatus.Name = "checkBoxBusStatus";
      componentResourceManager.ApplyResources((object) this.listBoxParity, "listBoxParity");
      this.listBoxParity.Items.AddRange(new object[3]
      {
        (object) componentResourceManager.GetString("listBoxParity.Items"),
        (object) componentResourceManager.GetString("listBoxParity.Items1"),
        (object) componentResourceManager.GetString("listBoxParity.Items2")
      });
      this.listBoxParity.Name = "listBoxParity";
      this.listBoxParity.SelectedIndexChanged += new System.EventHandler(this.listBoxParity_SelectedIndexChanged);
      componentResourceManager.ApplyResources((object) this.label12, "label12");
      this.label12.Name = "label12";
      componentResourceManager.ApplyResources((object) this.checkBoxTestEcho, "checkBoxTestEcho");
      this.checkBoxTestEcho.Name = "checkBoxTestEcho";
      this.checkBoxTestEcho.CheckedChanged += new System.EventHandler(this.checkBoxTestEcho_CheckedChanged);
      componentResourceManager.ApplyResources((object) this.buttonOpenClose, "buttonOpenClose");
      this.buttonOpenClose.Name = "buttonOpenClose";
      this.toolTip1.SetToolTip((Control) this.buttonOpenClose, componentResourceManager.GetString("buttonOpenClose.ToolTip"));
      this.buttonOpenClose.Click += new System.EventHandler(this.buttonOpenClose_Click);
      componentResourceManager.ApplyResources((object) this.textBoxRecTime_OffsetPerBlock, "textBoxRecTime_OffsetPerBlock");
      this.textBoxRecTime_OffsetPerBlock.Name = "textBoxRecTime_OffsetPerBlock";
      this.toolTip1.SetToolTip((Control) this.textBoxRecTime_OffsetPerBlock, componentResourceManager.GetString("textBoxRecTime_OffsetPerBlock.ToolTip"));
      this.textBoxRecTime_OffsetPerBlock.TextChanged += new System.EventHandler(this.TimeChanged);
      componentResourceManager.ApplyResources((object) this.textBoxTransTime_AfterOpen, "textBoxTransTime_AfterOpen");
      this.textBoxTransTime_AfterOpen.Name = "textBoxTransTime_AfterOpen";
      this.toolTip1.SetToolTip((Control) this.textBoxTransTime_AfterOpen, componentResourceManager.GetString("textBoxTransTime_AfterOpen.ToolTip"));
      this.textBoxTransTime_AfterOpen.TextChanged += new System.EventHandler(this.TimeChanged);
      componentResourceManager.ApplyResources((object) this.listBoxAvailableComPorts, "listBoxAvailableComPorts");
      this.listBoxAvailableComPorts.FormattingEnabled = true;
      this.listBoxAvailableComPorts.Name = "listBoxAvailableComPorts";
      this.listBoxAvailableComPorts.SelectedIndexChanged += new System.EventHandler(this.listBoxAvailableComPorts_SelectedIndexChanged);
      componentResourceManager.ApplyResources((object) this.buttonSet, "buttonSet");
      this.buttonSet.Name = "buttonSet";
      this.buttonSet.Click += new System.EventHandler(this.buttonSet_Click);
      componentResourceManager.ApplyResources((object) this.labelComServer, "labelComServer");
      this.labelComServer.Name = "labelComServer";
      componentResourceManager.ApplyResources((object) this.tabControl1, "tabControl1");
      this.tabControl1.Controls.Add((Control) this.tabPageBasic);
      this.tabControl1.Controls.Add((Control) this.tabPageEquipment);
      this.tabControl1.Controls.Add((Control) this.tabPageTiming);
      this.tabControl1.Controls.Add((Control) this.tabPageLogger);
      this.tabControl1.Controls.Add((Control) this.tabPageTerminal);
      this.tabControl1.Name = "tabControl1";
      this.tabControl1.SelectedIndex = 0;
      this.tabPageBasic.Controls.Add((Control) this.panelBasic);
      componentResourceManager.ApplyResources((object) this.tabPageBasic, "tabPageBasic");
      this.tabPageBasic.Name = "tabPageBasic";
      this.tabPageBasic.UseVisualStyleBackColor = true;
      this.panelBasic.Controls.Add((Control) this.buttonRefreshPortList);
      this.panelBasic.Controls.Add((Control) this.groupBoxRemoteCom);
      this.panelBasic.Controls.Add((Control) this.comboBoxComType);
      this.panelBasic.Controls.Add((Control) this.listBoxParity);
      this.panelBasic.Controls.Add((Control) this.label2);
      this.panelBasic.Controls.Add((Control) this.label1);
      this.panelBasic.Controls.Add((Control) this.Baudrate);
      this.panelBasic.Controls.Add((Control) this.label25);
      this.panelBasic.Controls.Add((Control) this.textBoxActiveComPort);
      this.panelBasic.Controls.Add((Control) this.label12);
      this.panelBasic.Controls.Add((Control) this.listBoxAvailableComPorts);
      componentResourceManager.ApplyResources((object) this.panelBasic, "panelBasic");
      this.panelBasic.Name = "panelBasic";
      componentResourceManager.ApplyResources((object) this.buttonRefreshPortList, "buttonRefreshPortList");
      this.buttonRefreshPortList.Name = "buttonRefreshPortList";
      this.buttonRefreshPortList.UseVisualStyleBackColor = true;
      this.buttonRefreshPortList.Click += new System.EventHandler(this.buttonRefreshPortList_Click);
      this.groupBoxRemoteCom.Controls.Add((Control) this.btnUpdateComServers);
      this.groupBoxRemoteCom.Controls.Add((Control) this.labelComServer);
      this.groupBoxRemoteCom.Controls.Add((Control) this.comboBoxAvailableCOMservers);
      this.groupBoxRemoteCom.Controls.Add((Control) this.buttonCOMserverAdmin);
      this.groupBoxRemoteCom.Controls.Add((Control) this.textBoxCOMserverIP);
      this.groupBoxRemoteCom.Controls.Add((Control) this.label20);
      componentResourceManager.ApplyResources((object) this.groupBoxRemoteCom, "groupBoxRemoteCom");
      this.groupBoxRemoteCom.Name = "groupBoxRemoteCom";
      this.groupBoxRemoteCom.TabStop = false;
      this.btnUpdateComServers.Image = (Image) AsyncComRes.RefreshButton;
      componentResourceManager.ApplyResources((object) this.btnUpdateComServers, "btnUpdateComServers");
      this.btnUpdateComServers.Name = "btnUpdateComServers";
      this.btnUpdateComServers.UseVisualStyleBackColor = true;
      this.btnUpdateComServers.Click += new System.EventHandler(this.btnUpdateComServers_Click);
      this.comboBoxAvailableCOMservers.DrawMode = DrawMode.OwnerDrawFixed;
      this.comboBoxAvailableCOMservers.DropDownStyle = ComboBoxStyle.DropDownList;
      this.comboBoxAvailableCOMservers.FormattingEnabled = true;
      componentResourceManager.ApplyResources((object) this.comboBoxAvailableCOMservers, "comboBoxAvailableCOMservers");
      this.comboBoxAvailableCOMservers.Name = "comboBoxAvailableCOMservers";
      this.comboBoxAvailableCOMservers.DrawItem += new DrawItemEventHandler(this.comboBoxAvailableCOMservers_DrawItem);
      this.comboBoxAvailableCOMservers.SelectedIndexChanged += new System.EventHandler(this.comboBoxAvailableCOMservers_SelectedIndexChanged);
      componentResourceManager.ApplyResources((object) this.buttonCOMserverAdmin, "buttonCOMserverAdmin");
      this.buttonCOMserverAdmin.Name = "buttonCOMserverAdmin";
      this.buttonCOMserverAdmin.Click += new System.EventHandler(this.buttonCOMserverAdmin_Click);
      componentResourceManager.ApplyResources((object) this.textBoxCOMserverIP, "textBoxCOMserverIP");
      this.textBoxCOMserverIP.Name = "textBoxCOMserverIP";
      this.textBoxCOMserverIP.TextChanged += new System.EventHandler(this.textBoxCOMserverIP_TextChanged);
      this.textBoxCOMserverIP.KeyPress += new KeyPressEventHandler(this.textBoxCOMserverIP_KeyPress);
      componentResourceManager.ApplyResources((object) this.label20, "label20");
      this.label20.Name = "label20";
      this.comboBoxComType.DropDownStyle = ComboBoxStyle.DropDownList;
      this.comboBoxComType.FormattingEnabled = true;
      componentResourceManager.ApplyResources((object) this.comboBoxComType, "comboBoxComType");
      this.comboBoxComType.Name = "comboBoxComType";
      this.comboBoxComType.SelectedIndexChanged += new System.EventHandler(this.comboBoxComType_SelectedIndexChanged);
      componentResourceManager.ApplyResources((object) this.label25, "label25");
      this.label25.Name = "label25";
      componentResourceManager.ApplyResources((object) this.textBoxActiveComPort, "textBoxActiveComPort");
      this.textBoxActiveComPort.Name = "textBoxActiveComPort";
      this.textBoxActiveComPort.Leave += new System.EventHandler(this.textBoxActiveComPort_Leave);
      this.tabPageEquipment.Controls.Add((Control) this.panelEquipment);
      componentResourceManager.ApplyResources((object) this.tabPageEquipment, "tabPageEquipment");
      this.tabPageEquipment.Name = "tabPageEquipment";
      this.tabPageEquipment.UseVisualStyleBackColor = true;
      this.panelEquipment.Controls.Add((Control) this.btnUpgradeMinoConnectFirmware);
      this.panelEquipment.Controls.Add((Control) this.label23);
      this.panelEquipment.Controls.Add((Control) this.textBoxTransceiverDeviceInfo);
      this.panelEquipment.Controls.Add((Control) this.groupBoxMinoConnect);
      this.panelEquipment.Controls.Add((Control) this.label24);
      this.panelEquipment.Controls.Add((Control) this.groupBoxDeviceEcho);
      this.panelEquipment.Controls.Add((Control) this.groupBoxWakeUp);
      this.panelEquipment.Controls.Add((Control) this.comboBoxTransceiverDevice);
      componentResourceManager.ApplyResources((object) this.panelEquipment, "panelEquipment");
      this.panelEquipment.Name = "panelEquipment";
      componentResourceManager.ApplyResources((object) this.btnUpgradeMinoConnectFirmware, "btnUpgradeMinoConnectFirmware");
      this.btnUpgradeMinoConnectFirmware.Name = "btnUpgradeMinoConnectFirmware";
      this.btnUpgradeMinoConnectFirmware.Click += new System.EventHandler(this.btnUpgradeMinoConnectFirmware_Click);
      componentResourceManager.ApplyResources((object) this.label23, "label23");
      this.label23.Name = "label23";
      componentResourceManager.ApplyResources((object) this.textBoxTransceiverDeviceInfo, "textBoxTransceiverDeviceInfo");
      this.textBoxTransceiverDeviceInfo.Name = "textBoxTransceiverDeviceInfo";
      this.textBoxTransceiverDeviceInfo.ReadOnly = true;
      componentResourceManager.ApplyResources((object) this.groupBoxMinoConnect, "groupBoxMinoConnect");
      this.groupBoxMinoConnect.Controls.Add((Control) this.textBoxMinoConnectState);
      this.groupBoxMinoConnect.Controls.Add((Control) this.labelModeState);
      this.groupBoxMinoConnect.Controls.Add((Control) this.groupBoxCombiOptoHead);
      this.groupBoxMinoConnect.Controls.Add((Control) this.textBoxOverloadCounter);
      this.groupBoxMinoConnect.Controls.Add((Control) this.textBoxMinoConnectRequests);
      this.groupBoxMinoConnect.Controls.Add((Control) this.textBoxKeyCounter);
      this.groupBoxMinoConnect.Controls.Add((Control) this.comboBoxSelectedMiConMode);
      this.groupBoxMinoConnect.Controls.Add((Control) this.textBoxIrDaPulseLength);
      this.groupBoxMinoConnect.Controls.Add((Control) this.textBoxAutoPowerOff);
      this.groupBoxMinoConnect.Controls.Add((Control) this.label22);
      this.groupBoxMinoConnect.Controls.Add((Control) this.label19);
      this.groupBoxMinoConnect.Controls.Add((Control) this.label14);
      this.groupBoxMinoConnect.Controls.Add((Control) this.label28);
      this.groupBoxMinoConnect.Controls.Add((Control) this.label13);
      this.groupBoxMinoConnect.Name = "groupBoxMinoConnect";
      this.groupBoxMinoConnect.TabStop = false;
      componentResourceManager.ApplyResources((object) this.textBoxMinoConnectState, "textBoxMinoConnectState");
      this.textBoxMinoConnectState.Name = "textBoxMinoConnectState";
      this.textBoxMinoConnectState.ReadOnly = true;
      componentResourceManager.ApplyResources((object) this.labelModeState, "labelModeState");
      this.labelModeState.Name = "labelModeState";
      this.groupBoxCombiOptoHead.Controls.Add((Control) this.checkBoxIrDa);
      this.groupBoxCombiOptoHead.Controls.Add((Control) this.checkBoxDoveTailSide);
      componentResourceManager.ApplyResources((object) this.groupBoxCombiOptoHead, "groupBoxCombiOptoHead");
      this.groupBoxCombiOptoHead.Name = "groupBoxCombiOptoHead";
      this.groupBoxCombiOptoHead.TabStop = false;
      componentResourceManager.ApplyResources((object) this.checkBoxIrDa, "checkBoxIrDa");
      this.checkBoxIrDa.Name = "checkBoxIrDa";
      this.checkBoxIrDa.UseVisualStyleBackColor = true;
      this.checkBoxIrDa.CheckedChanged += new System.EventHandler(this.checkBoxIrDa_CheckedChanged);
      componentResourceManager.ApplyResources((object) this.checkBoxDoveTailSide, "checkBoxDoveTailSide");
      this.checkBoxDoveTailSide.Name = "checkBoxDoveTailSide";
      this.checkBoxDoveTailSide.UseVisualStyleBackColor = true;
      this.checkBoxDoveTailSide.CheckedChanged += new System.EventHandler(this.checkBoxDoveTailSide_CheckedChanged);
      componentResourceManager.ApplyResources((object) this.textBoxOverloadCounter, "textBoxOverloadCounter");
      this.textBoxOverloadCounter.Name = "textBoxOverloadCounter";
      componentResourceManager.ApplyResources((object) this.textBoxMinoConnectRequests, "textBoxMinoConnectRequests");
      this.textBoxMinoConnectRequests.Name = "textBoxMinoConnectRequests";
      componentResourceManager.ApplyResources((object) this.textBoxKeyCounter, "textBoxKeyCounter");
      this.textBoxKeyCounter.Name = "textBoxKeyCounter";
      componentResourceManager.ApplyResources((object) this.comboBoxSelectedMiConMode, "comboBoxSelectedMiConMode");
      this.comboBoxSelectedMiConMode.DropDownStyle = ComboBoxStyle.DropDownList;
      this.comboBoxSelectedMiConMode.FormattingEnabled = true;
      this.comboBoxSelectedMiConMode.Name = "comboBoxSelectedMiConMode";
      this.comboBoxSelectedMiConMode.SelectedIndexChanged += new System.EventHandler(this.comboBoxSelectedPlugState_SelectedIndexChanged);
      componentResourceManager.ApplyResources((object) this.textBoxIrDaPulseLength, "textBoxIrDaPulseLength");
      this.textBoxIrDaPulseLength.Name = "textBoxIrDaPulseLength";
      componentResourceManager.ApplyResources((object) this.textBoxAutoPowerOff, "textBoxAutoPowerOff");
      this.textBoxAutoPowerOff.Name = "textBoxAutoPowerOff";
      componentResourceManager.ApplyResources((object) this.label22, "label22");
      this.label22.Name = "label22";
      componentResourceManager.ApplyResources((object) this.label19, "label19");
      this.label19.Name = "label19";
      componentResourceManager.ApplyResources((object) this.label14, "label14");
      this.label14.Name = "label14";
      componentResourceManager.ApplyResources((object) this.label28, "label28");
      this.label28.Name = "label28";
      componentResourceManager.ApplyResources((object) this.label13, "label13");
      this.label13.Name = "label13";
      componentResourceManager.ApplyResources((object) this.label24, "label24");
      this.label24.Name = "label24";
      componentResourceManager.ApplyResources((object) this.groupBoxDeviceEcho, "groupBoxDeviceEcho");
      this.groupBoxDeviceEcho.Controls.Add((Control) this.checkBoxTestEcho);
      this.groupBoxDeviceEcho.Controls.Add((Control) this.SelectEchoOn);
      this.groupBoxDeviceEcho.Name = "groupBoxDeviceEcho";
      this.groupBoxDeviceEcho.TabStop = false;
      componentResourceManager.ApplyResources((object) this.groupBoxWakeUp, "groupBoxWakeUp");
      this.groupBoxWakeUp.Controls.Add((Control) this.comboBoxDeviceWakeup);
      this.groupBoxWakeUp.Name = "groupBoxWakeUp";
      this.groupBoxWakeUp.TabStop = false;
      componentResourceManager.ApplyResources((object) this.comboBoxDeviceWakeup, "comboBoxDeviceWakeup");
      this.comboBoxDeviceWakeup.DropDownStyle = ComboBoxStyle.DropDownList;
      this.comboBoxDeviceWakeup.FormattingEnabled = true;
      this.comboBoxDeviceWakeup.Name = "comboBoxDeviceWakeup";
      this.comboBoxDeviceWakeup.SelectedIndexChanged += new System.EventHandler(this.comboBoxDeviceWakeup_SelectedIndexChanged);
      componentResourceManager.ApplyResources((object) this.comboBoxTransceiverDevice, "comboBoxTransceiverDevice");
      this.comboBoxTransceiverDevice.DropDownStyle = ComboBoxStyle.DropDownList;
      this.comboBoxTransceiverDevice.FormattingEnabled = true;
      this.comboBoxTransceiverDevice.Name = "comboBoxTransceiverDevice";
      this.comboBoxTransceiverDevice.SelectedIndexChanged += new System.EventHandler(this.comboBoxTransceiverDevice_SelectedIndexChanged);
      this.tabPageTiming.Controls.Add((Control) this.panelTiming);
      componentResourceManager.ApplyResources((object) this.tabPageTiming, "tabPageTiming");
      this.tabPageTiming.Name = "tabPageTiming";
      this.tabPageTiming.UseVisualStyleBackColor = true;
      this.panelTiming.Controls.Add((Control) this.buttonDefaultTiming);
      this.panelTiming.Controls.Add((Control) this.label3);
      this.panelTiming.Controls.Add((Control) this.textBoxWaitBeforeRepeatTime);
      this.panelTiming.Controls.Add((Control) this.label29);
      this.panelTiming.Controls.Add((Control) this.label8);
      this.panelTiming.Controls.Add((Control) this.textBoxRecTime_BeforFirstByte);
      this.panelTiming.Controls.Add((Control) this.textBoxRecTime_OffsetPerBlock);
      this.panelTiming.Controls.Add((Control) this.textBoxRecTime_OffsetPerByte);
      this.panelTiming.Controls.Add((Control) this.label4);
      this.panelTiming.Controls.Add((Control) this.label9);
      this.panelTiming.Controls.Add((Control) this.textBoxBreakIntervalTime);
      this.panelTiming.Controls.Add((Control) this.label7);
      this.panelTiming.Controls.Add((Control) this.textBoxRecTime_GlobalOffset);
      this.panelTiming.Controls.Add((Control) this.label11);
      this.panelTiming.Controls.Add((Control) this.textBoxTransTime_AfterOpen);
      this.panelTiming.Controls.Add((Control) this.textBoxTransTime_AfterBreak);
      this.panelTiming.Controls.Add((Control) this.textBoxRecTransTime);
      this.panelTiming.Controls.Add((Control) this.label10);
      this.panelTiming.Controls.Add((Control) this.textBoxTransTime_BreakTime);
      this.panelTiming.Controls.Add((Control) this.label15);
      this.panelTiming.Controls.Add((Control) this.label6);
      componentResourceManager.ApplyResources((object) this.panelTiming, "panelTiming");
      this.panelTiming.Name = "panelTiming";
      componentResourceManager.ApplyResources((object) this.buttonDefaultTiming, "buttonDefaultTiming");
      this.buttonDefaultTiming.Name = "buttonDefaultTiming";
      this.buttonDefaultTiming.UseVisualStyleBackColor = true;
      this.buttonDefaultTiming.Click += new System.EventHandler(this.buttonDefaultTiming_Click);
      componentResourceManager.ApplyResources((object) this.label29, "label29");
      this.label29.Name = "label29";
      componentResourceManager.ApplyResources((object) this.label15, "label15");
      this.label15.Name = "label15";
      this.tabPageLogger.Controls.Add((Control) this.LoggerBox);
      this.tabPageLogger.Controls.Add((Control) this.groupBoxLoggerSetup);
      componentResourceManager.ApplyResources((object) this.tabPageLogger, "tabPageLogger");
      this.tabPageLogger.Name = "tabPageLogger";
      this.tabPageLogger.UseVisualStyleBackColor = true;
      this.tabPageTerminal.Controls.Add((Control) this.radioButtonASCIdirect);
      this.tabPageTerminal.Controls.Add((Control) this.radioButtonASCI);
      this.tabPageTerminal.Controls.Add((Control) this.radioButtonHex);
      this.tabPageTerminal.Controls.Add((Control) this.label27);
      this.tabPageTerminal.Controls.Add((Control) this.buttonTransmit);
      this.tabPageTerminal.Controls.Add((Control) this.splitContainer1);
      componentResourceManager.ApplyResources((object) this.tabPageTerminal, "tabPageTerminal");
      this.tabPageTerminal.Name = "tabPageTerminal";
      this.tabPageTerminal.UseVisualStyleBackColor = true;
      componentResourceManager.ApplyResources((object) this.radioButtonASCIdirect, "radioButtonASCIdirect");
      this.radioButtonASCIdirect.Name = "radioButtonASCIdirect";
      this.radioButtonASCIdirect.UseVisualStyleBackColor = true;
      this.radioButtonASCIdirect.CheckedChanged += new System.EventHandler(this.radioButtonASCIdirect_CheckedChanged);
      componentResourceManager.ApplyResources((object) this.radioButtonASCI, "radioButtonASCI");
      this.radioButtonASCI.Name = "radioButtonASCI";
      this.radioButtonASCI.UseVisualStyleBackColor = true;
      componentResourceManager.ApplyResources((object) this.radioButtonHex, "radioButtonHex");
      this.radioButtonHex.Checked = true;
      this.radioButtonHex.Name = "radioButtonHex";
      this.radioButtonHex.TabStop = true;
      this.radioButtonHex.UseVisualStyleBackColor = true;
      componentResourceManager.ApplyResources((object) this.label27, "label27");
      this.label27.Name = "label27";
      componentResourceManager.ApplyResources((object) this.buttonTransmit, "buttonTransmit");
      this.buttonTransmit.Name = "buttonTransmit";
      this.buttonTransmit.Click += new System.EventHandler(this.buttonTransmit_Click);
      this.timerTerminal.Tick += new System.EventHandler(this.timerTerminal_Tick);
      componentResourceManager.ApplyResources((object) this.zennerCoroprateDesign1, "zennerCoroprateDesign1");
      this.zennerCoroprateDesign1.Name = "zennerCoroprateDesign1";
      componentResourceManager.ApplyResources((object) this, "$this");
      this.Controls.Add((Control) this.buttonOpenClose);
      this.Controls.Add((Control) this.tabControl1);
      this.Controls.Add((Control) this.buttonSet);
      this.Controls.Add((Control) this.cancel);
      this.Controls.Add((Control) this.ok);
      this.Controls.Add((Control) this.zennerCoroprateDesign1);
      this.Menu = this.mainMenu1;
      this.Name = nameof (ZR_AsyncCom);
      this.Activated += new System.EventHandler(this.ZR_AsyncCom_Activated);
      this.Load += new System.EventHandler(this.ZR_AsyncCom_Load);
      this.splitContainer1.Panel1.ResumeLayout(false);
      this.splitContainer1.Panel1.PerformLayout();
      this.splitContainer1.Panel2.ResumeLayout(false);
      this.splitContainer1.Panel2.PerformLayout();
      this.splitContainer1.EndInit();
      this.splitContainer1.ResumeLayout(false);
      this.groupBoxLoggerSetup.ResumeLayout(false);
      this.groupBoxLoggerSetup.PerformLayout();
      this.tabControl1.ResumeLayout(false);
      this.tabPageBasic.ResumeLayout(false);
      this.panelBasic.ResumeLayout(false);
      this.panelBasic.PerformLayout();
      this.groupBoxRemoteCom.ResumeLayout(false);
      this.groupBoxRemoteCom.PerformLayout();
      this.tabPageEquipment.ResumeLayout(false);
      this.panelEquipment.ResumeLayout(false);
      this.panelEquipment.PerformLayout();
      this.groupBoxMinoConnect.ResumeLayout(false);
      this.groupBoxMinoConnect.PerformLayout();
      this.groupBoxCombiOptoHead.ResumeLayout(false);
      this.groupBoxCombiOptoHead.PerformLayout();
      this.groupBoxDeviceEcho.ResumeLayout(false);
      this.groupBoxWakeUp.ResumeLayout(false);
      this.tabPageTiming.ResumeLayout(false);
      this.panelTiming.ResumeLayout(false);
      this.panelTiming.PerformLayout();
      this.tabPageLogger.ResumeLayout(false);
      this.tabPageLogger.PerformLayout();
      this.tabPageTerminal.ResumeLayout(false);
      this.tabPageTerminal.PerformLayout();
      this.ResumeLayout(false);
    }

    private void SetEnabledFunctions()
    {
      bool flag1 = UserRights.GlobalUserRights.CheckRight(UserRights.Rights.DeviceCollector);
      bool flag2 = UserRights.GlobalUserRights.CheckRight(UserRights.Rights.Designer);
      bool flag3 = this.comboBoxTransceiverDevice.SelectedIndex == 1;
      bool flag4 = UserRights.GlobalUserRights.CheckRight(UserRights.Rights.Configurator);
      this.menuItemDeviceCollector.Visible = flag1;
      this.menuItemDesigner.Visible = flag2;
      this.menuItemConfigurator.Visible = flag4;
      this.groupBoxMinoConnect.Enabled = flag3;
    }

    internal void InitStartMenu(string ComponentList)
    {
      this.StartComponentName = "";
      if (ComponentList != null)
        return;
      this.menuStarten.Visible = false;
    }

    private void ComOpen_Click(object sender, EventArgs e)
    {
      this.SetValues();
      this.PrivatOpen();
    }

    private void ComClose_Click(object sender, EventArgs e) => this.PrivatClose();

    private void buttonOpenClose_Click(object sender, EventArgs e)
    {
      this.SetValues();
      if (this.ComX.ComIsOpen)
        this.PrivatClose();
      else
        this.PrivatOpen();
      this.btnUpgradeMinoConnectFirmware.Enabled = this.ComX.ComIsOpen && this.ComX.Transceiver == ZR_ClassLibrary.TransceiverDevice.MinoConnect;
    }

    private bool PrivatOpen()
    {
      this.Cursor = Cursors.WaitCursor;
      bool errorMessageBox = this.ComX.ErrorMessageBox;
      this.ComX.ErrorMessageBox = true;
      this.ComX.BreakRequest = false;
      if (this.comboBoxTransceiverDevice.SelectedIndex == 1)
      {
        this.tabControl1.SelectedTab = this.tabPageEquipment;
        Application.DoEvents();
        Thread.Sleep(0);
      }
      bool flag = this.ComX.Open();
      this.ComX.ErrorMessageBox = errorMessageBox;
      this.Cursor = Cursors.Default;
      return flag;
    }

    private void PrivatClose()
    {
      this.Cursor = Cursors.WaitCursor;
      this.ComX.BreakRequest = true;
      this.ComX.Close();
      this.SetComState();
      this.Cursor = Cursors.Default;
    }

    private void TestHalloWorld_Click(object sender, EventArgs e)
    {
      string str = "Hallo World\n\r";
      ByteField DataBlock = new ByteField(str.Length);
      for (int index = 0; index < str.Length; ++index)
        DataBlock.Add((byte) str[index]);
      this.ComX.TransmitBlock(ref DataBlock);
    }

    private void menuLesen_Click(object sender, EventArgs e)
    {
      string DataString = "";
      ByteField DataBlock = new ByteField();
      this.ComX.ReceiveBlock(ref DataBlock, 10, true);
      DataBlock.ToHexString(ref DataString);
      int num = (int) MessageBox.Show(DataString);
    }

    private void menuItem7_Click(object sender, EventArgs e)
    {
      ArrayList FullNames = new ArrayList();
      Assembly assembly1 = Assembly.GetAssembly(typeof (AsyncFunctions));
      FullNames.Add((object) assembly1.FullName);
      Assembly assembly2 = Assembly.GetAssembly(typeof (ZR_About));
      FullNames.Add((object) assembly2.FullName);
      new ZR_About(FullNames).Show();
    }

    private void timerTerminal_Tick(object sender, EventArgs e)
    {
      if (!this.ComX.ComIsOpen)
      {
        this.timerTerminal.Enabled = false;
        if (!this.ComX.Open())
        {
          this.textBoxTerminal.AppendText(" *Com open error* Terminal stopped!" + Environment.NewLine);
          return;
        }
        this.timerTerminal.Enabled = true;
      }
      string DataString;
      if (!this.ComX.ReceiveString(out DataString))
      {
        this.timerTerminal.Enabled = false;
        string str = " *Receive error* Terminal stopped!" + Environment.NewLine;
      }
      if (DataString.Length <= 0)
        return;
      this.textBoxTerminal.AppendText(DataString);
    }

    private void textBoxType_Enter(object sender, EventArgs e)
    {
      if (!this.radioButtonASCIdirect.Checked)
        return;
      this.timerTerminal.Enabled = true;
    }

    private void textBoxType_Leave(object sender, EventArgs e)
    {
      this.timerTerminal.Enabled = false;
    }

    private void radioButtonASCIdirect_CheckedChanged(object sender, EventArgs e)
    {
      if (this.radioButtonASCIdirect.Checked)
      {
        this.textBoxType.Clear();
        this.buttonTransmit.Enabled = false;
      }
      else
        this.buttonTransmit.Enabled = true;
    }

    private void buttonTransmit_Click(object sender, EventArgs e)
    {
      this.Cursor = Cursors.WaitCursor;
      this.Enabled = false;
      try
      {
        if (this.radioButtonHex.Checked)
        {
          List<byte> byteList = new List<byte>();
          string str1 = this.textBoxType.Text.Replace("\r", "");
          char[] chArray = new char[1]{ ' ' };
          foreach (string str2 in str1.Split(chArray))
          {
            string s = str2.Trim();
            if (s.Length >= 1 && s.Length <= 2)
              byteList.Add(byte.Parse(s, NumberStyles.HexNumber));
          }
          ByteField DataBlock1 = new ByteField(byteList.Count);
          for (int index = 0; index < byteList.Count; ++index)
            DataBlock1.Add(byteList[index]);
          if (!this.ComX.Open())
            return;
          this.textBoxTerminal.Clear();
          if (!this.ComX.TransmitBlock(ref DataBlock1))
          {
            int num = (int) GMM_MessageBox.ShowMessage("AsymcCom terminal message", "Transmit error");
            return;
          }
          ByteField DataBlock2 = new ByteField(300);
          this.ComX.ReceiveBlock(ref DataBlock2, 300, true);
          if (DataBlock2.Count > 0)
          {
            int index = 0;
            while (index < DataBlock2.Count)
            {
              this.textBoxTerminal.AppendText(DataBlock2.Data[index].ToString("x2"));
              this.textBoxTerminal.AppendText(" ");
              ++index;
              if ((index & 15) == 0)
                this.textBoxTerminal.AppendText(Environment.NewLine);
            }
          }
          else
            this.textBoxTerminal.Text = "No answer";
        }
      }
      catch
      {
      }
      this.Cursor = Cursors.Default;
      this.Enabled = true;
    }

    private void textBoxType_TextChanged(object sender, EventArgs e)
    {
      if (!this.radioButtonASCIdirect.Checked || this.textBoxType.Text.Length == 0)
        return;
      string text = this.textBoxType.Text;
      this.textBoxType.Clear();
      if (!this.ComX.ComIsOpen)
        return;
      this.timerTerminal.Enabled = true;
      if (!this.ComX.TransmitString(text))
      {
        this.timerTerminal.Enabled = false;
        this.textBoxTerminal.AppendText(" *TransmitError*" + Environment.NewLine);
      }
      else
        this.textBoxTerminal.AppendText(text);
    }

    private void menuItemHelp_Click(object sender, EventArgs e)
    {
    }

    private void buttonSet_Click(object sender, EventArgs e) => this.SetValues();

    private void cancel_Click(object sender, EventArgs e)
    {
      this.StartComponentName = "";
      this.Hide();
    }

    private void ok_Click(object sender, EventArgs e)
    {
      this.SetValues();
      this.StartComponentName = "";
      this.Hide();
    }

    private void ZR_AsyncCom_Activated(object sender, EventArgs e)
    {
      if (!this.LoggerIsOn)
        return;
      this.RefreshLogger();
    }

    private void ZR_AsyncCom_Load(object sender, EventArgs e)
    {
      this.StartComponentName = "";
      this.Hide();
    }

    private void SetValues()
    {
      if (this.ComX.ComIsOpen)
        return;
      try
      {
        this.ComX.EchoOn = this.SelectEchoOn.Checked;
        this.ComX.TestEcho = this.checkBoxTestEcho.Checked;
        this.ComX.Wakeup = (WakeupSystem) this.comboBoxDeviceWakeup.SelectedIndex;
        this.ComX.Baudrate = ZR_AsyncCom.BaudrateTable[this.Baudrate.SelectedIndex];
        this.ComX.ComPort = this.textBoxActiveComPort.Text;
        this.ComX.Parity = ZR_AsyncCom.ParityTable[this.listBoxParity.SelectedIndex];
        this.ComX.RecTime_BeforFirstByte = int.Parse(this.textBoxRecTime_BeforFirstByte.Text);
        this.ComX.RecTime_OffsetPerByte = double.Parse(this.textBoxRecTime_OffsetPerByte.Text);
        this.ComX.RecTime_OffsetPerBlock = int.Parse(this.textBoxRecTime_OffsetPerBlock.Text);
        this.ComX.RecTime_GlobalOffset = int.Parse(this.textBoxRecTime_GlobalOffset.Text);
        this.ComX.TransTime_AfterOpen = int.Parse(this.textBoxTransTime_AfterOpen.Text);
        this.ComX.TransTime_BreakTime = int.Parse(this.textBoxTransTime_BreakTime.Text);
        this.ComX.TransTime_AfterBreak = int.Parse(this.textBoxTransTime_AfterBreak.Text);
        this.ComX.RecTransTime = int.Parse(this.textBoxRecTransTime.Text);
        this.ComX.WakeupIntervalTime = int.Parse(this.textBoxBreakIntervalTime.Text);
        this.ComX.WaitBeforeRepeatTime = int.Parse(this.textBoxWaitBeforeRepeatTime.Text);
        this.ComX.Transceiver = (ZR_ClassLibrary.TransceiverDevice) this.comboBoxTransceiverDevice.SelectedIndex;
        this.ComX.IrDa = this.checkBoxIrDa.Checked;
        this.ComX.IrDaDaveTailSide = this.checkBoxDoveTailSide.Checked;
        this.ComX.MinoConnectAutoPowerOffTime = int.Parse(this.textBoxAutoPowerOff.Text);
        this.ComX.MinoConnectIrDaPulseLength = int.Parse(this.textBoxIrDaPulseLength.Text);
        this.ComX.MinoConnectBaseState = (MinoConnectState.BaseStateEnum) Enum.Parse(typeof (MinoConnectState.BaseStateEnum), this.comboBoxSelectedMiConMode.SelectedItem.ToString());
        this.comboBoxSelectedMiConMode.BackColor = this.DefaultEnabledBackColor;
        if (this.ComX.ConnectionTypeSelected.ToString() != this.comboBoxComType.SelectedItem.ToString())
          this.listBoxAvailableComPorts.Items.Clear();
        this.ComX.SetType((AsyncComConnectionType) Enum.Parse(typeof (AsyncComConnectionType), this.comboBoxComType.SelectedItem.ToString(), false));
        this.ComX.RefreshComPorts();
        this.SetComState();
      }
      catch (Exception ex)
      {
        ZR_AsyncCom.logger.Error("Can not set value! Error: {0}", ex.Message);
      }
      this.SetLoggerEvents();
    }

    internal void SetComState()
    {
      this.EventsEnabled = false;
      if (this.ComX.ConnectionTypeSelected == AsyncComConnectionType.Remote || this.ComX.ConnectionTypeSelected == AsyncComConnectionType.Remote_VPN)
      {
        if (this.ComX.ConnectionTypeSelected == AsyncComConnectionType.Remote)
        {
          this.ComX.MyMeterVPN.SelectedCOMserver = this.textBoxCOMserverIP.Text;
          this.buttonCOMserverAdmin.Visible = false;
          this.textBoxCOMserverIP.Enabled = true;
        }
        else
        {
          this.buttonCOMserverAdmin.Visible = true;
          this.textBoxCOMserverIP.Enabled = false;
        }
        this.comboBoxAvailableCOMservers.Enabled = true;
        this.btnUpdateComServers.Enabled = true;
        this.comboBoxAvailableCOMservers.Items.Clear();
        string str = this.ComX.SingleParameter(CommParameter.COMserver, "");
        foreach (DictionaryEntry coMserver1 in this.ComX.MyMeterVPN.COMservers)
        {
          COMserver coMserver2 = (COMserver) coMserver1.Value;
          if (coMserver2.Online)
          {
            this.comboBoxAvailableCOMservers.Items.Add((object) coMserver2.Name);
            if (coMserver1.Key.ToString() == str)
              this.comboBoxAvailableCOMservers.Text = coMserver2.Name;
          }
        }
        foreach (DictionaryEntry coMserver3 in this.ComX.MyMeterVPN.COMservers)
        {
          COMserver coMserver4 = (COMserver) coMserver3.Value;
          if (!coMserver4.Online)
          {
            this.comboBoxAvailableCOMservers.Items.Add((object) ("*" + coMserver4.Name));
            if (coMserver3.Key.ToString() == str)
              this.comboBoxAvailableCOMservers.Text = coMserver4.Name;
          }
        }
      }
      else
      {
        this.buttonCOMserverAdmin.Visible = false;
        this.comboBoxAvailableCOMservers.Enabled = false;
        this.btnUpdateComServers.Enabled = false;
        this.textBoxCOMserverIP.Enabled = false;
      }
      this.EventsEnabled = true;
      this.Baudrate.SelectedIndex = this.GetBaudrateIndex(this.ComX.Baudrate);
      this.listBoxParity.SelectedIndex = this.GetParityIndex(this.ComX.Parity);
      this.textBoxTransTime_AfterOpen.Text = this.ComX.TransTime_AfterOpen.ToString();
      this.textBoxTransTime_AfterBreak.Text = this.ComX.TransTime_AfterBreak.ToString();
      this.textBoxRecTime_BeforFirstByte.Text = this.ComX.RecTime_BeforFirstByte.ToString();
      this.textBoxRecTime_OffsetPerByte.Text = this.ComX.RecTime_OffsetPerByte.ToString();
      this.textBoxRecTime_OffsetPerBlock.Text = this.ComX.RecTime_OffsetPerBlock.ToString();
      this.textBoxRecTime_GlobalOffset.Text = this.ComX.RecTime_GlobalOffset.ToString();
      this.textBoxTransTime_BreakTime.Text = this.ComX.TransTime_BreakTime.ToString();
      this.textBoxRecTransTime.Text = this.ComX.RecTransTime.ToString();
      this.textBoxBreakIntervalTime.Text = this.ComX.WakeupIntervalTime.ToString();
      this.textBoxWaitBeforeRepeatTime.Text = this.ComX.WaitBeforeRepeatTime.ToString();
      this.comboBoxDeviceWakeup.SelectedIndex = (int) this.ComX.Wakeup;
      this.ShowEcho();
      this.checkBoxIrDa.Checked = this.ComX.IrDa;
      this.checkBoxDoveTailSide.Checked = this.ComX.IrDaDaveTailSide;
      this.comboBoxTransceiverDevice.SelectedIndex = (int) this.ComX.Transceiver;
      this.textBoxAutoPowerOff.Text = this.ComX.MinoConnectAutoPowerOffTime.ToString();
      this.textBoxIrDaPulseLength.Text = this.ComX.MinoConnectIrDaPulseLength.ToString();
      string str1 = this.ComX.MinoConnectBaseState.ToString();
      this.comboBoxSelectedMiConMode.SelectedIndex = -1;
      for (int index = 0; index < this.comboBoxSelectedMiConMode.Items.Count; ++index)
      {
        if (this.comboBoxSelectedMiConMode.Items[index].ToString() == str1)
        {
          this.comboBoxSelectedMiConMode.SelectedIndex = index;
          break;
        }
      }
      this.comboBoxSelectedMiConMode.BackColor = this.DefaultEnabledBackColor;
      this.textBoxActiveComPort.Text = this.ComX.ComPort;
      this.SetPortListIndex(this.ComX.ComPort);
      this.listBoxAvailableComPorts.Enabled = true;
      this.SetComOpenState();
      this.buttonSet.Enabled = false;
    }

    public void SetComOpenState()
    {
      this.textBoxTransceiverDeviceInfo.Text = this.ComX.transceiverDeviceInfo;
      if (this.ComX.ComIsOpen)
      {
        this.buttonOpenClose.Image = Images.pics.Close_16x16.Image;
        this.panelBasic.Enabled = false;
        this.panelTiming.Enabled = false;
        this.groupBoxMinoConnect.Enabled = false;
        this.groupBoxDeviceEcho.Enabled = false;
        this.groupBoxWakeUp.Enabled = false;
        this.comboBoxTransceiverDevice.Enabled = false;
        this.textBoxMinoConnectState.Visible = true;
      }
      else
      {
        this.buttonOpenClose.Image = Images.pics.Open_16x16.Image;
        this.panelBasic.Enabled = true;
        this.panelTiming.Enabled = true;
        this.groupBoxMinoConnect.Enabled = this.comboBoxTransceiverDevice.SelectedIndex == 1;
        this.groupBoxDeviceEcho.Enabled = true;
        this.groupBoxWakeUp.Enabled = true;
        this.comboBoxTransceiverDevice.Enabled = true;
        this.textBoxMinoConnectState.Visible = false;
      }
    }

    private void SetPortListIndex(string PortString)
    {
      int num = -1;
      if (this.ComX.ConnectionTypeSelected != 0)
      {
        for (int index = 0; index < this.listBoxAvailableComPorts.Items.Count; ++index)
        {
          if (this.listBoxAvailableComPorts.Items[index].ToString() == PortString)
          {
            num = index;
            break;
          }
        }
      }
      else
      {
        for (int index = 0; index < this.listBoxAvailableComPorts.Items.Count; ++index)
        {
          string str = this.listBoxAvailableComPorts.Items[index].ToString();
          int length = str.IndexOf(' ');
          if (length > 0)
            str = str.Substring(0, length);
          if (str == PortString.Trim())
          {
            num = index;
            break;
          }
        }
      }
      if (num >= 0)
        this.textBoxActiveComPort.BackColor = Control.DefaultBackColor;
      else
        this.textBoxActiveComPort.BackColor = Color.Red;
      this.listBoxAvailableComPorts.SelectedIndex = num;
    }

    private void PresetDefaultTimeouts()
    {
      int Baudrate = ZR_AsyncCom.BaudrateTable[this.Baudrate.SelectedIndex];
      this.textBoxRecTime_GlobalOffset.Text = 0.ToString();
      this.textBoxRecTime_BeforFirstByte.Text = this.ComX.TimeBevorFirstByteDefaultFromBaudrate(Baudrate).ToString();
      this.textBoxRecTime_OffsetPerByte.Text = 0.0.ToString();
      this.textBoxRecTime_OffsetPerBlock.Text = 50.ToString();
      this.textBoxTransTime_BreakTime.Text = 700.ToString();
      this.textBoxTransTime_AfterBreak.Text = 50.ToString();
      this.textBoxTransTime_AfterOpen.Text = 200.ToString();
      this.textBoxRecTransTime.Text = 10.ToString();
      this.textBoxBreakIntervalTime.Text = 10000.ToString();
      this.textBoxWaitBeforeRepeatTime.Text = 200.ToString();
      this.buttonSet.Enabled = true;
    }

    private int GetBaudrateIndex(int BaudrateValue)
    {
      for (int baudrateIndex = 0; baudrateIndex < ZR_AsyncCom.BaudrateTable.Length; ++baudrateIndex)
      {
        if (ZR_AsyncCom.BaudrateTable[baudrateIndex] == BaudrateValue)
          return baudrateIndex;
      }
      return 5;
    }

    private int GetParityIndex(string ParityValue)
    {
      for (int parityIndex = 0; parityIndex < ZR_AsyncCom.ParityTable.Length; ++parityIndex)
      {
        if (ZR_AsyncCom.ParityTable[parityIndex] == ParityValue)
          return parityIndex;
      }
      return 1;
    }

    private void menuItemStartWindow_Click(object sender, EventArgs e)
    {
      this.StartComponentName = "StartWindow";
      this.Hide();
    }

    private void menuStartGlobalMeterManager_Click(object sender, EventArgs e)
    {
      this.StartComponentName = "GMM";
      this.Hide();
    }

    private void menuItemSerialBus_Click(object sender, EventArgs e)
    {
      this.StartComponentName = "DeviceCollector";
      this.Hide();
    }

    private void menuItemDesigner_Click(object sender, EventArgs e)
    {
      this.StartComponentName = "Designer";
      this.Hide();
    }

    private void menuItemConfigurator_Click(object sender, EventArgs e)
    {
      this.StartComponentName = "Configurator";
      this.Hide();
    }

    private void menuItemSetBreak_Click(object sender, EventArgs e) => this.ComX.SetBreak();

    private void menuItemClearBreak_Click(object sender, EventArgs e) => this.ComX.ClearBreak();

    private void menuBack_Click(object sender, EventArgs e)
    {
      this.StartComponentName = "";
      this.Hide();
    }

    private void menuQuit_Click(object sender, EventArgs e)
    {
      this.StartComponentName = "Exit";
      this.Hide();
    }

    internal void ShowEcho()
    {
      this.SelectEchoOn.Checked = this.ComX.EchoOn;
      this.checkBoxTestEcho.Checked = this.ComX.TestEcho;
      if (this.ComX.TestEcho)
        this.SelectEchoOn.Enabled = false;
      else
        this.SelectEchoOn.Enabled = true;
    }

    private void UpdateComPortList(bool ForceRefresh)
    {
      ZR_ClassLibMessages.ClearErrors();
      string strComPortIds = "";
      this.listBoxAvailableComPorts.Items.Clear();
      this.listBoxAvailableComPorts.Enabled = false;
      if (!this.ComX.GetComPortIds(out strComPortIds, ForceRefresh))
      {
        this.Cursor = Cursors.Default;
        if (ZR_ClassLibMessages.GetLastError() == 0)
          return;
        int num = (int) MessageBox.Show(ZR_ClassLibMessages.GetLastErrorStringTranslated());
      }
      else
      {
        string[] strArray = strComPortIds.Split(',');
        SortedDictionary<int, string> sortedDictionary = new SortedDictionary<int, string>();
        foreach (string str in strArray)
        {
          if (str.StartsWith("COM"))
          {
            int result = -1;
            if (int.TryParse(str.Substring(3), out result) && !sortedDictionary.ContainsKey(result))
              sortedDictionary.Add(result, str);
          }
        }
        foreach (string str in sortedDictionary.Values)
        {
          if (str.Length > 3)
            this.listBoxAvailableComPorts.Items.Add((object) str);
        }
        if (this.listBoxAvailableComPorts.Items.Count > 0)
          this.listBoxAvailableComPorts.SelectedItem = (object) ("COM" + this.ComX.SingleParameter(CommParameter.Port, ""));
        this.listBoxAvailableComPorts.Enabled = true;
      }
    }

    private void ComUpdateComPortList()
    {
      this.listBoxAvailableComPorts.Items.Clear();
      this.listBoxAvailableComPorts.Enabled = false;
      List<ValueItem> availableComPorts = Constants.GetAvailableComPorts();
      foreach (ValueItem valueItem in availableComPorts)
      {
        string str1 = valueItem.ToString();
        int startIndex = str1.IndexOf('{');
        string str2 = startIndex < 0 ? "" : str1.Substring(startIndex);
        this.listBoxAvailableComPorts.Items.Add((object) (valueItem.Value.PadRight(7) + str2));
      }
      string choosedComPort = this.ComX.SingleParameter(CommParameter.Port, "").Trim();
      int index = availableComPorts.FindIndex((Predicate<ValueItem>) (item => item.Value == choosedComPort));
      if (index >= 0)
        this.listBoxAvailableComPorts.SelectedIndex = index;
      this.listBoxAvailableComPorts.Enabled = true;
    }

    private void TheStatusChangedMessage(object sender, GMM_EventArgs TheMessage)
    {
      if (this.textBoxActiveComPort.InvokeRequired)
      {
        EventHandler<GMM_EventArgs> method = new EventHandler<GMM_EventArgs>(this.TheStatusChangedMessage);
        try
        {
          this.Invoke((Delegate) method, sender, (object) TheMessage);
        }
        catch (Exception ex)
        {
          ZR_AsyncCom.logger.Error(ex.Message);
        }
      }
      else
      {
        switch (TheMessage.TheMessageType)
        {
          case GMM_EventArgs.MessageType.Alive:
            this.textBoxMinoConnectRequests.Text = (long.Parse(this.textBoxMinoConnectRequests.Text) + 1L).ToString();
            break;
          case GMM_EventArgs.MessageType.KeyReceived:
            this.textBoxKeyCounter.Text = (int.Parse(this.textBoxKeyCounter.Text) + 1).ToString();
            break;
          case GMM_EventArgs.MessageType.StatusThreadStopped:
            this.textBoxOverloadCounter.Text = "0";
            this.textBoxMinoConnectRequests.Text = "0";
            this.textBoxKeyCounter.Text = "0";
            this.SetComOpenState();
            break;
          case GMM_EventArgs.MessageType.StatusChanged:
            this.SetComOpenState();
            this.ShowMinoConnectState();
            break;
          case GMM_EventArgs.MessageType.MinoConnectPlugMessage:
            this.SetComOpenState();
            break;
          case GMM_EventArgs.MessageType.Overload:
            this.textBoxOverloadCounter.Text = (int.Parse(this.textBoxOverloadCounter.Text) + 1).ToString();
            break;
          default:
            if (TheMessage.EventMessage.Length <= 0)
              break;
            this.textBoxTransceiverDeviceInfo.Text = TheMessage.EventMessage.Substring(1).Replace("\r\n", "").Replace("|", ZR_Constants.SystemNewLine);
            break;
        }
      }
    }

    private void ShowMinoConnectState()
    {
      if (!(this.ComX.MyComType is AsyncSerial) || !(((AsyncSerial) this.ComX.MyComType).MySerialPort is MinoConnectSerialPort))
        return;
      MinoConnectSerialPort serialPort = (MinoConnectSerialPort) ((AsyncSerial) this.ComX.MyComType).MySerialPort;
      if (serialPort.StateLastReceived == null)
        return;
      this.textBoxMinoConnectState.Text = serialPort.StateLastReceived.GetStateString(serialPort.StateRequired);
    }

    private void textBoxActiveComPort_Leave(object sender, EventArgs e)
    {
      this.SetPortListIndex(this.textBoxActiveComPort.Text);
    }

    private void comboBoxAvailableCOMservers_DrawItem(object sender, DrawItemEventArgs e)
    {
      Graphics graphics = e.Graphics;
      try
      {
        if (e.Index == -1 || this.comboBoxAvailableCOMservers.Items.Count <= 0 || this.comboBoxAvailableCOMservers.Items[e.Index] == null)
          return;
        string str = this.comboBoxAvailableCOMservers.Items[e.Index].ToString();
        SolidBrush solidBrush1 = new SolidBrush(!this.comboBoxAvailableCOMservers.Enabled ? SystemColors.Window : (!str.StartsWith("*") ? Color.Green : Color.Red));
        SolidBrush solidBrush2 = new SolidBrush(Color.White);
        graphics.FillRectangle((Brush) solidBrush1, e.Bounds);
        graphics.DrawString((string) this.comboBoxAvailableCOMservers.Items[e.Index], e.Font, (Brush) solidBrush2, (RectangleF) e.Bounds);
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show(ex.ToString());
      }
    }

    private void buttonRefreshPortList_Click(object sender, EventArgs e)
    {
      this.ComX.BreakRequest = false;
      if (this.ComX.ConnectionTypeSelected == AsyncComConnectionType.COM)
        this.ComUpdateComPortList();
      else
        this.UpdateComPortList(true);
    }

    private void comboBoxComType_SelectedIndexChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
    }

    private void checkBoxHardwareHandshake_CheckedChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
    }

    private void textBoxCOMserverIP_KeyPress(object sender, KeyPressEventArgs e)
    {
      this.buttonSet.Enabled = true;
      if (e.KeyChar != '\r')
        return;
      Cursor.Current = Cursors.WaitCursor;
      this.ComX.SingleParameter(CommParameter.COMserver, this.textBoxCOMserverIP.Text);
      this.SetComState();
      Cursor.Current = Cursors.Default;
    }

    private void comboBoxAvailableCOMservers_SelectedIndexChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
      if (!this.EventsEnabled || this.comboBoxAvailableCOMservers.Items.Count <= 0 || this.comboBoxAvailableCOMservers.SelectedIndex == -1)
        return;
      Cursor.Current = Cursors.WaitCursor;
      string ParameterValue = "";
      if (this.ComX.ConnectionTypeSelected == AsyncComConnectionType.Remote)
      {
        ParameterValue = this.comboBoxAvailableCOMservers.SelectedItem.ToString();
      }
      else
      {
        foreach (DictionaryEntry coMserver in this.ComX.MyMeterVPN.COMservers)
        {
          if (((COMserver) coMserver.Value).Name == this.comboBoxAvailableCOMservers.SelectedItem.ToString())
          {
            ParameterValue = coMserver.Key.ToString();
            break;
          }
        }
      }
      this.ComX.SingleParameter(CommParameter.COMserver, ParameterValue);
      this.listBoxAvailableComPorts.Items.Clear();
      if (this.ComX.ConnectionTypeSelected == AsyncComConnectionType.COM)
        this.ComUpdateComPortList();
      else
        this.UpdateComPortList(false);
      this.SetComState();
      Cursor.Current = Cursors.Default;
    }

    private void textBoxCOMserverIP_TextChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
    }

    private void buttonCOMserverAdmin_Click(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
      int num = (int) new ManageCOMservers(this.ComX).ShowDialog();
    }

    private void listBoxAvailableComPorts_SelectedIndexChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
      if (this.listBoxAvailableComPorts.SelectedIndex < 0)
        return;
      this.textBoxActiveComPort.BackColor = Control.DefaultBackColor;
      string str = this.listBoxAvailableComPorts.Items[this.listBoxAvailableComPorts.SelectedIndex].ToString().Trim();
      int length = str.IndexOf(' ');
      if (length > 0)
        str = str.Substring(0, length);
      this.textBoxActiveComPort.Text = str;
    }

    private void Baudrate_SelectedIndexChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
    }

    private void listBoxParity_SelectedIndexChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
    }

    private void comboBoxTransceiverDevice_SelectedIndexChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
      this.groupBoxMinoConnect.Enabled = this.comboBoxTransceiverDevice.SelectedIndex == 1;
    }

    private void checkBoxTestEcho_CheckedChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
      if (this.checkBoxTestEcho.Checked)
        this.SelectEchoOn.Enabled = false;
      else
        this.SelectEchoOn.Enabled = true;
    }

    private void SelectEchoOn_CheckedChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
    }

    private void comboBoxDeviceWakeup_SelectedIndexChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
    }

    private void checkBoxIrDa_CheckedChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
      if (this.checkBoxIrDa.Checked)
      {
        this.checkBoxDoveTailSide.Enabled = true;
      }
      else
      {
        this.checkBoxDoveTailSide.Enabled = false;
        this.checkBoxDoveTailSide.Checked = false;
      }
    }

    private void checkBoxDoveTailSide_CheckedChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
    }

    private void comboBoxSelectedPlugState_SelectedIndexChanged(object sender, EventArgs e)
    {
      this.buttonSet.Enabled = true;
      if (this.comboBoxSelectedMiConMode.SelectedIndex < 0 || this.comboBoxSelectedMiConMode.SelectedItem.ToString() == this.ComX.MinoConnectBaseState.ToString())
        this.comboBoxSelectedMiConMode.BackColor = this.DefaultEnabledBackColor;
      else
        this.comboBoxSelectedMiConMode.BackColor = Color.LightPink;
    }

    private void TimeChanged(object sender, EventArgs e) => this.buttonSet.Enabled = true;

    private void menuItemSearchUSB_Click(object sender, EventArgs e)
    {
    }

    private void btnUpgradeMinoConnectFirmware_Click(object sender, EventArgs e)
    {
      if (this.ComX.MyComType == null || !this.ComX.ComIsOpen || this.comboBoxTransceiverDevice.SelectedIndex != 1 || !this.ComX.CallTransceiverFunction(TransceiverDeviceFunction.DisableMinoConnectPolling) || !(this.ComX.MyComType.GetChannel() is SerialPort channel))
        return;
      FlashMinoConnectGmmForm minoConnectGmmForm = new FlashMinoConnectGmmForm(channel);
      minoConnectGmmForm.FirmwareInitialDirectory = SystemValues.SettingsPath;
      int num = (int) minoConnectGmmForm.ShowDialog();
      if (minoConnectGmmForm.IsMinoConnectSuccessfulUpdated)
      {
        this.btnUpgradeMinoConnectFirmware.Enabled = false;
        this.PrivatClose();
      }
      else
        this.ComX.CallTransceiverFunction(TransceiverDeviceFunction.EnableMinoConnectPolling);
    }

    private void checkBoxLoggerOn_CheckedChanged(object sender, EventArgs e)
    {
      if (this.checkBoxLoggerOn.Checked)
      {
        this.LoggerIsOn = true;
        this.SetLoggerEvents();
        this.RefreshLogger();
      }
      else
      {
        this.LoggerIsOn = false;
        this.LoggerBox.Visible = false;
        this.SetLoggerEvents();
        this.RefreshLogger();
      }
    }

    private void buttonClearLogger_Click(object sender, EventArgs e)
    {
      int MaxEvents = 100;
      try
      {
        MaxEvents = int.Parse(this.textBoxLoggerEntries.Text);
      }
      catch
      {
        this.textBoxLoggerEntries.Text = "100";
      }
      this.ComX.Logger.NewLogger(MaxEvents);
      this.SetLoggerEvents();
      this.RefreshLogger();
    }

    private void buttonRefreshLogger_Click(object sender, EventArgs e) => this.RefreshLogger();

    private void SetLoggerEvents()
    {
      this.ComX.Logger.ActiveLoggerEvents = 0;
      if (!this.LoggerIsOn)
        return;
      if (this.checkBoxComOpenClose.Checked)
        this.ComX.Logger.ActiveLoggerEvents |= 256;
      if (this.checkBoxComData.Checked)
        this.ComX.Logger.ActiveLoggerEvents |= 512;
      if (this.checkBoxComState.Checked)
        this.ComX.Logger.ActiveLoggerEvents |= 1024;
      if (this.checkBoxComErrors.Checked)
        this.ComX.Logger.ActiveLoggerEvents |= 2048;
      if (this.checkBoxComPolling.Checked)
        this.ComX.Logger.ActiveLoggerEvents |= 4096;
      if (this.checkBoxBusFunctions.Checked)
        this.ComX.Logger.ActiveLoggerEvents |= 8192;
      if (this.checkBoxBusStatus.Checked)
        this.ComX.Logger.ActiveLoggerEvents |= 16384;
      if (this.checkBoxBusErrors.Checked)
        this.ComX.Logger.ActiveLoggerEvents |= 32768;
      int MaxEvents = 100;
      try
      {
        MaxEvents = int.Parse(this.textBoxLoggerEntries.Text);
      }
      catch
      {
        this.textBoxLoggerEntries.Text = "100";
      }
      if (MaxEvents == this.ComX.Logger.MaxLoggerEvents)
        return;
      this.ComX.Logger.NewLogger(MaxEvents);
    }

    private void RefreshLogger()
    {
      if (!this.LoggerIsOn)
      {
        this.LoggerBox.Text = string.Empty;
        this.LoggerBox.Visible = false;
      }
      else
      {
        this.ComX.Logger.StartReadout();
        StringBuilder stringBuilder = new StringBuilder(5000);
        bool nextLine;
        do
        {
          string EventLine;
          nextLine = this.ComX.Logger.GetNextLine(out EventLine);
          stringBuilder.Append(EventLine);
        }
        while (nextLine);
        this.LoggerBox.Text = stringBuilder.ToString();
        this.LoggerBox.Visible = true;
      }
    }

    private void menuItemFrameTestWindowActive_Click(object sender, EventArgs e)
    {
      if (this.menuItemFrameTestWindowActive.Checked)
      {
        this.ComX.MBusFrameTestWindowOn = false;
        this.menuItemFrameTestWindowActive.Checked = false;
      }
      else
      {
        this.ComX.MBusFrameTestWindowOn = true;
        this.menuItemFrameTestWindowActive.Checked = true;
      }
    }

    private void buttonDefaultTiming_Click(object sender, EventArgs e)
    {
      this.PresetDefaultTimeouts();
    }

    private void menuItemSendWakeup_Click(object sender, EventArgs e)
    {
      if (!(this.ComX.MyComType is AsyncSerial))
        return;
      this.Cursor = Cursors.WaitCursor;
      AsyncSerial comType = (AsyncSerial) this.ComX.MyComType;
      this.menuItemWakeupLoopOn.Checked = true;
      while (this.menuItemWakeupLoopOn.Checked)
      {
        Application.DoEvents();
        this.ComX.LastWakeupRefreshTime = DateTime.MinValue;
        comType.ManageWakeup();
      }
      this.Cursor = Cursors.Default;
    }

    private void menuItemWakeupLoopOn_Click(object sender, EventArgs e)
    {
      this.menuItemWakeupLoopOn.Checked = !this.menuItemWakeupLoopOn.Checked;
    }

    private void btnUpdateComServers_Click(object sender, EventArgs e)
    {
      this.ComX.RefreshComPorts();
      this.SetComState();
    }
  }
}

