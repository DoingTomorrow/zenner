
--- AliasedMember.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.AliasedMember
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public class AliasedMember
  {
    public AliasedMember(string member, string alias)
    {
      this.Member = member;
      this.Alias = alias;
    }

    public string Member { get; private set; }

    public string Alias { get; private set; }

    public bool Equals(AliasedMember other)
    {
      if (object.ReferenceEquals((object) null, (object) other))
        return false;
      if (object.ReferenceEquals((object) this, (object) other))
        return true;
      return object.Equals((object) other.Member, (object) this.Member) && object.Equals((object) other.Alias, (object) this.Alias);
    }

    public override bool Equals(object obj)
    {
      if (object.ReferenceEquals((object) null, obj))
        return false;
      if (object.ReferenceEquals((object) this, obj))
        return true;
      return (object) obj.GetType() == (object) typeof (AliasedMember) && this.Equals((AliasedMember) obj);
    }

    public override int GetHashCode() => this.Member.GetHashCode() * 397 ^ this.Alias.GetHashCode();
  }
}


--- AssemblyInfo.cs ---

﻿using System.Reflection;
using System.Runtime.CompilerServices;

[assembly: AssemblyTrademark("AutoMapper")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyConfiguration("release")]
[assembly: AssemblyProduct("AutoMapper")]
[assembly: AssemblyCopyright("Copyright Jimmy Bogard 2008-2013")]
[assembly: AssemblyInformationalVersion("85fcd02c46e99c12fe1306eeb2c57b866585dd04")]
[assembly: Extension]
[assembly: AssemblyFileVersion("3.1.1")]
[assembly: AssemblyVersion("3.1.1.0")]


--- AutoMapperConfigurationException.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.AutoMapperConfigurationException
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

#nullable disable
namespace AutoMapper
{
  public class AutoMapperConfigurationException : Exception
  {
    public AutoMapperConfigurationException.TypeMapConfigErrors[] Errors { get; private set; }

    public ResolutionContext Context { get; private set; }

    public AutoMapperConfigurationException(string message)
      : base(message)
    {
    }

    protected AutoMapperConfigurationException(string message, Exception inner)
      : base(message, inner)
    {
    }

    public AutoMapperConfigurationException(
      AutoMapperConfigurationException.TypeMapConfigErrors[] errors)
    {
      this.Errors = errors;
    }

    public AutoMapperConfigurationException(ResolutionContext context) => this.Context = context;

    public override string Message
    {
      get
      {
        if (this.Context != null)
        {
          ResolutionContext resolutionContext = this.Context;
          string str1 = string.Format("The following property on {0} cannot be mapped: \n\t{2}\nAdd a custom mapping expression, ignore, add a custom resolver, or modify the destination type {1}.", new object[3]
          {
            (object) resolutionContext.DestinationType.FullName,
            (object) resolutionContext.DestinationType.FullName,
            (object) resolutionContext.GetContextPropertyMap().DestinationProperty.Name
          }) + "\nContext:";
          for (; resolutionContext != null; resolutionContext = resolutionContext.Parent)
          {
            string str2 = str1;
            string str3;
            if (resolutionContext.GetContextPropertyMap() != null)
              str3 = string.Format("\n\tMapping to property {0} from {2} to {1}", new object[3]
              {
                (object) resolutionContext.GetContextPropertyMap().DestinationProperty.Name,
                (object) resolutionContext.DestinationType.FullName,
                (object) resolutionContext.SourceType.FullName
              });
            else
              str3 = string.Format("\n\tMapping from type {1} to {0}", new object[2]
              {
                (object) resolutionContext.DestinationType.FullName,
                (object) resolutionContext.SourceType.FullName
              });
            str1 = str2 + str3;
          }
          return str1 + "\n" + base.Message;
        }
        if (this.Errors == null)
          return base.Message;
        StringBuilder stringBuilder = new StringBuilder("\nUnmapped members were found. Review the types and members below.\nAdd a custom mapping expression, ignore, add a custom resolver, or modify the source/destination type\n");
        foreach (AutoMapperConfigurationException.TypeMapConfigErrors error in this.Errors)
        {
          int count = error.TypeMap.SourceType.FullName.Length + error.TypeMap.DestinationType.FullName.Length + 5;
          stringBuilder.AppendLine(new string('=', count));
          stringBuilder.AppendLine(error.TypeMap.SourceType.Name + " -> " + error.TypeMap.DestinationType.Name + " (" + (object) error.TypeMap.ConfiguredMemberList + " member list)");
          stringBuilder.AppendLine(error.TypeMap.SourceType.FullName + " -> " + error.TypeMap.DestinationType.FullName + " (" + (object) error.TypeMap.ConfiguredMemberList + " member list)");
          stringBuilder.AppendLine(new string('-', count));
          foreach (string unmappedPropertyName in error.UnmappedPropertyNames)
            stringBuilder.AppendLine(unmappedPropertyName);
        }
        return stringBuilder.ToString();
      }
    }

    public override string StackTrace
    {
      get
      {
        if (this.Errors == null)
          return base.StackTrace;
        return string.Join(Environment.NewLine, ((IEnumerable<string>) base.StackTrace.Split(new string[1]
        {
          Environment.NewLine
        }, StringSplitOptions.None)).Where<string>((Func<string, bool>) (str => !str.TrimStart().StartsWith("at AutoMapper."))).ToArray<string>());
      }
    }

    public class TypeMapConfigErrors
    {
      public TypeMap TypeMap { get; private set; }

      public string[] UnmappedPropertyNames { get; private set; }

      public TypeMapConfigErrors(TypeMap typeMap, string[] unmappedPropertyNames)
      {
        this.TypeMap = typeMap;
        this.UnmappedPropertyNames = unmappedPropertyNames;
      }
    }
  }
}


--- AutoMapperMappingException.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.AutoMapperMappingException
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

#nullable disable
namespace AutoMapper
{
  public class AutoMapperMappingException : Exception
  {
    private new string _message;

    public AutoMapperMappingException()
    {
    }

    public AutoMapperMappingException(string message)
      : base(message)
    {
      this._message = message;
    }

    public AutoMapperMappingException(string message, Exception inner)
      : base((string) null, inner)
    {
      this._message = message;
    }

    public AutoMapperMappingException(ResolutionContext context) => this.Context = context;

    public AutoMapperMappingException(ResolutionContext context, Exception inner)
      : base((string) null, inner)
    {
      this.Context = context;
    }

    public AutoMapperMappingException(ResolutionContext context, string message)
      : this(context)
    {
      this._message = message;
    }

    public ResolutionContext Context { get; private set; }

    public override string Message
    {
      get
      {
        string str1 = (string) null;
        string newLine = Environment.NewLine;
        if (this.Context != null)
        {
          string str2 = this._message + newLine + newLine + "Mapping types:" + newLine + string.Format("{0} -> {1}", new object[2]
          {
            (object) this.Context.SourceType.Name,
            (object) this.Context.DestinationType.Name
          }) + newLine + string.Format("{0} -> {1}", new object[2]
          {
            (object) this.Context.SourceType.FullName,
            (object) this.Context.DestinationType.FullName
          });
          string destPath = this.GetDestPath(this.Context);
          return str2 + newLine + newLine + "Destination path:" + newLine + destPath + newLine + newLine + "Source value:" + newLine + (this.Context.SourceValue ?? (object) "(null)");
        }
        if (this._message != null)
          str1 = this._message;
        return (str1 == null ? (string) null : str1 + newLine) + base.Message;
      }
    }

    private string GetDestPath(ResolutionContext context)
    {
      IEnumerable<ResolutionContext> source = AutoMapperMappingException.GetContexts(context).Reverse<ResolutionContext>();
      StringBuilder stringBuilder = new StringBuilder(source.First<ResolutionContext>().DestinationType.Name);
      foreach (ResolutionContext resolutionContext in source)
      {
        if (!string.IsNullOrEmpty(resolutionContext.MemberName))
        {
          stringBuilder.Append(".");
          stringBuilder.Append(resolutionContext.MemberName);
        }
        if (resolutionContext.ArrayIndex.HasValue)
          stringBuilder.AppendFormat("[{0}]", new object[1]
          {
            (object) resolutionContext.ArrayIndex
          });
      }
      return stringBuilder.ToString();
    }

    private static IEnumerable<ResolutionContext> GetContexts(ResolutionContext context)
    {
      for (; context.Parent != null; context = context.Parent)
        yield return context;
      yield return context;
    }

    public override string StackTrace
    {
      get
      {
        return string.Join(Environment.NewLine, ((IEnumerable<string>) base.StackTrace.Split(new string[1]
        {
          Environment.NewLine
        }, StringSplitOptions.None)).Where<string>((Func<string, bool>) (str => !str.TrimStart().StartsWith("at AutoMapper."))));
      }
    }
  }
}


--- ConfigurationStore.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ConfigurationStore
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Impl;
using AutoMapper.Internal;
using AutoMapper.Mappers;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public class ConfigurationStore : 
    IConfigurationProvider,
    IProfileConfiguration,
    IConfiguration,
    IProfileExpression,
    IFormatterExpression,
    IMappingOptions
  {
    internal const string DefaultProfileName = "";
    private static readonly IDictionaryFactory DictionaryFactory = PlatformAdapter.Resolve<IDictionaryFactory>();
    private readonly ITypeMapFactory _typeMapFactory;
    private readonly IEnumerable<IObjectMapper> _mappers;
    private readonly ThreadSafeList<TypeMap> _typeMaps = new ThreadSafeList<TypeMap>();
    private readonly AutoMapper.Internal.IDictionary<TypePair, TypeMap> _typeMapCache = ConfigurationStore.DictionaryFactory.CreateDictionary<TypePair, TypeMap>();
    private readonly AutoMapper.Internal.IDictionary<string, FormatterExpression> _formatterProfiles = ConfigurationStore.DictionaryFactory.CreateDictionary<string, FormatterExpression>();
    private Func<Type, object> _serviceCtor = new Func<Type, object>(ObjectCreator.CreateObject);
    private readonly List<string> _globalIgnore;

    public ConfigurationStore(ITypeMapFactory typeMapFactory, IEnumerable<IObjectMapper> mappers)
    {
      this._typeMapFactory = typeMapFactory;
      this._mappers = mappers;
      this._globalIgnore = new List<string>();
    }

    public event EventHandler<TypeMapCreatedEventArgs> TypeMapCreated;

    public Func<Type, object> ServiceCtor => this._serviceCtor;

    public bool AllowNullDestinationValues
    {
      get => this.GetProfile("").AllowNullDestinationValues;
      set => this.GetProfile("").AllowNullDestinationValues = value;
    }

    public bool AllowNullCollections
    {
      get => this.GetProfile("").AllowNullCollections;
      set => this.GetProfile("").AllowNullCollections = value;
    }

    public void IncludeSourceExtensionMethods(Assembly assembly)
    {
      this.GetProfile("").IncludeSourceExtensionMethods(assembly);
    }

    public INamingConvention SourceMemberNamingConvention
    {
      get => this.GetProfile("").SourceMemberNamingConvention;
      set => this.GetProfile("").SourceMemberNamingConvention = value;
    }

    public INamingConvention DestinationMemberNamingConvention
    {
      get => this.GetProfile("").DestinationMemberNamingConvention;
      set => this.GetProfile("").DestinationMemberNamingConvention = value;
    }

    public IEnumerable<string> Prefixes => this.GetProfile("").Prefixes;

    public IEnumerable<string> Postfixes => this.GetProfile("").Postfixes;

    public IEnumerable<string> DestinationPrefixes => this.GetProfile("").DestinationPrefixes;

    public IEnumerable<string> DestinationPostfixes => this.GetProfile("").DestinationPostfixes;

    public IEnumerable<AliasedMember> Aliases => this.GetProfile("").Aliases;

    public bool ConstructorMappingEnabled => this.GetProfile("").ConstructorMappingEnabled;

    public bool DataReaderMapperYieldReturnEnabled
    {
      get => this.GetProfile("").DataReaderMapperYieldReturnEnabled;
    }

    public IEnumerable<MethodInfo> SourceExtensionMethods
    {
      get => this.GetProfile("").SourceExtensionMethods;
    }

    bool IProfileConfiguration.MapNullSourceValuesAsNull => this.AllowNullDestinationValues;

    bool IProfileConfiguration.MapNullSourceCollectionsAsNull => this.AllowNullCollections;

    public IProfileExpression CreateProfile(string profileName)
    {
      Profile profile = new Profile(profileName);
      profile.Initialize(this);
      return (IProfileExpression) profile;
    }

    public void CreateProfile(string profileName, Action<IProfileExpression> profileConfiguration)
    {
      Profile profile = new Profile(profileName);
      profile.Initialize(this);
      profileConfiguration((IProfileExpression) profile);
    }

    public void AddProfile(Profile profile)
    {
      profile.Initialize(this);
      profile.Configure();
    }

    public void AddProfile<TProfile>() where TProfile : Profile, new()
    {
      this.AddProfile((Profile) new TProfile());
    }

    public void ConstructServicesUsing(Func<Type, object> constructor)
    {
      this._serviceCtor = constructor;
    }

    public void DisableConstructorMapping()
    {
      this.GetProfile("").ConstructorMappingEnabled = false;
    }

    public void EnableYieldReturnForDataReaderMapper()
    {
      this.GetProfile("").DataReaderMapperYieldReturnEnabled = true;
    }

    public void Seal()
    {
      this._typeMaps.Each<TypeMap>((Action<TypeMap>) (typeMap => typeMap.Seal()));
    }

    public IMappingExpression<TSource, TDestination> CreateMap<TSource, TDestination>()
    {
      return this.CreateMap<TSource, TDestination>("");
    }

    public IMappingExpression<TSource, TDestination> CreateMap<TSource, TDestination>(
      MemberList memberList)
    {
      return this.CreateMap<TSource, TDestination>("", memberList);
    }

    public IMappingExpression<TSource, TDestination> CreateMap<TSource, TDestination>(
      string profileName)
    {
      return this.CreateMap<TSource, TDestination>(profileName, MemberList.Destination);
    }

    public IMappingExpression<TSource, TDestination> CreateMap<TSource, TDestination>(
      string profileName,
      MemberList memberList)
    {
      return this.CreateMappingExpression<TSource, TDestination>(this.CreateTypeMap(typeof (TSource), typeof (TDestination), profileName, memberList));
    }

    public IMappingExpression CreateMap(Type sourceType, Type destinationType)
    {
      return this.CreateMap(sourceType, destinationType, MemberList.Destination);
    }

    public IMappingExpression CreateMap(
      Type sourceType,
      Type destinationType,
      MemberList memberList)
    {
      return this.CreateMap(sourceType, destinationType, memberList, "");
    }

    public IMappingExpression CreateMap(
      Type sourceType,
      Type destinationType,
      MemberList memberList,
      string profileName)
    {
      return this.CreateMappingExpression(this.CreateTypeMap(sourceType, destinationType, profileName, memberList), destinationType);
    }

    public void RecognizePrefixes(params string[] prefixes)
    {
      this.GetProfile("").RecognizePrefixes(prefixes);
    }

    public void RecognizePostfixes(params string[] postfixes)
    {
      this.GetProfile("").RecognizePostfixes(postfixes);
    }

    public void RecognizeAlias(string original, string alias)
    {
      this.GetProfile("").RecognizeAlias(original, alias);
    }

    public void RecognizeDestinationPrefixes(params string[] prefixes)
    {
      this.GetProfile("").RecognizeDestinationPrefixes(prefixes);
    }

    public void RecognizeDestinationPostfixes(params string[] postfixes)
    {
      this.GetProfile("").RecognizeDestinationPostfixes(postfixes);
    }

    public TypeMap CreateTypeMap(Type source, Type destination)
    {
      return this.CreateTypeMap(source, destination, "", MemberList.Destination);
    }

    public TypeMap CreateTypeMap(
      Type source,
      Type destination,
      string profileName,
      MemberList memberList)
    {
      TypeMap typeMap = this.FindExplicitlyDefinedTypeMap(source, destination);
      if (typeMap == null)
      {
        FormatterExpression profile = this.GetProfile(profileName);
        typeMap = this._typeMapFactory.CreateTypeMap(source, destination, (IMappingOptions) profile, memberList);
        typeMap.Profile = profileName;
        typeMap.IgnorePropertiesStartingWith = this._globalIgnore;
        this.IncludeBaseMappings(source, destination, typeMap);
        this._typeMaps.Add(typeMap);
        this._typeMapCache.AddOrUpdate(new TypePair(source, destination), typeMap, (Func<TypePair, TypeMap, TypeMap>) ((tp, tm) => typeMap));
        this.OnTypeMapCreated(typeMap);
      }
      return typeMap;
    }

    private void IncludeBaseMappings(Type source, Type destination, TypeMap typeMap)
    {
      foreach (TypeMap typeMap1 in this._typeMaps.Where<TypeMap>((Func<TypeMap, bool>) (t => t.TypeHasBeenIncluded(source, destination))))
      {
        foreach (PropertyMap propertyMap1 in typeMap1.GetPropertyMaps().Where<PropertyMap>((Func<PropertyMap, bool>) (m => m.IsMapped())))
        {
          PropertyMap inheritedMappedProperty = propertyMap1;
          PropertyMap propertyMap2 = typeMap.GetPropertyMaps().SingleOrDefault<PropertyMap>((Func<PropertyMap, bool>) (m => m.DestinationProperty.Name == inheritedMappedProperty.DestinationProperty.Name));
          if (propertyMap2 != null && inheritedMappedProperty.HasCustomValueResolver)
            propertyMap2.AssignCustomValueResolver(inheritedMappedProperty.GetSourceValueResolvers().First<IValueResolver>());
          else if (propertyMap2 == null)
          {
            PropertyMap mappedProperty = new PropertyMap(inheritedMappedProperty);
            typeMap.AddInheritedPropertyMap(mappedProperty);
          }
        }
        if (typeMap1.BeforeMap != null)
          typeMap.AddBeforeMapAction(typeMap1.BeforeMap);
        if (typeMap1.AfterMap != null)
          typeMap.AddAfterMapAction(typeMap1.AfterMap);
      }
    }

    public IFormatterCtorExpression<TValueFormatter> AddFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
    {
      return this.GetProfile("").AddFormatter<TValueFormatter>();
    }

    public IFormatterCtorExpression AddFormatter(Type valueFormatterType)
    {
      return this.GetProfile("").AddFormatter(valueFormatterType);
    }

    public void AddFormatter(IValueFormatter formatter)
    {
      this.GetProfile("").AddFormatter(formatter);
    }

    public void AddFormatExpression(Func<ResolutionContext, string> formatExpression)
    {
      this.GetProfile("").AddFormatExpression(formatExpression);
    }

    public void SkipFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
    {
      this.GetProfile("").SkipFormatter<TValueFormatter>();
    }

    public IFormatterExpression ForSourceType<TSource>()
    {
      return this.GetProfile("").ForSourceType<TSource>();
    }

    public TypeMap[] GetAllTypeMaps() => this._typeMaps.ToArray<TypeMap>();

    public TypeMap FindTypeMapFor(Type sourceType, Type destinationType)
    {
      return this.FindTypeMapFor((object) null, (object) null, sourceType, destinationType);
    }

    public TypeMap FindTypeMapFor(
      object source,
      object destination,
      Type sourceType,
      Type destinationType)
    {
      TypePair key = new TypePair(sourceType, destinationType);
      TypeMap typeMapFor;
      if (!this._typeMapCache.TryGetValue(key, out typeMapFor))
      {
        typeMapFor = this.FindTypeMap(source, destination, sourceType, destinationType, "");
        if (source == null || (object) source.GetType() == (object) sourceType)
          this._typeMapCache[key] = typeMapFor;
      }
      else if (source != null && typeMapFor != null && !typeMapFor.SourceType.IsAssignableFrom(source.GetType()))
        typeMapFor = this.FindTypeMapFor(source, destination, source.GetType(), destinationType);
      if (typeMapFor == null && destination != null && (object) destination.GetType() != (object) destinationType)
        typeMapFor = this.FindTypeMapFor(source, destination, sourceType, destination.GetType());
      if (typeMapFor != null && (object) typeMapFor.DestinationTypeOverride != null)
        return this.FindTypeMapFor(source, destination, sourceType, typeMapFor.DestinationTypeOverride);
      if (typeMapFor != null && typeMapFor.HasDerivedTypesToInclude() && source != null && (object) source.GetType() != (object) sourceType)
      {
        Type potentialSourceType = source.GetType();
        IEnumerable<TypeMap> source1 = this._typeMaps.Where<TypeMap>((Func<TypeMap, bool>) (t =>
        {
          if (!destinationType.IsAssignableFrom(t.DestinationType) || !t.SourceType.IsAssignableFrom(source.GetType()))
            return false;
          return destinationType.IsAssignableFrom(t.DestinationType) || (object) t.GetDerivedTypeFor(potentialSourceType) != null;
        }));
        TypeMap potentialDestTypeMap = source1.OrderByDescending<TypeMap, int>((Func<TypeMap, int>) (t => ConfigurationStore.GetInheritanceDepth(t.DestinationType))).FirstOrDefault<TypeMap>();
        List<TypeMap> list = source1.Where<TypeMap>((Func<TypeMap, bool>) (t => (object) t.DestinationType == (object) potentialDestTypeMap.DestinationType)).ToList<TypeMap>();
        if (list.Count > 1)
          potentialDestTypeMap = list.OrderByDescending<TypeMap, int>((Func<TypeMap, int>) (t => ConfigurationStore.GetInheritanceDepth(t.SourceType))).FirstOrDefault<TypeMap>();
        if (potentialDestTypeMap == typeMapFor)
          return typeMapFor;
        Type destinationType1 = potentialDestTypeMap.DestinationType;
        TypeMap explicitlyDefinedTypeMap = this.FindExplicitlyDefinedTypeMap(potentialSourceType, destinationType1);
        if (explicitlyDefinedTypeMap == null)
        {
          Type sourceType1 = (object) destinationType1 != (object) destinationType ? potentialSourceType : typeMapFor.SourceType;
          typeMapFor = this.FindTypeMap(source, destination, sourceType1, destinationType1, "");
        }
        else
          typeMapFor = explicitlyDefinedTypeMap;
      }
      return typeMapFor;
    }

    private static int GetInheritanceDepth(Type type)
    {
      return (object) type != null ? ConfigurationStore.InheritanceTree(type).Count<Type>() : throw new ArgumentNullException(nameof (type));
    }

    private static IEnumerable<Type> InheritanceTree(Type type)
    {
      for (; (object) type != null; type = type.BaseType)
        yield return type;
    }

    public TypeMap FindTypeMapFor(ResolutionResult resolutionResult, Type destinationType)
    {
      return this.FindTypeMapFor(resolutionResult.Value, (object) null, resolutionResult.Type, destinationType) ?? this.FindTypeMapFor(resolutionResult.Value, (object) null, resolutionResult.MemberType, destinationType);
    }

    public IFormatterConfiguration GetProfileConfiguration(string profileName)
    {
      return (IFormatterConfiguration) this.GetProfile(profileName);
    }

    public void AssertConfigurationIsValid(TypeMap typeMap)
    {
      this.AssertConfigurationIsValid(Enumerable.Repeat<TypeMap>(typeMap, 1));
    }

    public void AssertConfigurationIsValid(string profileName)
    {
      this.AssertConfigurationIsValid(this._typeMaps.Where<TypeMap>((Func<TypeMap, bool>) (typeMap => typeMap.Profile == profileName)));
    }

    public void AssertConfigurationIsValid()
    {
      this.AssertConfigurationIsValid((IEnumerable<TypeMap>) this._typeMaps);
    }

    public IObjectMapper[] GetMappers() => this._mappers.ToArray<IObjectMapper>();

    private IMappingExpression<TSource, TDestination> CreateMappingExpression<TSource, TDestination>(
      TypeMap typeMap)
    {
      IMappingExpression<TSource, TDestination> mappingExpression = (IMappingExpression<TSource, TDestination>) new MappingExpression<TSource, TDestination>(typeMap, this._serviceCtor, (IProfileExpression) this);
      foreach (MemberInfo publicWriteAccessor in new TypeInfo(typeof (TDestination)).GetPublicWriteAccessors())
      {
        if (((IEnumerable<object>) publicWriteAccessor.GetCustomAttributes(true)).Any<object>((Func<object, bool>) (x => x is IgnoreMapAttribute)))
          mappingExpression = mappingExpression.ForMember(publicWriteAccessor.Name, (Action<IMemberConfigurationExpression<TSource>>) (y => y.Ignore()));
      }
      return mappingExpression;
    }

    private IMappingExpression CreateMappingExpression(TypeMap typeMap, Type destinationType)
    {
      IMappingExpression mappingExpression = (IMappingExpression) new MappingExpression(typeMap, this._serviceCtor);
      foreach (MemberInfo publicWriteAccessor in new TypeInfo(destinationType).GetPublicWriteAccessors())
      {
        if (((IEnumerable<object>) publicWriteAccessor.GetCustomAttributes(true)).Any<object>((Func<object, bool>) (x => x is IgnoreMapAttribute)))
          mappingExpression = mappingExpression.ForMember(publicWriteAccessor.Name, (Action<IMemberConfigurationExpression>) (y => y.Ignore()));
      }
      return mappingExpression;
    }

    private void AssertConfigurationIsValid(IEnumerable<TypeMap> typeMaps)
    {
      AutoMapperConfigurationException.TypeMapConfigErrors[] array = typeMaps.Where<TypeMap>((Func<TypeMap, bool>) (typeMap => ConfigurationStore.ShouldCheckMap(typeMap))).Select(typeMap => new
      {
        typeMap = typeMap,
        unmappedPropertyNames = typeMap.GetUnmappedPropertyNames()
      }).Where(_param0 => _param0.unmappedPropertyNames.Length > 0).Select(_param0 => new AutoMapperConfigurationException.TypeMapConfigErrors(_param0.typeMap, _param0.unmappedPropertyNames)).ToArray<AutoMapperConfigurationException.TypeMapConfigErrors>();
      if (((IEnumerable<AutoMapperConfigurationException.TypeMapConfigErrors>) array).Any<AutoMapperConfigurationException.TypeMapConfigErrors>())
        throw new AutoMapperConfigurationException(array);
      List<TypeMap> typeMapsChecked = new List<TypeMap>();
      foreach (TypeMap typeMap in (IEnumerable<TypeMap>) this._typeMaps)
        this.DryRunTypeMap((ICollection<TypeMap>) typeMapsChecked, new ResolutionContext(typeMap, (object) null, typeMap.SourceType, typeMap.DestinationType, new MappingOperationOptions()));
    }

    private static bool ShouldCheckMap(TypeMap typeMap)
    {
      return typeMap.CustomMapper == null && !FeatureDetector.IsIDataRecordType(typeMap.SourceType);
    }

    private TypeMap FindTypeMap(
      object source,
      object destination,
      Type sourceType,
      Type destinationType,
      string profileName)
    {
      TypeMap typeMap = this.FindExplicitlyDefinedTypeMap(sourceType, destinationType);
      if (typeMap == null && destinationType.IsNullableType())
        typeMap = this.FindExplicitlyDefinedTypeMap(sourceType, destinationType.GetTypeOfNullable());
      if (typeMap == null)
      {
        typeMap = this._typeMaps.FirstOrDefault<TypeMap>((Func<TypeMap, bool>) (x => (object) x.SourceType == (object) sourceType && (object) x.GetDerivedTypeFor(sourceType) == (object) destinationType));
        if (typeMap == null)
        {
          foreach (Type sourceType1 in sourceType.GetInterfaces())
          {
            typeMap = this.FindTypeMapFor(source, destination, sourceType1, destinationType);
            if (typeMap != null)
            {
              Type derivedTypeFor = typeMap.GetDerivedTypeFor(sourceType);
              if ((object) derivedTypeFor != (object) destinationType)
              {
                typeMap = this.CreateTypeMap(sourceType, derivedTypeFor, profileName, typeMap.ConfiguredMemberList);
                break;
              }
              break;
            }
          }
          if ((object) sourceType.BaseType != null && typeMap == null)
            typeMap = this.FindTypeMapFor(source, destination, sourceType.BaseType, destinationType);
        }
      }
      return typeMap;
    }

    private TypeMap FindExplicitlyDefinedTypeMap(Type sourceType, Type destinationType)
    {
      return this._typeMaps.FirstOrDefault<TypeMap>((Func<TypeMap, bool>) (x => (object) x.DestinationType == (object) destinationType && (object) x.SourceType == (object) sourceType));
    }

    private void DryRunTypeMap(ICollection<TypeMap> typeMapsChecked, ResolutionContext context)
    {
      if (context.TypeMap != null)
        typeMapsChecked.Add(context.TypeMap);
      IObjectMapper objectMapper = ((IEnumerable<IObjectMapper>) this.GetMappers()).FirstOrDefault<IObjectMapper>((Func<IObjectMapper, bool>) (mapper => mapper.IsMatch(context)));
      if (objectMapper == null && context.SourceType.IsNullableType())
      {
        ResolutionContext nullableContext = context.CreateValueContext((object) null, Nullable.GetUnderlyingType(context.SourceType));
        objectMapper = ((IEnumerable<IObjectMapper>) this.GetMappers()).FirstOrDefault<IObjectMapper>((Func<IObjectMapper, bool>) (mapper => mapper.IsMatch(nullableContext)));
      }
      switch (objectMapper)
      {
        case null:
          throw new AutoMapperConfigurationException(context);
        case TypeMapMapper _:
          using (IEnumerator<PropertyMap> enumerator = context.TypeMap.GetPropertyMaps().GetEnumerator())
          {
            while (enumerator.MoveNext())
            {
              PropertyMap current = enumerator.Current;
              if (!current.IsIgnored())
              {
                IMemberResolver memberResolver = current.GetSourceValueResolvers().OfType<IMemberResolver>().LastOrDefault<IMemberResolver>();
                if (memberResolver != null)
                {
                  Type memberType1 = memberResolver.MemberType;
                  Type memberType2 = current.DestinationProperty.MemberType;
                  TypeMap memberTypeMap = this.FindTypeMapFor(memberType1, memberType2);
                  if (!typeMapsChecked.Any<TypeMap>((Func<TypeMap, bool>) (typeMap => object.Equals((object) typeMap, (object) memberTypeMap))))
                  {
                    ResolutionContext memberContext = context.CreateMemberContext(memberTypeMap, (object) null, (object) null, memberType1, current);
                    this.DryRunTypeMap(typeMapsChecked, memberContext);
                  }
                }
              }
            }
            break;
          }
        case ArrayMapper _:
        case EnumerableMapper _:
        case CollectionMapper _:
          Type elementType1 = AutoMapper.Mappers.TypeHelper.GetElementType(context.SourceType);
          Type elementType2 = AutoMapper.Mappers.TypeHelper.GetElementType(context.DestinationType);
          TypeMap itemTypeMap = this.FindTypeMapFor(elementType1, elementType2);
          if (typeMapsChecked.Any<TypeMap>((Func<TypeMap, bool>) (typeMap => object.Equals((object) typeMap, (object) itemTypeMap))))
            break;
          ResolutionContext elementContext = context.CreateElementContext(itemTypeMap, (object) null, elementType1, elementType2, 0);
          this.DryRunTypeMap(typeMapsChecked, elementContext);
          break;
      }
    }

    protected void OnTypeMapCreated(TypeMap typeMap)
    {
      EventHandler<TypeMapCreatedEventArgs> typeMapCreated = this.TypeMapCreated;
      if (typeMapCreated == null)
        return;
      typeMapCreated((object) this, new TypeMapCreatedEventArgs(typeMap));
    }

    internal FormatterExpression GetProfile(string profileName)
    {
      return this._formatterProfiles.GetOrAdd(profileName, (Func<string, FormatterExpression>) (name => new FormatterExpression((Func<Type, IValueFormatter>) (t => (IValueFormatter) this._serviceCtor(t)))));
    }

    public void AddGlobalIgnore(string startingwith) => this._globalIgnore.Add(startingwith);
  }
}


--- ConstructorMap.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ConstructorMap
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Internal;
using System;
using System.Collections.Generic;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public class ConstructorMap
  {
    private static readonly IDelegateFactory DelegateFactory = PlatformAdapter.Resolve<IDelegateFactory>();
    private readonly LateBoundParamsCtor _runtimeCtor;

    public ConstructorInfo Ctor { get; private set; }

    public IEnumerable<ConstructorParameterMap> CtorParams { get; private set; }

    public ConstructorMap(ConstructorInfo ctor, IEnumerable<ConstructorParameterMap> ctorParams)
    {
      this.Ctor = ctor;
      this.CtorParams = ctorParams;
      this._runtimeCtor = ConstructorMap.DelegateFactory.CreateCtor(ctor, this.CtorParams);
    }

    public object ResolveValue(ResolutionContext context, IMappingEngineRunner mappingEngine)
    {
      List<object> objectList = new List<object>();
      foreach (ConstructorParameterMap ctorParam in this.CtorParams)
      {
        ResolutionResult resolutionResult = ctorParam.ResolveValue(context);
        Type type = resolutionResult.Type;
        Type parameterType = ctorParam.Parameter.ParameterType;
        TypeMap typeMapFor = mappingEngine.ConfigurationProvider.FindTypeMapFor(resolutionResult, parameterType);
        Type sourceType = typeMapFor != null ? typeMapFor.SourceType : type;
        ResolutionContext typeContext = context.CreateTypeContext(typeMapFor, resolutionResult.Value, (object) null, sourceType, parameterType);
        object obj = mappingEngine.Map(typeContext);
        objectList.Add(obj);
      }
      return this._runtimeCtor(objectList.ToArray());
    }
  }
}


--- ConstructorParameterMap.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ConstructorParameterMap
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public class ConstructorParameterMap
  {
    public ConstructorParameterMap(ParameterInfo parameter, IMemberGetter[] sourceResolvers)
    {
      this.Parameter = parameter;
      this.SourceResolvers = sourceResolvers;
    }

    public ParameterInfo Parameter { get; private set; }

    public IMemberGetter[] SourceResolvers { get; private set; }

    public ResolutionResult ResolveValue(ResolutionContext context)
    {
      return ((IEnumerable<IMemberGetter>) this.SourceResolvers).Aggregate<IMemberGetter, ResolutionResult>(new ResolutionResult(context), (Func<ResolutionResult, IMemberGetter, ResolutionResult>) ((current, resolver) => resolver.Resolve(current)));
    }
  }
}


--- DefaultResolver.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.DefaultResolver
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public class DefaultResolver : IValueResolver
  {
    public ResolutionResult Resolve(ResolutionResult source) => source.New(source.Value);
  }
}


--- DeferredInstantiatedConverter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.DeferredInstantiatedConverter
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public class DeferredInstantiatedConverter : ITypeConverter<object, object>
  {
    private readonly Func<ResolutionContext, object> _instantiator;
    private readonly MethodInfo _converterMethod;

    public DeferredInstantiatedConverter(
      Type typeConverterType,
      Func<ResolutionContext, object> instantiator)
    {
      this._instantiator = instantiator;
      this._converterMethod = typeConverterType.GetMethod("Convert");
    }

    public object Convert(ResolutionContext context)
    {
      return this._converterMethod.Invoke(this._instantiator(context), (object[]) new ResolutionContext[1]
      {
        context
      });
    }
  }
}


--- DeferredInstantiatedConverter`2.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.DeferredInstantiatedConverter`2
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public class DeferredInstantiatedConverter<TSource, TDestination> : 
    ITypeConverter<TSource, TDestination>
  {
    private readonly Func<ResolutionContext, ITypeConverter<TSource, TDestination>> _instantiator;

    public DeferredInstantiatedConverter(
      Func<ResolutionContext, ITypeConverter<TSource, TDestination>> instantiator)
    {
      this._instantiator = instantiator;
    }

    public TDestination Convert(ResolutionContext context)
    {
      return this._instantiator(context).Convert(context);
    }
  }
}


--- DeferredInstantiatedFormatter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.DeferredInstantiatedFormatter
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public class DeferredInstantiatedFormatter : IValueFormatter
  {
    private readonly Func<ResolutionContext, IValueFormatter> _instantiator;

    public DeferredInstantiatedFormatter(
      Func<ResolutionContext, IValueFormatter> instantiator)
    {
      this._instantiator = instantiator;
    }

    public string FormatValue(ResolutionContext context)
    {
      return this._instantiator(context).FormatValue(context);
    }

    public Type GetFormatterType(ResolutionContext context)
    {
      return this._instantiator(context).GetType();
    }
  }
}


--- DeferredInstantiatedResolver.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.DeferredInstantiatedResolver
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public class DeferredInstantiatedResolver : IValueResolver
  {
    private readonly Func<ResolutionContext, IValueResolver> _constructor;

    public DeferredInstantiatedResolver(
      Func<ResolutionContext, IValueResolver> constructor)
    {
      this._constructor = constructor;
    }

    public ResolutionResult Resolve(ResolutionResult source)
    {
      return this._constructor(source.Context).Resolve(source);
    }
  }
}


--- DelegateBasedResolver`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.DelegateBasedResolver`1
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public class DelegateBasedResolver<TSource> : IValueResolver
  {
    private readonly Func<TSource, object> _method;

    public DelegateBasedResolver(Func<TSource, object> method) => this._method = method;

    public ResolutionResult Resolve(ResolutionResult source)
    {
      if (source.Value != null && !(source.Value is TSource))
        throw new ArgumentException("Expected obj to be of type " + (object) typeof (TSource) + " but was " + (object) source.Value.GetType());
      object obj = this._method((TSource) source.Value);
      return source.New(obj);
    }
  }
}


--- DelegateBasedResolver`2.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.DelegateBasedResolver`2
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public class DelegateBasedResolver<TSource, TMember> : IMemberResolver, IValueResolver
  {
    private readonly Func<TSource, TMember> _method;

    public DelegateBasedResolver(Func<TSource, TMember> method) => this._method = method;

    public ResolutionResult Resolve(ResolutionResult source)
    {
      if (source.Value != null && !(source.Value is TSource))
        throw new ArgumentException("Expected obj to be of type " + (object) typeof (TSource) + " but was " + (object) source.Value.GetType());
      TMember member = this._method((TSource) source.Value);
      return source.New((object) member, this.MemberType);
    }

    public Type MemberType => typeof (TMember);
  }
}


--- DelegateFactory.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.DelegateFactory
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;

#nullable disable
namespace AutoMapper
{
  public class DelegateFactory : IDelegateFactory
  {
    private static readonly IDictionaryFactory DictionaryFactory = PlatformAdapter.Resolve<IDictionaryFactory>();
    private static readonly AutoMapper.Internal.IDictionary<Type, LateBoundCtor> _ctorCache = DelegateFactory.DictionaryFactory.CreateDictionary<Type, LateBoundCtor>();

    public LateBoundMethod CreateGet(MethodInfo method)
    {
      ParameterExpression instanceParameter;
      ParameterExpression argumentsParameter;
      return Expression.Lambda<LateBoundMethod>((Expression) Expression.Convert(method.IsDefined(typeof (ExtensionAttribute), false) ? (Expression) Expression.Call(method, DelegateFactory.CreateParameterExpressions(method, (Expression) instanceParameter, (Expression) argumentsParameter)) : (Expression) Expression.Call((Expression) Expression.Convert((Expression) instanceParameter, method.DeclaringType), method, DelegateFactory.CreateParameterExpressions(method, (Expression) instanceParameter, (Expression) argumentsParameter)), typeof (object)), instanceParameter, argumentsParameter).Compile();
    }

    public LateBoundPropertyGet CreateGet(PropertyInfo property)
    {
      ParameterExpression parameterExpression;
      return Expression.Lambda<LateBoundPropertyGet>((Expression) Expression.Convert((Expression) Expression.Property((Expression) Expression.Convert((Expression) parameterExpression, property.DeclaringType), property), typeof (object)), parameterExpression).Compile();
    }

    public LateBoundFieldGet CreateGet(FieldInfo field)
    {
      ParameterExpression parameterExpression;
      return Expression.Lambda<LateBoundFieldGet>((Expression) Expression.Convert((Expression) Expression.Field((Expression) Expression.Convert((Expression) parameterExpression, field.DeclaringType), field), typeof (object)), parameterExpression).Compile();
    }

    public virtual LateBoundFieldSet CreateSet(FieldInfo field)
    {
      return (LateBoundFieldSet) ((target, value) => field.SetValue(target, value));
    }

    public virtual LateBoundPropertySet CreateSet(PropertyInfo property)
    {
      return (LateBoundPropertySet) ((target, value) => property.SetValue(target, value, (object[]) null));
    }

    public LateBoundCtor CreateCtor(Type type)
    {
      return DelegateFactory._ctorCache.GetOrAdd(type, (Func<Type, LateBoundCtor>) (t => ((Expression<LateBoundCtor>) (() => (object) Expression.New(type))).Compile()));
    }

    private static Expression[] CreateParameterExpressions(
      MethodInfo method,
      Expression instanceParameter,
      Expression argumentsParameter)
    {
      List<UnaryExpression> unaryExpressionList = new List<UnaryExpression>();
      ParameterInfo[] source = method.GetParameters();
      if (method.IsDefined(typeof (ExtensionAttribute), false))
      {
        Type parameterType = method.GetParameters()[0].ParameterType;
        unaryExpressionList.Add(Expression.Convert(instanceParameter, parameterType));
        source = ((IEnumerable<ParameterInfo>) source).Skip<ParameterInfo>(1).ToArray<ParameterInfo>();
      }
      unaryExpressionList.AddRange(((IEnumerable<ParameterInfo>) source).Select<ParameterInfo, UnaryExpression>((Func<ParameterInfo, int, UnaryExpression>) ((parameter, index) => Expression.Convert((Expression) Expression.ArrayIndex(argumentsParameter, (Expression) Expression.Constant((object) index)), parameter.ParameterType))));
      return (Expression[]) unaryExpressionList.ToArray();
    }

    public LateBoundParamsCtor CreateCtor(
      ConstructorInfo constructorInfo,
      IEnumerable<ConstructorParameterMap> ctorParams)
    {
      ParameterExpression paramsExpr = Expression.Parameter(typeof (object[]), "parameters");
      UnaryExpression[] array = ctorParams.Select<ConstructorParameterMap, UnaryExpression>((Func<ConstructorParameterMap, int, UnaryExpression>) ((ctorParam, i) => Expression.Convert((Expression) Expression.ArrayIndex((Expression) paramsExpr, (Expression) Expression.Constant((object) i)), ctorParam.Parameter.ParameterType))).ToArray<UnaryExpression>();
      return Expression.Lambda<LateBoundParamsCtor>((Expression) Expression.New(constructorInfo, (Expression[]) array), paramsExpr).Compile();
    }
  }
}


--- EnumerableExtensions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.EnumerableExtensions
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace AutoMapper
{
  public static class EnumerableExtensions
  {
    public static void Each<T>(this IEnumerable<T> items, Action<T> action)
    {
      foreach (T obj in items)
        action(obj);
    }
  }
}


--- ExpressionResolutionResult.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ExpressionResolutionResult
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Linq.Expressions;

#nullable disable
namespace AutoMapper
{
  public class ExpressionResolutionResult
  {
    public Expression ResolutionExpression { get; private set; }

    public Type Type { get; private set; }

    public ExpressionResolutionResult(Expression resolutionExpression, Type type)
    {
      this.ResolutionExpression = resolutionExpression;
      this.Type = type;
    }
  }
}


--- ExpressionValueFormatter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ExpressionValueFormatter
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public class ExpressionValueFormatter : IValueFormatter
  {
    private readonly Func<ResolutionContext, string> _valueFormatterExpression;

    public ExpressionValueFormatter(
      Func<ResolutionContext, string> valueFormatterExpression)
    {
      this._valueFormatterExpression = valueFormatterExpression;
    }

    public string FormatValue(ResolutionContext context) => this._valueFormatterExpression(context);
  }
}


--- FormatterCtorExpression.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.FormatterCtorExpression
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public class FormatterCtorExpression : IFormatterCtorExpression
  {
    private readonly Type _formatterType;
    private readonly IFormatterCtorConfigurator _formatterCtorConfigurator;

    public FormatterCtorExpression(
      Type formatterType,
      IFormatterCtorConfigurator formatterCtorConfigurator)
    {
      this._formatterType = formatterType;
      this._formatterCtorConfigurator = formatterCtorConfigurator;
    }

    public void ConstructedBy(Func<IValueFormatter> constructor)
    {
      this._formatterCtorConfigurator.ConstructFormatterBy(this._formatterType, constructor);
    }
  }
}


--- FormatterCtorExpression`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.FormatterCtorExpression`1
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public class FormatterCtorExpression<TValueFormatter> : IFormatterCtorExpression<TValueFormatter> where TValueFormatter : IValueFormatter
  {
    private readonly IFormatterCtorConfigurator _formatterCtorConfigurator;

    public FormatterCtorExpression(
      IFormatterCtorConfigurator formatterCtorConfigurator)
    {
      this._formatterCtorConfigurator = formatterCtorConfigurator;
    }

    public void ConstructedBy(Func<TValueFormatter> constructor)
    {
      this._formatterCtorConfigurator.ConstructFormatterBy(typeof (TValueFormatter), (Func<IValueFormatter>) (() => (IValueFormatter) constructor()));
    }
  }
}


--- FormatterExpression.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.FormatterExpression
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;

#nullable disable
namespace AutoMapper
{
  public class FormatterExpression : 
    IFormatterExpression,
    IFormatterConfiguration,
    IProfileConfiguration,
    IFormatterCtorConfigurator,
    IMappingOptions
  {
    private readonly Func<Type, IValueFormatter> _formatterCtor;
    private readonly IList<IValueFormatter> _formatters = (IList<IValueFormatter>) new List<IValueFormatter>();
    private readonly IDictionary<Type, IFormatterConfiguration> _typeSpecificFormatters = (IDictionary<Type, IFormatterConfiguration>) new Dictionary<Type, IFormatterConfiguration>();
    private readonly IList<Type> _formattersToSkip = (IList<Type>) new List<Type>();
    private readonly ISet<string> _prefixes = (ISet<string>) new HashSet<string>();
    private readonly ISet<string> _postfixes = (ISet<string>) new HashSet<string>();
    private readonly ISet<string> _destinationPrefixes = (ISet<string>) new HashSet<string>();
    private readonly ISet<string> _destinationPostfixes = (ISet<string>) new HashSet<string>();
    private readonly ISet<AliasedMember> _aliases = (ISet<AliasedMember>) new HashSet<AliasedMember>();
    private readonly List<MethodInfo> _sourceExtensionMethods = new List<MethodInfo>();

    public FormatterExpression(Func<Type, IValueFormatter> formatterCtor)
    {
      this._formatterCtor = formatterCtor;
      this.SourceMemberNamingConvention = (INamingConvention) new PascalCaseNamingConvention();
      this.DestinationMemberNamingConvention = (INamingConvention) new PascalCaseNamingConvention();
      this.RecognizePrefixes("Get");
      this.AllowNullDestinationValues = true;
      this.ConstructorMappingEnabled = true;
      this.IncludeSourceExtensionMethods(typeof (Enumerable).Assembly);
    }

    public bool AllowNullDestinationValues { get; set; }

    public bool AllowNullCollections { get; set; }

    public INamingConvention SourceMemberNamingConvention { get; set; }

    public INamingConvention DestinationMemberNamingConvention { get; set; }

    public IEnumerable<string> Prefixes => (IEnumerable<string>) this._prefixes;

    public IEnumerable<string> Postfixes => (IEnumerable<string>) this._postfixes;

    public IEnumerable<string> DestinationPrefixes
    {
      get => (IEnumerable<string>) this._destinationPrefixes;
    }

    public IEnumerable<string> DestinationPostfixes
    {
      get => (IEnumerable<string>) this._destinationPostfixes;
    }

    public IEnumerable<AliasedMember> Aliases => (IEnumerable<AliasedMember>) this._aliases;

    public bool ConstructorMappingEnabled { get; set; }

    public bool DataReaderMapperYieldReturnEnabled { get; set; }

    public IEnumerable<MethodInfo> SourceExtensionMethods
    {
      get => (IEnumerable<MethodInfo>) this._sourceExtensionMethods;
    }

    public IFormatterCtorExpression<TValueFormatter> AddFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
    {
      this.AddFormatter((IValueFormatter) new DeferredInstantiatedFormatter(this.BuildCtor(typeof (TValueFormatter))));
      return (IFormatterCtorExpression<TValueFormatter>) new FormatterCtorExpression<TValueFormatter>((IFormatterCtorConfigurator) this);
    }

    public IFormatterCtorExpression AddFormatter(Type valueFormatterType)
    {
      this.AddFormatter((IValueFormatter) new DeferredInstantiatedFormatter(this.BuildCtor(valueFormatterType)));
      return (IFormatterCtorExpression) new FormatterCtorExpression(valueFormatterType, (IFormatterCtorConfigurator) this);
    }

    public void AddFormatter(IValueFormatter valueFormatter)
    {
      this._formatters.Add(valueFormatter);
    }

    public void AddFormatExpression(Func<ResolutionContext, string> formatExpression)
    {
      this._formatters.Add((IValueFormatter) new ExpressionValueFormatter(formatExpression));
    }

    public void SkipFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
    {
      this._formattersToSkip.Add(typeof (TValueFormatter));
    }

    public IFormatterExpression ForSourceType<TSource>()
    {
      FormatterExpression formatterExpression = new FormatterExpression(this._formatterCtor);
      this._typeSpecificFormatters[typeof (TSource)] = (IFormatterConfiguration) formatterExpression;
      return (IFormatterExpression) formatterExpression;
    }

    public IValueFormatter[] GetFormatters() => this._formatters.ToArray<IValueFormatter>();

    public IDictionary<Type, IFormatterConfiguration> GetTypeSpecificFormatters()
    {
      return (IDictionary<Type, IFormatterConfiguration>) new Dictionary<Type, IFormatterConfiguration>(this._typeSpecificFormatters);
    }

    public Type[] GetFormatterTypesToSkip() => this._formattersToSkip.ToArray<Type>();

    public IEnumerable<IValueFormatter> GetFormattersToApply(ResolutionContext context)
    {
      return this.GetFormatters(context);
    }

    private IEnumerable<IValueFormatter> GetFormatters(ResolutionContext context)
    {
      Type valueType = context.SourceType;
      IFormatterConfiguration typeSpecificFormatterConfig;
      if (context.PropertyMap != null)
      {
        foreach (IValueFormatter formatter in context.PropertyMap.GetFormatters())
          yield return formatter;
        if (this.GetTypeSpecificFormatters().TryGetValue(valueType, out typeSpecificFormatterConfig) && !context.PropertyMap.FormattersToSkipContains(typeSpecificFormatterConfig.GetType()))
        {
          foreach (IValueFormatter typeSpecificFormatter in typeSpecificFormatterConfig.GetFormattersToApply(context))
            yield return typeSpecificFormatter;
        }
      }
      else if (this.GetTypeSpecificFormatters().TryGetValue(valueType, out typeSpecificFormatterConfig))
      {
        foreach (IValueFormatter typeSpecificFormatter in typeSpecificFormatterConfig.GetFormattersToApply(context))
          yield return typeSpecificFormatter;
      }
      foreach (IValueFormatter formatter in this.GetFormatters())
      {
        Type formatterType = FormatterExpression.GetFormatterType(formatter, context);
        if (FormatterExpression.CheckPropertyMapSkipList(context, formatterType) && FormatterExpression.CheckTypeSpecificSkipList(typeSpecificFormatterConfig, formatterType))
          yield return formatter;
      }
    }

    public void ConstructFormatterBy(Type formatterType, Func<IValueFormatter> instantiator)
    {
      this._formatters.RemoveAt(this._formatters.Count - 1);
      this._formatters.Add((IValueFormatter) new DeferredInstantiatedFormatter((Func<ResolutionContext, IValueFormatter>) (ctxt => instantiator())));
    }

    public bool MapNullSourceValuesAsNull => this.AllowNullDestinationValues;

    public bool MapNullSourceCollectionsAsNull => this.AllowNullCollections;

    public void IncludeSourceExtensionMethods(Assembly assembly)
    {
      this._sourceExtensionMethods.AddRange(((IEnumerable<Type>) assembly.GetTypes()).Where<Type>((Func<Type, bool>) (type => type.IsSealed && !type.IsGenericType && !type.IsNested)).SelectMany<Type, MethodInfo>((Func<Type, IEnumerable<MethodInfo>>) (type => (IEnumerable<MethodInfo>) type.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic))).Where<MethodInfo>((Func<MethodInfo, bool>) (method => method.IsDefined(typeof (ExtensionAttribute), false))).Where<MethodInfo>((Func<MethodInfo, bool>) (method => method.GetParameters().Length == 1)));
    }

    public void RecognizePrefixes(params string[] prefixes)
    {
      foreach (string prefix in prefixes)
        this._prefixes.Add(prefix);
    }

    public void RecognizePostfixes(params string[] postfixes)
    {
      foreach (string postfix in postfixes)
        this._postfixes.Add(postfix);
    }

    public void RecognizeAlias(string original, string alias)
    {
      this._aliases.Add(new AliasedMember(original, alias));
    }

    public void RecognizeDestinationPrefixes(params string[] prefixes)
    {
      foreach (string prefix in prefixes)
        this._destinationPrefixes.Add(prefix);
    }

    public void RecognizeDestinationPostfixes(params string[] postfixes)
    {
      foreach (string postfix in postfixes)
        this._destinationPostfixes.Add(postfix);
    }

    private static Type GetFormatterType(IValueFormatter formatter, ResolutionContext context)
    {
      return !(formatter is DeferredInstantiatedFormatter) ? formatter.GetType() : ((DeferredInstantiatedFormatter) formatter).GetFormatterType(context);
    }

    private static bool CheckTypeSpecificSkipList(
      IFormatterConfiguration valueFormatter,
      Type formatterType)
    {
      return valueFormatter == null || !((IEnumerable<Type>) valueFormatter.GetFormatterTypesToSkip()).Contains<Type>(formatterType);
    }

    private static bool CheckPropertyMapSkipList(ResolutionContext context, Type formatterType)
    {
      return context.PropertyMap == null || !context.PropertyMap.FormattersToSkipContains(formatterType);
    }

    private Func<ResolutionContext, IValueFormatter> BuildCtor(Type type)
    {
      return (Func<ResolutionContext, IValueFormatter>) (context =>
      {
        if (context.Options.ServiceCtor != null)
        {
          object obj = context.Options.ServiceCtor(type);
          if (obj != null)
            return (IValueFormatter) obj;
        }
        return this._formatterCtor(type);
      });
    }

    private static string DefaultPrefixTransformer(string src, string prefix)
    {
      return src == null || string.IsNullOrEmpty(prefix) || !src.StartsWith(prefix, StringComparison.Ordinal) ? src : src.Substring(prefix.Length);
    }

    private static string DefaultPostfixTransformer(string src, string postfix)
    {
      return src == null || string.IsNullOrEmpty(postfix) || !src.EndsWith(postfix, StringComparison.Ordinal) ? src : src.Remove(src.Length - postfix.Length);
    }

    private static string DefaultAliasTransformer(string src, string original, string alias)
    {
      return src == null || string.IsNullOrEmpty(original) || !string.Equals(src, original, StringComparison.Ordinal) ? src : alias;
    }

    private static string DefaultSourceMemberNameTransformer(string src)
    {
      return src == null || !src.StartsWith("Get", StringComparison.Ordinal) ? src : src.Substring(3);
    }
  }
}


--- IConfiguration.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IConfiguration
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public interface IConfiguration : IProfileExpression, IFormatterExpression, IMappingOptions
  {
    IProfileExpression CreateProfile(string profileName);

    void CreateProfile(string profileName, Action<IProfileExpression> profileConfiguration);

    void AddProfile(Profile profile);

    void AddProfile<TProfile>() where TProfile : Profile, new();

    void ConstructServicesUsing(Func<Type, object> constructor);

    void DisableConstructorMapping();

    void Seal();

    void EnableYieldReturnForDataReaderMapper();
  }
}


--- IConfigurationProvider.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IConfigurationProvider
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public interface IConfigurationProvider : IProfileConfiguration
  {
    TypeMap[] GetAllTypeMaps();

    TypeMap FindTypeMapFor(
      object source,
      object destination,
      Type sourceType,
      Type destinationType);

    TypeMap FindTypeMapFor(Type sourceType, Type destinationType);

    TypeMap FindTypeMapFor(ResolutionResult resolutionResult, Type destinationType);

    IFormatterConfiguration GetProfileConfiguration(string profileName);

    void AssertConfigurationIsValid();

    void AssertConfigurationIsValid(TypeMap typeMap);

    void AssertConfigurationIsValid(string profileName);

    IObjectMapper[] GetMappers();

    TypeMap CreateTypeMap(Type sourceType, Type destinationType);

    event EventHandler<TypeMapCreatedEventArgs> TypeMapCreated;

    Func<Type, object> ServiceCtor { get; }
  }
}


--- IDelegateFactory.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IDelegateFactory
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Collections.Generic;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public interface IDelegateFactory
  {
    LateBoundMethod CreateGet(MethodInfo method);

    LateBoundPropertyGet CreateGet(PropertyInfo property);

    LateBoundFieldGet CreateGet(FieldInfo field);

    LateBoundFieldSet CreateSet(FieldInfo field);

    LateBoundPropertySet CreateSet(PropertyInfo property);

    LateBoundCtor CreateCtor(Type type);

    LateBoundParamsCtor CreateCtor(
      ConstructorInfo constructorInfo,
      IEnumerable<ConstructorParameterMap> ctorParams);
  }
}


--- IFormatterConfiguration.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IFormatterConfiguration
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace AutoMapper
{
  [Obsolete("Formatters should not be used")]
  public interface IFormatterConfiguration : IProfileConfiguration
  {
    [Obsolete("Formatters should not be used")]
    IValueFormatter[] GetFormatters();

    [Obsolete("Formatters should not be used")]
    IDictionary<Type, IFormatterConfiguration> GetTypeSpecificFormatters();

    [Obsolete("Formatters should not be used")]
    Type[] GetFormatterTypesToSkip();

    [Obsolete("Formatters should not be used")]
    IEnumerable<IValueFormatter> GetFormattersToApply(ResolutionContext context);
  }
}


--- IFormatterCtorConfigurator.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IFormatterCtorConfigurator
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public interface IFormatterCtorConfigurator
  {
    void ConstructFormatterBy(Type formatterType, Func<IValueFormatter> instantiator);
  }
}


--- IFormatterCtorExpression.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IFormatterCtorExpression
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  [Obsolete("Formatters should not be used.")]
  public interface IFormatterCtorExpression
  {
    void ConstructedBy(Func<IValueFormatter> constructor);
  }
}


--- IFormatterCtorExpression`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IFormatterCtorExpression`1
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  [Obsolete("Formatters should not be used.")]
  public interface IFormatterCtorExpression<TValueFormatter> where TValueFormatter : IValueFormatter
  {
    void ConstructedBy(Func<TValueFormatter> constructor);
  }
}


--- IFormatterExpression.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IFormatterExpression
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  [Obsolete("Formatters should not be used.")]
  public interface IFormatterExpression
  {
    [Obsolete("Formatters should not be used.")]
    IFormatterCtorExpression<TValueFormatter> AddFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter;

    [Obsolete("Formatters should not be used.")]
    IFormatterCtorExpression AddFormatter(Type valueFormatterType);

    [Obsolete("Formatters should not be used.")]
    void AddFormatter(IValueFormatter formatter);

    [Obsolete("Formatters should not be used.")]
    void AddFormatExpression(Func<ResolutionContext, string> formatExpression);

    [Obsolete("Formatters should not be used.")]
    void SkipFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter;

    [Obsolete("Formatters should not be used.")]
    IFormatterExpression ForSourceType<TSource>();
  }
}


--- IgnoreMapAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IgnoreMapAttribute
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
  public class IgnoreMapAttribute : Attribute
  {
  }
}


--- IMappingAction`2.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IMappingAction`2
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public interface IMappingAction<TSource, TDestination>
  {
    void Process(TSource source, TDestination destination);
  }
}


--- IMappingEngine.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IMappingEngine
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public interface IMappingEngine : IDisposable
  {
    IConfigurationProvider ConfigurationProvider { get; }

    TDestination Map<TDestination>(object source);

    TDestination Map<TDestination>(object source, Action<IMappingOperationOptions> opts);

    TDestination Map<TSource, TDestination>(TSource source);

    TDestination Map<TSource, TDestination>(TSource source, Action<IMappingOperationOptions> opts);

    TDestination Map<TSource, TDestination>(TSource source, TDestination destination);

    TDestination Map<TSource, TDestination>(
      TSource source,
      TDestination destination,
      Action<IMappingOperationOptions> opts);

    object Map(object source, Type sourceType, Type destinationType);

    object Map(
      object source,
      Type sourceType,
      Type destinationType,
      Action<IMappingOperationOptions> opts);

    object Map(object source, object destination, Type sourceType, Type destinationType);

    object Map(
      object source,
      object destination,
      Type sourceType,
      Type destinationType,
      Action<IMappingOperationOptions> opts);

    TDestination DynamicMap<TSource, TDestination>(TSource source);

    TDestination DynamicMap<TDestination>(object source);

    object DynamicMap(object source, Type sourceType, Type destinationType);

    void DynamicMap<TSource, TDestination>(TSource source, TDestination destination);

    void DynamicMap(object source, object destination, Type sourceType, Type destinationType);
  }
}


--- IMappingEngineRunner.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IMappingEngineRunner
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public interface IMappingEngineRunner
  {
    object Map(ResolutionContext context);

    object CreateObject(ResolutionContext context);

    string FormatValue(ResolutionContext context);

    IConfigurationProvider ConfigurationProvider { get; }

    bool ShouldMapSourceValueAsNull(ResolutionContext context);

    bool ShouldMapSourceCollectionAsNull(ResolutionContext context);
  }
}


--- IMappingExpression.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IMappingExpression
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public interface IMappingExpression
  {
    void ConvertUsing<TTypeConverter>();

    void ConvertUsing(Type typeConverterType);

    void As(Type typeOverride);

    IMappingExpression WithProfile(string profileName);

    IMappingExpression ForMember(
      string name,
      Action<IMemberConfigurationExpression> memberOptions);

    IMappingExpression ForSourceMember(
      string sourceMemberName,
      Action<ISourceMemberConfigurationExpression> memberOptions);
  }
}


--- IMappingExpression`2.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IMappingExpression`2
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Linq.Expressions;

#nullable disable
namespace AutoMapper
{
  public interface IMappingExpression<TSource, TDestination>
  {
    IMappingExpression<TSource, TDestination> ForMember(
      Expression<Func<TDestination, object>> destinationMember,
      Action<IMemberConfigurationExpression<TSource>> memberOptions);

    IMappingExpression<TSource, TDestination> ForMember(
      string name,
      Action<IMemberConfigurationExpression<TSource>> memberOptions);

    void ForAllMembers(
      Action<IMemberConfigurationExpression<TSource>> memberOptions);

    IMappingExpression<TSource, TDestination> Include<TOtherSource, TOtherDestination>()
      where TOtherSource : TSource
      where TOtherDestination : TDestination;

    IMappingExpression<TSource, TDestination> WithProfile(string profileName);

    void ConvertUsing(Func<TSource, TDestination> mappingFunction);

    void ConvertUsing(ITypeConverter<TSource, TDestination> converter);

    void ConvertUsing<TTypeConverter>() where TTypeConverter : ITypeConverter<TSource, TDestination>;

    IMappingExpression<TSource, TDestination> BeforeMap(Action<TSource, TDestination> beforeFunction);

    IMappingExpression<TSource, TDestination> BeforeMap<TMappingAction>() where TMappingAction : IMappingAction<TSource, TDestination>;

    IMappingExpression<TSource, TDestination> AfterMap(Action<TSource, TDestination> afterFunction);

    IMappingExpression<TSource, TDestination> AfterMap<TMappingAction>() where TMappingAction : IMappingAction<TSource, TDestination>;

    IMappingExpression<TSource, TDestination> ConstructUsing(Func<TSource, TDestination> ctor);

    IMappingExpression<TSource, TDestination> ConstructUsing(
      Func<ResolutionContext, TDestination> ctor);

    void As<T>();

    IMappingExpression<TSource, TDestination> MaxDepth(int depth);

    IMappingExpression<TSource, TDestination> ConstructUsingServiceLocator();

    IMappingExpression<TDestination, TSource> ReverseMap();

    IMappingExpression<TSource, TDestination> ForSourceMember(
      Expression<Func<TSource, object>> sourceMember,
      Action<ISourceMemberConfigurationExpression<TSource>> memberOptions);

    IMappingExpression<TSource, TDestination> ForSourceMember(
      string sourceMemberName,
      Action<ISourceMemberConfigurationExpression<TSource>> memberOptions);
  }
}


--- IMappingOperationOptions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IMappingOperationOptions
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace AutoMapper
{
  public interface IMappingOperationOptions
  {
    void ConstructServicesUsing(Func<Type, object> constructor);

    bool CreateMissingTypeMaps { get; set; }

    IDictionary<string, object> Items { get; }
  }
}


--- IMappingOptions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IMappingOptions
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System.Collections.Generic;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public interface IMappingOptions
  {
    INamingConvention SourceMemberNamingConvention { get; set; }

    INamingConvention DestinationMemberNamingConvention { get; set; }

    IEnumerable<string> Prefixes { get; }

    IEnumerable<string> Postfixes { get; }

    IEnumerable<string> DestinationPrefixes { get; }

    IEnumerable<string> DestinationPostfixes { get; }

    IEnumerable<AliasedMember> Aliases { get; }

    bool ConstructorMappingEnabled { get; }

    bool DataReaderMapperYieldReturnEnabled { get; }

    IEnumerable<MethodInfo> SourceExtensionMethods { get; }
  }
}


--- IMemberAccessor.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IMemberAccessor
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public interface IMemberAccessor : IMemberGetter, IMemberResolver, IValueResolver
  {
    void SetValue(object destination, object value);
  }
}


--- IMemberConfigurationExpression.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IMemberConfigurationExpression
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public interface IMemberConfigurationExpression
  {
    void MapFrom(string sourceMember);

    IResolutionExpression ResolveUsing(IValueResolver valueResolver);

    IResolverConfigurationExpression ResolveUsing(Type valueResolverType);

    IResolverConfigurationExpression ResolveUsing<TValueResolver>();

    void Ignore();
  }
}


--- IMemberConfigurationExpression`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IMemberConfigurationExpression`1
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Linq.Expressions;

#nullable disable
namespace AutoMapper
{
  public interface IMemberConfigurationExpression<TSource>
  {
    [Obsolete("Formatters should not be used.")]
    void SkipFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter;

    [Obsolete("Formatters should not be used.")]
    IFormatterCtorExpression<TValueFormatter> AddFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter;

    [Obsolete("Formatters should not be used.")]
    IFormatterCtorExpression AddFormatter(Type valueFormatterType);

    [Obsolete("Formatters should not be used.")]
    void AddFormatter(IValueFormatter formatter);

    void NullSubstitute(object nullSubstitute);

    IResolverConfigurationExpression<TSource, TValueResolver> ResolveUsing<TValueResolver>() where TValueResolver : IValueResolver;

    IResolverConfigurationExpression<TSource> ResolveUsing(Type valueResolverType);

    IResolutionExpression<TSource> ResolveUsing(IValueResolver valueResolver);

    void ResolveUsing(Func<TSource, object> resolver);

    void MapFrom<TMember>(Expression<Func<TSource, TMember>> sourceMember);

    void Ignore();

    void SetMappingOrder(int mappingOrder);

    void UseDestinationValue();

    void DoNotUseDestinationValue();

    void UseValue<TValue>(TValue value);

    void UseValue(object value);

    void Condition(Func<TSource, bool> condition);

    void Condition(Func<ResolutionContext, bool> condition);
  }
}


--- IMemberGetter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IMemberGetter
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public interface IMemberGetter : IMemberResolver, IValueResolver
  {
    MemberInfo MemberInfo { get; }

    string Name { get; }

    object GetValue(object source);
  }
}


--- IMemberResolver.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IMemberResolver
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public interface IMemberResolver : IValueResolver
  {
    Type MemberType { get; }
  }
}


--- INamingConvention.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.INamingConvention
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System.Text.RegularExpressions;

#nullable disable
namespace AutoMapper
{
  public interface INamingConvention
  {
    Regex SplittingExpression { get; }

    string SeparatorCharacter { get; }
  }
}


--- IObjectMapper.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IObjectMapper
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public interface IObjectMapper
  {
    object Map(ResolutionContext context, IMappingEngineRunner mapper);

    bool IsMatch(ResolutionContext context);
  }
}


--- IProfileConfiguration.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IProfileConfiguration
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public interface IProfileConfiguration
  {
    bool MapNullSourceValuesAsNull { get; }

    bool MapNullSourceCollectionsAsNull { get; }
  }
}


--- IProfileExpression.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IProfileExpression
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public interface IProfileExpression : IFormatterExpression, IMappingOptions
  {
    IMappingExpression<TSource, TDestination> CreateMap<TSource, TDestination>();

    IMappingExpression<TSource, TDestination> CreateMap<TSource, TDestination>(MemberList memberList);

    IMappingExpression CreateMap(Type sourceType, Type destinationType);

    IMappingExpression CreateMap(Type sourceType, Type destinationType, MemberList memberList);

    void RecognizePrefixes(params string[] prefixes);

    void RecognizePostfixes(params string[] postfixes);

    void RecognizeAlias(string original, string alias);

    void RecognizeDestinationPrefixes(params string[] prefixes);

    void RecognizeDestinationPostfixes(params string[] postfixes);

    void AddGlobalIgnore(string propertyNameStartingWith);

    bool AllowNullDestinationValues { get; set; }

    bool AllowNullCollections { get; set; }

    void IncludeSourceExtensionMethods(Assembly assembly);
  }
}


--- IResolutionExpression.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IResolutionExpression
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public interface IResolutionExpression
  {
    void FromMember(string sourcePropertyName);
  }
}


--- IResolutionExpression`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IResolutionExpression`1
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Linq.Expressions;

#nullable disable
namespace AutoMapper
{
  public interface IResolutionExpression<TSource> : IResolutionExpression
  {
    void FromMember(Expression<Func<TSource, object>> sourceMember);
  }
}


--- IResolverConfigurationExpression.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IResolverConfigurationExpression
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public interface IResolverConfigurationExpression : IResolutionExpression
  {
    IResolutionExpression ConstructedBy(Func<IValueResolver> constructor);
  }
}


--- IResolverConfigurationExpression`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IResolverConfigurationExpression`1
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public interface IResolverConfigurationExpression<TSource> : 
    IResolutionExpression<TSource>,
    IResolutionExpression
  {
    IResolutionExpression<TSource> ConstructedBy(Func<IValueResolver> constructor);
  }
}


--- IResolverConfigurationExpression`2.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IResolverConfigurationExpression`2
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Linq.Expressions;

#nullable disable
namespace AutoMapper
{
  public interface IResolverConfigurationExpression<TSource, TValueResolver> where TValueResolver : IValueResolver
  {
    IResolverConfigurationExpression<TSource, TValueResolver> FromMember(
      Expression<Func<TSource, object>> sourceMember);

    IResolverConfigurationExpression<TSource, TValueResolver> FromMember(string sourcePropertyName);

    IResolverConfigurationExpression<TSource, TValueResolver> ConstructedBy(
      Func<TValueResolver> constructor);
  }
}


--- ISourceMemberConfigurationExpression.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ISourceMemberConfigurationExpression
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public interface ISourceMemberConfigurationExpression
  {
    void Ignore();
  }
}


--- ISourceMemberConfigurationExpression`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ISourceMemberConfigurationExpression`1
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public interface ISourceMemberConfigurationExpression<TSource> : 
    ISourceMemberConfigurationExpression
  {
  }
}


--- ITypeConverter`2.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ITypeConverter`2
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public interface ITypeConverter<in TSource, out TDestination>
  {
    TDestination Convert(ResolutionContext context);
  }
}


--- ITypeMapFactory.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ITypeMapFactory
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public interface ITypeMapFactory
  {
    TypeMap CreateTypeMap(
      Type sourceType,
      Type destinationType,
      IMappingOptions mappingOptions,
      MemberList memberList);
  }
}


--- IValueFormatter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IValueFormatter
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  [Obsolete("Formatters should not be used")]
  public interface IValueFormatter
  {
    string FormatValue(ResolutionContext context);
  }
}


--- IValueResolver.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.IValueResolver
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public interface IValueResolver
  {
    ResolutionResult Resolve(ResolutionResult source);
  }
}


--- LateBoundCtor.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.LateBoundCtor
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public delegate object LateBoundCtor();
}


--- LateBoundFieldGet.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.LateBoundFieldGet
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public delegate object LateBoundFieldGet(object target);
}


--- LateBoundFieldSet.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.LateBoundFieldSet
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public delegate void LateBoundFieldSet(object target, object value);
}


--- LateBoundMethod.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.LateBoundMethod
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public delegate object LateBoundMethod(object target, object[] arguments);
}


--- LateBoundParamsCtor.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.LateBoundParamsCtor
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public delegate object LateBoundParamsCtor(params object[] parameters);
}


--- LateBoundPropertyGet.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.LateBoundPropertyGet
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public delegate object LateBoundPropertyGet(object target);
}


--- LateBoundPropertySet.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.LateBoundPropertySet
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public delegate void LateBoundPropertySet(object target, object value);
}


--- LateBoundValueTypeFieldSet.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.LateBoundValueTypeFieldSet
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public delegate void LateBoundValueTypeFieldSet(ref object target, object value);
}


--- LateBoundValueTypePropertySet.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.LateBoundValueTypePropertySet
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public delegate void LateBoundValueTypePropertySet(ref object target, object value);
}


--- LowerUnderscoreNamingConvention.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.LowerUnderscoreNamingConvention
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System.Text.RegularExpressions;

#nullable disable
namespace AutoMapper
{
  public class LowerUnderscoreNamingConvention : INamingConvention
  {
    private readonly Regex _splittingExpression = new Regex("[\\p{Ll}0-9]+(?=_?)");

    public Regex SplittingExpression => this._splittingExpression;

    public string SeparatorCharacter => "_";
  }
}


--- Mapper.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.Mapper
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Internal;
using AutoMapper.Mappers;
using System;
using System.Collections.Generic;

#nullable disable
namespace AutoMapper
{
  public static class Mapper
  {
    private static readonly Func<ConfigurationStore> _configurationInit = (Func<ConfigurationStore>) (() =>
    {
      PlatformAdapter.Resolve<IPlatformSpecificMapperRegistry>().Initialize();
      return new ConfigurationStore((ITypeMapFactory) new TypeMapFactory(), (IEnumerable<IObjectMapper>) MapperRegistry.Mappers);
    });
    private static ILazy<ConfigurationStore> _configuration = LazyFactory.Create<ConfigurationStore>(Mapper._configurationInit);
    private static readonly Func<IMappingEngine> _mappingEngineInit = (Func<IMappingEngine>) (() => (IMappingEngine) new MappingEngine((IConfigurationProvider) Mapper._configuration.Value));
    private static ILazy<IMappingEngine> _mappingEngine = LazyFactory.Create<IMappingEngine>(Mapper._mappingEngineInit);

    public static bool AllowNullDestinationValues
    {
      get => Mapper.Configuration.AllowNullDestinationValues;
      set => Mapper.Configuration.AllowNullDestinationValues = value;
    }

    public static TDestination Map<TDestination>(object source)
    {
      return Mapper.Engine.Map<TDestination>(source);
    }

    public static TDestination Map<TDestination>(
      object source,
      Action<IMappingOperationOptions> opts)
    {
      return Mapper.Engine.Map<TDestination>(source, opts);
    }

    public static TDestination Map<TSource, TDestination>(TSource source)
    {
      return Mapper.Engine.Map<TSource, TDestination>(source);
    }

    public static TDestination Map<TSource, TDestination>(TSource source, TDestination destination)
    {
      return Mapper.Engine.Map<TSource, TDestination>(source, destination);
    }

    public static TDestination Map<TSource, TDestination>(
      TSource source,
      TDestination destination,
      Action<IMappingOperationOptions> opts)
    {
      return Mapper.Engine.Map<TSource, TDestination>(source, destination, opts);
    }

    public static TDestination Map<TSource, TDestination>(
      TSource source,
      Action<IMappingOperationOptions> opts)
    {
      return Mapper.Engine.Map<TSource, TDestination>(source, opts);
    }

    public static object Map(object source, Type sourceType, Type destinationType)
    {
      return Mapper.Engine.Map(source, sourceType, destinationType);
    }

    public static object Map(
      object source,
      Type sourceType,
      Type destinationType,
      Action<IMappingOperationOptions> opts)
    {
      return Mapper.Engine.Map(source, sourceType, destinationType, opts);
    }

    public static object Map(
      object source,
      object destination,
      Type sourceType,
      Type destinationType)
    {
      return Mapper.Engine.Map(source, destination, sourceType, destinationType);
    }

    public static object Map(
      object source,
      object destination,
      Type sourceType,
      Type destinationType,
      Action<IMappingOperationOptions> opts)
    {
      return Mapper.Engine.Map(source, destination, sourceType, destinationType, opts);
    }

    public static TDestination DynamicMap<TSource, TDestination>(TSource source)
    {
      return Mapper.Engine.DynamicMap<TSource, TDestination>(source);
    }

    public static void DynamicMap<TSource, TDestination>(TSource source, TDestination destination)
    {
      Mapper.Engine.DynamicMap<TSource, TDestination>(source, destination);
    }

    public static TDestination DynamicMap<TDestination>(object source)
    {
      return Mapper.Engine.DynamicMap<TDestination>(source);
    }

    public static object DynamicMap(object source, Type sourceType, Type destinationType)
    {
      return Mapper.Engine.DynamicMap(source, sourceType, destinationType);
    }

    public static void DynamicMap(
      object source,
      object destination,
      Type sourceType,
      Type destinationType)
    {
      Mapper.Engine.DynamicMap(source, destination, sourceType, destinationType);
    }

    public static void Initialize(Action<IConfiguration> action)
    {
      Mapper.Reset();
      action(Mapper.Configuration);
      Mapper.Configuration.Seal();
    }

    [Obsolete("Formatters should not be used.")]
    public static IFormatterCtorExpression<TValueFormatter> AddFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
    {
      return Mapper.Configuration.AddFormatter<TValueFormatter>();
    }

    [Obsolete("Formatters should not be used.")]
    public static IFormatterCtorExpression AddFormatter(Type valueFormatterType)
    {
      return Mapper.Configuration.AddFormatter(valueFormatterType);
    }

    [Obsolete("Formatters should not be used.")]
    public static void AddFormatter(IValueFormatter formatter)
    {
      Mapper.Configuration.AddFormatter(formatter);
    }

    [Obsolete("Formatters should not be used.")]
    public static void AddFormatExpression(Func<ResolutionContext, string> formatExpression)
    {
      Mapper.Configuration.AddFormatExpression(formatExpression);
    }

    [Obsolete("Formatters should not be used.")]
    public static void SkipFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
    {
      Mapper.Configuration.SkipFormatter<TValueFormatter>();
    }

    public static IFormatterExpression ForSourceType<TSource>()
    {
      return Mapper.Configuration.ForSourceType<TSource>();
    }

    public static IMappingExpression<TSource, TDestination> CreateMap<TSource, TDestination>()
    {
      return Mapper.Configuration.CreateMap<TSource, TDestination>();
    }

    public static IMappingExpression<TSource, TDestination> CreateMap<TSource, TDestination>(
      MemberList memberList)
    {
      return Mapper.Configuration.CreateMap<TSource, TDestination>(memberList);
    }

    public static IMappingExpression CreateMap(Type sourceType, Type destinationType)
    {
      return Mapper.Configuration.CreateMap(sourceType, destinationType);
    }

    public static IMappingExpression CreateMap(
      Type sourceType,
      Type destinationType,
      MemberList memberList)
    {
      return Mapper.Configuration.CreateMap(sourceType, destinationType, memberList);
    }

    public static IProfileExpression CreateProfile(string profileName)
    {
      return Mapper.Configuration.CreateProfile(profileName);
    }

    public static void CreateProfile(
      string profileName,
      Action<IProfileExpression> profileConfiguration)
    {
      Mapper.Configuration.CreateProfile(profileName, profileConfiguration);
    }

    public static void AddProfile(Profile profile) => Mapper.Configuration.AddProfile(profile);

    public static void AddProfile<TProfile>() where TProfile : Profile, new()
    {
      Mapper.Configuration.AddProfile<TProfile>();
    }

    public static TypeMap FindTypeMapFor(Type sourceType, Type destinationType)
    {
      return Mapper.ConfigurationProvider.FindTypeMapFor(sourceType, destinationType);
    }

    public static TypeMap FindTypeMapFor<TSource, TDestination>()
    {
      return Mapper.ConfigurationProvider.FindTypeMapFor(typeof (TSource), typeof (TDestination));
    }

    public static TypeMap[] GetAllTypeMaps() => Mapper.ConfigurationProvider.GetAllTypeMaps();

    public static void AssertConfigurationIsValid()
    {
      Mapper.ConfigurationProvider.AssertConfigurationIsValid();
    }

    public static void AssertConfigurationIsValid(TypeMap typeMap)
    {
      Mapper.ConfigurationProvider.AssertConfigurationIsValid(typeMap);
    }

    public static void AssertConfigurationIsValid(string profileName)
    {
      Mapper.ConfigurationProvider.AssertConfigurationIsValid(profileName);
    }

    public static void Reset()
    {
      MapperRegistry.Reset();
      Mapper._configuration = LazyFactory.Create<ConfigurationStore>(Mapper._configurationInit);
      Mapper._mappingEngine = LazyFactory.Create<IMappingEngine>(Mapper._mappingEngineInit);
    }

    public static IMappingEngine Engine => Mapper._mappingEngine.Value;

    public static IConfiguration Configuration => (IConfiguration) Mapper.ConfigurationProvider;

    private static IConfigurationProvider ConfigurationProvider
    {
      get => (IConfigurationProvider) Mapper._configuration.Value;
    }

    public static void AddGlobalIgnore(string startingwith)
    {
      Mapper.Configuration.AddGlobalIgnore(startingwith);
    }
  }
}


--- MappingEngine.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.MappingEngine
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Impl;
using AutoMapper.Internal;
using AutoMapper.Mappers;
using System;
using System.Collections.Generic;
using System.Linq;

#nullable disable
namespace AutoMapper
{
  public class MappingEngine : IMappingEngine, IDisposable, IMappingEngineRunner
  {
    private static readonly IDictionaryFactory DictionaryFactory = PlatformAdapter.Resolve<IDictionaryFactory>();
    private static readonly IProxyGeneratorFactory ProxyGeneratorFactory = PlatformAdapter.Resolve<IProxyGeneratorFactory>();
    private bool _disposed;
    private readonly IConfigurationProvider _configurationProvider;
    private readonly IObjectMapper[] _mappers;
    private readonly AutoMapper.Internal.IDictionary<TypePair, IObjectMapper> _objectMapperCache = MappingEngine.DictionaryFactory.CreateDictionary<TypePair, IObjectMapper>();
    private readonly Func<Type, object> _serviceCtor;

    public MappingEngine(IConfigurationProvider configurationProvider)
      : this(configurationProvider, MappingEngine.DictionaryFactory.CreateDictionary<TypePair, IObjectMapper>(), configurationProvider.ServiceCtor)
    {
    }

    public MappingEngine(
      IConfigurationProvider configurationProvider,
      AutoMapper.Internal.IDictionary<TypePair, IObjectMapper> objectMapperCache,
      Func<Type, object> serviceCtor)
    {
      this._configurationProvider = configurationProvider;
      this._objectMapperCache = objectMapperCache;
      this._serviceCtor = serviceCtor;
      this._mappers = configurationProvider.GetMappers();
      this._configurationProvider.TypeMapCreated += new EventHandler<TypeMapCreatedEventArgs>(this.ClearTypeMap);
    }

    public IConfigurationProvider ConfigurationProvider => this._configurationProvider;

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    protected virtual void Dispose(bool disposing)
    {
      if (this._disposed)
        return;
      if (disposing && this._configurationProvider != null)
        this._configurationProvider.TypeMapCreated -= new EventHandler<TypeMapCreatedEventArgs>(this.ClearTypeMap);
      this._disposed = true;
    }

    public TDestination Map<TDestination>(object source)
    {
      return this.Map<TDestination>(source, new Action<IMappingOperationOptions>(this.DefaultMappingOptions));
    }

    public TDestination Map<TDestination>(object source, Action<IMappingOperationOptions> opts)
    {
      TDestination destination = default (TDestination);
      if (source != null)
      {
        Type type = source.GetType();
        Type destinationType = typeof (TDestination);
        destination = (TDestination) this.Map(source, type, destinationType, opts);
      }
      return destination;
    }

    public TDestination Map<TSource, TDestination>(TSource source)
    {
      Type sourceType = typeof (TSource);
      Type destinationType = typeof (TDestination);
      return (TDestination) this.Map((object) source, sourceType, destinationType, new Action<IMappingOperationOptions>(this.DefaultMappingOptions));
    }

    public TDestination Map<TSource, TDestination>(
      TSource source,
      Action<IMappingOperationOptions> opts)
    {
      Type sourceType = typeof (TSource);
      Type destinationType = typeof (TDestination);
      return (TDestination) this.Map((object) source, sourceType, destinationType, opts);
    }

    public TDestination Map<TSource, TDestination>(TSource source, TDestination destination)
    {
      return this.Map<TSource, TDestination>(source, destination, new Action<IMappingOperationOptions>(this.DefaultMappingOptions));
    }

    public TDestination Map<TSource, TDestination>(
      TSource source,
      TDestination destination,
      Action<IMappingOperationOptions> opts)
    {
      Type sourceType = typeof (TSource);
      Type destinationType = typeof (TDestination);
      return (TDestination) this.Map((object) source, (object) destination, sourceType, destinationType, opts);
    }

    public object Map(object source, Type sourceType, Type destinationType)
    {
      return this.Map(source, sourceType, destinationType, new Action<IMappingOperationOptions>(this.DefaultMappingOptions));
    }

    public object Map(
      object source,
      Type sourceType,
      Type destinationType,
      Action<IMappingOperationOptions> opts)
    {
      TypeMap typeMapFor = this.ConfigurationProvider.FindTypeMapFor(source, (object) null, sourceType, destinationType);
      MappingOperationOptions options = new MappingOperationOptions();
      opts((IMappingOperationOptions) options);
      return ((IMappingEngineRunner) this).Map(new ResolutionContext(typeMapFor, source, sourceType, destinationType, options));
    }

    public object Map(object source, object destination, Type sourceType, Type destinationType)
    {
      return this.Map(source, destination, sourceType, destinationType, new Action<IMappingOperationOptions>(this.DefaultMappingOptions));
    }

    public object Map(
      object source,
      object destination,
      Type sourceType,
      Type destinationType,
      Action<IMappingOperationOptions> opts)
    {
      TypeMap typeMapFor = this.ConfigurationProvider.FindTypeMapFor(source, destination, sourceType, destinationType);
      MappingOperationOptions options = new MappingOperationOptions();
      opts((IMappingOperationOptions) options);
      return ((IMappingEngineRunner) this).Map(new ResolutionContext(typeMapFor, source, destination, sourceType, destinationType, options));
    }

    public TDestination DynamicMap<TSource, TDestination>(TSource source)
    {
      Type sourceType = typeof (TSource);
      Type destinationType = typeof (TDestination);
      return (TDestination) this.DynamicMap((object) source, sourceType, destinationType);
    }

    public void DynamicMap<TSource, TDestination>(TSource source, TDestination destination)
    {
      Type sourceType = typeof (TSource);
      Type destinationType = typeof (TDestination);
      this.DynamicMap((object) source, (object) destination, sourceType, destinationType);
    }

    public TDestination DynamicMap<TDestination>(object source)
    {
      Type sourceType = source == null ? typeof (object) : source.GetType();
      Type destinationType = typeof (TDestination);
      return (TDestination) this.DynamicMap(source, sourceType, destinationType);
    }

    public object DynamicMap(object source, Type sourceType, Type destinationType)
    {
      return ((IMappingEngineRunner) this).Map(new ResolutionContext(this.ConfigurationProvider.FindTypeMapFor(source, (object) null, sourceType, destinationType) ?? this.ConfigurationProvider.CreateTypeMap(sourceType, destinationType), source, sourceType, destinationType, new MappingOperationOptions()
      {
        CreateMissingTypeMaps = true
      }));
    }

    public void DynamicMap(
      object source,
      object destination,
      Type sourceType,
      Type destinationType)
    {
      ((IMappingEngineRunner) this).Map(new ResolutionContext(this.ConfigurationProvider.FindTypeMapFor(source, destination, sourceType, destinationType) ?? this.ConfigurationProvider.CreateTypeMap(sourceType, destinationType), source, destination, sourceType, destinationType, new MappingOperationOptions()
      {
        CreateMissingTypeMaps = true
      }));
    }

    public TDestination Map<TSource, TDestination>(ResolutionContext parentContext, TSource source)
    {
      Type destinationType = typeof (TDestination);
      Type sourceType = typeof (TSource);
      TypeMap typeMapFor = this.ConfigurationProvider.FindTypeMapFor((object) source, (object) null, sourceType, destinationType);
      return (TDestination) ((IMappingEngineRunner) this).Map(parentContext.CreateTypeContext(typeMapFor, (object) source, (object) null, sourceType, destinationType));
    }

    object IMappingEngineRunner.Map(ResolutionContext context)
    {
      try
      {
        TypePair key = new TypePair(context.SourceType, context.DestinationType);
        Func<TypePair, IObjectMapper> valueFactory = (Func<TypePair, IObjectMapper>) (tp => ((IEnumerable<IObjectMapper>) this._mappers).FirstOrDefault<IObjectMapper>((Func<IObjectMapper, bool>) (mapper => mapper.IsMatch(context))));
        IObjectMapper orAdd = this._objectMapperCache.GetOrAdd(key, valueFactory);
        if (orAdd == null)
        {
          if (context.Options.CreateMissingTypeMaps)
          {
            TypeMap typeMap = this.ConfigurationProvider.CreateTypeMap(context.SourceType, context.DestinationType);
            context = context.CreateTypeContext(typeMap, context.SourceValue, context.DestinationValue, context.SourceType, context.DestinationType);
            orAdd = this._objectMapperCache.GetOrAdd(key, valueFactory);
          }
          else
            return context.SourceValue == null ? ObjectCreator.CreateDefaultValue(context.DestinationType) : throw new AutoMapperMappingException(context, "Missing type map configuration or unsupported mapping.");
        }
        return orAdd.Map(context, (IMappingEngineRunner) this);
      }
      catch (AutoMapperMappingException ex)
      {
        throw;
      }
      catch (Exception ex)
      {
        throw new AutoMapperMappingException(context, ex);
      }
    }

    string IMappingEngineRunner.FormatValue(ResolutionContext context)
    {
      TypeMap contextTypeMap = context.GetContextTypeMap();
      IFormatterConfiguration formatterConfiguration = contextTypeMap != null ? this.ConfigurationProvider.GetProfileConfiguration(contextTypeMap.Profile) : this.ConfigurationProvider.GetProfileConfiguration("");
      object sourceValue = context.SourceValue;
      string str = context.SourceValue.ToNullSafeString();
      foreach (IValueFormatter valueFormatter in formatterConfiguration.GetFormattersToApply(context))
      {
        str = valueFormatter.FormatValue(context.CreateValueContext(sourceValue));
        sourceValue = (object) str;
      }
      return str == null && !((IMappingEngineRunner) this).ShouldMapSourceValueAsNull(context) ? string.Empty : str;
    }

    object IMappingEngineRunner.CreateObject(ResolutionContext context)
    {
      TypeMap typeMap = context.TypeMap;
      Type type = context.DestinationType;
      if (typeMap != null)
      {
        if (typeMap.DestinationCtor != null)
          return typeMap.DestinationCtor(context);
        if (typeMap.ConstructDestinationUsingServiceLocator)
          return context.Options.ServiceCtor(type);
        if (typeMap.ConstructorMap != null)
          return typeMap.ConstructorMap.ResolveValue(context, (IMappingEngineRunner) this);
      }
      if (context.DestinationValue != null)
        return context.DestinationValue;
      if (type.IsInterface)
        type = MappingEngine.ProxyGeneratorFactory.Create().GetProxyType(type);
      return ObjectCreator.CreateObject(type);
    }

    bool IMappingEngineRunner.ShouldMapSourceValueAsNull(ResolutionContext context)
    {
      if (context.DestinationType.IsValueType && !context.DestinationType.IsNullableType())
        return false;
      TypeMap contextTypeMap = context.GetContextTypeMap();
      return contextTypeMap != null ? this.ConfigurationProvider.GetProfileConfiguration(contextTypeMap.Profile).MapNullSourceValuesAsNull : this.ConfigurationProvider.MapNullSourceValuesAsNull;
    }

    bool IMappingEngineRunner.ShouldMapSourceCollectionAsNull(ResolutionContext context)
    {
      TypeMap contextTypeMap = context.GetContextTypeMap();
      return contextTypeMap != null ? this.ConfigurationProvider.GetProfileConfiguration(contextTypeMap.Profile).MapNullSourceCollectionsAsNull : this.ConfigurationProvider.MapNullSourceCollectionsAsNull;
    }

    private void ClearTypeMap(object sender, TypeMapCreatedEventArgs e)
    {
      this._objectMapperCache.TryRemove(new TypePair(e.TypeMap.SourceType, e.TypeMap.DestinationType), out IObjectMapper _);
    }

    private void DefaultMappingOptions(IMappingOperationOptions opts)
    {
      opts.ConstructServicesUsing(this._serviceCtor);
    }
  }
}


--- MappingExpression.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.MappingExpression
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Impl;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public class MappingExpression : IMappingExpression, IMemberConfigurationExpression
  {
    private readonly TypeMap _typeMap;
    private readonly Func<Type, object> _typeConverterCtor;
    private PropertyMap _propertyMap;

    public MappingExpression(TypeMap typeMap, Func<Type, object> typeConverterCtor)
    {
      this._typeMap = typeMap;
      this._typeConverterCtor = typeConverterCtor;
    }

    public void ConvertUsing<TTypeConverter>() => this.ConvertUsing(typeof (TTypeConverter));

    public void ConvertUsing(Type typeConverterType)
    {
      Type type = typeof (ITypeConverter<,>).MakeGenericType(this._typeMap.SourceType, this._typeMap.DestinationType);
      this._typeMap.UseCustomMapper(new Func<ResolutionContext, object>(new DeferredInstantiatedConverter(type.IsAssignableFrom(typeConverterType) ? type : typeConverterType, this.BuildCtor<object>(typeConverterType)).Convert));
    }

    public void As(Type typeOverride) => this._typeMap.DestinationTypeOverride = typeOverride;

    public IMappingExpression WithProfile(string profileName)
    {
      this._typeMap.Profile = profileName;
      return (IMappingExpression) this;
    }

    public IMappingExpression ForMember(
      string name,
      Action<IMemberConfigurationExpression> memberOptions)
    {
      IMemberAccessor destinationProperty = (IMemberAccessor) null;
      PropertyInfo property = this._typeMap.DestinationType.GetProperty(name);
      if ((object) property != null)
        destinationProperty = (IMemberAccessor) new PropertyAccessor(property);
      if (destinationProperty == null)
        destinationProperty = (IMemberAccessor) new FieldAccessor(this._typeMap.DestinationType.GetField(name));
      this.ForDestinationMember(destinationProperty, memberOptions);
      return (IMappingExpression) new MappingExpression(this._typeMap, this._typeConverterCtor);
    }

    public IMappingExpression ForSourceMember(
      string sourceMemberName,
      Action<ISourceMemberConfigurationExpression> memberOptions)
    {
      MappingExpression.SourceMappingExpression mappingExpression = new MappingExpression.SourceMappingExpression(this._typeMap, ((IEnumerable<MemberInfo>) this._typeMap.SourceType.GetMember(sourceMemberName)).First<MemberInfo>());
      memberOptions((ISourceMemberConfigurationExpression) mappingExpression);
      return (IMappingExpression) new MappingExpression(this._typeMap, this._typeConverterCtor);
    }

    private void ForDestinationMember(
      IMemberAccessor destinationProperty,
      Action<IMemberConfigurationExpression> memberOptions)
    {
      this._propertyMap = this._typeMap.FindOrCreatePropertyMapFor(destinationProperty);
      memberOptions((IMemberConfigurationExpression) this);
    }

    public void MapFrom(string sourceMember)
    {
      MemberInfo[] member = this._typeMap.SourceType.GetMember(sourceMember);
      if (!((IEnumerable<MemberInfo>) member).Any<MemberInfo>())
        throw new AutoMapperConfigurationException(string.Format("Unable to find source member {0} on type {1}", new object[2]
        {
          (object) sourceMember,
          (object) this._typeMap.SourceType.FullName
        }));
      MemberInfo accessorCandidate = !((IEnumerable<MemberInfo>) member).Skip<MemberInfo>(1).Any<MemberInfo>() ? ((IEnumerable<MemberInfo>) member).Single<MemberInfo>() : throw new AutoMapperConfigurationException(string.Format("Source member {0} is ambiguous on type {1}", new object[2]
      {
        (object) sourceMember,
        (object) this._typeMap.SourceType.FullName
      }));
      this._propertyMap.SourceMember = accessorCandidate;
      this._propertyMap.AssignCustomValueResolver((IValueResolver) accessorCandidate.ToMemberGetter());
    }

    public IResolutionExpression ResolveUsing(IValueResolver valueResolver)
    {
      this._propertyMap.AssignCustomValueResolver(valueResolver);
      return (IResolutionExpression) new ResolutionExpression(this._typeMap.SourceType, this._propertyMap);
    }

    public IResolverConfigurationExpression ResolveUsing(Type valueResolverType)
    {
      this.ResolveUsing((IValueResolver) new DeferredInstantiatedResolver(this.BuildCtor<IValueResolver>(valueResolverType)));
      return (IResolverConfigurationExpression) new ResolutionExpression(this._typeMap.SourceType, this._propertyMap);
    }

    public IResolverConfigurationExpression ResolveUsing<TValueResolver>()
    {
      this.ResolveUsing((IValueResolver) new DeferredInstantiatedResolver(this.BuildCtor<IValueResolver>(typeof (TValueResolver))));
      return (IResolverConfigurationExpression) new ResolutionExpression(this._typeMap.SourceType, this._propertyMap);
    }

    public void Ignore() => this._propertyMap.Ignore();

    private Func<ResolutionContext, TServiceType> BuildCtor<TServiceType>(Type type)
    {
      return (Func<ResolutionContext, TServiceType>) (context =>
      {
        if (context.Options.ServiceCtor != null)
        {
          object obj = context.Options.ServiceCtor(type);
          if (obj != null)
            return (TServiceType) obj;
        }
        return (TServiceType) this._typeConverterCtor(type);
      });
    }

    private class SourceMappingExpression : ISourceMemberConfigurationExpression
    {
      private readonly SourceMemberConfig _sourcePropertyConfig;

      public SourceMappingExpression(TypeMap typeMap, MemberInfo sourceMember)
      {
        this._sourcePropertyConfig = typeMap.FindOrCreateSourceMemberConfigFor(sourceMember);
      }

      public void Ignore() => this._sourcePropertyConfig.Ignore();
    }
  }
}


--- MappingExpression`2.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.MappingExpression`2
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Impl;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public class MappingExpression<TSource, TDestination> : 
    IMappingExpression<TSource, TDestination>,
    IMemberConfigurationExpression<TSource>,
    IFormatterCtorConfigurator
  {
    private readonly TypeMap _typeMap;
    private readonly Func<Type, object> _serviceCtor;
    private readonly IProfileExpression _configurationContainer;
    private PropertyMap _propertyMap;

    public MappingExpression(
      TypeMap typeMap,
      Func<Type, object> serviceCtor,
      IProfileExpression configurationContainer)
    {
      this._typeMap = typeMap;
      this._serviceCtor = serviceCtor;
      this._configurationContainer = configurationContainer;
    }

    public IMappingExpression<TSource, TDestination> ForMember(
      Expression<Func<TDestination, object>> destinationMember,
      Action<IMemberConfigurationExpression<TSource>> memberOptions)
    {
      this.ForDestinationMember(ReflectionHelper.FindProperty((LambdaExpression) destinationMember).ToMemberAccessor(), memberOptions);
      return (IMappingExpression<TSource, TDestination>) new MappingExpression<TSource, TDestination>(this._typeMap, this._serviceCtor, this._configurationContainer);
    }

    public IMappingExpression<TSource, TDestination> ForMember(
      string name,
      Action<IMemberConfigurationExpression<TSource>> memberOptions)
    {
      IMemberAccessor destinationProperty = (IMemberAccessor) null;
      PropertyInfo property = this._typeMap.DestinationType.GetProperty(name);
      if ((object) property != null)
        destinationProperty = (IMemberAccessor) new PropertyAccessor(property);
      if (destinationProperty == null)
        destinationProperty = (IMemberAccessor) new FieldAccessor(this._typeMap.DestinationType.GetField(name));
      this.ForDestinationMember(destinationProperty, memberOptions);
      return (IMappingExpression<TSource, TDestination>) new MappingExpression<TSource, TDestination>(this._typeMap, this._serviceCtor, this._configurationContainer);
    }

    public void ForAllMembers(
      Action<IMemberConfigurationExpression<TSource>> memberOptions)
    {
      new TypeInfo(this._typeMap.DestinationType).GetPublicWriteAccessors().Each<MemberInfo>((Action<MemberInfo>) (acc => this.ForDestinationMember(acc.ToMemberAccessor(), memberOptions)));
    }

    public IMappingExpression<TSource, TDestination> Include<TOtherSource, TOtherDestination>()
      where TOtherSource : TSource
      where TOtherDestination : TDestination
    {
      this._typeMap.IncludeDerivedTypes(typeof (TOtherSource), typeof (TOtherDestination));
      return (IMappingExpression<TSource, TDestination>) this;
    }

    public IMappingExpression<TSource, TDestination> WithProfile(string profileName)
    {
      this._typeMap.Profile = profileName;
      return (IMappingExpression<TSource, TDestination>) this;
    }

    public void SkipFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
    {
      this._propertyMap.AddFormatterToSkip<TValueFormatter>();
    }

    public IFormatterCtorExpression<TValueFormatter> AddFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
    {
      this.AddFormatter((IValueFormatter) new DeferredInstantiatedFormatter(this.BuildCtor<IValueFormatter>(typeof (TValueFormatter))));
      return (IFormatterCtorExpression<TValueFormatter>) new FormatterCtorExpression<TValueFormatter>((IFormatterCtorConfigurator) this);
    }

    public IFormatterCtorExpression AddFormatter(Type valueFormatterType)
    {
      this.AddFormatter((IValueFormatter) new DeferredInstantiatedFormatter(this.BuildCtor<IValueFormatter>(valueFormatterType)));
      return (IFormatterCtorExpression) new FormatterCtorExpression(valueFormatterType, (IFormatterCtorConfigurator) this);
    }

    public void AddFormatter(IValueFormatter formatter)
    {
      this._propertyMap.AddFormatter(formatter);
    }

    public void NullSubstitute(object nullSubstitute)
    {
      this._propertyMap.SetNullSubstitute(nullSubstitute);
    }

    public IResolverConfigurationExpression<TSource, TValueResolver> ResolveUsing<TValueResolver>() where TValueResolver : IValueResolver
    {
      this.ResolveUsing((IValueResolver) new DeferredInstantiatedResolver(this.BuildCtor<IValueResolver>(typeof (TValueResolver))));
      return (IResolverConfigurationExpression<TSource, TValueResolver>) new ResolutionExpression<TSource, TValueResolver>(this._propertyMap);
    }

    public IResolverConfigurationExpression<TSource> ResolveUsing(Type valueResolverType)
    {
      this.ResolveUsing((IValueResolver) new DeferredInstantiatedResolver(this.BuildCtor<IValueResolver>(valueResolverType)));
      return (IResolverConfigurationExpression<TSource>) new ResolutionExpression<TSource>(this._propertyMap);
    }

    public IResolutionExpression<TSource> ResolveUsing(IValueResolver valueResolver)
    {
      this._propertyMap.AssignCustomValueResolver(valueResolver);
      return (IResolutionExpression<TSource>) new ResolutionExpression<TSource>(this._propertyMap);
    }

    public void ResolveUsing(Func<TSource, object> resolver)
    {
      this._propertyMap.AssignCustomValueResolver((IValueResolver) new DelegateBasedResolver<TSource>(resolver));
    }

    public void MapFrom<TMember>(Expression<Func<TSource, TMember>> sourceMember)
    {
      this._propertyMap.SetCustomValueResolverExpression<TSource, TMember>(sourceMember);
    }

    public void UseValue<TValue>(TValue value)
    {
      this.MapFrom<TValue>((Expression<Func<TSource, TValue>>) (src => value));
    }

    public void UseValue(object value)
    {
      this._propertyMap.AssignCustomValueResolver((IValueResolver) new DelegateBasedResolver<TSource>((Func<TSource, object>) (src => value)));
    }

    public void Condition(Func<TSource, bool> condition)
    {
      this.Condition((Func<ResolutionContext, bool>) (context => condition((TSource) context.Parent.SourceValue)));
    }

    public IMappingExpression<TSource, TDestination> MaxDepth(int depth)
    {
      this._typeMap.SetCondition((Func<ResolutionContext, bool>) (o => MappingExpression<TSource, TDestination>.PassesDepthCheck(o, depth)));
      return (IMappingExpression<TSource, TDestination>) this;
    }

    public IMappingExpression<TSource, TDestination> ConstructUsingServiceLocator()
    {
      this._typeMap.ConstructDestinationUsingServiceLocator = true;
      return (IMappingExpression<TSource, TDestination>) this;
    }

    public IMappingExpression<TDestination, TSource> ReverseMap()
    {
      return this._configurationContainer.CreateMap<TDestination, TSource>(MemberList.Source);
    }

    public IMappingExpression<TSource, TDestination> ForSourceMember(
      Expression<Func<TSource, object>> sourceMember,
      Action<ISourceMemberConfigurationExpression<TSource>> memberOptions)
    {
      MappingExpression<TSource, TDestination>.SourceMappingExpression mappingExpression = new MappingExpression<TSource, TDestination>.SourceMappingExpression(this._typeMap, ReflectionHelper.FindProperty((LambdaExpression) sourceMember));
      memberOptions((ISourceMemberConfigurationExpression<TSource>) mappingExpression);
      return (IMappingExpression<TSource, TDestination>) this;
    }

    public IMappingExpression<TSource, TDestination> ForSourceMember(
      string sourceMemberName,
      Action<ISourceMemberConfigurationExpression<TSource>> memberOptions)
    {
      MappingExpression<TSource, TDestination>.SourceMappingExpression mappingExpression = new MappingExpression<TSource, TDestination>.SourceMappingExpression(this._typeMap, ((IEnumerable<MemberInfo>) this._typeMap.SourceType.GetMember(sourceMemberName)).First<MemberInfo>());
      memberOptions((ISourceMemberConfigurationExpression<TSource>) mappingExpression);
      return (IMappingExpression<TSource, TDestination>) this;
    }

    private static bool PassesDepthCheck(ResolutionContext context, int maxDepth)
    {
      if (context.InstanceCache.ContainsKey(context))
        return true;
      ResolutionContext resolutionContext = context;
      int num = 1;
      for (; resolutionContext.Parent != null; resolutionContext = resolutionContext.Parent)
      {
        if ((object) resolutionContext.SourceType == (object) context.TypeMap.SourceType && (object) resolutionContext.DestinationType == (object) context.TypeMap.DestinationType)
          ++num;
      }
      return num <= maxDepth;
    }

    public void Condition(Func<ResolutionContext, bool> condition)
    {
      this._propertyMap.ApplyCondition(condition);
    }

    public void Ignore() => this._propertyMap.Ignore();

    public void UseDestinationValue() => this._propertyMap.UseDestinationValue = true;

    public void DoNotUseDestinationValue() => this._propertyMap.UseDestinationValue = false;

    public void SetMappingOrder(int mappingOrder)
    {
      this._propertyMap.SetMappingOrder(mappingOrder);
    }

    public void ConstructFormatterBy(Type formatterType, Func<IValueFormatter> instantiator)
    {
      this._propertyMap.RemoveLastFormatter();
      this._propertyMap.AddFormatter((IValueFormatter) new DeferredInstantiatedFormatter((Func<ResolutionContext, IValueFormatter>) (ctxt => instantiator())));
    }

    public void ConvertUsing(Func<TSource, TDestination> mappingFunction)
    {
      this._typeMap.UseCustomMapper((Func<ResolutionContext, object>) (source => (object) mappingFunction((TSource) source.SourceValue)));
    }

    public void ConvertUsing(
      Func<ResolutionContext, TDestination> mappingFunction)
    {
      this._typeMap.UseCustomMapper((Func<ResolutionContext, object>) (context => (object) mappingFunction(context)));
    }

    public void ConvertUsing(
      Func<ResolutionContext, TSource, TDestination> mappingFunction)
    {
      this._typeMap.UseCustomMapper((Func<ResolutionContext, object>) (source => (object) mappingFunction(source, (TSource) source.SourceValue)));
    }

    public void ConvertUsing(ITypeConverter<TSource, TDestination> converter)
    {
      this.ConvertUsing(new Func<ResolutionContext, TDestination>(converter.Convert));
    }

    public void ConvertUsing<TTypeConverter>() where TTypeConverter : ITypeConverter<TSource, TDestination>
    {
      this.ConvertUsing(new Func<ResolutionContext, TDestination>(new DeferredInstantiatedConverter<TSource, TDestination>(this.BuildCtor<ITypeConverter<TSource, TDestination>>(typeof (TTypeConverter))).Convert));
    }

    public IMappingExpression<TSource, TDestination> BeforeMap(
      Action<TSource, TDestination> beforeFunction)
    {
      this._typeMap.AddBeforeMapAction((Action<object, object>) ((src, dest) => beforeFunction((TSource) src, (TDestination) dest)));
      return (IMappingExpression<TSource, TDestination>) this;
    }

    public IMappingExpression<TSource, TDestination> BeforeMap<TMappingAction>() where TMappingAction : IMappingAction<TSource, TDestination>
    {
      return this.BeforeMap((Action<TSource, TDestination>) ((src, dest) => ((TMappingAction) this._serviceCtor(typeof (TMappingAction))).Process(src, dest)));
    }

    public IMappingExpression<TSource, TDestination> AfterMap(
      Action<TSource, TDestination> afterFunction)
    {
      this._typeMap.AddAfterMapAction((Action<object, object>) ((src, dest) => afterFunction((TSource) src, (TDestination) dest)));
      return (IMappingExpression<TSource, TDestination>) this;
    }

    public IMappingExpression<TSource, TDestination> AfterMap<TMappingAction>() where TMappingAction : IMappingAction<TSource, TDestination>
    {
      return this.AfterMap((Action<TSource, TDestination>) ((src, dest) => ((TMappingAction) this._serviceCtor(typeof (TMappingAction))).Process(src, dest)));
    }

    public IMappingExpression<TSource, TDestination> ConstructUsing(Func<TSource, TDestination> ctor)
    {
      return this.ConstructUsing((Func<ResolutionContext, TDestination>) (ctxt => ctor((TSource) ctxt.SourceValue)));
    }

    public IMappingExpression<TSource, TDestination> ConstructUsing(
      Func<ResolutionContext, TDestination> ctor)
    {
      this._typeMap.DestinationCtor = (Func<ResolutionContext, object>) (ctxt => (object) ctor(ctxt));
      return (IMappingExpression<TSource, TDestination>) this;
    }

    private void ForDestinationMember(
      IMemberAccessor destinationProperty,
      Action<IMemberConfigurationExpression<TSource>> memberOptions)
    {
      this._propertyMap = this._typeMap.FindOrCreatePropertyMapFor(destinationProperty);
      memberOptions((IMemberConfigurationExpression<TSource>) this);
    }

    public void As<T>() => this._typeMap.DestinationTypeOverride = typeof (T);

    private Func<ResolutionContext, TServiceType> BuildCtor<TServiceType>(Type type)
    {
      return (Func<ResolutionContext, TServiceType>) (context =>
      {
        if (context.Options.ServiceCtor != null)
        {
          object obj = context.Options.ServiceCtor(type);
          if (obj != null)
            return (TServiceType) obj;
        }
        return (TServiceType) this._serviceCtor(type);
      });
    }

    private class SourceMappingExpression : 
      ISourceMemberConfigurationExpression<TSource>,
      ISourceMemberConfigurationExpression
    {
      private readonly SourceMemberConfig _sourcePropertyConfig;

      public SourceMappingExpression(TypeMap typeMap, MemberInfo memberInfo)
      {
        this._sourcePropertyConfig = typeMap.FindOrCreateSourceMemberConfigFor(memberInfo);
      }

      public void Ignore() => this._sourcePropertyConfig.Ignore();
    }
  }
}


--- MappingOperationOptions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.MappingOperationOptions
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace AutoMapper
{
  public class MappingOperationOptions : IMappingOperationOptions
  {
    public MappingOperationOptions()
    {
      this.Items = (IDictionary<string, object>) new Dictionary<string, object>();
    }

    public Func<Type, object> ServiceCtor { get; private set; }

    public bool CreateMissingTypeMaps { get; set; }

    public IDictionary<string, object> Items { get; private set; }

    void IMappingOperationOptions.ConstructServicesUsing(Func<Type, object> constructor)
    {
      this.ServiceCtor = constructor;
    }
  }
}


--- MemberList.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.MemberList
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public enum MemberList
  {
    Destination,
    Source,
  }
}


--- NullReferenceExceptionSwallowingResolver.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.NullReferenceExceptionSwallowingResolver
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public class NullReferenceExceptionSwallowingResolver : IMemberResolver, IValueResolver
  {
    private readonly IMemberResolver _inner;

    public NullReferenceExceptionSwallowingResolver(IMemberResolver inner) => this._inner = inner;

    public ResolutionResult Resolve(ResolutionResult source)
    {
      try
      {
        return this._inner.Resolve(source);
      }
      catch (NullReferenceException ex)
      {
        return source.New((object) null, this.MemberType);
      }
    }

    public Type MemberType => this._inner.MemberType;
  }
}


--- NullReplacementMethod.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.NullReplacementMethod
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public class NullReplacementMethod : IValueResolver
  {
    private readonly object _nullSubstitute;

    public NullReplacementMethod(object nullSubstitute) => this._nullSubstitute = nullSubstitute;

    public ResolutionResult Resolve(ResolutionResult source)
    {
      return this._nullSubstitute == null || source.Value != null ? source : source.New(this._nullSubstitute);
    }
  }
}


--- PascalCaseNamingConvention.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.PascalCaseNamingConvention
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System.Text.RegularExpressions;

#nullable disable
namespace AutoMapper
{
  public class PascalCaseNamingConvention : INamingConvention
  {
    private readonly Regex _splittingExpression = new Regex("(\\p{Lu}+(?=$|\\p{Lu}[\\p{Ll}0-9])|\\p{Lu}?[\\p{Ll}0-9]+)");

    public Regex SplittingExpression => this._splittingExpression;

    public string SeparatorCharacter => string.Empty;
  }
}


--- Profile.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.Profile
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Collections.Generic;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public class Profile : IProfileExpression, IFormatterExpression, IMappingOptions
  {
    private ConfigurationStore _configurator;

    internal Profile(string profileName) => this.ProfileName = profileName;

    protected Profile() => this.ProfileName = this.GetType().FullName;

    public virtual string ProfileName { get; private set; }

    public void DisableConstructorMapping() => this.GetProfile().ConstructorMappingEnabled = false;

    public bool AllowNullDestinationValues
    {
      get => this.GetProfile().AllowNullDestinationValues;
      set => this.GetProfile().AllowNullDestinationValues = value;
    }

    public bool AllowNullCollections
    {
      get => this.GetProfile().AllowNullCollections;
      set => this.GetProfile().AllowNullCollections = value;
    }

    public void IncludeSourceExtensionMethods(Assembly assembly)
    {
      this.GetProfile().IncludeSourceExtensionMethods(assembly);
    }

    public INamingConvention SourceMemberNamingConvention
    {
      get => this.GetProfile().SourceMemberNamingConvention;
      set => this.GetProfile().SourceMemberNamingConvention = value;
    }

    public INamingConvention DestinationMemberNamingConvention
    {
      get => this.GetProfile().DestinationMemberNamingConvention;
      set => this.GetProfile().DestinationMemberNamingConvention = value;
    }

    public IEnumerable<string> Prefixes => this.GetProfile().Prefixes;

    public IEnumerable<string> Postfixes => this.GetProfile().Postfixes;

    public IEnumerable<string> DestinationPrefixes => this.GetProfile().DestinationPrefixes;

    public IEnumerable<string> DestinationPostfixes => this.GetProfile().DestinationPostfixes;

    public IEnumerable<AliasedMember> Aliases => throw new NotImplementedException();

    public bool ConstructorMappingEnabled => this._configurator.ConstructorMappingEnabled;

    public bool DataReaderMapperYieldReturnEnabled
    {
      get => this._configurator.DataReaderMapperYieldReturnEnabled;
    }

    public IEnumerable<MethodInfo> SourceExtensionMethods
    {
      get => this.GetProfile().SourceExtensionMethods;
    }

    public IFormatterCtorExpression<TValueFormatter> AddFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
    {
      return this.GetProfile().AddFormatter<TValueFormatter>();
    }

    public IFormatterCtorExpression AddFormatter(Type valueFormatterType)
    {
      return this.GetProfile().AddFormatter(valueFormatterType);
    }

    public void AddFormatter(IValueFormatter formatter)
    {
      this.GetProfile().AddFormatter(formatter);
    }

    public void AddFormatExpression(Func<ResolutionContext, string> formatExpression)
    {
      this.GetProfile().AddFormatExpression(formatExpression);
    }

    public void SkipFormatter<TValueFormatter>() where TValueFormatter : IValueFormatter
    {
      this.GetProfile().SkipFormatter<TValueFormatter>();
    }

    public IFormatterExpression ForSourceType<TSource>()
    {
      return this.GetProfile().ForSourceType<TSource>();
    }

    public IMappingExpression<TSource, TDestination> CreateMap<TSource, TDestination>()
    {
      return this.CreateMap<TSource, TDestination>(MemberList.Destination);
    }

    public IMappingExpression<TSource, TDestination> CreateMap<TSource, TDestination>(
      MemberList memberList)
    {
      return this._configurator.CreateMap<TSource, TDestination>(this.ProfileName, memberList);
    }

    public IMappingExpression CreateMap(Type sourceType, Type destinationType)
    {
      return this.CreateMap(sourceType, destinationType, MemberList.Destination);
    }

    public IMappingExpression CreateMap(
      Type sourceType,
      Type destinationType,
      MemberList memberList)
    {
      return this._configurator.CreateMap(sourceType, destinationType, memberList, this.ProfileName);
    }

    public void RecognizeAlias(string original, string alias)
    {
      this.GetProfile().RecognizeAlias(original, alias);
    }

    public void RecognizePrefixes(params string[] prefixes)
    {
      this.GetProfile().RecognizePrefixes(prefixes);
    }

    public void RecognizePostfixes(params string[] postfixes)
    {
      this.GetProfile().RecognizePostfixes(postfixes);
    }

    public void RecognizeDestinationPrefixes(params string[] prefixes)
    {
      this.GetProfile().RecognizeDestinationPrefixes(prefixes);
    }

    public void RecognizeDestinationPostfixes(params string[] postfixes)
    {
      this.GetProfile().RecognizeDestinationPostfixes(postfixes);
    }

    public void AddGlobalIgnore(string propertyNameStartingWith)
    {
      this._configurator.AddGlobalIgnore(propertyNameStartingWith);
    }

    protected internal virtual void Configure()
    {
    }

    public void Initialize(ConfigurationStore configurator) => this._configurator = configurator;

    private FormatterExpression GetProfile() => this._configurator.GetProfile(this.ProfileName);
  }
}


--- PropertyMap.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.PropertyMap
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Impl;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public class PropertyMap
  {
    private readonly LinkedList<IValueResolver> _sourceValueResolvers = new LinkedList<IValueResolver>();
    private readonly IList<Type> _valueFormattersToSkip = (IList<Type>) new List<Type>();
    private readonly IList<IValueFormatter> _valueFormatters = (IList<IValueFormatter>) new List<IValueFormatter>();
    private bool _ignored;
    private int _mappingOrder;
    private bool _hasCustomValueResolver;
    private IValueResolver _customResolver;
    private IValueResolver _customMemberResolver;
    private object _nullSubstitute;
    private bool _sealed;
    private IValueResolver[] _cachedResolvers;
    private Func<ResolutionContext, bool> _condition;
    private MemberInfo _sourceMember;

    public PropertyMap(IMemberAccessor destinationProperty)
    {
      this.UseDestinationValue = true;
      this.DestinationProperty = destinationProperty;
    }

    public PropertyMap(PropertyMap inheritedMappedProperty)
      : this(inheritedMappedProperty.DestinationProperty)
    {
      if (inheritedMappedProperty.IsIgnored())
      {
        this.Ignore();
      }
      else
      {
        foreach (IValueResolver sourceValueResolver in inheritedMappedProperty.GetSourceValueResolvers())
          this.ChainResolver(sourceValueResolver);
      }
      this.ApplyCondition(inheritedMappedProperty._condition);
      this.SetNullSubstitute(inheritedMappedProperty._nullSubstitute);
      this.SetMappingOrder(inheritedMappedProperty._mappingOrder);
    }

    public IMemberAccessor DestinationProperty { get; private set; }

    public Type DestinationPropertyType => this.DestinationProperty.MemberType;

    public LambdaExpression CustomExpression { get; private set; }

    public MemberInfo SourceMember
    {
      get
      {
        if ((object) this._sourceMember != null)
          return this._sourceMember;
        return this.GetSourceValueResolvers().OfType<IMemberGetter>().LastOrDefault<IMemberGetter>()?.MemberInfo;
      }
      internal set => this._sourceMember = value;
    }

    public bool CanBeSet
    {
      get
      {
        return !(this.DestinationProperty is PropertyAccessor) || ((PropertyAccessor) this.DestinationProperty).HasSetter;
      }
    }

    public bool UseDestinationValue { get; set; }

    internal bool HasCustomValueResolver => this._hasCustomValueResolver;

    public IEnumerable<IValueResolver> GetSourceValueResolvers()
    {
      if (this._customMemberResolver != null)
        yield return this._customMemberResolver;
      if (this._customResolver != null)
        yield return this._customResolver;
      foreach (IValueResolver resolver in this._sourceValueResolvers)
        yield return resolver;
      if (this._nullSubstitute != null)
        yield return (IValueResolver) new NullReplacementMethod(this._nullSubstitute);
    }

    public void RemoveLastResolver() => this._sourceValueResolvers.RemoveLast();

    public ResolutionResult ResolveValue(ResolutionContext context)
    {
      this.Seal();
      return ((IEnumerable<IValueResolver>) this._cachedResolvers).Aggregate<IValueResolver, ResolutionResult>(new ResolutionResult(context), (Func<ResolutionResult, IValueResolver, ResolutionResult>) ((current, resolver) => resolver.Resolve(current)));
    }

    internal void Seal()
    {
      if (this._sealed)
        return;
      this._cachedResolvers = this.GetSourceValueResolvers().ToArray<IValueResolver>();
      this._sealed = true;
    }

    public void ChainResolver(IValueResolver IValueResolver)
    {
      this._sourceValueResolvers.AddLast(IValueResolver);
    }

    public void AddFormatterToSkip<TValueFormatter>() where TValueFormatter : IValueFormatter
    {
      this._valueFormattersToSkip.Add(typeof (TValueFormatter));
    }

    public bool FormattersToSkipContains(Type valueFormatterType)
    {
      return this._valueFormattersToSkip.Contains(valueFormatterType);
    }

    public void AddFormatter(IValueFormatter valueFormatter)
    {
      this._valueFormatters.Add(valueFormatter);
    }

    public IValueFormatter[] GetFormatters() => this._valueFormatters.ToArray<IValueFormatter>();

    public void AssignCustomValueResolver(IValueResolver valueResolver)
    {
      this._ignored = false;
      this._customResolver = valueResolver;
      this.ResetSourceMemberChain();
      this._hasCustomValueResolver = true;
    }

    public void ChainTypeMemberForResolver(IValueResolver valueResolver)
    {
      this.ResetSourceMemberChain();
      this._customMemberResolver = valueResolver;
    }

    public void ChainConstructorForResolver(IValueResolver valueResolver)
    {
      this._customResolver = valueResolver;
    }

    public void Ignore() => this._ignored = true;

    public bool IsIgnored() => this._ignored;

    public void SetMappingOrder(int mappingOrder) => this._mappingOrder = mappingOrder;

    public int GetMappingOrder() => this._mappingOrder;

    public bool IsMapped()
    {
      return this._sourceValueResolvers.Count > 0 || this._hasCustomValueResolver || this._ignored;
    }

    public bool CanResolveValue()
    {
      return (this._sourceValueResolvers.Count > 0 || this._hasCustomValueResolver || this.UseDestinationValue) && !this._ignored;
    }

    public void RemoveLastFormatter()
    {
      this._valueFormatters.RemoveAt(this._valueFormatters.Count - 1);
    }

    public void SetNullSubstitute(object nullSubstitute) => this._nullSubstitute = nullSubstitute;

    private void ResetSourceMemberChain() => this._sourceValueResolvers.Clear();

    public bool Equals(PropertyMap other)
    {
      if (object.ReferenceEquals((object) null, (object) other))
        return false;
      return object.ReferenceEquals((object) this, (object) other) || object.Equals((object) other.DestinationProperty, (object) this.DestinationProperty);
    }

    public override bool Equals(object obj)
    {
      if (object.ReferenceEquals((object) null, obj))
        return false;
      if (object.ReferenceEquals((object) this, obj))
        return true;
      return (object) obj.GetType() == (object) typeof (PropertyMap) && this.Equals((PropertyMap) obj);
    }

    public override int GetHashCode() => this.DestinationProperty.GetHashCode();

    public void ApplyCondition(Func<ResolutionContext, bool> condition)
    {
      this._condition = condition;
    }

    public bool ShouldAssignValue(ResolutionContext context)
    {
      return this._condition == null || this._condition(context);
    }

    public void SetCustomValueResolverExpression<TSource, TMember>(
      Expression<Func<TSource, TMember>> sourceMember)
    {
      if (sourceMember.Body is MemberExpression)
        this.SourceMember = ((MemberExpression) sourceMember.Body).Member;
      this.CustomExpression = (LambdaExpression) sourceMember;
      this.AssignCustomValueResolver((IValueResolver) new NullReferenceExceptionSwallowingResolver((IMemberResolver) new DelegateBasedResolver<TSource, TMember>(sourceMember.Compile())));
    }

    public object GetDestinationValue(object mappedObject)
    {
      return !this.UseDestinationValue ? (object) null : this.DestinationProperty.GetValue(mappedObject);
    }

    public ExpressionResolutionResult ResolveExpression(
      Type currentType,
      Expression instanceParameter)
    {
      Expression expression = instanceParameter;
      Type type = currentType;
      foreach (IValueResolver sourceValueResolver in this.GetSourceValueResolvers())
      {
        if (sourceValueResolver is IMemberGetter memberGetter)
        {
          PropertyInfo memberInfo = memberGetter.MemberInfo as PropertyInfo;
          expression = (object) memberInfo != null ? (Expression) Expression.Property(expression, memberInfo) : throw new NotImplementedException("Expressions mapping from methods not supported yet.");
          type = memberInfo.PropertyType;
        }
        else
        {
          ParameterExpression oldParameter = this.CustomExpression.Parameters.Single<ParameterExpression>();
          expression = new PropertyMap.ConversionVisitor(instanceParameter, oldParameter).Visit(this.CustomExpression.Body);
          type = expression.Type;
        }
      }
      return new ExpressionResolutionResult(expression, type);
    }

    private class ConversionVisitor : ExpressionVisitor
    {
      private readonly Expression newParameter;
      private readonly ParameterExpression oldParameter;

      public ConversionVisitor(Expression newParameter, ParameterExpression oldParameter)
      {
        this.newParameter = newParameter;
        this.oldParameter = oldParameter;
      }

      protected override Expression VisitParameter(ParameterExpression node)
      {
        return (object) node.Type != (object) this.oldParameter.Type ? (Expression) node : this.newParameter;
      }

      protected override Expression VisitMember(MemberExpression node)
      {
        return node.Expression != this.oldParameter ? base.VisitMember(node) : (Expression) Expression.MakeMemberAccess(this.Visit(node.Expression), ((IEnumerable<MemberInfo>) this.newParameter.Type.GetMember(node.Member.Name)).First<MemberInfo>());
      }
    }
  }
}


--- PropertyNameResolver.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.PropertyNameResolver
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public class PropertyNameResolver : IValueResolver
  {
    private readonly Type _sourceType;
    private readonly PropertyInfo _propertyInfo;

    public PropertyNameResolver(Type sourceType, string propertyName)
    {
      this._sourceType = sourceType;
      this._propertyInfo = sourceType.GetProperty(propertyName);
    }

    public ResolutionResult Resolve(ResolutionResult source)
    {
      if (source.Value == null)
        return source;
      Type type = source.Value.GetType();
      if (!this._sourceType.IsAssignableFrom(type))
        throw new ArgumentException("Expected obj to be of type " + (object) this._sourceType + " but was " + (object) type);
      object obj = this._propertyInfo.GetValue(source.Value, (object[]) null);
      return source.New(obj);
    }
  }
}


--- ResolutionContext.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ResolutionContext
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace AutoMapper
{
  public class ResolutionContext : IEquatable<ResolutionContext>
  {
    public MappingOperationOptions Options { get; private set; }

    public TypeMap TypeMap { get; private set; }

    public PropertyMap PropertyMap { get; private set; }

    public Type SourceType { get; private set; }

    public Type DestinationType { get; private set; }

    public int? ArrayIndex { get; private set; }

    public object SourceValue { get; private set; }

    public object DestinationValue { get; private set; }

    public ResolutionContext Parent { get; private set; }

    public Dictionary<ResolutionContext, object> InstanceCache { get; private set; }

    public ResolutionContext(
      TypeMap typeMap,
      object source,
      Type sourceType,
      Type destinationType,
      MappingOperationOptions options)
      : this(typeMap, source, (object) null, sourceType, destinationType, options)
    {
    }

    public ResolutionContext(
      TypeMap typeMap,
      object source,
      object destination,
      Type sourceType,
      Type destinationType,
      MappingOperationOptions options)
    {
      this.TypeMap = typeMap;
      this.SourceValue = source;
      this.DestinationValue = destination;
      this.AssignTypes(typeMap, sourceType, destinationType);
      this.InstanceCache = new Dictionary<ResolutionContext, object>();
      this.Options = options;
    }

    private void AssignTypes(TypeMap typeMap, Type sourceType, Type destinationType)
    {
      if (typeMap != null)
      {
        this.SourceType = typeMap.SourceType;
        this.DestinationType = typeMap.DestinationType;
      }
      else
      {
        this.SourceType = sourceType;
        this.DestinationType = destinationType;
      }
    }

    private ResolutionContext(ResolutionContext context, object sourceValue)
    {
      this.ArrayIndex = context.ArrayIndex;
      this.TypeMap = context.TypeMap;
      this.PropertyMap = context.PropertyMap;
      this.SourceType = context.SourceType;
      this.SourceValue = sourceValue;
      this.DestinationValue = context.DestinationValue;
      this.Parent = context;
      this.DestinationType = context.DestinationType;
      this.InstanceCache = context.InstanceCache;
      this.Options = context.Options;
    }

    private ResolutionContext(ResolutionContext context, object sourceValue, Type sourceType)
    {
      this.ArrayIndex = context.ArrayIndex;
      this.TypeMap = context.TypeMap;
      this.PropertyMap = context.PropertyMap;
      this.SourceType = sourceType;
      this.SourceValue = sourceValue;
      this.DestinationValue = context.DestinationValue;
      this.Parent = context;
      this.DestinationType = context.DestinationType;
      this.InstanceCache = context.InstanceCache;
      this.Options = context.Options;
    }

    private ResolutionContext(
      ResolutionContext context,
      TypeMap memberTypeMap,
      object sourceValue,
      object destinationValue,
      Type sourceType,
      Type destinationType)
    {
      this.TypeMap = memberTypeMap;
      this.SourceValue = sourceValue;
      this.DestinationValue = destinationValue;
      this.Parent = context;
      this.AssignTypes(memberTypeMap, sourceType, destinationType);
      this.InstanceCache = context.InstanceCache;
      this.Options = context.Options;
    }

    private ResolutionContext(
      ResolutionContext context,
      object sourceValue,
      object destinationValue,
      TypeMap memberTypeMap,
      PropertyMap propertyMap)
    {
      this.TypeMap = memberTypeMap;
      this.PropertyMap = propertyMap;
      this.SourceValue = sourceValue;
      this.DestinationValue = destinationValue;
      this.Parent = context;
      this.InstanceCache = context.InstanceCache;
      this.SourceType = memberTypeMap.SourceType;
      this.DestinationType = memberTypeMap.DestinationType;
      this.Options = context.Options;
    }

    private ResolutionContext(
      ResolutionContext context,
      object sourceValue,
      object destinationValue,
      Type sourceType,
      PropertyMap propertyMap)
    {
      this.PropertyMap = propertyMap;
      this.SourceType = sourceType;
      this.SourceValue = sourceValue;
      this.DestinationValue = destinationValue;
      this.Parent = context;
      this.DestinationType = propertyMap.DestinationProperty.MemberType;
      this.InstanceCache = context.InstanceCache;
      this.Options = context.Options;
    }

    private ResolutionContext(
      ResolutionContext context,
      object sourceValue,
      TypeMap typeMap,
      Type sourceType,
      Type destinationType,
      int arrayIndex)
    {
      this.ArrayIndex = new int?(arrayIndex);
      this.TypeMap = typeMap;
      this.PropertyMap = context.PropertyMap;
      this.SourceValue = sourceValue;
      this.Parent = context;
      this.InstanceCache = context.InstanceCache;
      this.AssignTypes(typeMap, sourceType, destinationType);
      this.Options = context.Options;
    }

    public string MemberName
    {
      get
      {
        if (this.PropertyMap == null)
          return string.Empty;
        return this.ArrayIndex.HasValue ? this.PropertyMap.DestinationProperty.Name + (object) this.ArrayIndex.Value : this.PropertyMap.DestinationProperty.Name;
      }
    }

    public bool IsSourceValueNull => this.SourceValue is null;

    public ResolutionContext CreateValueContext(object sourceValue)
    {
      return new ResolutionContext(this, sourceValue);
    }

    public ResolutionContext CreateValueContext(object sourceValue, Type sourceType)
    {
      return new ResolutionContext(this, sourceValue, sourceType);
    }

    public ResolutionContext CreateTypeContext(
      TypeMap memberTypeMap,
      object sourceValue,
      object destinationValue,
      Type sourceType,
      Type destinationType)
    {
      return new ResolutionContext(this, memberTypeMap, sourceValue, destinationValue, sourceType, destinationType);
    }

    public ResolutionContext CreatePropertyMapContext(PropertyMap propertyMap)
    {
      return new ResolutionContext(this, this.SourceValue, this.DestinationValue, this.SourceType, propertyMap);
    }

    public ResolutionContext CreateMemberContext(
      TypeMap memberTypeMap,
      object memberValue,
      object destinationValue,
      Type sourceMemberType,
      PropertyMap propertyMap)
    {
      return memberTypeMap == null ? new ResolutionContext(this, memberValue, destinationValue, sourceMemberType, propertyMap) : new ResolutionContext(this, memberValue, destinationValue, memberTypeMap, propertyMap);
    }

    public ResolutionContext CreateElementContext(
      TypeMap elementTypeMap,
      object item,
      Type sourceElementType,
      Type destinationElementType,
      int arrayIndex)
    {
      return new ResolutionContext(this, item, elementTypeMap, sourceElementType, destinationElementType, arrayIndex);
    }

    public override string ToString()
    {
      return string.Format("Trying to map {0} to {1}.", new object[2]
      {
        (object) this.SourceType.Name,
        (object) this.DestinationType.Name
      });
    }

    public TypeMap GetContextTypeMap()
    {
      TypeMap typeMap = this.TypeMap;
      for (ResolutionContext parent = this.Parent; typeMap == null && parent != null; parent = parent.Parent)
        typeMap = parent.TypeMap;
      return typeMap;
    }

    public PropertyMap GetContextPropertyMap()
    {
      PropertyMap propertyMap = this.PropertyMap;
      for (ResolutionContext parent = this.Parent; propertyMap == null && parent != null; parent = parent.Parent)
        propertyMap = parent.PropertyMap;
      return propertyMap;
    }

    public bool Equals(ResolutionContext other)
    {
      if (object.ReferenceEquals((object) null, (object) other))
        return false;
      if (object.ReferenceEquals((object) this, (object) other))
        return true;
      return object.Equals((object) other.TypeMap, (object) this.TypeMap) && object.Equals((object) other.SourceType, (object) this.SourceType) && object.Equals((object) other.DestinationType, (object) this.DestinationType) && object.Equals(other.SourceValue, this.SourceValue);
    }

    public override bool Equals(object obj)
    {
      if (object.ReferenceEquals((object) null, obj))
        return false;
      if (object.ReferenceEquals((object) this, obj))
        return true;
      return (object) obj.GetType() == (object) typeof (ResolutionContext) && this.Equals((ResolutionContext) obj);
    }

    public override int GetHashCode()
    {
      return (((this.TypeMap != null ? this.TypeMap.GetHashCode() : 0) * 397 ^ ((object) this.SourceType != null ? this.SourceType.GetHashCode() : 0)) * 397 ^ ((object) this.DestinationType != null ? this.DestinationType.GetHashCode() : 0)) * 397 ^ (this.SourceValue != null ? this.SourceValue.GetHashCode() : 0);
    }

    public static ResolutionContext New<TSource>(TSource sourceValue)
    {
      return new ResolutionContext((TypeMap) null, (object) sourceValue, typeof (TSource), (Type) null, new MappingOperationOptions());
    }
  }
}


--- ResolutionExpression.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ResolutionExpression
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public class ResolutionExpression(Type sourceType, PropertyMap propertyMap) : 
    ResolutionExpression<object>(sourceType, propertyMap)
  {
  }
}


--- ResolutionExpression`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ResolutionExpression`1
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Linq.Expressions;

#nullable disable
namespace AutoMapper
{
  public class ResolutionExpression<TSource> : 
    IResolverConfigurationExpression<TSource>,
    IResolutionExpression<TSource>,
    IResolverConfigurationExpression,
    IResolutionExpression
  {
    private readonly Type _sourceType;
    private readonly PropertyMap _propertyMap;

    public ResolutionExpression(PropertyMap propertyMap)
      : this(typeof (TSource), propertyMap)
    {
    }

    public ResolutionExpression(Type sourceType, PropertyMap propertyMap)
    {
      this._sourceType = sourceType;
      this._propertyMap = propertyMap;
    }

    public void FromMember(Expression<Func<TSource, object>> sourceMember)
    {
      if (sourceMember.Body is MemberExpression)
        this._propertyMap.SourceMember = (sourceMember.Body as MemberExpression).Member;
      this._propertyMap.ChainTypeMemberForResolver((IValueResolver) new DelegateBasedResolver<TSource>(sourceMember.Compile()));
    }

    public void FromMember(string sourcePropertyName)
    {
      this._propertyMap.SourceMember = this._sourceType.GetMember(sourcePropertyName)[0];
      this._propertyMap.ChainTypeMemberForResolver((IValueResolver) new PropertyNameResolver(this._sourceType, sourcePropertyName));
    }

    IResolutionExpression IResolverConfigurationExpression.ConstructedBy(
      Func<IValueResolver> constructor)
    {
      return (IResolutionExpression) this.ConstructedBy(constructor);
    }

    public IResolutionExpression<TSource> ConstructedBy(Func<IValueResolver> constructor)
    {
      this._propertyMap.ChainConstructorForResolver((IValueResolver) new DeferredInstantiatedResolver((Func<ResolutionContext, IValueResolver>) (ctxt => constructor())));
      return (IResolutionExpression<TSource>) this;
    }
  }
}


--- ResolutionExpression`2.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ResolutionExpression`2
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;
using System.Linq.Expressions;

#nullable disable
namespace AutoMapper
{
  public class ResolutionExpression<TSource, TValueResolver> : 
    IResolverConfigurationExpression<TSource, TValueResolver>
    where TValueResolver : IValueResolver
  {
    private readonly PropertyMap _propertyMap;

    public ResolutionExpression(PropertyMap propertyMap) => this._propertyMap = propertyMap;

    public IResolverConfigurationExpression<TSource, TValueResolver> FromMember(
      Expression<Func<TSource, object>> sourceMember)
    {
      if (sourceMember.Body is MemberExpression)
        this._propertyMap.SourceMember = ((MemberExpression) sourceMember.Body).Member;
      this._propertyMap.ChainTypeMemberForResolver((IValueResolver) new DelegateBasedResolver<TSource>(sourceMember.Compile()));
      return (IResolverConfigurationExpression<TSource, TValueResolver>) this;
    }

    public IResolverConfigurationExpression<TSource, TValueResolver> FromMember(
      string sourcePropertyName)
    {
      this._propertyMap.SourceMember = typeof (TSource).GetMember(sourcePropertyName)[0];
      this._propertyMap.ChainTypeMemberForResolver((IValueResolver) new PropertyNameResolver(typeof (TSource), sourcePropertyName));
      return (IResolverConfigurationExpression<TSource, TValueResolver>) this;
    }

    public IResolverConfigurationExpression<TSource, TValueResolver> ConstructedBy(
      Func<TValueResolver> constructor)
    {
      this._propertyMap.ChainConstructorForResolver((IValueResolver) new DeferredInstantiatedResolver((Func<ResolutionContext, IValueResolver>) (ctxt => (IValueResolver) constructor())));
      return (IResolverConfigurationExpression<TSource, TValueResolver>) this;
    }
  }
}


--- ResolutionResult.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ResolutionResult
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public class ResolutionResult
  {
    private readonly object _value;
    private readonly ResolutionContext _context;
    private readonly Type _type;
    private readonly Type _memberType;

    public ResolutionResult(ResolutionContext context)
      : this(context.SourceValue, context, context.SourceType)
    {
    }

    private ResolutionResult(object value, ResolutionContext context, Type memberType)
    {
      this._value = value;
      this._context = context;
      this._type = this.ResolveType(value, memberType);
      this._memberType = memberType;
    }

    private ResolutionResult(object value, ResolutionContext context)
    {
      this._value = value;
      this._context = context;
      this._type = this.ResolveType(value, typeof (object));
      this._memberType = this._type;
    }

    public object Value => this._value;

    public Type Type => this._type;

    public Type MemberType => this._memberType;

    public ResolutionContext Context => this._context;

    public bool ShouldIgnore { get; set; }

    private Type ResolveType(object value, Type memberType)
    {
      return value == null ? memberType : value.GetType();
    }

    public ResolutionResult Ignore()
    {
      return new ResolutionResult(this.Context)
      {
        ShouldIgnore = true
      };
    }

    public ResolutionResult New(object value) => new ResolutionResult(value, this.Context);

    public ResolutionResult New(object value, Type memberType)
    {
      return new ResolutionResult(value, this.Context, memberType);
    }
  }
}


--- SourceMemberConfig.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.SourceMemberConfig
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public class SourceMemberConfig
  {
    private bool _ignored;

    public SourceMemberConfig(MemberInfo sourceMember) => this.SourceMember = sourceMember;

    public MemberInfo SourceMember { get; private set; }

    public void Ignore() => this._ignored = true;

    public bool IsIgnored() => this._ignored;
  }
}


--- ThreadSafeList`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ThreadSafeList`1
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Internal;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

#nullable disable
namespace AutoMapper
{
  public class ThreadSafeList<T> : IEnumerable<T>, IEnumerable, IDisposable where T : class
  {
    private static readonly IReaderWriterLockSlimFactory ReaderWriterLockSlimFactory = PlatformAdapter.Resolve<IReaderWriterLockSlimFactory>();
    private IReaderWriterLockSlim _lock = ThreadSafeList<T>.ReaderWriterLockSlimFactory.Create();
    private readonly IList<T> _propertyMaps = (IList<T>) new List<T>();
    private bool _disposed;

    public void Add(T propertyMap)
    {
      this._lock.EnterWriteLock();
      try
      {
        this._propertyMaps.Add(propertyMap);
      }
      finally
      {
        this._lock.ExitWriteLock();
      }
    }

    public T GetOrCreate(Predicate<T> predicate, Func<T> creatorFunc)
    {
      this._lock.EnterUpgradeableReadLock();
      try
      {
        T obj = this._propertyMaps.FirstOrDefault<T>((Func<T, bool>) (pm => predicate(pm)));
        if ((object) obj == null)
        {
          this._lock.EnterWriteLock();
          try
          {
            obj = creatorFunc();
            this._propertyMaps.Add(obj);
          }
          finally
          {
            this._lock.ExitWriteLock();
          }
        }
        return obj;
      }
      finally
      {
        this._lock.ExitUpgradeableReadLock();
      }
    }

    public void Clear()
    {
      this._lock.EnterWriteLock();
      try
      {
        this._propertyMaps.Clear();
      }
      finally
      {
        this._lock.ExitWriteLock();
      }
    }

    IEnumerator<T> IEnumerable<T>.GetEnumerator() => this.GetEnumeratorImpl();

    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumeratorImpl();

    private IEnumerator<T> GetEnumeratorImpl()
    {
      this._lock.EnterReadLock();
      try
      {
        return (IEnumerator<T>) this._propertyMaps.ToList<T>().GetEnumerator();
      }
      finally
      {
        this._lock.ExitReadLock();
      }
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    protected virtual void Dispose(bool disposing)
    {
      if (this._disposed)
        return;
      if (disposing && this._lock != null)
        this._lock.Dispose();
      this._lock = (IReaderWriterLockSlim) null;
      this._disposed = true;
    }
  }
}


--- TypeConverter`2.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.TypeConverter`2
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public abstract class TypeConverter<TSource, TDestination> : ITypeConverter<TSource, TDestination>
  {
    public TDestination Convert(ResolutionContext context)
    {
      return context.SourceValue == null || context.SourceValue is TSource ? this.ConvertCore((TSource) context.SourceValue) : throw new AutoMapperMappingException(context, string.Format("Value supplied is of type {0} but expected {1}.\nChange the type converter source type, or redirect the source value supplied to the value resolver using FromMember.", new object[2]
      {
        (object) typeof (TSource),
        (object) context.SourceValue.GetType()
      }));
    }

    protected abstract TDestination ConvertCore(TSource source);
  }
}


--- TypeInfo.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.TypeInfo
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Internal;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public class TypeInfo
  {
    private readonly MemberInfo[] _publicGetters;
    private readonly MemberInfo[] _publicAccessors;
    private readonly MethodInfo[] _publicGetMethods;
    private readonly ConstructorInfo[] _constructors;
    private readonly MethodInfo[] _extensionMethods;

    public Type Type { get; private set; }

    public TypeInfo(Type type)
      : this(type, (IEnumerable<MethodInfo>) new MethodInfo[0])
    {
    }

    public TypeInfo(
      Type type,
      IEnumerable<MethodInfo> sourceExtensionMethodSearch)
    {
      this.Type = type;
      IEnumerable<MemberInfo> publicReadableMembers = this.GetAllPublicReadableMembers();
      IEnumerable<MemberInfo> publicWritableMembers = this.GetAllPublicWritableMembers();
      this._publicGetters = this.BuildPublicReadAccessors(publicReadableMembers);
      this._publicAccessors = this.BuildPublicAccessors(publicWritableMembers);
      this._publicGetMethods = this.BuildPublicNoArgMethods();
      this._constructors = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
      this._extensionMethods = this.BuildPublicNoArgExtensionMethods(sourceExtensionMethodSearch);
    }

    public IEnumerable<ConstructorInfo> GetConstructors()
    {
      return (IEnumerable<ConstructorInfo>) this._constructors;
    }

    public IEnumerable<MemberInfo> GetPublicReadAccessors()
    {
      return (IEnumerable<MemberInfo>) this._publicGetters;
    }

    public IEnumerable<MemberInfo> GetPublicWriteAccessors()
    {
      return (IEnumerable<MemberInfo>) this._publicAccessors;
    }

    public IEnumerable<MethodInfo> GetPublicNoArgMethods()
    {
      return (IEnumerable<MethodInfo>) this._publicGetMethods;
    }

    public IEnumerable<MethodInfo> GetPublicNoArgExtensionMethods()
    {
      return (IEnumerable<MethodInfo>) this._extensionMethods;
    }

    private MethodInfo[] BuildPublicNoArgExtensionMethods(
      IEnumerable<MethodInfo> sourceExtensionMethodSearch)
    {
      MethodInfo[] array = sourceExtensionMethodSearch.ToArray<MethodInfo>();
      List<MethodInfo> list1 = ((IEnumerable<MethodInfo>) array).Where<MethodInfo>((Func<MethodInfo, bool>) (method => (object) method.GetParameters()[0].ParameterType == (object) this.Type)).ToList<MethodInfo>();
      List<Type> list2 = ((IEnumerable<Type>) this.Type.GetInterfaces()).Where<Type>((Func<Type, bool>) (t => t.IsGenericType)).ToList<Type>();
      if (this.Type.IsInterface && this.Type.IsGenericType)
        list2.Add(this.Type);
      foreach (MethodInfo methodInfo in ((IEnumerable<MethodInfo>) array).Where<MethodInfo>((Func<MethodInfo, bool>) (method => method.IsGenericMethodDefinition)))
      {
        MethodInfo method = methodInfo;
        Type parameterType = method.GetParameters()[0].ParameterType;
        Type type = list2.Where<Type>((Func<Type, bool>) (t => t.GetGenericTypeDefinition().GetGenericArguments().Length == parameterType.GetGenericArguments().Length)).FirstOrDefault<Type>((Func<Type, bool>) (t => method.MakeGenericMethod(t.GetGenericArguments()).GetParameters()[0].ParameterType.IsAssignableFrom(t)));
        if ((object) type != null)
          list1.Add(method.MakeGenericMethod(type.GetGenericArguments()));
      }
      return list1.ToArray();
    }

    private MemberInfo[] BuildPublicReadAccessors(IEnumerable<MemberInfo> allMembers)
    {
      return allMembers.OfType<PropertyInfo>().GroupBy<PropertyInfo, string>((Func<PropertyInfo, string>) (x => x.Name)).Select<IGrouping<string, PropertyInfo>, PropertyInfo>((Func<IGrouping<string, PropertyInfo>, PropertyInfo>) (x => x.First<PropertyInfo>())).OfType<MemberInfo>().Concat<MemberInfo>(allMembers.Where<MemberInfo>((Func<MemberInfo, bool>) (x => x is FieldInfo))).ToArray<MemberInfo>();
    }

    private MemberInfo[] BuildPublicAccessors(IEnumerable<MemberInfo> allMembers)
    {
      return allMembers.OfType<PropertyInfo>().GroupBy<PropertyInfo, string>((Func<PropertyInfo, string>) (x => x.Name)).Select<IGrouping<string, PropertyInfo>, PropertyInfo>((Func<IGrouping<string, PropertyInfo>, PropertyInfo>) (x => !x.Any<PropertyInfo>((Func<PropertyInfo, bool>) (y => y.CanWrite && y.CanRead)) ? x.First<PropertyInfo>() : x.First<PropertyInfo>((Func<PropertyInfo, bool>) (y => y.CanWrite && y.CanRead)))).Where<PropertyInfo>((Func<PropertyInfo, bool>) (pi => pi.CanWrite || pi.PropertyType.IsListOrDictionaryType())).OfType<MemberInfo>().Concat<MemberInfo>(allMembers.Where<MemberInfo>((Func<MemberInfo, bool>) (x => x is FieldInfo))).ToArray<MemberInfo>();
    }

    private IEnumerable<MemberInfo> GetAllPublicReadableMembers()
    {
      return this.GetAllPublicMembers(new Func<PropertyInfo, bool>(this.PropertyReadable), BindingFlags.Instance | BindingFlags.Public);
    }

    private IEnumerable<MemberInfo> GetAllPublicWritableMembers()
    {
      return this.GetAllPublicMembers(new Func<PropertyInfo, bool>(this.PropertyWritable), BindingFlags.Instance | BindingFlags.Public);
    }

    private bool PropertyReadable(PropertyInfo propertyInfo) => propertyInfo.CanRead;

    private bool PropertyWritable(PropertyInfo propertyInfo)
    {
      bool flag = (object) typeof (string) != (object) propertyInfo.PropertyType && typeof (IEnumerable).IsAssignableFrom(propertyInfo.PropertyType);
      return propertyInfo.CanWrite || flag;
    }

    private IEnumerable<MemberInfo> GetAllPublicMembers(
      Func<PropertyInfo, bool> propertyAvailableFor,
      BindingFlags bindingAttr)
    {
      List<Type> source = new List<Type>();
      for (Type type = this.Type; (object) type != null; type = type.BaseType)
        source.Add(type);
      if (this.Type.IsInterface)
        source.AddRange((IEnumerable<Type>) this.Type.GetInterfaces());
      return source.Where<Type>((Func<Type, bool>) (x => (object) x != null)).SelectMany<Type, MemberInfo>((Func<Type, IEnumerable<MemberInfo>>) (x => ((IEnumerable<MemberInfo>) x.GetMembers(bindingAttr | BindingFlags.DeclaredOnly)).Where<MemberInfo>((Func<MemberInfo, bool>) (m =>
      {
        if ((object) (m as FieldInfo) != null)
          return true;
        return (object) (m as PropertyInfo) != null && propertyAvailableFor((PropertyInfo) m) && !((IEnumerable<ParameterInfo>) ((PropertyInfo) m).GetIndexParameters()).Any<ParameterInfo>();
      }))));
    }

    private MethodInfo[] BuildPublicNoArgMethods()
    {
      return ((IEnumerable<MethodInfo>) this.Type.GetMethods(BindingFlags.Instance | BindingFlags.Public)).Where<MethodInfo>((Func<MethodInfo, bool>) (m => (object) m.ReturnType != (object) typeof (void) && m.GetParameters().Length == 0)).ToArray<MethodInfo>();
    }
  }
}


--- TypeMap.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.TypeMap
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Impl;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

#nullable disable
namespace AutoMapper
{
  public class TypeMap
  {
    private readonly IList<Action<object, object>> _afterMapActions = (IList<Action<object, object>>) new List<Action<object, object>>();
    private readonly IList<Action<object, object>> _beforeMapActions = (IList<Action<object, object>>) new List<Action<object, object>>();
    private readonly TypeInfo _destinationType;
    private readonly ISet<TypePair> _includedDerivedTypes = (ISet<TypePair>) new HashSet<TypePair>();
    private readonly ThreadSafeList<PropertyMap> _propertyMaps = new ThreadSafeList<PropertyMap>();
    private readonly ThreadSafeList<SourceMemberConfig> _sourceMemberConfigs = new ThreadSafeList<SourceMemberConfig>();
    private readonly IList<PropertyMap> _inheritedMaps = (IList<PropertyMap>) new List<PropertyMap>();
    private PropertyMap[] _orderedPropertyMaps;
    private readonly TypeInfo _sourceType;
    private bool _sealed;
    private Func<ResolutionContext, bool> _condition;
    private ConstructorMap _constructorMap;

    public TypeMap(TypeInfo sourceType, TypeInfo destinationType, MemberList memberList)
    {
      this._sourceType = sourceType;
      this._destinationType = destinationType;
      this.Profile = "";
      this.ConfiguredMemberList = memberList;
    }

    public ConstructorMap ConstructorMap => this._constructorMap;

    public Type SourceType => this._sourceType.Type;

    public Type DestinationType => this._destinationType.Type;

    public string Profile { get; set; }

    public Func<ResolutionContext, object> CustomMapper { get; private set; }

    public Action<object, object> BeforeMap
    {
      get
      {
        return (Action<object, object>) ((src, dest) =>
        {
          foreach (Action<object, object> beforeMapAction in (IEnumerable<Action<object, object>>) this._beforeMapActions)
            beforeMapAction(src, dest);
        });
      }
    }

    public Action<object, object> AfterMap
    {
      get
      {
        return (Action<object, object>) ((src, dest) =>
        {
          foreach (Action<object, object> afterMapAction in (IEnumerable<Action<object, object>>) this._afterMapActions)
            afterMapAction(src, dest);
        });
      }
    }

    public Func<ResolutionContext, object> DestinationCtor { get; set; }

    public List<string> IgnorePropertiesStartingWith { get; set; }

    public Type DestinationTypeOverride { get; set; }

    public bool ConstructDestinationUsingServiceLocator { get; set; }

    public MemberList ConfiguredMemberList { get; private set; }

    public IEnumerable<PropertyMap> GetPropertyMaps()
    {
      return this._sealed ? (IEnumerable<PropertyMap>) this._orderedPropertyMaps : this._propertyMaps.Concat<PropertyMap>((IEnumerable<PropertyMap>) this._inheritedMaps);
    }

    public IEnumerable<PropertyMap> GetCustomPropertyMaps()
    {
      return (IEnumerable<PropertyMap>) this._propertyMaps;
    }

    public void AddPropertyMap(PropertyMap propertyMap) => this._propertyMaps.Add(propertyMap);

    protected void AddInheritedMap(PropertyMap propertyMap) => this._inheritedMaps.Add(propertyMap);

    public void AddPropertyMap(IMemberAccessor destProperty, IEnumerable<IValueResolver> resolvers)
    {
      PropertyMap propertyMap = new PropertyMap(destProperty);
      resolvers.Each<IValueResolver>(new Action<IValueResolver>(propertyMap.ChainResolver));
      this.AddPropertyMap(propertyMap);
    }

    public string[] GetUnmappedPropertyNames()
    {
      IEnumerable<string> second1 = this._propertyMaps.Where<PropertyMap>((Func<PropertyMap, bool>) (pm => pm.IsMapped())).Select<PropertyMap, string>((Func<PropertyMap, string>) (pm => pm.DestinationProperty.Name));
      IEnumerable<string> second2 = this._inheritedMaps.Where<PropertyMap>((Func<PropertyMap, bool>) (pm => pm.IsMapped())).Select<PropertyMap, string>((Func<PropertyMap, string>) (pm => pm.DestinationProperty.Name));
      IEnumerable<string> source;
      if (this.ConfiguredMemberList == MemberList.Destination)
      {
        source = this._destinationType.GetPublicWriteAccessors().Select<MemberInfo, string>((Func<MemberInfo, string>) (p => p.Name)).Except<string>(second1).Except<string>(second2);
      }
      else
      {
        IEnumerable<string> second3 = this._propertyMaps.Where<PropertyMap>((Func<PropertyMap, bool>) (pm => pm.IsMapped())).Where<PropertyMap>((Func<PropertyMap, bool>) (pm => pm.CustomExpression != null)).Where<PropertyMap>((Func<PropertyMap, bool>) (pm => (object) pm.SourceMember != null)).Select<PropertyMap, string>((Func<PropertyMap, string>) (pm => pm.SourceMember.Name));
        IEnumerable<string> second4 = this._sourceMemberConfigs.Where<SourceMemberConfig>((Func<SourceMemberConfig, bool>) (smc => smc.IsIgnored())).Select<SourceMemberConfig, string>((Func<SourceMemberConfig, string>) (pm => pm.SourceMember.Name));
        source = this._sourceType.GetPublicReadAccessors().Select<MemberInfo, string>((Func<MemberInfo, string>) (p => p.Name)).Except<string>(second1).Except<string>(second2).Except<string>(second3).Except<string>(second4);
      }
      return source.Where<string>((Func<string, bool>) (memberName => !this.IgnorePropertiesStartingWith.Any<string>(new Func<string, bool>(memberName.StartsWith)))).ToArray<string>();
    }

    public PropertyMap FindOrCreatePropertyMapFor(IMemberAccessor destinationProperty)
    {
      PropertyMap propertyMap = this.GetExistingPropertyMapFor(destinationProperty);
      if (propertyMap == null)
      {
        propertyMap = new PropertyMap(destinationProperty);
        this.AddPropertyMap(propertyMap);
      }
      return propertyMap;
    }

    public void IncludeDerivedTypes(Type derivedSourceType, Type derivedDestinationType)
    {
      this._includedDerivedTypes.Add(new TypePair(derivedSourceType, derivedDestinationType));
    }

    public Type GetDerivedTypeFor(Type derivedSourceType)
    {
      TypePair typePair = this._includedDerivedTypes.FirstOrDefault<TypePair>((Func<TypePair, bool>) (tp => (object) tp.SourceType == (object) derivedSourceType));
      return !typePair.Equals(new TypePair()) ? typePair.DestinationType : this.DestinationType;
    }

    public bool TypeHasBeenIncluded(Type derivedSourceType, Type derivedDestinationType)
    {
      return this._includedDerivedTypes.Contains(new TypePair(derivedSourceType, derivedDestinationType));
    }

    public bool HasDerivedTypesToInclude() => this._includedDerivedTypes.Any<TypePair>();

    public void UseCustomMapper(Func<ResolutionContext, object> customMapper)
    {
      this.CustomMapper = customMapper;
      this._propertyMaps.Clear();
    }

    public void AddBeforeMapAction(Action<object, object> beforeMap)
    {
      this._beforeMapActions.Add(beforeMap);
    }

    public void AddAfterMapAction(Action<object, object> afterMap)
    {
      this._afterMapActions.Add(afterMap);
    }

    public void Seal()
    {
      if (this._sealed)
        return;
      this._orderedPropertyMaps = this._propertyMaps.Union<PropertyMap>((IEnumerable<PropertyMap>) this._inheritedMaps).OrderBy<PropertyMap, int>((Func<PropertyMap, int>) (map => map.GetMappingOrder())).ToArray<PropertyMap>();
      ((IEnumerable<PropertyMap>) this._orderedPropertyMaps).Each<PropertyMap>((Action<PropertyMap>) (pm => pm.Seal()));
      this._sealed = true;
    }

    public bool Equals(TypeMap other)
    {
      if (object.ReferenceEquals((object) null, (object) other))
        return false;
      if (object.ReferenceEquals((object) this, (object) other))
        return true;
      return object.Equals((object) other._sourceType, (object) this._sourceType) && object.Equals((object) other._destinationType, (object) this._destinationType);
    }

    public override bool Equals(object obj)
    {
      if (object.ReferenceEquals((object) null, obj))
        return false;
      if (object.ReferenceEquals((object) this, obj))
        return true;
      return (object) obj.GetType() == (object) typeof (TypeMap) && this.Equals((TypeMap) obj);
    }

    public override int GetHashCode()
    {
      return this._sourceType.GetHashCode() * 397 ^ this._destinationType.GetHashCode();
    }

    public PropertyMap GetExistingPropertyMapFor(IMemberAccessor destinationProperty)
    {
      return this._propertyMaps.FirstOrDefault<PropertyMap>((Func<PropertyMap, bool>) (pm => pm.DestinationProperty.Name.Equals(destinationProperty.Name))) ?? this._inheritedMaps.FirstOrDefault<PropertyMap>((Func<PropertyMap, bool>) (pm => pm.DestinationProperty.Name.Equals(destinationProperty.Name)));
    }

    public void AddInheritedPropertyMap(PropertyMap mappedProperty)
    {
      this._inheritedMaps.Add(mappedProperty);
    }

    public void InheritTypes(TypeMap inheritedTypeMap)
    {
      foreach (TypePair typePair in inheritedTypeMap._includedDerivedTypes.Where<TypePair>((Func<TypePair, bool>) (includedDerivedType => !this._includedDerivedTypes.Contains(includedDerivedType))))
        this._includedDerivedTypes.Add(typePair);
    }

    public void SetCondition(Func<ResolutionContext, bool> condition)
    {
      this._condition = condition;
    }

    public bool ShouldAssignValue(ResolutionContext resolutionContext)
    {
      return this._condition == null || this._condition(resolutionContext);
    }

    public void AddConstructorMap(
      ConstructorInfo constructorInfo,
      IEnumerable<ConstructorParameterMap> parameters)
    {
      this._constructorMap = new ConstructorMap(constructorInfo, parameters);
    }

    public SourceMemberConfig FindOrCreateSourceMemberConfigFor(MemberInfo sourceMember)
    {
      SourceMemberConfig propertyMap = this._sourceMemberConfigs.FirstOrDefault<SourceMemberConfig>((Func<SourceMemberConfig, bool>) (smc => (object) smc.SourceMember == (object) sourceMember));
      if (propertyMap == null)
      {
        propertyMap = new SourceMemberConfig(sourceMember);
        this._sourceMemberConfigs.Add(propertyMap);
      }
      return propertyMap;
    }
  }
}


--- TypeMapCreatedEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.TypeMapCreatedEventArgs
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using System;

#nullable disable
namespace AutoMapper
{
  public class TypeMapCreatedEventArgs : EventArgs
  {
    public TypeMap TypeMap { get; private set; }

    public TypeMapCreatedEventArgs(TypeMap typeMap) => this.TypeMap = typeMap;
  }
}


--- TypeMapFactory.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.TypeMapFactory
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Impl;
using AutoMapper.Internal;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;

#nullable disable
namespace AutoMapper
{
  public class TypeMapFactory : ITypeMapFactory
  {
    private static readonly IDictionaryFactory DictionaryFactory = PlatformAdapter.Resolve<IDictionaryFactory>();
    private static readonly AutoMapper.Internal.IDictionary<Type, TypeInfo> _typeInfos = TypeMapFactory.DictionaryFactory.CreateDictionary<Type, TypeInfo>();

    public TypeMap CreateTypeMap(
      Type sourceType,
      Type destinationType,
      IMappingOptions options,
      MemberList memberList)
    {
      TypeInfo typeInfo1 = TypeMapFactory.GetTypeInfo(sourceType, options.SourceExtensionMethods);
      TypeInfo typeInfo2 = TypeMapFactory.GetTypeInfo(destinationType, (IEnumerable<MethodInfo>) new MethodInfo[0]);
      TypeMap typeMap = new TypeMap(typeInfo1, typeInfo2, memberList);
      foreach (MemberInfo publicWriteAccessor in typeInfo2.GetPublicWriteAccessors())
      {
        LinkedList<MemberInfo> linkedList = new LinkedList<MemberInfo>();
        if (this.MapDestinationPropertyToSource(linkedList, typeInfo1, publicWriteAccessor.Name, options))
        {
          IEnumerable<IMemberGetter> source = linkedList.Select<MemberInfo, IMemberGetter>((Func<MemberInfo, IMemberGetter>) (mi => mi.ToMemberGetter()));
          IMemberAccessor memberAccessor = publicWriteAccessor.ToMemberAccessor();
          typeMap.AddPropertyMap(memberAccessor, source.Cast<IValueResolver>());
        }
      }
      if (!destinationType.IsAbstract && destinationType.IsClass)
      {
        foreach (ConstructorInfo destCtor in (IEnumerable<ConstructorInfo>) typeInfo2.GetConstructors().OrderByDescending<ConstructorInfo, int>((Func<ConstructorInfo, int>) (ci => ci.GetParameters().Length)))
        {
          if (this.MapDestinationCtorToSource(typeMap, destCtor, typeInfo1, options))
            break;
        }
      }
      return typeMap;
    }

    private bool MapDestinationCtorToSource(
      TypeMap typeMap,
      ConstructorInfo destCtor,
      TypeInfo sourceTypeInfo,
      IMappingOptions options)
    {
      List<ConstructorParameterMap> parameters1 = new List<ConstructorParameterMap>();
      ParameterInfo[] parameters2 = destCtor.GetParameters();
      if (parameters2.Length == 0 || !options.ConstructorMappingEnabled)
        return false;
      foreach (ParameterInfo parameter in parameters2)
      {
        LinkedList<MemberInfo> linkedList = new LinkedList<MemberInfo>();
        if (!this.MapDestinationPropertyToSource(linkedList, sourceTypeInfo, parameter.Name, options))
          return false;
        IEnumerable<IMemberGetter> source = linkedList.Select<MemberInfo, IMemberGetter>((Func<MemberInfo, IMemberGetter>) (mi => mi.ToMemberGetter()));
        ConstructorParameterMap constructorParameterMap = new ConstructorParameterMap(parameter, source.ToArray<IMemberGetter>());
        parameters1.Add(constructorParameterMap);
      }
      typeMap.AddConstructorMap(destCtor, (IEnumerable<ConstructorParameterMap>) parameters1);
      return true;
    }

    private static TypeInfo GetTypeInfo(Type type, IEnumerable<MethodInfo> extensionMethodsToSearch)
    {
      return TypeMapFactory._typeInfos.GetOrAdd(type, (Func<Type, TypeInfo>) (t => new TypeInfo(type, extensionMethodsToSearch)));
    }

    private bool MapDestinationPropertyToSource(
      LinkedList<MemberInfo> resolvers,
      TypeInfo sourceType,
      string nameToSearch,
      IMappingOptions mappingOptions)
    {
      if (string.IsNullOrEmpty(nameToSearch))
        return true;
      IEnumerable<MemberInfo> publicReadAccessors = sourceType.GetPublicReadAccessors();
      IEnumerable<MethodInfo> publicNoArgMethods = sourceType.GetPublicNoArgMethods();
      IEnumerable<MethodInfo> extensionMethods = sourceType.GetPublicNoArgExtensionMethods();
      MemberInfo typeMember1 = TypeMapFactory.FindTypeMember(publicReadAccessors, publicNoArgMethods, extensionMethods, nameToSearch, mappingOptions);
      bool source = (object) typeMember1 != null;
      if (source)
      {
        resolvers.AddLast(typeMember1);
      }
      else
      {
        string[] array = mappingOptions.DestinationMemberNamingConvention.SplittingExpression.Matches(nameToSearch).Cast<Match>().Select<Match, string>((Func<Match, string>) (m => m.Value)).ToArray<string>();
        for (int i = 1; i <= array.Length && !source; ++i)
        {
          TypeMapFactory.NameSnippet nameSnippet = this.CreateNameSnippet((IEnumerable<string>) array, i, mappingOptions);
          MemberInfo typeMember2 = TypeMapFactory.FindTypeMember(publicReadAccessors, publicNoArgMethods, extensionMethods, nameSnippet.First, mappingOptions);
          if ((object) typeMember2 != null)
          {
            resolvers.AddLast(typeMember2);
            source = this.MapDestinationPropertyToSource(resolvers, TypeMapFactory.GetTypeInfo(typeMember2.GetMemberType(), mappingOptions.SourceExtensionMethods), nameSnippet.Second, mappingOptions);
            if (!source)
              resolvers.RemoveLast();
          }
        }
      }
      return source;
    }

    private static MemberInfo FindTypeMember(
      IEnumerable<MemberInfo> modelProperties,
      IEnumerable<MethodInfo> getMethods,
      IEnumerable<MethodInfo> getExtensionMethods,
      string nameToSearch,
      IMappingOptions mappingOptions)
    {
      MemberInfo typeMember1 = modelProperties.FirstOrDefault<MemberInfo>((Func<MemberInfo, bool>) (prop => TypeMapFactory.NameMatches(prop.Name, nameToSearch, mappingOptions)));
      if ((object) typeMember1 != null)
        return typeMember1;
      MethodInfo typeMember2 = getMethods.FirstOrDefault<MethodInfo>((Func<MethodInfo, bool>) (m => TypeMapFactory.NameMatches(m.Name, nameToSearch, mappingOptions)));
      if ((object) typeMember2 != null)
        return (MemberInfo) typeMember2;
      MethodInfo methodInfo = getExtensionMethods.FirstOrDefault<MethodInfo>((Func<MethodInfo, bool>) (m => TypeMapFactory.NameMatches(m.Name, nameToSearch, mappingOptions)));
      return (object) methodInfo != null ? (MemberInfo) methodInfo : (MemberInfo) null;
    }

    private static bool NameMatches(
      string memberName,
      string nameToMatch,
      IMappingOptions mappingOptions)
    {
      IEnumerable<string> source = TypeMapFactory.PossibleNames(memberName, mappingOptions.Aliases, mappingOptions.Prefixes, mappingOptions.Postfixes);
      IEnumerable<string> possibleDestNames = TypeMapFactory.PossibleNames(nameToMatch, mappingOptions.Aliases, mappingOptions.DestinationPrefixes, mappingOptions.DestinationPostfixes);
      return source.SelectMany((Func<string, IEnumerable<string>>) (sourceName => possibleDestNames), (sourceName, destName) => new
      {
        sourceName = sourceName,
        destName = destName
      }).Any(pair => string.Compare(pair.sourceName, pair.destName, StringComparison.OrdinalIgnoreCase) == 0);
    }

    private static IEnumerable<string> PossibleNames(
      string memberName,
      IEnumerable<AliasedMember> aliases,
      IEnumerable<string> prefixes,
      IEnumerable<string> postfixes)
    {
      if (!string.IsNullOrEmpty(memberName))
      {
        yield return memberName;
        foreach (AliasedMember alias in aliases.Where<AliasedMember>((Func<AliasedMember, bool>) (alias => string.Equals(memberName, alias.Member, StringComparison.Ordinal))))
          yield return alias.Alias;
        foreach (string prefix in prefixes.Where<string>((Func<string, bool>) (prefix => memberName.StartsWith(prefix, StringComparison.Ordinal))))
        {
          string withoutPrefix = memberName.Substring(prefix.Length);
          yield return withoutPrefix;
          foreach (string postfix in postfixes.Where<string>((Func<string, bool>) (postfix => withoutPrefix.EndsWith(postfix, StringComparison.Ordinal))))
            yield return withoutPrefix.Remove(withoutPrefix.Length - postfix.Length);
        }
        foreach (string postfix in postfixes.Where<string>((Func<string, bool>) (postfix => memberName.EndsWith(postfix, StringComparison.Ordinal))))
          yield return memberName.Remove(memberName.Length - postfix.Length);
      }
    }

    private TypeMapFactory.NameSnippet CreateNameSnippet(
      IEnumerable<string> matches,
      int i,
      IMappingOptions mappingOptions)
    {
      return new TypeMapFactory.NameSnippet()
      {
        First = string.Join(mappingOptions.SourceMemberNamingConvention.SeparatorCharacter, matches.Take<string>(i).ToArray<string>()),
        Second = string.Join(mappingOptions.SourceMemberNamingConvention.SeparatorCharacter, matches.Skip<string>(i).ToArray<string>())
      };
    }

    private class NameSnippet
    {
      public string First { get; set; }

      public string Second { get; set; }
    }
  }
}


--- ValueFormatter`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ValueFormatter`1
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

using AutoMapper.Internal;

#nullable disable
namespace AutoMapper
{
  public abstract class ValueFormatter<T> : IValueFormatter
  {
    public string FormatValue(ResolutionContext context)
    {
      if (context.SourceValue == null)
        return (string) null;
      return !(context.SourceValue is T) ? context.SourceValue.ToNullSafeString() : this.FormatValueCore((T) context.SourceValue);
    }

    protected abstract string FormatValueCore(T value);
  }
}


--- ValueResolver`2.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: AutoMapper.ValueResolver`2
// Assembly: AutoMapper, Version=3.1.1.0, Culture=neutral, PublicKeyToken=be96cd2c38ef1005
// MVID: D6FEE810-B806-4119-85A4-5044E7EED03C
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\AutoMapper.dll

#nullable disable
namespace AutoMapper
{
  public abstract class ValueResolver<TSource, TDestination> : IValueResolver
  {
    public ResolutionResult Resolve(ResolutionResult source)
    {
      return source.Value == null || source.Value is TSource ? source.New((object) this.ResolveCore((TSource) source.Value), typeof (TDestination)) : throw new AutoMapperMappingException(string.Format("Value supplied is of type {0} but expected {1}.\nChange the value resolver source type, or redirect the source value supplied to the value resolver using FromMember.", new object[2]
      {
        (object) source.Value.GetType(),
        (object) typeof (TSource)
      }));
    }

    protected abstract TDestination ResolveCore(TSource source);
  }
}

