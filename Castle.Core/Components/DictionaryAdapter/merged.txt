
--- AbstractDictionaryAdapter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.AbstractDictionaryAdapter
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public abstract class AbstractDictionaryAdapter : IDictionary, ICollection, IEnumerable
  {
    public void Add(object key, object value) => throw new NotSupportedException();

    public void Clear() => throw new NotSupportedException();

    public abstract bool Contains(object key);

    public IDictionaryEnumerator GetEnumerator() => throw new NotSupportedException();

    public bool IsFixedSize => throw new NotSupportedException();

    public abstract bool IsReadOnly { get; }

    public ICollection Keys => throw new NotSupportedException();

    public void Remove(object key) => throw new NotSupportedException();

    public ICollection Values => throw new NotSupportedException();

    public abstract object this[object key] { get; set; }

    public void CopyTo(Array array, int index) => throw new NotSupportedException();

    public int Count => throw new NotSupportedException();

    public virtual bool IsSynchronized => false;

    public virtual object SyncRoot => (object) this;

    IEnumerator IEnumerable.GetEnumerator() => throw new NotSupportedException();
  }
}


--- AbstractDictionaryAdapterVisitor.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.AbstractDictionaryAdapterVisitor
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;
using System.Collections.Generic;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public abstract class AbstractDictionaryAdapterVisitor : IDictionaryAdapterVisitor
  {
    public virtual void VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter)
    {
      foreach (PropertyDescriptor property in (IEnumerable<PropertyDescriptor>) dictionaryAdapter.This.Properties.Values)
      {
        Type collectionItemType;
        if (AbstractDictionaryAdapterVisitor.IsCollection(property, out collectionItemType))
          this.VisitCollection(dictionaryAdapter, property, collectionItemType);
        else if (property.PropertyType.IsInterface)
          this.VisitInterface(dictionaryAdapter, property);
        else
          this.VisitProperty(dictionaryAdapter, property);
      }
    }

    void IDictionaryAdapterVisitor.VisitProperty(
      IDictionaryAdapter dictionaryAdapter,
      PropertyDescriptor property)
    {
      this.VisitProperty(dictionaryAdapter, property);
    }

    protected virtual void VisitProperty(
      IDictionaryAdapter dictionaryAdapter,
      PropertyDescriptor property)
    {
    }

    void IDictionaryAdapterVisitor.VisitInterface(
      IDictionaryAdapter dictionaryAdapter,
      PropertyDescriptor property)
    {
      this.VisitInterface(dictionaryAdapter, property);
    }

    protected virtual void VisitInterface(
      IDictionaryAdapter dictionaryAdapter,
      PropertyDescriptor property)
    {
    }

    void IDictionaryAdapterVisitor.VisitCollection(
      IDictionaryAdapter dictionaryAdapter,
      PropertyDescriptor property,
      Type collectionItemType)
    {
      this.VisitCollection(dictionaryAdapter, property, collectionItemType);
    }

    protected virtual void VisitCollection(
      IDictionaryAdapter dictionaryAdapter,
      PropertyDescriptor property,
      Type collectionItemType)
    {
      this.VisitProperty(dictionaryAdapter, property);
    }

    private static bool IsCollection(PropertyDescriptor property, out Type collectionItemType)
    {
      collectionItemType = (Type) null;
      Type propertyType = property.PropertyType;
      if (propertyType == typeof (string) || !typeof (IEnumerable).IsAssignableFrom(propertyType))
        return false;
      if (propertyType.IsArray)
        collectionItemType = propertyType.GetElementType();
      else if (propertyType.IsGenericType)
      {
        Type[] genericArguments = propertyType.GetGenericArguments();
        collectionItemType = genericArguments[0];
      }
      else
        collectionItemType = typeof (object);
      return true;
    }
  }
}


--- BehaviorVisitor.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.BehaviorVisitor
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;
using System.Collections.Generic;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class BehaviorVisitor
  {
    private List<KeyValuePair<Func<object, bool>, Func<object, bool>>> conditions;

    public BehaviorVisitor()
    {
      this.conditions = new List<KeyValuePair<Func<object, bool>, Func<object, bool>>>();
    }

    public BehaviorVisitor OfType<T>(Func<T, bool> apply)
    {
      return this.AddCondition((Func<object, bool>) (b => b is T), (Func<object, bool>) (b => apply((T) b)));
    }

    public BehaviorVisitor OfType<T>(Action<T> apply)
    {
      return this.AddCondition((Func<object, bool>) (b => b is T), (Func<object, bool>) (b =>
      {
        apply((T) b);
        return true;
      }));
    }

    public BehaviorVisitor Match<T>(Func<T, bool> match, Func<T, bool> apply)
    {
      return this.AddCondition((Func<object, bool>) (b => b is T obj && match(obj)), (Func<object, bool>) (b => apply((T) b)));
    }

    public BehaviorVisitor Match<T>(Func<T, bool> match, Action<T> apply)
    {
      return this.AddCondition((Func<object, bool>) (b => b is T obj && match(obj)), (Func<object, bool>) (b =>
      {
        apply((T) b);
        return true;
      }));
    }

    public BehaviorVisitor Match(Func<object, bool> match, Func<object, bool> apply)
    {
      return this.Match<object>(match, apply);
    }

    public BehaviorVisitor Match(Func<object, bool> match, Action<object> apply)
    {
      return this.Match<object>(match, apply);
    }

    public void Apply(IEnumerable behaviors)
    {
      foreach (object behavior in behaviors)
      {
        foreach (KeyValuePair<Func<object, bool>, Func<object, bool>> condition in this.conditions)
        {
          if (condition.Key(behavior))
          {
            int num = condition.Value(behavior) ? 1 : 0;
          }
        }
      }
    }

    private BehaviorVisitor AddCondition(Func<object, bool> predicate, Func<object, bool> action)
    {
      this.conditions.Add(new KeyValuePair<Func<object, bool>, Func<object, bool>>(predicate, action));
      return this;
    }
  }
}


--- BindingListInitializer`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.BindingListInitializer`1
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.ComponentModel;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class BindingListInitializer<T> : IValueInitializer
  {
    private readonly Action<int, object> addAt;
    private readonly Func<object> addNew;
    private readonly Action<int, object> setAt;
    private readonly Action<int> removeAt;
    private bool addingNew;

    public BindingListInitializer(
      Action<int, object> addAt,
      Func<object> addNew,
      Action<int, object> setAt,
      Action<int> removeAt)
    {
      this.addAt = addAt;
      this.addNew = addNew;
      this.setAt = setAt;
      this.removeAt = removeAt;
    }

    public void Initialize(IDictionaryAdapter dictionaryAdapter, object value)
    {
      BindingList<T> bindingList = (BindingList<T>) value;
      if (this.addNew != null)
        bindingList.AddingNew += (AddingNewEventHandler) ((sender, args) =>
        {
          args.NewObject = this.addNew();
          this.addingNew = true;
        });
      bindingList.ListChanged += (ListChangedEventHandler) ((sender, args) =>
      {
        switch (args.ListChangedType)
        {
          case ListChangedType.ItemAdded:
            if (!this.addingNew && this.addAt != null)
              this.addAt(args.NewIndex, (object) bindingList[args.NewIndex]);
            this.addingNew = false;
            break;
          case ListChangedType.ItemDeleted:
            if (this.removeAt == null)
              break;
            this.removeAt(args.NewIndex);
            break;
          case ListChangedType.ItemChanged:
            if (this.setAt == null)
              break;
            this.setAt(args.NewIndex, (object) bindingList[args.NewIndex]);
            break;
        }
      });
    }
  }
}


--- CascadingDictionaryAdapter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.CascadingDictionaryAdapter
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.Collections;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class CascadingDictionaryAdapter : AbstractDictionaryAdapter
  {
    private readonly IDictionary primary;
    private readonly IDictionary secondary;

    public CascadingDictionaryAdapter(IDictionary primary, IDictionary secondary)
    {
      this.primary = primary;
      this.secondary = secondary;
    }

    public IDictionary Primary => this.primary;

    public IDictionary Secondary => this.secondary;

    public override bool IsReadOnly => this.primary.IsReadOnly;

    public override bool Contains(object key)
    {
      return this.primary.Contains(key) || this.secondary.Contains(key);
    }

    public override object this[object key]
    {
      get => this.primary[key] ?? this.secondary[key];
      set => this.primary[key] = value;
    }
  }
}


--- ComponentAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.ComponentAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
  public class ComponentAttribute : 
    DictionaryBehaviorAttribute,
    IDictionaryKeyBuilder,
    IDictionaryPropertyGetter,
    IDictionaryPropertySetter,
    IDictionaryBehavior
  {
    public bool NoPrefix
    {
      get => this.Prefix == "";
      set
      {
        if (!value)
          return;
        this.Prefix = "";
      }
    }

    public string Prefix { get; set; }

    string IDictionaryKeyBuilder.GetKey(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      PropertyDescriptor property)
    {
      return this.Prefix ?? key + "_";
    }

    object IDictionaryPropertyGetter.GetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      object storedValue,
      PropertyDescriptor property,
      bool ifExists)
    {
      if (storedValue != null)
        return storedValue;
      object propertyValue = dictionaryAdapter.This.ExtendedProperties[(object) property.PropertyName];
      if (propertyValue == null)
      {
        PropertyDescriptor descriptor = new PropertyDescriptor(property.Property, (object[]) null);
        descriptor.AddKeyBuilder((IDictionaryKeyBuilder) new KeyPrefixAttribute(key));
        propertyValue = dictionaryAdapter.This.Factory.GetAdapter(property.Property.PropertyType, dictionaryAdapter.This.Dictionary, descriptor);
        dictionaryAdapter.This.ExtendedProperties[(object) property.PropertyName] = propertyValue;
      }
      return propertyValue;
    }

    public bool SetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      ref object value,
      PropertyDescriptor property)
    {
      dictionaryAdapter.This.ExtendedProperties.Remove((object) property.PropertyName);
      return true;
    }
  }
}


--- DefaultPropertyGetter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.DefaultPropertyGetter
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.ComponentModel;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class DefaultPropertyGetter : IDictionaryPropertyGetter, IDictionaryBehavior
  {
    private readonly TypeConverter converter;

    public DefaultPropertyGetter(TypeConverter converter) => this.converter = converter;

    public int ExecutionOrder => int.MaxValue;

    public object GetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      object storedValue,
      PropertyDescriptor property,
      bool ifExists)
    {
      Type propertyType = property.PropertyType;
      return storedValue != null && !propertyType.IsInstanceOfType(storedValue) && this.converter != null && this.converter.CanConvertFrom(storedValue.GetType()) ? this.converter.ConvertFrom(storedValue) : storedValue;
    }
  }
}


--- DefaultXmlSerializer.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.DefaultXmlSerializer
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.Text;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.XPath;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class DefaultXmlSerializer : IXPathSerializer
  {
    public static readonly DefaultXmlSerializer Instance = new DefaultXmlSerializer();

    private DefaultXmlSerializer()
    {
    }

    public bool WriteObject(XPathResult result, XPathNavigator node, object value)
    {
      XmlRootAttribute root = new XmlRootAttribute(node.LocalName)
      {
        Namespace = node.NamespaceURI
      };
      StringBuilder output = new StringBuilder();
      XmlWriterSettings settings = new XmlWriterSettings()
      {
        OmitXmlDeclaration = true,
        Indent = false
      };
      XmlSerializerNamespaces namespaces = new XmlSerializerNamespaces();
      namespaces.Add(string.Empty, string.Empty);
      if (!string.IsNullOrEmpty(node.NamespaceURI))
      {
        string prefix = result.Context.AddNamespace(node.NamespaceURI);
        namespaces.Add(prefix, node.NamespaceURI);
      }
      using (XmlWriter xmlWriter = XmlWriter.Create(output, settings))
      {
        new XmlSerializer(result.Type, root).Serialize(xmlWriter, value, namespaces);
        xmlWriter.Flush();
      }
      node.ReplaceSelf(output.ToString());
      return true;
    }

    public bool ReadObject(XPathResult result, XPathNavigator node, out object value)
    {
      XmlRootAttribute root = new XmlRootAttribute(node.LocalName)
      {
        Namespace = node.NamespaceURI
      };
      XmlSerializer xmlSerializer = new XmlSerializer(result.Type, root);
      using (XmlReader xmlReader = node.ReadSubtree())
      {
        int content = (int) xmlReader.MoveToContent();
        if (xmlSerializer.CanDeserialize(xmlReader))
        {
          value = xmlSerializer.Deserialize(xmlReader);
          return true;
        }
      }
      value = (object) null;
      return false;
    }
  }
}


--- DictionaryAdapterAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.DictionaryAdapterAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
  public class DictionaryAdapterAttribute : Attribute
  {
    public DictionaryAdapterAttribute(Type interfaceType) => this.InterfaceType = interfaceType;

    public Type InterfaceType { get; private set; }
  }
}


--- DictionaryAdapterBase.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.DictionaryAdapterBase
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Linq;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public abstract class DictionaryAdapterBase : 
    IDictionaryAdapter,
    IDictionaryEdit,
    IEditableObject,
    IRevertibleChangeTracking,
    IChangeTracking,
    IDictionaryNotify,
    INotifyPropertyChanging,
    IDictionaryCreate,
    IDictionaryValidate,
    IDataErrorInfo,
    INotifyPropertyChanged
  {
    private int suppressEditingCount;
    private Stack<Dictionary<string, DictionaryAdapterBase.Edit>> updates;
    private HashSet<IEditableObject> editDependencies;
    private int suppressNotificationCount;
    private bool propagateChildNotifications = true;
    private Dictionary<object, object> composedChildNotifications;
    [ThreadStatic]
    private static DictionaryAdapterBase.TrackPropertyChangeScope readonlyTrackingScope;
    private ICollection<IDictionaryValidator> validators;

    public T Create<T>() => this.Create<T>((IDictionary) new HybridDictionary());

    public object Create(Type type) => this.Create(type, (IDictionary) new HybridDictionary());

    public T Create<T>(IDictionary dictionary)
    {
      return (T) this.Create(typeof (T), dictionary ?? (IDictionary) new HybridDictionary());
    }

    public object Create(Type type, IDictionary dictionary)
    {
      if (this.This.CreateStrategy != null)
        return this.This.CreateStrategy.Create((IDictionaryAdapter) this, type, dictionary);
      dictionary = dictionary ?? (IDictionary) new HybridDictionary();
      return this.This.Factory.GetAdapter(type, dictionary, this.This.Descriptor);
    }

    public T Create<T>(Action<T> init)
    {
      return this.Create<T>((IDictionary) new HybridDictionary(), init);
    }

    public T Create<T>(IDictionary dictionary, Action<T> init)
    {
      T obj = this.Create<T>(dictionary ?? (IDictionary) new HybridDictionary());
      if (init != null)
        init(obj);
      return obj;
    }

    public DictionaryAdapterBase(DictionaryAdapterInstance instance)
    {
      this.This = instance;
      this.CanEdit = typeof (IEditableObject).IsAssignableFrom(this.Meta.Type);
      this.CanNotify = typeof (INotifyPropertyChanged).IsAssignableFrom(this.Meta.Type);
      this.CanValidate = typeof (IDataErrorInfo).IsAssignableFrom(this.Meta.Type);
      this.Initialize();
    }

    public abstract DictionaryAdapterMeta Meta { get; }

    public DictionaryAdapterInstance This { get; private set; }

    public string GetKey(string propertyName)
    {
      PropertyDescriptor propertyDescriptor;
      return this.This.Properties.TryGetValue(propertyName, out propertyDescriptor) ? propertyDescriptor.GetKey((IDictionaryAdapter) this, propertyName, this.This.Descriptor) : (string) null;
    }

    public virtual object GetProperty(string propertyName, bool ifExists)
    {
      PropertyDescriptor property;
      if (!this.This.Properties.TryGetValue(propertyName, out property))
        return (object) null;
      object propertyValue = property.GetPropertyValue((IDictionaryAdapter) this, propertyName, (object) null, this.This.Descriptor, ifExists);
      if (propertyValue is IEditableObject)
        this.AddEditDependency((IEditableObject) propertyValue);
      this.ComposeChildNotifications(property, (object) null, propertyValue);
      return propertyValue;
    }

    public T GetPropertyOfType<T>(string propertyName)
    {
      object property = this.GetProperty(propertyName, false);
      return property == null ? default (T) : (T) property;
    }

    public object ReadProperty(string key)
    {
      object propertyValue = (object) null;
      if (!this.GetEditedProperty(key, out propertyValue))
      {
        IDictionary dictionary = DictionaryAdapterBase.GetDictionary(this.This.Dictionary, ref key);
        if (dictionary != null)
          propertyValue = dictionary[(object) key];
      }
      return propertyValue;
    }

    public virtual bool SetProperty(string propertyName, ref object value)
    {
      bool flag1 = false;
      PropertyDescriptor property1;
      if (this.This.Properties.TryGetValue(propertyName, out property1))
      {
        if (!this.ShouldNotify)
        {
          bool flag2 = property1.SetPropertyValue((IDictionaryAdapter) this, propertyName, ref value, this.This.Descriptor);
          this.Invalidate();
          return flag2;
        }
        object property2 = this.GetProperty(propertyName, true);
        if (!this.NotifyPropertyChanging(property1, property2, value))
          return false;
        DictionaryAdapterBase.TrackPropertyChangeScope propertyChangeScope = this.TrackPropertyChange(property1, property2, value);
        flag1 = property1.SetPropertyValue((IDictionaryAdapter) this, propertyName, ref value, this.This.Descriptor);
        if (flag1 && propertyChangeScope != null)
          propertyChangeScope.Notify();
      }
      return flag1;
    }

    public void StoreProperty(PropertyDescriptor property, string key, object value)
    {
      if (property != null && this.EditProperty(property, key, value))
        return;
      IDictionary dictionary = DictionaryAdapterBase.GetDictionary(this.This.Dictionary, ref key);
      if (dictionary == null)
        return;
      dictionary[(object) key] = value;
    }

    public void ClearProperty(PropertyDescriptor property, string key)
    {
      if (property != null && this.ClearEditProperty(property, key))
        return;
      DictionaryAdapterBase.GetDictionary(this.This.Dictionary, ref key)?.Remove((object) key);
    }

    public void CopyTo(IDictionaryAdapter other)
    {
      this.CopyTo(other, (Predicate<PropertyDescriptor>) null);
    }

    public void CopyTo(IDictionaryAdapter other, Predicate<PropertyDescriptor> selector)
    {
      if (!this.Meta.Type.IsAssignableFrom(other.Meta.Type))
        throw new ArgumentException(string.Format("Unable to copy to {0}.  Type must be assignable from {1}.", (object) other.Meta.Type.FullName, (object) this.Meta.Type.FullName));
      selector = selector ?? (Predicate<PropertyDescriptor>) (p => true);
      foreach (PropertyDescriptor propertyDescriptor in this.This.Properties.Values.Where<PropertyDescriptor>((Func<PropertyDescriptor, bool>) (p => selector(p))))
      {
        object property = this.GetProperty(propertyDescriptor.PropertyName, true);
        if (property != null)
          other.SetProperty(propertyDescriptor.PropertyName, ref property);
      }
    }

    public T Coerce<T>() where T : class
    {
      return (T) this.This.Factory.GetAdapter(typeof (T), this.This.Dictionary, this.This.Descriptor);
    }

    public override bool Equals(object obj)
    {
      if (!(obj is IDictionaryAdapter adapter2))
        return false;
      if (object.ReferenceEquals((object) this, obj))
        return true;
      if (this.Meta.Type != adapter2.Meta.Type)
        return false;
      return this.This.EqualityHashCodeStrategy != null ? this.This.EqualityHashCodeStrategy.Equals((IDictionaryAdapter) this, adapter2) : base.Equals(obj);
    }

    public override int GetHashCode()
    {
      if (this.This.OldHashCode.HasValue)
        return this.This.OldHashCode.Value;
      int hashCode;
      if (this.This.EqualityHashCodeStrategy == null || !this.This.EqualityHashCodeStrategy.GetHashCode((IDictionaryAdapter) this, out hashCode))
        hashCode = base.GetHashCode();
      this.This.OldHashCode = new int?(hashCode);
      return hashCode;
    }

    protected void Initialize()
    {
      foreach (IDictionaryInitializer initializer in this.This.Initializers)
        initializer.Initialize((IDictionaryAdapter) this, this.Meta.Behaviors);
      foreach (PropertyDescriptor propertyDescriptor in this.This.Properties.Values.Where<PropertyDescriptor>((Func<PropertyDescriptor, bool>) (p => p.Fetch)))
        this.GetProperty(propertyDescriptor.PropertyName, false);
    }

    private static IDictionary GetDictionary(IDictionary dictionary, ref string key)
    {
      if (!key.StartsWith("!"))
      {
        string[] strArray = key.Split(',');
        for (int index = 0; index < strArray.Length - 1; ++index)
        {
          dictionary = dictionary[(object) strArray[index]] as IDictionary;
          if (dictionary == null)
            return (IDictionary) null;
        }
        key = strArray[strArray.Length - 1];
      }
      return dictionary;
    }

    public bool CanEdit
    {
      get => this.suppressEditingCount == 0 && this.updates != null;
      set
      {
        this.updates = value ? new Stack<Dictionary<string, DictionaryAdapterBase.Edit>>() : (Stack<Dictionary<string, DictionaryAdapterBase.Edit>>) null;
      }
    }

    public bool IsEditing => this.CanEdit && this.updates != null && this.updates.Count > 0;

    public bool SupportsMultiLevelEdit { get; set; }

    public bool IsChanged
    {
      get
      {
        return this.IsEditing && this.updates.Any<Dictionary<string, DictionaryAdapterBase.Edit>>((Func<Dictionary<string, DictionaryAdapterBase.Edit>, bool>) (level => level.Count > 0)) || this.This.Properties.Values.Where<PropertyDescriptor>((Func<PropertyDescriptor, bool>) (prop => typeof (IChangeTracking).IsAssignableFrom(prop.PropertyType))).Select<PropertyDescriptor, object>((Func<PropertyDescriptor, object>) (prop => this.GetProperty(prop.PropertyName, true))).Cast<IChangeTracking>().Any<IChangeTracking>((Func<IChangeTracking, bool>) (track => track != null && track.IsChanged));
      }
    }

    public void BeginEdit()
    {
      if (!this.CanEdit || this.IsEditing && !this.SupportsMultiLevelEdit)
        return;
      this.updates.Push(new Dictionary<string, DictionaryAdapterBase.Edit>());
    }

    public void CancelEdit()
    {
      if (!this.IsEditing)
        return;
      if (this.editDependencies != null)
      {
        foreach (IEditableObject editableObject in this.editDependencies.ToArray<IEditableObject>())
          editableObject.CancelEdit();
        this.editDependencies.Clear();
      }
      using (this.SuppressEditingBlock())
      {
        using (this.TrackReadonlyPropertyChanges())
        {
          Dictionary<string, DictionaryAdapterBase.Edit> dictionary = this.updates.Peek();
          if (dictionary.Count <= 0)
            return;
          foreach (DictionaryAdapterBase.Edit edit in dictionary.Values)
            edit.PropertyValue = this.GetProperty(edit.Property.PropertyName, true);
          this.updates.Pop();
          foreach (DictionaryAdapterBase.Edit edit in dictionary.Values.ToArray<DictionaryAdapterBase.Edit>())
          {
            object propertyValue = edit.PropertyValue;
            object property = this.GetProperty(edit.Property.PropertyName, true);
            if (!object.Equals(propertyValue, property))
            {
              this.NotifyPropertyChanging(edit.Property, propertyValue, property);
              this.NotifyPropertyChanged(edit.Property, propertyValue, property);
            }
          }
        }
      }
    }

    public void EndEdit()
    {
      if (!this.IsEditing)
        return;
      using (this.SuppressEditingBlock())
      {
        Dictionary<string, DictionaryAdapterBase.Edit> source = this.updates.Pop();
        if (source.Count > 0)
        {
          foreach (KeyValuePair<string, DictionaryAdapterBase.Edit> keyValuePair in source.ToArray<KeyValuePair<string, DictionaryAdapterBase.Edit>>())
            this.StoreProperty((PropertyDescriptor) null, keyValuePair.Key, keyValuePair.Value.PropertyValue);
        }
      }
      if (this.editDependencies == null)
        return;
      foreach (IEditableObject editableObject in this.editDependencies.ToArray<IEditableObject>())
        editableObject.EndEdit();
      this.editDependencies.Clear();
    }

    public void RejectChanges() => this.CancelEdit();

    public void AcceptChanges() => this.EndEdit();

    public IDisposable SuppressEditingBlock()
    {
      return (IDisposable) new DictionaryAdapterBase.SuppressEditingScope(this);
    }

    public void SuppressEditing() => ++this.suppressEditingCount;

    public void ResumeEditing() => --this.suppressEditingCount;

    protected bool GetEditedProperty(string propertyName, out object propertyValue)
    {
      if (this.updates != null)
      {
        foreach (Dictionary<string, DictionaryAdapterBase.Edit> dictionary in this.updates.ToArray())
        {
          DictionaryAdapterBase.Edit edit;
          if (dictionary.TryGetValue(propertyName, out edit))
          {
            propertyValue = edit.PropertyValue;
            return true;
          }
        }
      }
      propertyValue = (object) null;
      return false;
    }

    protected bool EditProperty(PropertyDescriptor property, string key, object propertyValue)
    {
      if (!this.IsEditing)
        return false;
      this.updates.Peek()[key] = new DictionaryAdapterBase.Edit(property, propertyValue);
      return true;
    }

    protected bool ClearEditProperty(PropertyDescriptor property, string key)
    {
      if (!this.IsEditing)
        return false;
      this.updates.Peek().Remove(key);
      return true;
    }

    protected void AddEditDependency(IEditableObject editDependency)
    {
      if (!this.IsEditing)
        return;
      if (this.editDependencies == null)
        this.editDependencies = new HashSet<IEditableObject>();
      if (!this.editDependencies.Add(editDependency))
        return;
      editDependency.BeginEdit();
    }

    public event PropertyChangingEventHandler PropertyChanging;

    public event PropertyChangedEventHandler PropertyChanged;

    public bool CanNotify { get; set; }

    public bool ShouldNotify => this.CanNotify && this.suppressNotificationCount == 0;

    public bool PropagateChildNotifications
    {
      get => this.propagateChildNotifications;
      set => this.propagateChildNotifications = value;
    }

    public IDisposable SuppressNotificationsBlock()
    {
      return (IDisposable) new DictionaryAdapterBase.SuppressNotificationsScope(this);
    }

    public void SuppressNotifications() => ++this.suppressNotificationCount;

    public void ResumeNotifications() => --this.suppressNotificationCount;

    protected bool NotifyPropertyChanging(
      PropertyDescriptor property,
      object oldValue,
      object newValue)
    {
      if (!property.SuppressNotifications)
      {
        PropertyChangingEventHandler propertyChanging = this.PropertyChanging;
        if (propertyChanging != null)
        {
          PropertyModifyingEventArgs e = new PropertyModifyingEventArgs(property.PropertyName, oldValue, newValue);
          propertyChanging((object) this, (PropertyChangingEventArgs) e);
          return !e.Cancel;
        }
      }
      return true;
    }

    protected void NotifyPropertyChanged(
      PropertyDescriptor property,
      object oldValue,
      object newValue)
    {
      if (property.SuppressNotifications)
        return;
      PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
      this.ComposeChildNotifications(property, oldValue, newValue);
      if (propertyChanged == null)
        return;
      propertyChanged((object) this, (PropertyChangedEventArgs) new PropertyModifiedEventArgs(property.PropertyName, oldValue, newValue));
    }

    protected void NotifyPropertyChanged(string propertyName)
    {
      if (!this.ShouldNotify)
        return;
      PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
      if (propertyChanged == null)
        return;
      propertyChanged((object) this, new PropertyChangedEventArgs(propertyName));
    }

    protected DictionaryAdapterBase.TrackPropertyChangeScope TrackPropertyChange(
      PropertyDescriptor property,
      object oldValue,
      object newValue)
    {
      return this.ShouldNotify && !property.SuppressNotifications ? new DictionaryAdapterBase.TrackPropertyChangeScope(this, property, oldValue) : (DictionaryAdapterBase.TrackPropertyChangeScope) null;
    }

    protected DictionaryAdapterBase.TrackPropertyChangeScope TrackReadonlyPropertyChanges()
    {
      if (!this.ShouldNotify || DictionaryAdapterBase.readonlyTrackingScope != null)
        return (DictionaryAdapterBase.TrackPropertyChangeScope) null;
      DictionaryAdapterBase.TrackPropertyChangeScope propertyChangeScope = new DictionaryAdapterBase.TrackPropertyChangeScope(this);
      DictionaryAdapterBase.readonlyTrackingScope = propertyChangeScope;
      return propertyChangeScope;
    }

    private void ComposeChildNotifications(
      PropertyDescriptor property,
      object oldValue,
      object newValue)
    {
      if (this.composedChildNotifications == null)
        this.composedChildNotifications = new Dictionary<object, object>();
      object obj;
      if (oldValue != null && this.composedChildNotifications.TryGetValue(oldValue, out obj))
      {
        this.composedChildNotifications.Remove(oldValue);
        if (oldValue is INotifyPropertyChanged)
        {
          ((INotifyPropertyChanged) oldValue).PropertyChanged -= new PropertyChangedEventHandler(this.Child_PropertyChanged);
          if (oldValue is INotifyPropertyChanging)
            ((INotifyPropertyChanging) oldValue).PropertyChanging -= new PropertyChangingEventHandler(this.Child_PropertyChanging);
        }
        else if (oldValue is IBindingList)
          ((IBindingList) oldValue).ListChanged -= (ListChangedEventHandler) obj;
      }
      if (newValue == null || this.composedChildNotifications.ContainsKey(newValue))
        return;
      switch (newValue)
      {
        case INotifyPropertyChanged _:
          ((INotifyPropertyChanged) newValue).PropertyChanged += new PropertyChangedEventHandler(this.Child_PropertyChanged);
          if (newValue is INotifyPropertyChanging)
            ((INotifyPropertyChanging) newValue).PropertyChanging += new PropertyChangingEventHandler(this.Child_PropertyChanging);
          this.composedChildNotifications.Add(newValue, (object) null);
          break;
        case IBindingList _:
          ListChangedEventHandler changedEventHandler = (ListChangedEventHandler) ((sender, args) =>
          {
            if (!this.propagateChildNotifications)
              return;
            PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
            if (propertyChanged == null)
              return;
            if (args.PropertyDescriptor != null)
            {
              string name = args.PropertyDescriptor.Name;
              propertyChanged(sender, new PropertyChangedEventArgs(name));
            }
            propertyChanged((object) this, new PropertyChangedEventArgs(property.PropertyName));
          });
          ((IBindingList) newValue).ListChanged += changedEventHandler;
          this.composedChildNotifications.Add(newValue, (object) changedEventHandler);
          break;
      }
    }

    private void Child_PropertyChanging(object sender, PropertyChangingEventArgs e)
    {
      if (!this.propagateChildNotifications)
        return;
      PropertyChangingEventHandler propertyChanging = this.PropertyChanging;
      if (propertyChanging == null)
        return;
      propertyChanging(sender, e);
    }

    private void Child_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
      if (!this.propagateChildNotifications)
        return;
      PropertyChangedEventHandler propertyChanged = this.PropertyChanged;
      if (propertyChanged == null)
        return;
      propertyChanged(sender, e);
    }

    public bool CanValidate { get; set; }

    public bool IsValid
    {
      get
      {
        return this.CanValidate && this.validators != null ? !this.validators.Any<IDictionaryValidator>((Func<IDictionaryValidator, bool>) (v => !v.IsValid((IDictionaryAdapter) this))) : !this.CanValidate;
      }
    }

    public string Error
    {
      get
      {
        return this.CanValidate && this.validators != null ? string.Join(Environment.NewLine, this.validators.Select<IDictionaryValidator, string>((Func<IDictionaryValidator, string>) (v => v.Validate((IDictionaryAdapter) this))).Where<string>((Func<string, bool>) (e => !string.IsNullOrEmpty(e))).ToArray<string>()) : string.Empty;
      }
    }

    public string this[string columnName]
    {
      get
      {
        if (this.CanValidate && this.validators != null)
        {
          PropertyDescriptor property;
          if (this.This.Properties.TryGetValue(columnName, out property))
            return string.Join(Environment.NewLine, this.validators.Select<IDictionaryValidator, string>((Func<IDictionaryValidator, string>) (v => v.Validate((IDictionaryAdapter) this, property))).Where<string>((Func<string, bool>) (e => !string.IsNullOrEmpty(e))).ToArray<string>());
        }
        return string.Empty;
      }
    }

    public DictionaryValidateGroup ValidateGroups(params object[] groups)
    {
      return new DictionaryValidateGroup(groups, (IDictionaryAdapter) this);
    }

    public IEnumerable<IDictionaryValidator> Validators
    {
      get
      {
        return (IEnumerable<IDictionaryValidator>) this.validators ?? Enumerable.Empty<IDictionaryValidator>();
      }
    }

    public void AddValidator(IDictionaryValidator validator)
    {
      if (this.validators == null)
        this.validators = (ICollection<IDictionaryValidator>) new HashSet<IDictionaryValidator>();
      this.validators.Add(validator);
    }

    protected internal void Invalidate()
    {
      if (!this.CanValidate)
        return;
      if (this.validators != null)
      {
        foreach (IDictionaryValidator validator in (IEnumerable<IDictionaryValidator>) this.validators)
          validator.Invalidate((IDictionaryAdapter) this);
      }
      this.NotifyPropertyChanged("IsValid");
    }

    private struct Edit(PropertyDescriptor property, object propertyValue)
    {
      public readonly PropertyDescriptor Property = property;
      public object PropertyValue = propertyValue;
    }

    private class SuppressEditingScope : IDisposable
    {
      private readonly DictionaryAdapterBase adapter;

      public SuppressEditingScope(DictionaryAdapterBase adapter)
      {
        this.adapter = adapter;
        this.adapter.SuppressEditing();
      }

      public void Dispose() => this.adapter.ResumeEditing();
    }

    private class SuppressNotificationsScope : IDisposable
    {
      private readonly DictionaryAdapterBase adapter;

      public SuppressNotificationsScope(DictionaryAdapterBase adapter)
      {
        this.adapter = adapter;
        this.adapter.SuppressNotifications();
      }

      public void Dispose() => this.adapter.ResumeNotifications();
    }

    public class TrackPropertyChangeScope : IDisposable
    {
      private readonly DictionaryAdapterBase adapter;
      private readonly PropertyDescriptor property;
      private readonly object existingValue;
      private IDictionary<PropertyDescriptor, object> readonlyProperties;

      public TrackPropertyChangeScope(DictionaryAdapterBase adapter)
      {
        this.adapter = adapter;
        this.readonlyProperties = (IDictionary<PropertyDescriptor, object>) adapter.This.Properties.Values.Where<PropertyDescriptor>((Func<PropertyDescriptor, bool>) (pd => !pd.Property.CanWrite || pd.IsDynamicProperty)).ToDictionary<PropertyDescriptor, PropertyDescriptor, object>((Func<PropertyDescriptor, PropertyDescriptor>) (pd => pd), (Func<PropertyDescriptor, object>) (pd => this.GetEffectivePropertyValue(pd)));
      }

      public TrackPropertyChangeScope(
        DictionaryAdapterBase adapter,
        PropertyDescriptor property,
        object existingValue)
        : this(adapter)
      {
        this.property = property;
        this.existingValue = existingValue;
        existingValue = adapter.GetProperty(property.PropertyName, true);
      }

      public bool Notify()
      {
        if (DictionaryAdapterBase.readonlyTrackingScope == this)
        {
          DictionaryAdapterBase.readonlyTrackingScope = (DictionaryAdapterBase.TrackPropertyChangeScope) null;
          return this.NotifyReadonly();
        }
        if (!this.NotifyIfChanged(this.property, this.existingValue, this.GetEffectivePropertyValue(this.property)))
          return false;
        if (DictionaryAdapterBase.readonlyTrackingScope == null)
          this.NotifyReadonly();
        return true;
      }

      private bool NotifyReadonly()
      {
        bool flag = false;
        foreach (KeyValuePair<PropertyDescriptor, object> readonlyProperty in (IEnumerable<KeyValuePair<PropertyDescriptor, object>>) this.readonlyProperties)
        {
          PropertyDescriptor key = readonlyProperty.Key;
          object effectivePropertyValue = this.GetEffectivePropertyValue(key);
          flag |= this.NotifyIfChanged(key, readonlyProperty.Value, effectivePropertyValue);
        }
        this.adapter.Invalidate();
        return flag;
      }

      private bool NotifyIfChanged(PropertyDescriptor descriptor, object oldValue, object newValue)
      {
        if (object.Equals(oldValue, newValue))
          return false;
        this.adapter.NotifyPropertyChanged(descriptor, oldValue, newValue);
        return true;
      }

      private object GetEffectivePropertyValue(PropertyDescriptor property)
      {
        object property1 = this.adapter.GetProperty(property.PropertyName, true);
        if (property1 != null & property.IsDynamicProperty)
          property1 = ((IDynamicValue) property1).GetValue();
        return property1;
      }

      public void Dispose() => this.Notify();
    }
  }
}


--- DictionaryAdapterFactory.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.DictionaryAdapterFactory
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using Castle.Core.Internal;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Threading;
using System.Xml.XPath;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class DictionaryAdapterFactory : IDictionaryAdapterFactory
  {
    private readonly Dictionary<Type, Type> interfaceToAdapter = new Dictionary<Type, Type>();
    private readonly object typesDictionaryLocker = new object();
    private static readonly ICollection<Type> InfrastructureTypes = (ICollection<Type>) new HashSet<Type>()
    {
      typeof (IEditableObject),
      typeof (IDictionaryEdit),
      typeof (IChangeTracking),
      typeof (IRevertibleChangeTracking),
      typeof (IDictionaryNotify),
      typeof (IDataErrorInfo),
      typeof (IDictionaryValidate),
      typeof (IDictionaryAdapter)
    };
    private static readonly PropertyInfo AdapterGetMeta = typeof (IDictionaryAdapter).GetProperty("Meta");
    private static readonly MethodInfo AdapterGetProperty = typeof (IDictionaryAdapter).GetMethod("GetProperty");
    private static readonly MethodInfo AdapterSetProperty = typeof (IDictionaryAdapter).GetMethod("SetProperty");

    public T GetAdapter<T>(IDictionary dictionary) => (T) this.GetAdapter(typeof (T), dictionary);

    public object GetAdapter(Type type, IDictionary dictionary)
    {
      return this.InternalGetAdapter(type, dictionary, (PropertyDescriptor) null);
    }

    public object GetAdapter(Type type, IDictionary dictionary, PropertyDescriptor descriptor)
    {
      return this.InternalGetAdapter(type, dictionary, descriptor);
    }

    public T GetAdapter<T, R>(IDictionary<string, R> dictionary)
    {
      return (T) this.GetAdapter<R>(typeof (T), dictionary);
    }

    public object GetAdapter<R>(Type type, IDictionary<string, R> dictionary)
    {
      GenericDictionaryAdapter<R> dictionaryAdapter = new GenericDictionaryAdapter<R>(dictionary);
      return this.InternalGetAdapter(type, (IDictionary) dictionaryAdapter, (PropertyDescriptor) null);
    }

    public T GetAdapter<T>(NameValueCollection nameValues)
    {
      return this.GetAdapter<T>((IDictionary) new NameValueCollectionAdapter(nameValues));
    }

    public object GetAdapter(Type type, NameValueCollection nameValues)
    {
      return this.GetAdapter(type, (IDictionary) new NameValueCollectionAdapter(nameValues));
    }

    public T GetAdapter<T>(IXPathNavigable xpathNavigable)
    {
      return (T) this.GetAdapter(typeof (T), xpathNavigable);
    }

    public object GetAdapter(Type type, IXPathNavigable xpathNavigable)
    {
      XPathAdapter xpathAdapter = new XPathAdapter(xpathNavigable);
      return this.GetAdapter(type, (IDictionary) new Hashtable(), new DictionaryDescriptor().AddBehavior((IDictionaryBehavior) XPathBehavior.Instance).AddBehavior((IDictionaryBehavior) xpathAdapter));
    }

    public DictionaryAdapterMeta GetAdapterMeta(Type type)
    {
      return this.GetAdapterMeta(type, (PropertyDescriptor) null);
    }

    public DictionaryAdapterMeta GetAdapterMeta(Type type, PropertyDescriptor descriptor)
    {
      return type.IsInterface ? (DictionaryAdapterMeta) this.InternalGetAdapterType(type, descriptor).InvokeMember("__meta", BindingFlags.Static | BindingFlags.Public | BindingFlags.GetField, (Binder) null, (object) null, (object[]) null) : throw new ArgumentException("Only interfaces can be adapted and have metadata");
    }

    private Type InternalGetAdapterType(Type type, PropertyDescriptor descriptor)
    {
      if (!type.IsInterface)
        throw new ArgumentException("Only interfaces can be adapted to a dictionary");
      Type adapterType;
      if (!this.interfaceToAdapter.TryGetValue(type, out adapterType))
      {
        lock (this.typesDictionaryLocker)
        {
          if (!this.interfaceToAdapter.TryGetValue(type, out adapterType))
          {
            AppDomain domain = Thread.GetDomain();
            string adapterAssemblyName = this.GetAdapterAssemblyName(type);
            TypeBuilder typeBuilder = DictionaryAdapterFactory.CreateTypeBuilder(type, domain, adapterAssemblyName);
            Assembly adapterAssembly = this.CreateAdapterAssembly(type, typeBuilder, descriptor);
            adapterType = DictionaryAdapterFactory.CreateAdapterType(type, adapterAssembly);
            this.interfaceToAdapter[type] = adapterType;
          }
        }
      }
      return adapterType;
    }

    private object InternalGetAdapter(
      Type type,
      IDictionary dictionary,
      PropertyDescriptor descriptor)
    {
      Type adapterType = this.InternalGetAdapterType(type, descriptor);
      return this.CreateAdapterInstance(dictionary, descriptor, adapterType);
    }

    private static TypeBuilder CreateTypeBuilder(
      Type type,
      AppDomain appDomain,
      string adapterAssemblyName)
    {
      AssemblyName name = new AssemblyName(adapterAssemblyName);
      ModuleBuilder moduleBuilder = appDomain.DefineDynamicAssembly(name, AssemblyBuilderAccess.Run).DefineDynamicModule(adapterAssemblyName);
      return DictionaryAdapterFactory.CreateAdapterType(type, moduleBuilder);
    }

    private static TypeBuilder CreateAdapterType(Type type, ModuleBuilder moduleBuilder)
    {
      TypeBuilder adapterType = moduleBuilder.DefineType(DictionaryAdapterFactory.GetAdapterFullTypeName(type), TypeAttributes.Public | TypeAttributes.BeforeFieldInit);
      adapterType.AddInterfaceImplementation(type);
      adapterType.SetParent(typeof (DictionaryAdapterBase));
      CustomAttributeBuilder customBuilder1 = new CustomAttributeBuilder(typeof (DictionaryAdapterAttribute).GetConstructor(new Type[1]
      {
        typeof (Type)
      }), (object[]) new Type[1]{ type });
      adapterType.SetCustomAttribute(customBuilder1);
      CustomAttributeBuilder customBuilder2 = new CustomAttributeBuilder(typeof (DebuggerDisplayAttribute).GetConstructor(new Type[1]
      {
        typeof (string)
      }), (object[]) new string[1]
      {
        "Type: {Meta.Type.FullName,nq}"
      });
      adapterType.SetCustomAttribute(customBuilder2);
      return adapterType;
    }

    private Assembly CreateAdapterAssembly(
      Type type,
      TypeBuilder typeBuilder,
      PropertyDescriptor descriptor)
    {
      FieldAttributes attributes = FieldAttributes.Public | FieldAttributes.Static;
      FieldBuilder field = typeBuilder.DefineField("__meta", typeof (DictionaryAdapterMeta), attributes);
      DictionaryAdapterFactory.CreateAdapterConstructor(typeBuilder);
      IDictionaryInitializer[] typeInitializers;
      IDictionaryMetaInitializer[] metaInitializers;
      object[] typeBehaviors;
      Dictionary<string, PropertyDescriptor> propertyDescriptors = DictionaryAdapterFactory.GetPropertyDescriptors(type, out typeInitializers, out metaInitializers, out typeBehaviors);
      DictionaryAdapterFactory.CreateMetaProperty(typeBuilder, DictionaryAdapterFactory.AdapterGetMeta, (FieldInfo) field);
      foreach (KeyValuePair<string, PropertyDescriptor> keyValuePair in propertyDescriptors)
        DictionaryAdapterFactory.CreateAdapterProperty(typeBuilder, keyValuePair.Value);
      typeBuilder.CreateType().InvokeMember("__meta", BindingFlags.Static | BindingFlags.Public | BindingFlags.SetField, (Binder) null, (object) null, (object[]) new DictionaryAdapterMeta[1]
      {
        new DictionaryAdapterMeta(type, typeInitializers, metaInitializers, typeBehaviors, (IDictionary<string, PropertyDescriptor>) propertyDescriptors, descriptor as DictionaryDescriptor, (IDictionaryAdapterFactory) this)
      });
      return typeBuilder.Assembly;
    }

    private static void CreateAdapterConstructor(TypeBuilder typeBuilder)
    {
      ILGenerator ilGenerator = typeBuilder.DefineConstructor(MethodAttributes.Public | MethodAttributes.HideBySig, CallingConventions.Standard, new Type[1]
      {
        typeof (DictionaryAdapterInstance)
      }).GetILGenerator();
      ConstructorInfo constructor = typeof (DictionaryAdapterBase).GetConstructors()[0];
      ilGenerator.Emit(OpCodes.Ldarg_0);
      ilGenerator.Emit(OpCodes.Ldarg_1);
      ilGenerator.Emit(OpCodes.Call, constructor);
      ilGenerator.Emit(OpCodes.Ret);
    }

    private static void CreateMetaProperty(
      TypeBuilder typeBuilder,
      PropertyInfo prop,
      FieldInfo field)
    {
      MethodAttributes attributes = MethodAttributes.Public | MethodAttributes.Final | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.SpecialName;
      MethodBuilder methodInfoBody = typeBuilder.DefineMethod("get_" + prop.Name, attributes, prop.PropertyType, (Type[]) null);
      ILGenerator ilGenerator = methodInfoBody.GetILGenerator();
      if (field.IsStatic)
      {
        ilGenerator.Emit(OpCodes.Ldsfld, field);
      }
      else
      {
        ilGenerator.Emit(OpCodes.Ldarg_0);
        ilGenerator.Emit(OpCodes.Ldfld, field);
      }
      ilGenerator.Emit(OpCodes.Ret);
      typeBuilder.DefineMethodOverride((MethodInfo) methodInfoBody, prop.GetGetMethod());
    }

    private static void CreateAdapterProperty(
      TypeBuilder typeBuilder,
      PropertyDescriptor descriptor)
    {
      PropertyInfo property = descriptor.Property;
      PropertyBuilder propertyBuilder = typeBuilder.DefineProperty(property.Name, property.Attributes, property.PropertyType, (Type[]) null);
      MethodAttributes propAttribs = MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.SpecialName;
      if (property.CanRead)
        DictionaryAdapterFactory.CreatePropertyGetMethod(typeBuilder, propertyBuilder, descriptor, propAttribs);
      if (!property.CanWrite)
        return;
      DictionaryAdapterFactory.CreatePropertySetMethod(typeBuilder, propertyBuilder, descriptor, propAttribs);
    }

    private static void PreparePropertyMethod(
      PropertyDescriptor descriptor,
      ILGenerator propILGenerator)
    {
      propILGenerator.DeclareLocal(typeof (string));
      propILGenerator.DeclareLocal(typeof (object));
      propILGenerator.Emit(OpCodes.Ldstr, descriptor.PropertyName);
      propILGenerator.Emit(OpCodes.Stloc_0);
    }

    private static void CreatePropertyGetMethod(
      TypeBuilder typeBuilder,
      PropertyBuilder propertyBuilder,
      PropertyDescriptor descriptor,
      MethodAttributes propAttribs)
    {
      MethodBuilder mdBuilder = typeBuilder.DefineMethod("get_" + descriptor.PropertyName, propAttribs, descriptor.PropertyType, (Type[]) null);
      ILGenerator ilGenerator = mdBuilder.GetILGenerator();
      Label label1 = ilGenerator.DefineLabel();
      Label label2 = ilGenerator.DefineLabel();
      Label label3 = ilGenerator.DefineLabel();
      DictionaryAdapterFactory.PreparePropertyMethod(descriptor, ilGenerator);
      LocalBuilder local = ilGenerator.DeclareLocal(descriptor.PropertyType);
      ilGenerator.Emit(OpCodes.Ldarg_0);
      ilGenerator.Emit(OpCodes.Ldloc_0);
      ilGenerator.Emit(OpCodes.Ldc_I4_0);
      ilGenerator.Emit(OpCodes.Callvirt, DictionaryAdapterFactory.AdapterGetProperty);
      ilGenerator.Emit(OpCodes.Stloc_1);
      ilGenerator.Emit(OpCodes.Ldloc_1);
      ilGenerator.Emit(OpCodes.Brfalse_S, label1);
      ilGenerator.Emit(OpCodes.Ldloc_1);
      ilGenerator.Emit(OpCodes.Unbox_Any, descriptor.PropertyType);
      ilGenerator.Emit(OpCodes.Br_S, label2);
      ilGenerator.MarkLabel(label1);
      ilGenerator.Emit(OpCodes.Ldloca_S, local);
      ilGenerator.Emit(OpCodes.Initobj, descriptor.PropertyType);
      ilGenerator.Emit(OpCodes.Br_S, label3);
      ilGenerator.MarkLabel(label2);
      ilGenerator.Emit(OpCodes.Stloc_S, local);
      ilGenerator.MarkLabel(label3);
      ilGenerator.Emit(OpCodes.Ldloc_S, local);
      ilGenerator.Emit(OpCodes.Ret);
      propertyBuilder.SetGetMethod(mdBuilder);
    }

    private static void CreatePropertySetMethod(
      TypeBuilder typeBuilder,
      PropertyBuilder propertyBuilder,
      PropertyDescriptor descriptor,
      MethodAttributes propAttribs)
    {
      MethodBuilder mdBuilder = typeBuilder.DefineMethod("set_" + descriptor.PropertyName, propAttribs, (Type) null, new Type[1]
      {
        descriptor.PropertyType
      });
      ILGenerator ilGenerator = mdBuilder.GetILGenerator();
      DictionaryAdapterFactory.PreparePropertyMethod(descriptor, ilGenerator);
      ilGenerator.Emit(OpCodes.Ldarg_1);
      if (descriptor.PropertyType.IsValueType)
        ilGenerator.Emit(OpCodes.Box, descriptor.PropertyType);
      ilGenerator.Emit(OpCodes.Stloc_1);
      ilGenerator.Emit(OpCodes.Ldarg_0);
      ilGenerator.Emit(OpCodes.Ldloc_0);
      ilGenerator.Emit(OpCodes.Ldloca_S, 1);
      ilGenerator.Emit(OpCodes.Callvirt, DictionaryAdapterFactory.AdapterSetProperty);
      ilGenerator.Emit(OpCodes.Pop);
      ilGenerator.Emit(OpCodes.Ret);
      propertyBuilder.SetSetMethod(mdBuilder);
    }

    private static Dictionary<string, PropertyDescriptor> GetPropertyDescriptors(
      Type type,
      out IDictionaryInitializer[] typeInitializers,
      out IDictionaryMetaInitializer[] metaInitializers,
      out object[] typeBehaviors)
    {
      Dictionary<string, PropertyDescriptor> propertyMap = new Dictionary<string, PropertyDescriptor>();
      object[] interfaceBehaviors = typeBehaviors = DictionaryAdapterFactory.ExpandBehaviors(DictionaryAdapterFactory.GetInterfaceBehaviors<object>(type)).ToArray<object>();
      typeInitializers = typeBehaviors.OfType<IDictionaryInitializer>().Prioritize<IDictionaryInitializer>().ToArray<IDictionaryInitializer>();
      metaInitializers = typeBehaviors.OfType<IDictionaryMetaInitializer>().Prioritize<IDictionaryMetaInitializer>().ToArray<IDictionaryMetaInitializer>();
      bool defaultFetch = typeBehaviors.OfType<FetchAttribute>().Select<FetchAttribute, bool>((Func<FetchAttribute, bool>) (b => b.Fetch)).FirstOrDefault<bool>();
      DictionaryAdapterFactory.CollectProperties(type, (Action<PropertyInfo>) (property =>
      {
        object[] array = DictionaryAdapterFactory.ExpandBehaviors(DictionaryAdapterFactory.GetPropertyBehaviors<object>((MemberInfo) property)).ToArray<object>();
        PropertyDescriptor propertyDescriptor1 = new PropertyDescriptor(property, array);
        foreach (IPropertyDescriptorInitializer descriptorInitializer in (IEnumerable<IPropertyDescriptorInitializer>) array.OfType<IPropertyDescriptorInitializer>().OrderBy<IPropertyDescriptorInitializer, int>((Func<IPropertyDescriptorInitializer, int>) (b => b.ExecutionOrder)))
          descriptorInitializer.Initialize(propertyDescriptor1, array);
        propertyDescriptor1.AddKeyBuilders(array.OfType<IDictionaryKeyBuilder>().Prioritize<IDictionaryKeyBuilder>(DictionaryAdapterFactory.GetInterfaceBehaviors<IDictionaryKeyBuilder>(property.ReflectedType)));
        propertyDescriptor1.AddGetters(array.OfType<IDictionaryPropertyGetter>().Prioritize<IDictionaryPropertyGetter>(interfaceBehaviors.OfType<IDictionaryPropertyGetter>()));
        DictionaryAdapterFactory.AddDefaultGetter(propertyDescriptor1);
        propertyDescriptor1.AddSetters(array.OfType<IDictionaryPropertySetter>().Prioritize<IDictionaryPropertySetter>(interfaceBehaviors.OfType<IDictionaryPropertySetter>()));
        bool? nullable = new bool?(array.OfType<FetchAttribute>().Select<FetchAttribute, bool>((Func<FetchAttribute, bool>) (b => b.Fetch)).FirstOrDefault<bool>());
        propertyDescriptor1.Fetch = nullable.GetValueOrDefault(defaultFetch);
        PropertyDescriptor propertyDescriptor2;
        if (propertyMap.TryGetValue(property.Name, out propertyDescriptor2) && propertyDescriptor2.Property.PropertyType == property.PropertyType)
        {
          if (!property.CanRead || !property.CanWrite)
            return;
          propertyMap[property.Name] = propertyDescriptor1;
        }
        else
          propertyMap.Add(property.Name, propertyDescriptor1);
      }));
      return propertyMap;
    }

    private static IEnumerable<T> GetInterfaceBehaviors<T>(Type type) where T : class
    {
      return (IEnumerable<T>) AttributesUtil.GetTypeAttributes<T>(type);
    }

    private static IEnumerable<T> GetPropertyBehaviors<T>(MemberInfo member) where T : class
    {
      return (IEnumerable<T>) member.GetAttributes<T>();
    }

    private static IEnumerable<object> ExpandBehaviors(IEnumerable<object> behaviors)
    {
      return behaviors.SelectMany<object, object>((Func<object, IEnumerable<object>>) (behavior => behavior is IDictionaryBehaviorBuilder ? ((IDictionaryBehaviorBuilder) behavior).BuildBehaviors().Cast<object>() : Enumerable.Repeat<object>(behavior, 1)));
    }

    private static void CollectProperties(Type currentType, Action<PropertyInfo> onProperty)
    {
      List<Type> typeList = new List<Type>();
      typeList.Add(currentType);
      typeList.AddRange((IEnumerable<Type>) currentType.GetInterfaces());
      BindingFlags bindingAttr = BindingFlags.Instance | BindingFlags.Public;
      foreach (Type type in typeList)
      {
        if (!DictionaryAdapterFactory.InfrastructureTypes.Contains(type))
        {
          foreach (PropertyInfo property in type.GetProperties(bindingAttr))
            onProperty(property);
        }
      }
    }

    private static void AddDefaultGetter(PropertyDescriptor descriptor)
    {
      if (descriptor.TypeConverter == null)
        return;
      descriptor.AddGetter((IDictionaryPropertyGetter) new DefaultPropertyGetter(descriptor.TypeConverter));
    }

    private string GetAdapterAssemblyName(Type type)
    {
      return type.Assembly.GetName().Name + "." + DictionaryAdapterFactory.GetSafeTypeFullName(type) + ".DictionaryAdapter";
    }

    private static string GetAdapterFullTypeName(Type type)
    {
      return type.Namespace + "." + DictionaryAdapterFactory.GetAdapterTypeName(type);
    }

    private static string GetAdapterTypeName(Type type)
    {
      return DictionaryAdapterFactory.GetSafeTypeName(type).Substring(1) + "DictionaryAdapter";
    }

    public static string GetSafeTypeFullName(Type type)
    {
      if (type.IsGenericTypeDefinition)
        return type.FullName.Replace("`", "_");
      if (!type.IsGenericType)
        return type.FullName;
      StringBuilder sb = new StringBuilder();
      if (!string.IsNullOrEmpty(type.Namespace))
        sb.Append(type.Namespace).Append(".");
      DictionaryAdapterFactory.AppendGenericTypeName(type, sb);
      return sb.ToString();
    }

    public static string GetSafeTypeName(Type type)
    {
      if (type.IsGenericTypeDefinition)
        return type.Name.Replace("`", "_");
      if (!type.IsGenericType)
        return type.Name;
      StringBuilder sb = new StringBuilder();
      DictionaryAdapterFactory.AppendGenericTypeName(type, sb);
      return sb.ToString();
    }

    private static void AppendGenericTypeName(Type type, StringBuilder sb)
    {
      sb.Append(type.Name.Replace("`", "_"));
      foreach (Type genericArgument in type.GetGenericArguments())
        sb.Append("_").Append(DictionaryAdapterFactory.GetSafeTypeFullName(genericArgument).Replace(".", "_"));
    }

    private static Type CreateAdapterType(Type type, Assembly assembly)
    {
      string adapterFullTypeName = DictionaryAdapterFactory.GetAdapterFullTypeName(type);
      return assembly.GetType(adapterFullTypeName, true);
    }

    private object CreateAdapterInstance(
      IDictionary dictionary,
      PropertyDescriptor descriptor,
      Type adapterType)
    {
      BindingFlags invokeAttr = BindingFlags.Static | BindingFlags.Public | BindingFlags.GetField;
      DictionaryAdapterMeta meta = (DictionaryAdapterMeta) adapterType.InvokeMember("__meta", invokeAttr, (Binder) null, (object) null, (object[]) null);
      DictionaryAdapterInstance dictionaryAdapterInstance = new DictionaryAdapterInstance(dictionary, meta, descriptor, (IDictionaryAdapterFactory) this);
      return Activator.CreateInstance(adapterType, (object) dictionaryAdapterInstance);
    }
  }
}


--- DictionaryAdapterInstance.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.DictionaryAdapterInstance
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.Collections;
using System.Collections.Generic;
using System.Linq;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class DictionaryAdapterInstance
  {
    private IDictionary extendedProperties;

    public DictionaryAdapterInstance(
      IDictionary dictionary,
      DictionaryAdapterMeta meta,
      PropertyDescriptor descriptor,
      IDictionaryAdapterFactory factory)
    {
      this.Dictionary = dictionary;
      this.Descriptor = descriptor;
      this.Factory = factory;
      this.Properties = meta.Properties;
      this.Initializers = meta.Initializers;
      this.MergeBehaviorOverrides(meta);
    }

    internal int? OldHashCode { get; set; }

    public IDictionary Dictionary { get; private set; }

    public PropertyDescriptor Descriptor { get; private set; }

    public IDictionaryAdapterFactory Factory { get; private set; }

    public IDictionaryInitializer[] Initializers { get; private set; }

    public IDictionary<string, PropertyDescriptor> Properties { get; private set; }

    public IDictionaryEqualityHashCodeStrategy EqualityHashCodeStrategy { get; set; }

    public IDictionaryCreateStrategy CreateStrategy { get; set; }

    public IDictionary ExtendedProperties
    {
      get
      {
        if (this.extendedProperties == null)
          this.extendedProperties = (IDictionary) new System.Collections.Generic.Dictionary<object, object>();
        return this.extendedProperties;
      }
    }

    private void MergeBehaviorOverrides(DictionaryAdapterMeta meta)
    {
      if (this.Descriptor == null)
        return;
      if (this.Descriptor is DictionaryDescriptor descriptor)
        this.Initializers = ((IEnumerable<IDictionaryInitializer>) this.Initializers).Prioritize<IDictionaryInitializer>((IEnumerable<IDictionaryInitializer>) descriptor.Initializers).ToArray<IDictionaryInitializer>();
      this.Properties = (IDictionary<string, PropertyDescriptor>) new System.Collections.Generic.Dictionary<string, PropertyDescriptor>();
      foreach (KeyValuePair<string, PropertyDescriptor> property in (IEnumerable<KeyValuePair<string, PropertyDescriptor>>) meta.Properties)
      {
        PropertyDescriptor source = property.Value;
        PropertyDescriptor propertyDescriptor = new PropertyDescriptor(source, false).AddKeyBuilders(source.KeyBuilders.Prioritize<IDictionaryKeyBuilder>((IEnumerable<IDictionaryKeyBuilder>) this.Descriptor.KeyBuilders)).AddGetters(source.Getters.Prioritize<IDictionaryPropertyGetter>((IEnumerable<IDictionaryPropertyGetter>) this.Descriptor.Getters)).AddSetters(source.Setters.Prioritize<IDictionaryPropertySetter>((IEnumerable<IDictionaryPropertySetter>) this.Descriptor.Setters));
        this.Properties.Add(property.Key, propertyDescriptor);
      }
    }
  }
}


--- DictionaryAdapterMeta.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.DictionaryAdapterMeta
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [DebuggerDisplay("Type: {Type.FullName,nq}")]
  public class DictionaryAdapterMeta
  {
    private IDictionary extendedProperties;

    public DictionaryAdapterMeta(
      Type type,
      IDictionaryInitializer[] initializers,
      IDictionaryMetaInitializer[] metaInitializers,
      object[] behaviors,
      IDictionary<string, PropertyDescriptor> properties,
      DictionaryDescriptor descriptor,
      IDictionaryAdapterFactory factory)
    {
      this.Type = type;
      this.Initializers = initializers;
      this.MetaInitializers = metaInitializers;
      this.Behaviors = behaviors;
      this.Properties = properties;
      this.InitializeMeta(factory, descriptor);
    }

    public Type Type { get; private set; }

    public object[] Behaviors { get; private set; }

    public IDictionaryInitializer[] Initializers { get; private set; }

    public IDictionaryMetaInitializer[] MetaInitializers { get; private set; }

    public IDictionary<string, PropertyDescriptor> Properties { get; private set; }

    public IDictionary ExtendedProperties
    {
      get
      {
        if (this.extendedProperties == null)
          this.extendedProperties = (IDictionary) new Dictionary<object, object>();
        return this.extendedProperties;
      }
    }

    private void InitializeMeta(IDictionaryAdapterFactory factory, DictionaryDescriptor descriptor)
    {
      if (descriptor != null)
        this.MetaInitializers = ((IEnumerable<IDictionaryMetaInitializer>) this.MetaInitializers).Prioritize<IDictionaryMetaInitializer>((IEnumerable<IDictionaryMetaInitializer>) descriptor.MetaInitializers).ToArray<IDictionaryMetaInitializer>();
      foreach (IDictionaryMetaInitializer metaInitializer in this.MetaInitializers)
        metaInitializer.Initialize(factory, this);
    }
  }
}


--- DictionaryBehaviorAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.DictionaryBehaviorAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public abstract class DictionaryBehaviorAttribute : Attribute, IDictionaryBehavior
  {
    public const int FiratExecutionOrder = 0;
    public const int DefaultExecutionOrder = 1073741823;
    public const int LastExecutionOrder = 2147483647;

    public DictionaryBehaviorAttribute() => this.ExecutionOrder = 1073741823;

    public int ExecutionOrder { get; set; }
  }
}


--- DictionaryDescriptor.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.DictionaryDescriptor
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class DictionaryDescriptor : PropertyDescriptor
  {
    private List<IDictionaryInitializer> initializers;
    private List<IDictionaryMetaInitializer> metaInitializers;
    private static readonly ICollection<IDictionaryInitializer> NoInitializers = (ICollection<IDictionaryInitializer>) new IDictionaryInitializer[0];
    private static readonly ICollection<IDictionaryMetaInitializer> NoMetaInitializers = (ICollection<IDictionaryMetaInitializer>) new IDictionaryMetaInitializer[0];

    public DictionaryDescriptor()
    {
    }

    public DictionaryDescriptor(PropertyInfo property, object[] behaviors)
      : base(property, behaviors)
    {
    }

    public ICollection<IDictionaryInitializer> Initializers
    {
      get
      {
        return (ICollection<IDictionaryInitializer>) this.initializers ?? DictionaryDescriptor.NoInitializers;
      }
    }

    public ICollection<IDictionaryMetaInitializer> MetaInitializers
    {
      get
      {
        return (ICollection<IDictionaryMetaInitializer>) this.metaInitializers ?? DictionaryDescriptor.NoMetaInitializers;
      }
    }

    public DictionaryDescriptor AddInitializer(params IDictionaryInitializer[] inits)
    {
      return this.AddInitializers((IEnumerable<IDictionaryInitializer>) inits);
    }

    public DictionaryDescriptor AddInitializers(IEnumerable<IDictionaryInitializer> inits)
    {
      if (inits != null)
      {
        if (this.initializers == null)
          this.initializers = new List<IDictionaryInitializer>(inits);
        else
          this.initializers.AddRange(inits);
      }
      return this;
    }

    public DictionaryDescriptor CopyInitializers(DictionaryDescriptor other)
    {
      if (this.initializers != null)
        other.AddInitializers((IEnumerable<IDictionaryInitializer>) this.initializers);
      return this;
    }

    public DictionaryDescriptor CopyInitializers(
      DictionaryDescriptor other,
      Func<IDictionaryInitializer, bool> selector)
    {
      if (selector == null)
        throw new ArgumentNullException(nameof (selector));
      if (this.initializers != null)
        other.AddInitializers(this.initializers.Where<IDictionaryInitializer>(selector));
      return this;
    }

    public DictionaryDescriptor AddMetaInitializer(params IDictionaryMetaInitializer[] inits)
    {
      return this.AddMetaInitializers((IEnumerable<IDictionaryMetaInitializer>) inits);
    }

    public DictionaryDescriptor AddMetaInitializers(IEnumerable<IDictionaryMetaInitializer> inits)
    {
      if (inits != null)
      {
        if (this.metaInitializers == null)
          this.metaInitializers = new List<IDictionaryMetaInitializer>(inits);
        else
          this.metaInitializers.AddRange(inits);
      }
      return this;
    }

    public DictionaryDescriptor CopyMetaInitializers(DictionaryDescriptor other)
    {
      if (this.metaInitializers != null)
        other.AddMetaInitializers((IEnumerable<IDictionaryMetaInitializer>) this.metaInitializers);
      return this;
    }

    public DictionaryDescriptor CopyMetaInitializers(
      DictionaryDescriptor other,
      Func<IDictionaryMetaInitializer, bool> selector)
    {
      if (selector == null)
        throw new ArgumentNullException(nameof (selector));
      if (this.metaInitializers != null)
        other.AddMetaInitializers(this.metaInitializers.Where<IDictionaryMetaInitializer>(selector));
      return this;
    }

    public override PropertyDescriptor CopyBehaviors(PropertyDescriptor other)
    {
      if (other is DictionaryDescriptor)
      {
        DictionaryDescriptor other1 = (DictionaryDescriptor) other;
        this.CopyMetaInitializers(other1).CopyInitializers(other1);
      }
      return base.CopyBehaviors(other);
    }

    protected override void InternalAddBehavior(IDictionaryBehavior behavior)
    {
      if (behavior is IDictionaryInitializer)
        this.AddInitializer((IDictionaryInitializer) behavior);
      if (behavior is IDictionaryMetaInitializer)
        this.AddMetaInitializer((IDictionaryMetaInitializer) behavior);
      base.InternalAddBehavior(behavior);
    }
  }
}


--- DictionaryValidateGroup.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.DictionaryValidateGroup
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class DictionaryValidateGroup : 
    IDictionaryValidate,
    IDataErrorInfo,
    INotifyPropertyChanged,
    IDisposable
  {
    private readonly object[] groups;
    private readonly IDictionaryAdapter adapter;
    private readonly string[] propertyNames;
    private readonly PropertyChangedEventHandler propertyChanged;

    public DictionaryValidateGroup(object[] groups, IDictionaryAdapter adapter)
    {
      this.groups = groups;
      this.adapter = adapter;
      this.propertyNames = this.adapter.This.Properties.Values.SelectMany((Func<PropertyDescriptor, IEnumerable<GroupAttribute>>) (property => property.Behaviors.OfType<GroupAttribute>()), (property, groupings) => new
      {
        property = property,
        groupings = groupings
      }).Where(_param1 => ((IEnumerable<object>) this.groups).Intersect<object>((IEnumerable<object>) _param1.groupings.Group).Any<object>()).Select(_param0 => _param0.property.PropertyName).Distinct<string>().ToArray<string>();
      if (this.propertyNames.Length <= 0 || !adapter.CanNotify)
        return;
      this.propertyChanged += (PropertyChangedEventHandler) ((sender, args) =>
      {
        if (this.PropertyChanged == null)
          return;
        this.PropertyChanged((object) this, args);
      });
      this.adapter.PropertyChanged += this.propertyChanged;
    }

    public event PropertyChangedEventHandler PropertyChanged;

    public bool CanValidate
    {
      get => this.adapter.CanValidate;
      set => this.adapter.CanValidate = value;
    }

    public bool IsValid => string.IsNullOrEmpty(this.Error);

    public string Error
    {
      get
      {
        return string.Join(Environment.NewLine, ((IEnumerable<string>) this.propertyNames).Select<string, string>((Func<string, string>) (propertyName => this.adapter[propertyName])).Where<string>((Func<string, bool>) (errors => !string.IsNullOrEmpty(errors))).ToArray<string>());
      }
    }

    public string this[string columnName]
    {
      get
      {
        return Array.IndexOf<string>(this.propertyNames, columnName) >= 0 ? this.adapter[columnName] : string.Empty;
      }
    }

    public DictionaryValidateGroup ValidateGroups(params object[] groups)
    {
      groups = ((IEnumerable<object>) this.groups).Union<object>((IEnumerable<object>) groups).ToArray<object>();
      return new DictionaryValidateGroup(groups, this.adapter);
    }

    public IEnumerable<IDictionaryValidator> Validators => this.adapter.Validators;

    public void AddValidator(IDictionaryValidator validator) => throw new NotSupportedException();

    public void Dispose() => this.adapter.PropertyChanged -= this.propertyChanged;
  }
}


--- DynamicValue`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.DynamicValue`1
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public abstract class DynamicValue<T> : IDynamicValue<T>, IDynamicValue
  {
    object IDynamicValue.GetValue() => (object) this.Value;

    public abstract T Value { get; }

    public override string ToString()
    {
      T obj = this.Value;
      return (object) obj != null ? obj.ToString() : base.ToString();
    }
  }
}


--- DynamicValueDelegate`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.DynamicValueDelegate`1
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class DynamicValueDelegate<T> : DynamicValue<T>
  {
    private readonly Func<T> dynamicDelegate;

    public DynamicValueDelegate(Func<T> dynamicDelegate) => this.dynamicDelegate = dynamicDelegate;

    public override T Value => this.dynamicDelegate();
  }
}


--- EditableBindingList`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.EditableBindingList`1
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class EditableBindingList<T> : 
    BindingList<T>,
    IList<T>,
    ICollection<T>,
    IEnumerable<T>,
    IEnumerable,
    IEditableObject,
    IRevertibleChangeTracking,
    IChangeTracking
  {
    private bool isEditing;
    private List<T> snapshot;

    public EditableBindingList()
    {
    }

    public EditableBindingList(IList<T> initial)
      : base(initial)
    {
    }

    public bool IsChanged
    {
      get
      {
        if (this.snapshot == null || this.snapshot.Count != this.Count)
          return false;
        IEnumerator<T> enumerator1 = this.GetEnumerator();
        List<T>.Enumerator enumerator2 = this.snapshot.GetEnumerator();
        while (enumerator1.MoveNext() && enumerator2.MoveNext() && object.ReferenceEquals((object) enumerator1.Current, (object) enumerator2.Current))
        {
          if (enumerator1.Current is IChangeTracking current && current.IsChanged)
            return true;
        }
        return false;
      }
    }

    public void BeginEdit()
    {
      if (this.isEditing)
        return;
      this.snapshot = new List<T>((IEnumerable<T>) this);
      this.isEditing = true;
    }

    public void EndEdit()
    {
      this.isEditing = false;
      this.snapshot = (List<T>) null;
    }

    public void CancelEdit()
    {
      if (!this.isEditing)
        return;
      this.Clear();
      foreach (T obj in this.snapshot)
        this.Add(obj);
      this.snapshot = (List<T>) null;
      this.isEditing = false;
    }

    public void AcceptChanges() => this.BeginEdit();

    public void RejectChanges() => this.CancelEdit();
  }
}


--- EditableList.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.EditableList
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.Collections;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class EditableList : EditableList<object>, IList, ICollection, IEnumerable
  {
  }
}


--- EditableList`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.EditableList`1
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.Collections.Generic;
using System.ComponentModel;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class EditableList<T> : List<T>, IEditableObject, IRevertibleChangeTracking, IChangeTracking
  {
    private bool isEditing;
    private List<T> snapshot;

    public void BeginEdit()
    {
      if (this.isEditing)
        return;
      this.snapshot = new List<T>((IEnumerable<T>) this);
      this.isEditing = true;
    }

    public bool IsChanged
    {
      get
      {
        if (this.snapshot == null || this.snapshot.Count != this.Count)
          return false;
        List<T>.Enumerator enumerator1 = this.GetEnumerator();
        List<T>.Enumerator enumerator2 = this.snapshot.GetEnumerator();
        while (enumerator1.MoveNext() && enumerator2.MoveNext() && object.ReferenceEquals((object) enumerator1.Current, (object) enumerator2.Current))
        {
          if (enumerator1.Current is IChangeTracking current && current.IsChanged)
            return true;
        }
        return false;
      }
    }

    public void EndEdit()
    {
      this.isEditing = false;
      this.snapshot = (List<T>) null;
    }

    public void CancelEdit()
    {
      if (!this.isEditing)
        return;
      this.Clear();
      this.AddRange((IEnumerable<T>) this.snapshot);
      this.snapshot = (List<T>) null;
      this.isEditing = false;
    }

    public void AcceptChanges() => this.BeginEdit();

    public void RejectChanges() => this.CancelEdit();
  }
}


--- FetchAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.FetchAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Interface, AllowMultiple = false)]
  public class FetchAttribute : Attribute
  {
    public FetchAttribute()
      : this(true)
    {
    }

    public FetchAttribute(bool fetch) => this.Fetch = fetch;

    public bool Fetch { get; private set; }
  }
}


--- GenericDictionaryAdapter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.GenericDictionaryAdapter
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.Collections.Generic;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public static class GenericDictionaryAdapter
  {
    public static GenericDictionaryAdapter<TValue> ForDictionaryAdapter<TValue>(
      this IDictionary<string, TValue> dictionary)
    {
      return new GenericDictionaryAdapter<TValue>(dictionary);
    }
  }
}


--- GenericDictionaryAdapter`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.GenericDictionaryAdapter`1
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class GenericDictionaryAdapter<TValue> : AbstractDictionaryAdapter
  {
    private readonly IDictionary<string, TValue> dictionary;

    public GenericDictionaryAdapter(IDictionary<string, TValue> dictionary)
    {
      this.dictionary = dictionary;
    }

    public override bool IsReadOnly => this.dictionary.IsReadOnly;

    public override bool Contains(object key)
    {
      return this.dictionary.Keys.Contains(GenericDictionaryAdapter<TValue>.GetKey(key));
    }

    public override object this[object key]
    {
      get => (object) this.dictionary[GenericDictionaryAdapter<TValue>.GetKey(key)];
      set => this.dictionary[GenericDictionaryAdapter<TValue>.GetKey(key)] = (TValue) value;
    }

    private static string GetKey(object key)
    {
      return key != null ? key.ToString() : throw new ArgumentNullException(nameof (key));
    }
  }
}


--- GroupAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.GroupAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property, AllowMultiple = true)]
  public class GroupAttribute : Attribute
  {
    public GroupAttribute(object group)
    {
      this.Group = new object[1]{ group };
    }

    public GroupAttribute(params object[] group) => this.Group = group;

    public object[] Group { get; private set; }
  }
}


--- IDictionaryAdapter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryAdapter
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.ComponentModel;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryAdapter : 
    IDictionaryEdit,
    IEditableObject,
    IRevertibleChangeTracking,
    IChangeTracking,
    IDictionaryNotify,
    INotifyPropertyChanging,
    IDictionaryValidate,
    IDataErrorInfo,
    INotifyPropertyChanged,
    IDictionaryCreate
  {
    DictionaryAdapterMeta Meta { get; }

    DictionaryAdapterInstance This { get; }

    string GetKey(string propertyName);

    object GetProperty(string propertyName, bool ifExists);

    object ReadProperty(string key);

    T GetPropertyOfType<T>(string propertyName);

    bool SetProperty(string propertyName, ref object value);

    void StoreProperty(PropertyDescriptor property, string key, object value);

    void ClearProperty(PropertyDescriptor property, string key);

    void CopyTo(IDictionaryAdapter other);

    void CopyTo(IDictionaryAdapter other, Predicate<PropertyDescriptor> selector);

    T Coerce<T>() where T : class;
  }
}


--- IDictionaryAdapterFactory.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryAdapterFactory
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;
using System.Collections.Specialized;
using System.Xml.XPath;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryAdapterFactory
  {
    T GetAdapter<T>(IDictionary dictionary);

    object GetAdapter(Type type, IDictionary dictionary);

    object GetAdapter(Type type, IDictionary dictionary, PropertyDescriptor descriptor);

    T GetAdapter<T>(NameValueCollection nameValues);

    object GetAdapter(Type type, NameValueCollection nameValues);

    T GetAdapter<T>(IXPathNavigable xpathNavigable);

    object GetAdapter(Type type, IXPathNavigable xpathNavigable);

    DictionaryAdapterMeta GetAdapterMeta(Type type);

    DictionaryAdapterMeta GetAdapterMeta(Type type, PropertyDescriptor descriptor);
  }
}


--- IDictionaryAdapterVisitor.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryAdapterVisitor
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryAdapterVisitor
  {
    void VisitDictionaryAdapter(IDictionaryAdapter dictionaryAdapter);

    void VisitProperty(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property);

    void VisitInterface(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property);

    void VisitCollection(
      IDictionaryAdapter dictionaryAdapter,
      PropertyDescriptor property,
      Type collectionItemType);
  }
}


--- IDictionaryBehavior.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryBehavior
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryBehavior
  {
    int ExecutionOrder { get; }
  }
}


--- IDictionaryBehaviorBuilder.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryBehaviorBuilder
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.Collections.Generic;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryBehaviorBuilder
  {
    IEnumerable<IDictionaryBehavior> BuildBehaviors();
  }
}


--- IDictionaryCreate.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryCreate
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryCreate
  {
    T Create<T>();

    object Create(Type type);

    T Create<T>(IDictionary dictionary);

    object Create(Type type, IDictionary dictionary);

    T Create<T>(Action<T> init);

    T Create<T>(IDictionary dictionary, Action<T> init);
  }
}


--- IDictionaryCreateStrategy.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryCreateStrategy
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryCreateStrategy
  {
    object Create(IDictionaryAdapter adapter, Type type, IDictionary dictionary);
  }
}


--- IDictionaryEdit.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryEdit
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.ComponentModel;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryEdit : IEditableObject, IRevertibleChangeTracking, IChangeTracking
  {
    bool CanEdit { get; }

    bool IsEditing { get; }

    bool SupportsMultiLevelEdit { get; set; }

    IDisposable SuppressEditingBlock();

    void SuppressEditing();

    void ResumeEditing();
  }
}


--- IDictionaryEqualityHashCodeStrategy.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryEqualityHashCodeStrategy
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryEqualityHashCodeStrategy
  {
    bool Equals(IDictionaryAdapter adapter1, IDictionaryAdapter adapter2);

    bool GetHashCode(IDictionaryAdapter adapter, out int hashCode);
  }
}


--- IDictionaryInitializer.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryInitializer
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryInitializer : IDictionaryBehavior
  {
    void Initialize(IDictionaryAdapter dictionaryAdapter, object[] behaviors);
  }
}


--- IDictionaryKeyBuilder.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryKeyBuilder
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryKeyBuilder : IDictionaryBehavior
  {
    string GetKey(IDictionaryAdapter dictionaryAdapter, string key, PropertyDescriptor property);
  }
}


--- IDictionaryMetaInitializer.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryMetaInitializer
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryMetaInitializer : IDictionaryBehavior
  {
    void Initialize(IDictionaryAdapterFactory factory, DictionaryAdapterMeta dictionaryMeta);
  }
}


--- IDictionaryNotify.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryNotify
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.ComponentModel;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryNotify : INotifyPropertyChanging, INotifyPropertyChanged
  {
    bool CanNotify { get; }

    bool ShouldNotify { get; }

    bool PropagateChildNotifications { get; set; }

    IDisposable SuppressNotificationsBlock();

    void SuppressNotifications();

    void ResumeNotifications();
  }
}


--- IDictionaryPropertyGetter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryPropertyGetter
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryPropertyGetter : IDictionaryBehavior
  {
    object GetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      object storedValue,
      PropertyDescriptor property,
      bool ifExists);
  }
}


--- IDictionaryPropertySetter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryPropertySetter
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryPropertySetter : IDictionaryBehavior
  {
    bool SetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      ref object value,
      PropertyDescriptor property);
  }
}


--- IDictionaryValidate.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryValidate
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.Collections.Generic;
using System.ComponentModel;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryValidate : IDataErrorInfo, INotifyPropertyChanged
  {
    bool CanValidate { get; set; }

    bool IsValid { get; }

    DictionaryValidateGroup ValidateGroups(params object[] groups);

    IEnumerable<IDictionaryValidator> Validators { get; }

    void AddValidator(IDictionaryValidator validator);
  }
}


--- IDictionaryValidator.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDictionaryValidator
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDictionaryValidator
  {
    bool IsValid(IDictionaryAdapter dictionaryAdapter);

    string Validate(IDictionaryAdapter dictionaryAdapter);

    string Validate(IDictionaryAdapter dictionaryAdapter, PropertyDescriptor property);

    void Invalidate(IDictionaryAdapter dictionaryAdapter);
  }
}


--- IDynamicValue.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDynamicValue
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDynamicValue
  {
    object GetValue();
  }
}


--- IDynamicValue`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IDynamicValue`1
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IDynamicValue<T> : IDynamicValue
  {
    T Value { get; }
  }
}


--- IPropertyDescriptorInitializer.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IPropertyDescriptorInitializer
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IPropertyDescriptorInitializer : IDictionaryBehavior
  {
    void Initialize(PropertyDescriptor propertyDescriptor, object[] behaviors);
  }
}


--- IValueInitializer.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IValueInitializer
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IValueInitializer
  {
    void Initialize(IDictionaryAdapter dictionaryAdapter, object value);
  }
}


--- IXPathSerializer.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.IXPathSerializer
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.Xml.XPath;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public interface IXPathSerializer
  {
    bool WriteObject(XPathResult result, XPathNavigator node, object value);

    bool ReadObject(XPathResult result, XPathNavigator node, out object value);
  }
}


--- KeyAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.KeyAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
  public class KeyAttribute : DictionaryBehaviorAttribute, IDictionaryKeyBuilder, IDictionaryBehavior
  {
    private readonly string key;

    public KeyAttribute(string key) => this.key = key;

    public KeyAttribute(string[] keys) => this.key = string.Join(",", keys);

    public string Key { get; private set; }

    string IDictionaryKeyBuilder.GetKey(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      PropertyDescriptor property)
    {
      return this.key;
    }
  }
}


--- KeyPrefixAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.KeyPrefixAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Interface, AllowMultiple = false, Inherited = true)]
  public class KeyPrefixAttribute : 
    DictionaryBehaviorAttribute,
    IDictionaryKeyBuilder,
    IDictionaryBehavior
  {
    private string keyPrefix;

    public KeyPrefixAttribute()
    {
    }

    public KeyPrefixAttribute(string keyPrefix) => this.keyPrefix = keyPrefix;

    public string KeyPrefix
    {
      get => this.keyPrefix;
      set => this.keyPrefix = value;
    }

    string IDictionaryKeyBuilder.GetKey(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      PropertyDescriptor property)
    {
      return this.keyPrefix + key;
    }
  }
}


--- KeySubstitutionAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.KeySubstitutionAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Interface, AllowMultiple = true, Inherited = true)]
  public class KeySubstitutionAttribute : 
    DictionaryBehaviorAttribute,
    IDictionaryKeyBuilder,
    IDictionaryBehavior
  {
    private readonly string oldValue;
    private readonly string newValue;

    public KeySubstitutionAttribute(string oldValue, string newValue)
    {
      this.oldValue = oldValue;
      this.newValue = newValue;
    }

    string IDictionaryKeyBuilder.GetKey(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      PropertyDescriptor property)
    {
      return key.Replace(this.oldValue, this.newValue);
    }
  }
}


--- MultiLevelEditAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.MultiLevelEditAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Interface, AllowMultiple = false)]
  public class MultiLevelEditAttribute : 
    DictionaryBehaviorAttribute,
    IDictionaryInitializer,
    IDictionaryBehavior
  {
    public void Initialize(IDictionaryAdapter dictionaryAdapter, object[] behaviors)
    {
      dictionaryAdapter.SupportsMultiLevelEdit = true;
    }
  }
}


--- NameValueCollectionAdapter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.NameValueCollectionAdapter
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections.Specialized;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class NameValueCollectionAdapter : AbstractDictionaryAdapter
  {
    private readonly NameValueCollection nameValues;

    public NameValueCollectionAdapter(NameValueCollection nameValues)
    {
      this.nameValues = nameValues;
    }

    public override bool IsReadOnly => false;

    public override bool Contains(object key)
    {
      return Array.IndexOf<object>((object[]) this.nameValues.AllKeys, key) >= 0;
    }

    public override object this[object key]
    {
      get => (object) this.nameValues[key.ToString()];
      set
      {
        string str = value?.ToString();
        this.nameValues[key.ToString()] = str;
      }
    }

    public static NameValueCollectionAdapter Adapt(NameValueCollection nameValues)
    {
      return new NameValueCollectionAdapter(nameValues);
    }
  }
}


--- NewGuidAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.NewGuidAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Interface, AllowMultiple = false)]
  public class NewGuidAttribute : 
    DictionaryBehaviorAttribute,
    IDictionaryPropertyGetter,
    IDictionaryBehavior
  {
    private static readonly Guid UnassignedGuid = new Guid();

    public object GetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      object storedValue,
      PropertyDescriptor property,
      bool ifExists)
    {
      if (storedValue == null || storedValue.Equals((object) NewGuidAttribute.UnassignedGuid))
      {
        storedValue = (object) Guid.NewGuid();
        property.SetPropertyValue(dictionaryAdapter, key, ref storedValue, dictionaryAdapter.This.Descriptor);
      }
      return storedValue;
    }
  }
}


--- OnDemandAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.OnDemandAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Interface, AllowMultiple = false)]
  public class OnDemandAttribute : 
    DictionaryBehaviorAttribute,
    IDictionaryPropertyGetter,
    IDictionaryBehavior
  {
    public OnDemandAttribute()
    {
    }

    public OnDemandAttribute(Type type)
    {
      this.Type = type.GetConstructor(Type.EmptyTypes) != null ? type : throw new ArgumentException("On-demand values must have a parameterless constructor");
    }

    public OnDemandAttribute(object value) => this.Value = value;

    public Type Type { get; private set; }

    public object Value { get; private set; }

    public object GetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      object storedValue,
      PropertyDescriptor property,
      bool ifExists)
    {
      if (storedValue == null && !ifExists)
      {
        IValueInitializer initializer = (IValueInitializer) null;
        if (this.Value != null)
        {
          storedValue = this.Value;
        }
        else
        {
          Type type = this.Type ?? this.GetInferredType(dictionaryAdapter, property, out initializer);
          if (this.IsAcceptedType(type))
          {
            if (type.IsInterface)
            {
              if (!property.IsDynamicProperty && storedValue == null)
                storedValue = dictionaryAdapter.Create(property.PropertyType);
            }
            else if (type.IsArray)
              storedValue = (object) Array.CreateInstance(type.GetElementType(), 0);
            else if (storedValue == null)
            {
              object[] parameters = (object[]) null;
              ConstructorInfo constructorInfo = (ConstructorInfo) null;
              if (property.IsDynamicProperty)
              {
                constructorInfo = ((IEnumerable<ConstructorInfo>) type.GetConstructors()).Select(ctor => new
                {
                  ctor = ctor,
                  parms = ctor.GetParameters()
                }).Where(_param1 => _param1.parms.Length == 1 && _param1.parms[0].ParameterType.IsAssignableFrom(dictionaryAdapter.Meta.Type)).Select(_param0 => _param0.ctor).FirstOrDefault<ConstructorInfo>();
                if (constructorInfo != null)
                  parameters = (object[]) new IDictionaryAdapter[1]
                  {
                    dictionaryAdapter
                  };
              }
              if (constructorInfo == null)
                constructorInfo = type.GetConstructor(Type.EmptyTypes);
              if (constructorInfo != null)
                storedValue = constructorInfo.Invoke(parameters);
            }
          }
        }
        if (storedValue != null)
        {
          using (dictionaryAdapter.SuppressNotificationsBlock())
          {
            if (storedValue is ISupportInitialize)
            {
              ((ISupportInitialize) storedValue).BeginInit();
              ((ISupportInitialize) storedValue).EndInit();
            }
            initializer?.Initialize(dictionaryAdapter, storedValue);
            property.SetPropertyValue(dictionaryAdapter, property.PropertyName, ref storedValue, dictionaryAdapter.This.Descriptor);
          }
        }
      }
      return storedValue;
    }

    private bool IsAcceptedType(Type type)
    {
      return type != null && type != typeof (string) && !type.IsPrimitive && !type.IsEnum;
    }

    private Type GetInferredType(
      IDictionaryAdapter dictionaryAdapter,
      PropertyDescriptor property,
      out IValueInitializer initializer)
    {
      initializer = (IValueInitializer) null;
      Type propertyType = property.PropertyType;
      if (!typeof (IEnumerable).IsAssignableFrom(propertyType))
        return propertyType;
      Type type = (Type) null;
      if (propertyType.IsGenericType)
      {
        Type genericTypeDefinition = propertyType.GetGenericTypeDefinition();
        Type genericArg = propertyType.GetGenericArguments()[0];
        bool flag = genericTypeDefinition == typeof (BindingList<>);
        if (flag || genericTypeDefinition == typeof (List<>))
        {
          if (dictionaryAdapter.CanEdit)
            type = flag ? typeof (EditableBindingList<>) : typeof (EditableList<>);
          if (flag && genericArg.IsInterface)
          {
            Func<object> func = (Func<object>) (() => dictionaryAdapter.Create(genericArg));
            initializer = (IValueInitializer) Activator.CreateInstance(typeof (BindingListInitializer<>).MakeGenericType(genericArg), new object[4]
            {
              null,
              (object) func,
              null,
              null
            });
          }
        }
        else if (genericTypeDefinition == typeof (IList<>) || genericTypeDefinition == typeof (ICollection<>))
          type = dictionaryAdapter.CanEdit ? typeof (EditableList<>) : typeof (List<>);
        if (type != null)
          return type.MakeGenericType(genericArg);
      }
      else if (propertyType == typeof (IList) || propertyType == typeof (ICollection))
        return !dictionaryAdapter.CanEdit ? typeof (List<object>) : typeof (EditableList);
      return propertyType;
    }
  }
}


--- PriorityBehaviorExtensions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.PriorityBehaviorExtensions
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections.Generic;
using System.Linq;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  internal static class PriorityBehaviorExtensions
  {
    public static IEnumerable<T> Prioritize<T>(
      this IEnumerable<T> first,
      params IEnumerable<T>[] remaining)
      where T : IDictionaryBehavior
    {
      IEnumerable<T>[] array = ((IEnumerable<IEnumerable<T>>) new IEnumerable<T>[1]
      {
        first
      }).Union<IEnumerable<T>>((IEnumerable<IEnumerable<T>>) remaining).Where<IEnumerable<T>>((Func<IEnumerable<T>, bool>) (behaviors => behaviors != null && behaviors.Any<T>())).ToArray<IEnumerable<T>>();
      switch (array.Length)
      {
        case 0:
          return Enumerable.Empty<T>();
        case 1:
          return (IEnumerable<T>) array[0].OrderBy<T, int>((Func<T, int>) (behavior => behavior.ExecutionOrder));
        default:
          return ((IEnumerable<IEnumerable<T>>) array).SelectMany<IEnumerable<T>, PriorityBehaviorExtensions.PriorityBehavior<T>>((Func<IEnumerable<T>, int, IEnumerable<PriorityBehaviorExtensions.PriorityBehavior<T>>>) ((bs, priority) => bs.Select<T, PriorityBehaviorExtensions.PriorityBehavior<T>>((Func<T, PriorityBehaviorExtensions.PriorityBehavior<T>>) (b => new PriorityBehaviorExtensions.PriorityBehavior<T>(b, priority))))).OrderBy<PriorityBehaviorExtensions.PriorityBehavior<T>, PriorityBehaviorExtensions.PriorityBehavior<T>>((Func<PriorityBehaviorExtensions.PriorityBehavior<T>, PriorityBehaviorExtensions.PriorityBehavior<T>>) (priority => priority)).Select<PriorityBehaviorExtensions.PriorityBehavior<T>, T>((Func<PriorityBehaviorExtensions.PriorityBehavior<T>, T>) (priority => priority.Behavior));
      }
    }

    private class PriorityBehavior<T> : IComparable<PriorityBehaviorExtensions.PriorityBehavior<T>> where T : IDictionaryBehavior
    {
      public PriorityBehavior(T behavior, int priority)
      {
        this.Behavior = behavior;
        this.Priority = priority;
      }

      public T Behavior { get; private set; }

      public int Priority { get; private set; }

      public int CompareTo(
        PriorityBehaviorExtensions.PriorityBehavior<T> other)
      {
        int num = this.Behavior.ExecutionOrder - other.Behavior.ExecutionOrder;
        return num != 0 ? num : this.Priority - other.Priority;
      }
    }
  }
}


--- PropagateNotificationsAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.PropagateNotificationsAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Interface, AllowMultiple = false)]
  public class PropagateNotificationsAttribute : 
    DictionaryBehaviorAttribute,
    IDictionaryInitializer,
    IDictionaryBehavior
  {
    public PropagateNotificationsAttribute(bool propagateNotifications)
    {
      this.PropagateNotifications = propagateNotifications;
    }

    public bool PropagateNotifications { get; private set; }

    public void Initialize(IDictionaryAdapter dictionaryAdapter, object[] behaviors)
    {
      dictionaryAdapter.PropagateChildNotifications = this.PropagateNotifications;
    }
  }
}


--- PropertyDescriptor.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.PropertyDescriptor
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using Castle.Core.Internal;
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [DebuggerDisplay("{Property.DeclaringType.FullName,nq}.{PropertyName,nq}")]
  public class PropertyDescriptor : 
    IDictionaryKeyBuilder,
    IDictionaryPropertyGetter,
    IDictionaryPropertySetter,
    IDictionaryBehavior
  {
    private List<IDictionaryPropertyGetter> getters;
    private List<IDictionaryPropertySetter> setters;
    private List<IDictionaryKeyBuilder> keyBuilders;
    private IDictionary state;
    private static readonly object[] NoBehaviors = new object[0];
    private static readonly ICollection<IDictionaryKeyBuilder> NoKeysBuilders = (ICollection<IDictionaryKeyBuilder>) new IDictionaryKeyBuilder[0];
    private static readonly ICollection<IDictionaryPropertyGetter> NoHGetters = (ICollection<IDictionaryPropertyGetter>) new IDictionaryPropertyGetter[0];
    private static readonly ICollection<IDictionaryPropertySetter> NoSetters = (ICollection<IDictionaryPropertySetter>) new IDictionaryPropertySetter[0];

    public PropertyDescriptor() => this.Behaviors = PropertyDescriptor.NoBehaviors;

    public PropertyDescriptor(PropertyInfo property, object[] behaviors)
      : this()
    {
      this.Property = property;
      this.Behaviors = behaviors ?? PropertyDescriptor.NoBehaviors;
      this.IsDynamicProperty = typeof (IDynamicValue).IsAssignableFrom(property.PropertyType);
      this.ObtainTypeConverter();
    }

    public PropertyDescriptor(PropertyDescriptor source, bool copyBehaviors)
    {
      this.Property = source.Property;
      this.Behaviors = source.Behaviors;
      this.IsDynamicProperty = source.IsDynamicProperty;
      this.TypeConverter = source.TypeConverter;
      this.SuppressNotifications = source.SuppressNotifications;
      this.state = source.state;
      this.Fetch = source.Fetch;
      if (!copyBehaviors)
        return;
      this.keyBuilders = source.keyBuilders;
      this.getters = source.getters;
      this.setters = source.setters;
    }

    public int ExecutionOrder => 0;

    public string PropertyName => this.Property == null ? (string) null : this.Property.Name;

    public Type PropertyType => this.Property == null ? (Type) null : this.Property.PropertyType;

    public PropertyInfo Property { get; private set; }

    public bool IsDynamicProperty { get; private set; }

    public IDictionary State
    {
      get
      {
        if (this.state == null)
          this.state = (IDictionary) new Dictionary<object, object>();
        return this.state;
      }
    }

    public bool Fetch { get; set; }

    public bool SuppressNotifications { get; set; }

    public object[] Behaviors { get; private set; }

    public TypeConverter TypeConverter { get; private set; }

    public ICollection<IDictionaryKeyBuilder> KeyBuilders
    {
      get
      {
        return (ICollection<IDictionaryKeyBuilder>) this.keyBuilders ?? PropertyDescriptor.NoKeysBuilders;
      }
    }

    public ICollection<IDictionaryPropertySetter> Setters
    {
      get => (ICollection<IDictionaryPropertySetter>) this.setters ?? PropertyDescriptor.NoSetters;
    }

    public ICollection<IDictionaryPropertyGetter> Getters
    {
      get => (ICollection<IDictionaryPropertyGetter>) this.getters ?? PropertyDescriptor.NoHGetters;
    }

    public string GetKey(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      PropertyDescriptor descriptor)
    {
      if (this.keyBuilders != null)
      {
        foreach (IDictionaryKeyBuilder keyBuilder in this.keyBuilders)
          key = keyBuilder.GetKey(dictionaryAdapter, key, this);
      }
      return key;
    }

    public PropertyDescriptor AddKeyBuilder(params IDictionaryKeyBuilder[] builders)
    {
      return this.AddKeyBuilders((IEnumerable<IDictionaryKeyBuilder>) builders);
    }

    public PropertyDescriptor AddKeyBuilders(IEnumerable<IDictionaryKeyBuilder> builders)
    {
      if (builders != null)
      {
        if (this.keyBuilders == null)
          this.keyBuilders = new List<IDictionaryKeyBuilder>(builders);
        else
          this.keyBuilders.AddRange(builders);
      }
      return this;
    }

    public PropertyDescriptor CopyKeyBuilders(PropertyDescriptor other)
    {
      if (this.keyBuilders != null)
        other.AddKeyBuilders((IEnumerable<IDictionaryKeyBuilder>) this.keyBuilders);
      return this;
    }

    public PropertyDescriptor CopyKeyBuilders(
      PropertyDescriptor other,
      Func<IDictionaryKeyBuilder, bool> selector)
    {
      if (selector == null)
        throw new ArgumentNullException(nameof (selector));
      if (this.keyBuilders != null)
        other.AddKeyBuilders(this.keyBuilders.Where<IDictionaryKeyBuilder>(selector));
      return this;
    }

    public object GetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      object storedValue,
      PropertyDescriptor descriptor,
      bool ifExists)
    {
      key = this.GetKey(dictionaryAdapter, key, descriptor);
      storedValue = storedValue ?? dictionaryAdapter.ReadProperty(key);
      if (this.getters != null)
      {
        foreach (IDictionaryPropertyGetter getter in this.getters)
          storedValue = getter.GetPropertyValue(dictionaryAdapter, key, storedValue, this, ifExists);
      }
      return storedValue;
    }

    public PropertyDescriptor AddGetter(params IDictionaryPropertyGetter[] getters)
    {
      return this.AddGetters((IEnumerable<IDictionaryPropertyGetter>) getters);
    }

    public PropertyDescriptor AddGetters(IEnumerable<IDictionaryPropertyGetter> gets)
    {
      if (gets != null)
      {
        if (this.getters == null)
          this.getters = new List<IDictionaryPropertyGetter>(gets);
        else
          this.getters.AddRange(gets);
      }
      return this;
    }

    public PropertyDescriptor CopyGetters(PropertyDescriptor other)
    {
      if (this.getters != null)
        other.AddGetters((IEnumerable<IDictionaryPropertyGetter>) this.getters);
      return this;
    }

    public PropertyDescriptor CopyGetters(
      PropertyDescriptor other,
      Func<IDictionaryPropertyGetter, bool> selector)
    {
      if (selector == null)
        throw new ArgumentNullException(nameof (selector));
      if (this.getters != null)
        other.AddGetters(this.getters.Where<IDictionaryPropertyGetter>(selector));
      return this;
    }

    public bool SetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      ref object value,
      PropertyDescriptor descriptor)
    {
      bool flag = false;
      key = this.GetKey(dictionaryAdapter, key, descriptor);
      if (this.setters != null)
      {
        foreach (IDictionaryPropertySetter setter in this.setters)
        {
          if (!setter.SetPropertyValue(dictionaryAdapter, key, ref value, this))
            flag = true;
        }
      }
      if (!flag)
        dictionaryAdapter.StoreProperty(this, key, value);
      return !flag;
    }

    public PropertyDescriptor AddSetter(params IDictionaryPropertySetter[] setters)
    {
      return this.AddSetters((IEnumerable<IDictionaryPropertySetter>) setters);
    }

    public PropertyDescriptor AddSetters(IEnumerable<IDictionaryPropertySetter> sets)
    {
      if (sets != null)
      {
        if (this.setters == null)
          this.setters = new List<IDictionaryPropertySetter>(sets);
        else
          this.setters.AddRange(sets);
      }
      return this;
    }

    public PropertyDescriptor CopySetters(PropertyDescriptor other)
    {
      if (this.setters != null)
        other.AddSetters((IEnumerable<IDictionaryPropertySetter>) this.setters);
      return this;
    }

    public PropertyDescriptor CopySetters(
      PropertyDescriptor other,
      Func<IDictionaryPropertySetter, bool> selector)
    {
      if (selector == null)
        throw new ArgumentNullException(nameof (selector));
      if (this.setters != null)
        other.AddSetters(this.setters.Where<IDictionaryPropertySetter>(selector));
      return this;
    }

    public PropertyDescriptor AddBehavior(params IDictionaryBehavior[] behaviors)
    {
      return this.AddBehaviors((IEnumerable<IDictionaryBehavior>) behaviors);
    }

    public PropertyDescriptor AddBehaviors(IEnumerable<IDictionaryBehavior> behaviors)
    {
      if (behaviors != null)
      {
        foreach (IDictionaryBehavior behavior in behaviors)
          this.InternalAddBehavior(behavior);
      }
      return this;
    }

    public PropertyDescriptor AddBehaviors(params IDictionaryBehaviorBuilder[] builders)
    {
      this.AddBehaviors(((IEnumerable<IDictionaryBehaviorBuilder>) builders).SelectMany<IDictionaryBehaviorBuilder, IDictionaryBehavior>((Func<IDictionaryBehaviorBuilder, IEnumerable<IDictionaryBehavior>>) (builder => builder.BuildBehaviors())));
      return this;
    }

    public virtual PropertyDescriptor CopyBehaviors(PropertyDescriptor other)
    {
      return this.CopyKeyBuilders(other).CopyGetters(other).CopySetters(other);
    }

    public PropertyDescriptor CopyBehaviors(
      PropertyDescriptor other,
      Func<IDictionaryBehavior, bool> selector)
    {
      if (selector == null)
        throw new ArgumentNullException(nameof (selector));
      return this.CopyKeyBuilders(other, (Func<IDictionaryKeyBuilder, bool>) (key => selector((IDictionaryBehavior) key))).CopyGetters(other, (Func<IDictionaryPropertyGetter, bool>) (getter => selector((IDictionaryBehavior) getter))).CopySetters(other, (Func<IDictionaryPropertySetter, bool>) (setter => selector((IDictionaryBehavior) setter)));
    }

    protected virtual void InternalAddBehavior(IDictionaryBehavior behavior)
    {
      if (behavior is IDictionaryKeyBuilder)
        this.AddKeyBuilder((IDictionaryKeyBuilder) behavior);
      if (behavior is IDictionaryPropertyGetter)
        this.AddGetter((IDictionaryPropertyGetter) behavior);
      if (!(behavior is IDictionaryPropertySetter))
        return;
      this.AddSetter((IDictionaryPropertySetter) behavior);
    }

    private void ObtainTypeConverter()
    {
      Type typeConverter = AttributesUtil.GetTypeConverter((MemberInfo) this.Property);
      if (typeConverter != null)
        this.TypeConverter = (TypeConverter) Activator.CreateInstance(typeConverter);
      else
        this.TypeConverter = TypeDescriptor.GetConverter(this.PropertyType);
    }
  }
}


--- PropertyModifiedEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.PropertyModifiedEventArgs
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.ComponentModel;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class PropertyModifiedEventArgs : PropertyChangedEventArgs
  {
    public PropertyModifiedEventArgs(
      string propertyName,
      object oldPropertyValue,
      object newPropertyValue)
      : base(propertyName)
    {
      this.OldPropertyValue = oldPropertyValue;
      this.NewPropertyValue = newPropertyValue;
    }

    public object OldPropertyValue { get; private set; }

    public object NewPropertyValue { get; private set; }
  }
}


--- PropertyModifyingEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.PropertyModifyingEventArgs
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.ComponentModel;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class PropertyModifyingEventArgs : PropertyChangingEventArgs
  {
    public PropertyModifyingEventArgs(
      string propertyName,
      object oldPropertyValue,
      object newPropertyValue)
      : base(propertyName)
    {
      this.OldPropertyValue = oldPropertyValue;
      this.NewPropertyValue = newPropertyValue;
    }

    public object OldPropertyValue { get; private set; }

    public object NewPropertyValue { get; private set; }

    public bool Cancel { get; set; }
  }
}


--- PropertyModifyingEventHandler.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.PropertyModifyingEventHandler
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public delegate void PropertyModifyingEventHandler(object sender, PropertyModifyingEventArgs e);
}


--- StringFormatAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.StringFormatAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
  public class StringFormatAttribute : 
    DictionaryBehaviorAttribute,
    IDictionaryPropertyGetter,
    IDictionaryBehavior
  {
    private static readonly char[] PropertyDelimeters = new char[2]
    {
      ',',
      ' '
    };

    public StringFormatAttribute(string format, string properties)
    {
      this.Format = format != null ? format : throw new ArgumentNullException(nameof (format));
      this.Properties = properties;
    }

    public string Format { get; private set; }

    public string Properties { get; private set; }

    object IDictionaryPropertyGetter.GetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      object storedValue,
      PropertyDescriptor property,
      bool ifExists)
    {
      return (object) string.Format(this.Format, this.GetFormatArguments(dictionaryAdapter, property.Property.Name)).Trim();
    }

    private object[] GetFormatArguments(
      IDictionaryAdapter dictionaryAdapter,
      string formattedPropertyName)
    {
      string[] strArray = this.Properties.Split(StringFormatAttribute.PropertyDelimeters, StringSplitOptions.RemoveEmptyEntries);
      object[] formatArguments = new object[strArray.Length];
      for (int index = 0; index < strArray.Length; ++index)
      {
        string propertyName = strArray[index];
        formatArguments[index] = !(propertyName != formattedPropertyName) ? (object) "(recursive)" : dictionaryAdapter.GetProperty(propertyName, false);
      }
      return formatArguments;
    }
  }
}


--- StringListAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.StringListAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Text;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
  public class StringListAttribute : 
    DictionaryBehaviorAttribute,
    IDictionaryPropertyGetter,
    IDictionaryPropertySetter,
    IDictionaryBehavior
  {
    private char separator = ',';

    public char Separator
    {
      get => this.separator;
      set => this.separator = value;
    }

    object IDictionaryPropertyGetter.GetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      object storedValue,
      PropertyDescriptor property,
      bool ifExists)
    {
      Type propertyType = property.PropertyType;
      if ((storedValue == null || !storedValue.GetType().IsInstanceOfType((object) propertyType)) && propertyType.IsGenericType)
      {
        Type genericTypeDefinition = propertyType.GetGenericTypeDefinition();
        if (genericTypeDefinition == typeof (IList<>) || genericTypeDefinition == typeof (ICollection<>) || genericTypeDefinition == typeof (List<>) || genericTypeDefinition == typeof (IEnumerable<>))
        {
          Type genericArgument = propertyType.GetGenericArguments()[0];
          TypeConverter converter = TypeDescriptor.GetConverter(genericArgument);
          if (converter != null && converter.CanConvertFrom(typeof (string)))
            return Activator.CreateInstance(typeof (StringListWrapper<>).MakeGenericType(genericArgument), (object) key, storedValue, (object) this.separator, (object) dictionaryAdapter.This.Dictionary);
        }
      }
      return storedValue;
    }

    bool IDictionaryPropertySetter.SetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      ref object value,
      PropertyDescriptor property)
    {
      if (value is IEnumerable enumerable)
        value = (object) StringListAttribute.BuildString(enumerable, this.separator);
      return true;
    }

    internal static string BuildString(IEnumerable enumerable, char separator)
    {
      bool flag = true;
      StringBuilder stringBuilder = new StringBuilder();
      foreach (object obj in enumerable)
      {
        if (flag)
          flag = false;
        else
          stringBuilder.Append(separator);
        stringBuilder.Append(obj.ToString());
      }
      return stringBuilder.ToString();
    }
  }
}


--- StringListWrapper`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.StringListWrapper`1
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  internal class StringListWrapper<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
  {
    private readonly string key;
    private readonly char separator;
    private readonly IDictionary dictionary;
    private readonly List<T> inner;

    public StringListWrapper(string key, string list, char separator, IDictionary dictionary)
    {
      this.key = key;
      this.separator = separator;
      this.dictionary = dictionary;
      this.inner = new List<T>();
      this.ParseList(list);
    }

    public int IndexOf(T item) => this.inner.IndexOf(item);

    public void Insert(int index, T item)
    {
      this.inner.Insert(index, item);
      this.SynchronizeDictionary();
    }

    public void RemoveAt(int index)
    {
      this.inner.RemoveAt(index);
      this.SynchronizeDictionary();
    }

    public T this[int index]
    {
      get => this.inner[index];
      set
      {
        this.inner[index] = value;
        this.SynchronizeDictionary();
      }
    }

    public void Add(T item)
    {
      this.inner.Add(item);
      this.SynchronizeDictionary();
    }

    public void Clear()
    {
      this.inner.Clear();
      this.SynchronizeDictionary();
    }

    public bool Contains(T item) => this.inner.Contains(item);

    public void CopyTo(T[] array, int arrayIndex) => this.inner.CopyTo(array, arrayIndex);

    public int Count => this.inner.Count;

    public bool IsReadOnly => false;

    public bool Remove(T item)
    {
      if (!this.inner.Remove(item))
        return false;
      this.SynchronizeDictionary();
      return true;
    }

    public IEnumerator<T> GetEnumerator() => (IEnumerator<T>) this.inner.GetEnumerator();

    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.inner.GetEnumerator();

    private void ParseList(string list)
    {
      if (list == null)
        return;
      TypeConverter converter = TypeDescriptor.GetConverter(typeof (T));
      string str1 = list;
      char[] chArray = new char[1]{ this.separator };
      foreach (string str2 in str1.Split(chArray))
        this.inner.Add((T) converter.ConvertFrom((object) str2));
    }

    private void SynchronizeDictionary()
    {
      this.dictionary[(object) this.key] = (object) StringListAttribute.BuildString((IEnumerable) this.inner, this.separator);
    }
  }
}


--- StringStorageAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.StringStorageAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class StringStorageAttribute : 
    DictionaryBehaviorAttribute,
    IDictionaryPropertySetter,
    IDictionaryBehavior
  {
    public bool SetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      ref object value,
      PropertyDescriptor property)
    {
      value = value != null ? (object) value.ToString() : (object) (string) null;
      return true;
    }
  }
}


--- StringValuesAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.StringValuesAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.ComponentModel;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Interface, AllowMultiple = false, Inherited = true)]
  public class StringValuesAttribute : 
    DictionaryBehaviorAttribute,
    IDictionaryPropertySetter,
    IDictionaryBehavior
  {
    private string format;

    public string Format
    {
      get => this.format;
      set => this.format = value;
    }

    bool IDictionaryPropertySetter.SetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      ref object value,
      PropertyDescriptor property)
    {
      if (value != null)
        value = (object) this.GetPropertyAsString(property, value);
      return true;
    }

    private string GetPropertyAsString(PropertyDescriptor property, object value)
    {
      if (!string.IsNullOrEmpty(this.format))
        return string.Format(this.format, value);
      TypeConverter typeConverter = property.TypeConverter;
      return typeConverter != null && typeConverter.CanConvertTo(typeof (string)) ? (string) typeConverter.ConvertTo(value, typeof (string)) : value.ToString();
    }
  }
}


--- SuppressNotificationsAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.SuppressNotificationsAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
  public class SuppressNotificationsAttribute : 
    DictionaryBehaviorAttribute,
    IPropertyDescriptorInitializer,
    IDictionaryBehavior
  {
    public void Initialize(PropertyDescriptor propertyDescriptor, object[] behaviors)
    {
      propertyDescriptor.SuppressNotifications = true;
    }
  }
}


--- TypeKeyPrefixAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.TypeKeyPrefixAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Interface, AllowMultiple = false, Inherited = true)]
  public class TypeKeyPrefixAttribute : 
    DictionaryBehaviorAttribute,
    IDictionaryKeyBuilder,
    IDictionaryBehavior
  {
    string IDictionaryKeyBuilder.GetKey(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      PropertyDescriptor property)
    {
      return property.Property.DeclaringType.FullName + "#" + key;
    }
  }
}


--- XmlMetadata.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.XmlMetadata
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections.Generic;
using System.Xml.Serialization;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class XmlMetadata
  {
    public XmlMetadata(
      Type type,
      XmlTypeAttribute xmlType,
      XmlRootAttribute xmlRoot,
      IEnumerable<Type> xmlIncludes)
    {
      this.Type = type;
      this.XmlType = xmlType;
      this.XmlRoot = xmlRoot;
      this.XmlIncludes = xmlIncludes;
    }

    public Type Type { get; private set; }

    public XmlTypeAttribute XmlType { get; private set; }

    public XmlRootAttribute XmlRoot { get; private set; }

    public IEnumerable<Type> XmlIncludes { get; private set; }
  }
}


--- XmlNamespaceAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.XmlNamespaceAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Interface, AllowMultiple = true)]
  public class XmlNamespaceAttribute : Attribute
  {
    public XmlNamespaceAttribute(string namespaceUri, string prefix)
    {
      this.NamespaceUri = namespaceUri;
      this.Prefix = prefix;
    }

    public bool Default { get; set; }

    public string NamespaceUri { get; private set; }

    public string Prefix { get; private set; }
  }
}


--- XPathAdapter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.XPathAdapter
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.XPath;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class XPathAdapter : 
    DictionaryBehaviorAttribute,
    IDictionaryInitializer,
    IDictionaryPropertyGetter,
    IDictionaryPropertySetter,
    IDictionaryBehavior,
    IDictionaryCreateStrategy
  {
    private readonly Func<XPathNavigator> createRoot;
    private XPathNavigator root;
    private XmlMetadata xmlMeta;
    private static readonly XPathExpression XPathElement = XPathExpression.Compile("*[castle-da:match($key,$ns)]");
    private static readonly XPathExpression XPathAttribute = XPathExpression.Compile("@*[castle-da:match($key,$ns)]");
    private static readonly XPathExpression XPathElementOrAttribute = XPathExpression.Compile("(*|@*)[castle-da:match($key,$ns)]");

    public XPathNavigator Root => this.EnsureOffRoot();

    public XPathAdapter Parent { get; private set; }

    public IXPathNavigable Source { get; private set; }

    public XPathContext Context { get; private set; }

    public XPathAdapter()
      : this((IXPathNavigable) new XmlDocument())
    {
    }

    public XPathAdapter(IXPathNavigable source)
    {
      this.Source = source;
      this.Context = new XPathContext();
      this.root = source.CreateNavigator();
    }

    protected XPathAdapter(XPathNavigator source, XPathAdapter parent)
    {
      this.Parent = parent;
      this.Context = parent.Context.CreateChild();
      this.root = source.Clone();
    }

    protected XPathAdapter(Func<XPathNavigator> createSource, XPathAdapter parent)
    {
      this.Parent = parent;
      this.Context = parent.Context.CreateChild();
      this.createRoot = createSource;
    }

    void IDictionaryInitializer.Initialize(IDictionaryAdapter dictionaryAdapter, object[] behaviors)
    {
      DictionaryAdapterMeta meta = dictionaryAdapter.Meta;
      if (meta.MetaInitializers.OfType<XPathBehavior>().FirstOrDefault<XPathBehavior>() == null)
        throw new InvalidOperationException(string.Format("Interface {0} requested xpath support, but was not configured properly.  Did you forget to add an XPathBehavior?", (object) meta.Type.FullName));
      dictionaryAdapter.This.CreateStrategy = (IDictionaryCreateStrategy) this;
      this.Context.ApplyBehaviors((IEnumerable) behaviors);
      this.xmlMeta = dictionaryAdapter.GetXmlMeta();
      if (!string.IsNullOrEmpty(this.xmlMeta.XmlType.Namespace))
        this.Context.AddNamespace(string.Empty, this.xmlMeta.XmlType.Namespace);
      if (this.Parent != null)
        return;
      foreach (object behavior in behaviors)
      {
        if (behavior is Castle.Components.DictionaryAdapter.XPathAttribute)
        {
          XPathExpression compiledExpression = ((Castle.Components.DictionaryAdapter.XPathAttribute) behavior).CompiledExpression;
          if (XPathAdapter.MoveOffRoot(this.root, XPathNodeType.Element) && !this.Context.Matches(compiledExpression, this.root))
          {
            XPathNavigator xpathNavigator = this.Context.SelectSingleNode(compiledExpression, this.root);
            if (xpathNavigator != null)
            {
              this.root = xpathNavigator;
              break;
            }
          }
          else
            break;
        }
      }
      XPathAdapter.MoveOffRoot(this.root, XPathNodeType.Element);
    }

    object IDictionaryPropertyGetter.GetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      object storedValue,
      PropertyDescriptor property,
      bool ifExists)
    {
      return XPathAdapter.ShouldIgnoreProperty(property) ? storedValue : dictionaryAdapter.This.ExtendedProperties[(object) property.PropertyName] ?? this.ReadProperty(this.EvaluateProperty(key, property, dictionaryAdapter), ifExists, dictionaryAdapter);
    }

    bool IDictionaryPropertySetter.SetPropertyValue(
      IDictionaryAdapter dictionaryAdapter,
      string key,
      ref object value,
      PropertyDescriptor property)
    {
      if (XPathAdapter.ShouldIgnoreProperty(property))
        return true;
      this.EnsureOffRoot();
      if (this.root.CanEdit)
      {
        XPathResult property1 = this.EvaluateProperty(key, property, dictionaryAdapter);
        if (property1.CanWrite)
          this.WriteProperty(property1, value, dictionaryAdapter);
      }
      return false;
    }

    object IDictionaryCreateStrategy.Create(
      IDictionaryAdapter adapter,
      Type type,
      IDictionary dictionary)
    {
      dictionary = dictionary ?? (IDictionary) new Hashtable();
      DictionaryDescriptor dictionaryDescriptor = new DictionaryDescriptor();
      adapter.This.Descriptor.CopyBehaviors((PropertyDescriptor) dictionaryDescriptor, (Func<IDictionaryBehavior, bool>) (b => !(b is XPathAdapter)));
      dictionaryDescriptor.AddBehavior((IDictionaryBehavior) XPathBehavior.Instance).AddBehavior((IDictionaryBehavior) new XPathAdapter((IXPathNavigable) new XmlDocument()));
      return adapter.This.Factory.GetAdapter(type, dictionary, (PropertyDescriptor) dictionaryDescriptor);
    }

    private object ReadProperty(
      XPathResult result,
      bool ifExists,
      IDictionaryAdapter dictionaryAdapter)
    {
      Type type = result.Type;
      object obj;
      if (this.ReadCustom(result, out obj))
        return obj;
      if (type != typeof (string))
      {
        if (typeof (IXPathNavigable).IsAssignableFrom(type))
          return this.ReadFragment(result);
        if (type.IsArray || typeof (IEnumerable).IsAssignableFrom(type))
          return this.ReadCollection(result, dictionaryAdapter);
        if (type.IsInterface)
          return this.ReadComponent(result, ifExists, dictionaryAdapter);
      }
      return this.ReadSimple(result);
    }

    private object ReadFragment(XPathResult result)
    {
      XPathNavigator navigator = result.GetNavigator(false);
      if (result.Type != typeof (XmlElement))
        return (object) navigator.Clone();
      XmlDocument xmlDocument = new XmlDocument();
      xmlDocument.Load(navigator.ReadSubtree());
      return (object) xmlDocument.DocumentElement;
    }

    private object ReadSimple(XPathResult result)
    {
      XPathNavigator navigator = result.GetNavigator(false);
      if (navigator != null)
      {
        if (result.Type.IsEnum)
          return Enum.Parse(result.Type, navigator.Value);
        try
        {
          return navigator.ValueAs(result.Type);
        }
        catch (InvalidCastException ex)
        {
          object obj;
          if (DefaultXmlSerializer.Instance.ReadObject(result, navigator, out obj))
            return obj;
        }
      }
      return result.Result != null ? Convert.ChangeType(result.Result, result.Type) : (object) null;
    }

    private object ReadComponent(
      XPathResult result,
      bool ifExists,
      IDictionaryAdapter dictionaryAdapter)
    {
      XPathNavigator navigator = result.GetNavigator(false);
      if (navigator == null && ifExists)
        return (object) null;
      Type type = result.Type;
      XPathAdapter xpathAdapter;
      if (navigator != null)
      {
        if (result.XmlMeta != null)
        {
          type = result.XmlMeta.Type;
        }
        else
        {
          XmlQualifiedName xmlType = this.Context.GetXmlType(navigator);
          type = dictionaryAdapter.GetXmlSubclass(xmlType, type) ?? type;
        }
        xpathAdapter = new XPathAdapter(navigator, this);
      }
      else
        xpathAdapter = new XPathAdapter((Func<XPathNavigator>) (() => result.GetNavigator(true)), this);
      object adapter = dictionaryAdapter.This.Factory.GetAdapter(type, (IDictionary) new Hashtable(), new DictionaryDescriptor().AddBehavior((IDictionaryBehavior) XPathBehavior.Instance, (IDictionaryBehavior) xpathAdapter));
      if (result.Property != null)
        dictionaryAdapter.This.ExtendedProperties[(object) result.Property.PropertyName] = adapter;
      return adapter;
    }

    private object ReadCollection(XPathResult result, IDictionaryAdapter dictionaryAdapter)
    {
      if (result.Type.IsArray)
        return this.ReadArray(result, dictionaryAdapter);
      return result.Type.IsGenericType ? this.ReadList(result, dictionaryAdapter) : (object) null;
    }

    private object ReadArray(XPathResult result, IDictionaryAdapter dictionaryAdapter)
    {
      Type elementType = result.Type.GetElementType();
      object[] array = result.GetNodes(elementType, (Func<Type, XmlMetadata>) (type => dictionaryAdapter.GetXmlMeta(type))).Select<XPathResult, object>((Func<XPathResult, object>) (node => this.ReadProperty(node, false, dictionaryAdapter))).ToArray<object>();
      Array instance = Array.CreateInstance(elementType, array.Length);
      array.CopyTo(instance, 0);
      return (object) instance;
    }

    private object ReadList(XPathResult result, IDictionaryAdapter dictionaryAdapter)
    {
      Type type1 = (Type) null;
      Type[] genericArguments = result.Type.GetGenericArguments();
      Type genericTypeDefinition = result.Type.GetGenericTypeDefinition();
      Type itemType = genericArguments[0];
      Type type2;
      if (genericTypeDefinition == typeof (List<>))
      {
        type2 = typeof (EditableList<>).MakeGenericType(genericArguments);
      }
      else
      {
        type2 = typeof (EditableBindingList<>).MakeGenericType(genericArguments);
        type1 = typeof (BindingListInitializer<>).MakeGenericType(genericArguments);
      }
      IList instance = (IList) Activator.CreateInstance(type2);
      Func<Type, XmlMetadata> getXmlMeta = (Func<Type, XmlMetadata>) (type => dictionaryAdapter.GetXmlMeta(type));
      foreach (XPathResult node in result.GetNodes(itemType, getXmlMeta))
        instance.Add(this.ReadProperty(node, false, dictionaryAdapter));
      if (type1 != null)
      {
        Func<object> func = (Func<object>) (() => this.ReadProperty(result.CreateNode(itemType, (object) null, getXmlMeta), false, dictionaryAdapter));
        Action<int, object> action1 = (Action<int, object>) ((index, item) => this.WriteProperty(result.CreateNode(itemType, item, getXmlMeta), item, dictionaryAdapter));
        Action<int, object> action2 = (Action<int, object>) ((index, item) => this.WriteProperty(result.GetNodeAt(itemType, index), item, dictionaryAdapter));
        Action<int> action3 = (Action<int>) (index => result.RemoveAt(index));
        ((IValueInitializer) Activator.CreateInstance(type1, (object) action1, (object) func, (object) action2, (object) action3)).Initialize(dictionaryAdapter, (object) instance);
      }
      return (object) instance;
    }

    private bool ReadCustom(XPathResult result, out object value) => result.ReadObject(out value);

    private void WriteProperty(
      XPathResult result,
      object value,
      IDictionaryAdapter dictionaryAdapter)
    {
      Type type = result.Type;
      if (this.WriteCustom(result, value, dictionaryAdapter))
        return;
      if (type == typeof (string))
        this.WriteSimple(result, value, dictionaryAdapter);
      else if (typeof (IXPathNavigable).IsAssignableFrom(type))
        this.WriteFragment(result, (IXPathNavigable) value);
      else if (type.IsArray || typeof (IEnumerable).IsAssignableFrom(type))
        this.WriteCollection(result, value, dictionaryAdapter);
      else if (type.IsInterface)
        this.WriteComponent(result, value, dictionaryAdapter);
      else
        this.WriteSimple(result, value, dictionaryAdapter);
    }

    private void WriteFragment(XPathResult result, IXPathNavigable value)
    {
      XPathNavigator navigator = result.GetNavigator(true);
      if (navigator == null)
        this.root.AppendChild(value.CreateNavigator());
      else if (value != null)
        navigator.ReplaceSelf(value.CreateNavigator());
      else
        navigator.DeleteSelf();
    }

    private void WriteSimple(
      XPathResult result,
      object value,
      IDictionaryAdapter dictionaryAdapter)
    {
      if (value == null)
      {
        result.Remove();
        if (result.Property == null)
          return;
        dictionaryAdapter.This.ExtendedProperties.Remove((object) result.Property.PropertyName);
      }
      else
      {
        XPathNavigator navigator = result.GetNavigator(true);
        if (result.Type.IsEnum)
        {
          navigator.SetTypedValue((object) value.ToString());
        }
        else
        {
          try
          {
            navigator.SetTypedValue(value);
          }
          catch (InvalidCastException ex)
          {
            if (!DefaultXmlSerializer.Instance.WriteObject(result, navigator, value) || result.Property == null)
              return;
            dictionaryAdapter.This.ExtendedProperties[(object) result.Property.PropertyName] = value;
          }
        }
      }
    }

    private void WriteComponent(
      XPathResult result,
      object value,
      IDictionaryAdapter dictionaryAdapter)
    {
      if (result.Property != null)
        dictionaryAdapter.This.ExtendedProperties.Remove((object) result.Property.PropertyName);
      if (value == null)
      {
        result.Remove();
      }
      else
      {
        if (!(value is IDictionaryAdapter dictionaryAdapter1))
          return;
        XPathNavigator source = result.RemoveChildren();
        if (result.Type != dictionaryAdapter1.Meta.Type && !result.OmitPolymorphism)
        {
          XmlTypeAttribute xmlType = dictionaryAdapter1.GetXmlMeta().XmlType;
          this.Context.SetXmlType(xmlType.TypeName, xmlType.Namespace, source);
        }
        IDictionaryAdapter other = (IDictionaryAdapter) this.ReadComponent(result, false, dictionaryAdapter);
        dictionaryAdapter1.CopyTo(other);
      }
    }

    private void WriteCollection(
      XPathResult result,
      object value,
      IDictionaryAdapter dictionaryAdapter)
    {
      result.Remove();
      if (value == null)
        return;
      if (result.Type.IsArray)
      {
        this.WriteArray(result, value, dictionaryAdapter);
      }
      else
      {
        if (!result.Type.IsGenericType)
          return;
        this.WriteList(result, value, dictionaryAdapter);
      }
    }

    private void WriteArray(XPathResult result, object value, IDictionaryAdapter dictionaryAdapter)
    {
      Array array = (Array) value;
      Type elementType = array.GetType().GetElementType();
      foreach (object obj in array)
        this.WriteProperty(result.CreateNode(elementType, obj, (Func<Type, XmlMetadata>) (type => dictionaryAdapter.GetXmlMeta(type))), obj, dictionaryAdapter);
    }

    private void WriteList(XPathResult result, object value, IDictionaryAdapter dictionaryAdapter)
    {
      Type genericArgument = result.Type.GetGenericArguments()[0];
      foreach (object obj in (IEnumerable) value)
        this.WriteProperty(result.CreateNode(genericArgument, obj, (Func<Type, XmlMetadata>) (type => dictionaryAdapter.GetXmlMeta(type))), obj, dictionaryAdapter);
    }

    private bool WriteCustom(
      XPathResult result,
      object value,
      IDictionaryAdapter dictionaryAdapter)
    {
      if (!result.WriteObject(value))
        return false;
      if (result.Property != null)
        dictionaryAdapter.This.ExtendedProperties[(object) result.Property.PropertyName] = value;
      return true;
    }

    public static XPathAdapter For(object adapter)
    {
      if (adapter == null)
        throw new ArgumentNullException(nameof (adapter));
      if (adapter is IDictionaryAdapter dictionaryAdapter)
      {
        XPathAdapter xpathAdapter = (XPathAdapter) null;
        ICollection<IDictionaryPropertyGetter> getters = dictionaryAdapter.This.Descriptor.Getters;
        if (getters != null)
          xpathAdapter = getters.OfType<XPathAdapter>().SingleOrDefault<XPathAdapter>();
        if (xpathAdapter != null)
          return xpathAdapter;
      }
      return (XPathAdapter) null;
    }

    private XPathResult EvaluateProperty(
      string key,
      PropertyDescriptor property,
      IDictionaryAdapter dictionaryAdapter)
    {
      XPathExpression xpath = (XPathExpression) null;
      object matchingBehavior = (object) null;
      Func<XPathNavigator> create1 = (Func<XPathNavigator>) null;
      XPathContext keyContext = this.Context.CreateChild((IEnumerable) Enumerable.Repeat<object>((object) dictionaryAdapter.GetXmlMeta(property.Property.DeclaringType).XmlType, 1).Union<object>((IEnumerable<object>) property.Behaviors));
      object result;
      foreach (object behavior in property.Behaviors)
      {
        string name = key;
        string ns = (string) null;
        Func<XPathNavigator> func = (Func<XPathNavigator>) null;
        switch (behavior)
        {
          case XmlElementAttribute _:
            xpath = XPathAdapter.XPathElement;
            XPathNavigator node1 = this.root.Clone();
            XmlElementAttribute elementAttribute = (XmlElementAttribute) behavior;
            if (!string.IsNullOrEmpty(elementAttribute.ElementName))
              name = elementAttribute.ElementName;
            if (!string.IsNullOrEmpty(elementAttribute.Namespace))
              ns = elementAttribute.Namespace;
            func = (Func<XPathNavigator>) (() => keyContext.AppendElement(name, ns, node1));
            break;
          case XmlAttributeAttribute _:
            xpath = XPathAdapter.XPathAttribute;
            XPathNavigator node2 = this.root.Clone();
            XmlAttributeAttribute attributeAttribute = (XmlAttributeAttribute) behavior;
            if (!string.IsNullOrEmpty(attributeAttribute.AttributeName))
              name = attributeAttribute.AttributeName;
            if (!string.IsNullOrEmpty(attributeAttribute.Namespace))
              ns = attributeAttribute.Namespace;
            func = (Func<XPathNavigator>) (() => keyContext.CreateAttribute(name, ns, node2));
            break;
          case XmlArrayAttribute _:
            xpath = XPathAdapter.XPathElement;
            XPathNavigator node3 = this.root.Clone();
            XmlArrayAttribute xmlArrayAttribute = (XmlArrayAttribute) behavior;
            if (!string.IsNullOrEmpty(xmlArrayAttribute.ElementName))
              name = xmlArrayAttribute.ElementName;
            if (!string.IsNullOrEmpty(xmlArrayAttribute.Namespace))
              ns = xmlArrayAttribute.Namespace;
            func = (Func<XPathNavigator>) (() => keyContext.AppendElement(name, ns, node3));
            break;
          case Castle.Components.DictionaryAdapter.XPathAttribute _:
            xpath = ((Castle.Components.DictionaryAdapter.XPathAttribute) behavior).CompiledExpression;
            break;
          default:
            continue;
        }
        if (xpath != null)
        {
          keyContext.Arguments.Clear();
          keyContext.Arguments.AddParam(nameof (key), "", (object) name);
          keyContext.Arguments.AddParam("ns", "", (object) (ns ?? "_"));
          if (keyContext.Evaluate(xpath, this.Root, out result))
          {
            Func<XPathNavigator> create2 = func ?? create1;
            return new XPathResult(property, result, keyContext, behavior, create2);
          }
        }
        matchingBehavior = matchingBehavior ?? behavior;
        create1 = create1 ?? func;
      }
      if (xpath != null)
        return new XPathResult(property, (object) null, keyContext, matchingBehavior, create1);
      keyContext.Arguments.Clear();
      keyContext.Arguments.AddParam(nameof (key), "", (object) key);
      keyContext.Arguments.AddParam("ns", "", (object) "_");
      Func<XPathNavigator> create3 = create1 ?? (Func<XPathNavigator>) (() => keyContext.AppendElement(key, (string) null, this.root));
      keyContext.Evaluate(XPathAdapter.XPathElementOrAttribute, this.Root, out result);
      return new XPathResult(property, result, keyContext, (object) null, create3);
    }

    private static bool ShouldIgnoreProperty(PropertyDescriptor property)
    {
      return ((IEnumerable<object>) property.Behaviors).Any<object>((Func<object, bool>) (behavior => behavior is XmlIgnoreAttribute));
    }

    private XPathNavigator EnsureOffRoot()
    {
      if (this.root == null && this.createRoot != null)
        this.root = this.createRoot().Clone();
      if (this.root != null && !XPathAdapter.MoveOffRoot(this.root, XPathNodeType.Element))
      {
        string namespaceUri = "";
        XmlRootAttribute xmlRoot = this.xmlMeta.XmlRoot;
        string name;
        if (xmlRoot != null)
        {
          name = xmlRoot.ElementName;
          namespaceUri = xmlRoot.Namespace;
        }
        else
          name = this.xmlMeta.XmlType.TypeName;
        this.root = this.Context.AppendElement(name, namespaceUri, this.root);
        this.Context.AddStandardNamespaces(this.root);
      }
      return this.root;
    }

    private static bool MoveOffRoot(XPathNavigator source, XPathNodeType to)
    {
      return source.NodeType != XPathNodeType.Root || source.MoveToChild(to);
    }
  }
}


--- XPathAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.XPathAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Xml.XPath;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Interface, AllowMultiple = true)]
  public class XPathAttribute : Attribute
  {
    private string expression;

    public XPathAttribute(string expression) => this.Expression = expression;

    public string Expression
    {
      get => this.expression;
      private set
      {
        this.expression = value;
        this.CompiledExpression = XPathExpression.Compile(this.expression);
      }
    }

    public XPathExpression CompiledExpression { get; private set; }
  }
}


--- XPathBehavior.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.XPathBehavior
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml.Serialization;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class XPathBehavior : 
    DictionaryBehaviorAttribute,
    IDictionaryMetaInitializer,
    IDictionaryBehavior
  {
    public static readonly XPathBehavior Instance = new XPathBehavior();

    void IDictionaryMetaInitializer.Initialize(
      IDictionaryAdapterFactory factory,
      DictionaryAdapterMeta dictionaryMeta)
    {
      Type type = dictionaryMeta.Type;
      string defaultNamespace = (string) null;
      XmlTypeAttribute xmlType = (XmlTypeAttribute) null;
      XmlRootAttribute xmlRoot = (XmlRootAttribute) null;
      List<Type> xmlIncludes = (List<Type>) null;
      new BehaviorVisitor().OfType<XmlTypeAttribute>((Action<XmlTypeAttribute>) (attrib => xmlType = attrib)).OfType<XmlRootAttribute>((Action<XmlRootAttribute>) (attrib => xmlRoot = attrib)).OfType<XmlNamespaceAttribute>((Action<XmlNamespaceAttribute>) (attrib =>
      {
        if (!attrib.Default)
          return;
        defaultNamespace = attrib.NamespaceUri;
      })).OfType<XmlIncludeAttribute>((Action<XmlIncludeAttribute>) (attrib =>
      {
        xmlIncludes = xmlIncludes ?? new List<Type>();
        if (type == attrib.Type || !type.IsAssignableFrom(attrib.Type))
          return;
        xmlIncludes.Add(attrib.Type);
      })).Apply((IEnumerable) dictionaryMeta.Behaviors);
      if (xmlType == null)
      {
        xmlType = new XmlTypeAttribute()
        {
          TypeName = type.Name,
          Namespace = defaultNamespace
        };
        if (xmlType.TypeName.StartsWith("I"))
          xmlType.TypeName = xmlType.TypeName.Substring(1);
      }
      else if (xmlType.Namespace == null)
        xmlType.Namespace = defaultNamespace;
      dictionaryMeta.SetXmlMeta(new XmlMetadata(type, xmlType, xmlRoot, (IEnumerable<Type>) xmlIncludes));
    }
  }
}


--- XPathContext.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.XPathContext
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using System.Xml.Serialization;
using System.Xml.XPath;
using System.Xml.Xsl;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class XPathContext : XsltContext
  {
    public const string Prefix = "castle-da";
    public const string NamespaceUri = "urn:castleproject.org:da";
    public const string IgnoreNamespace = "_";
    private const string Xsd = "http://www.w3.org/2001/XMLSchema";
    private const string Xsi = "http://www.w3.org/2001/XMLSchema-instance";
    private readonly XPathContext parent;
    private IDictionary<string, Func<IXsltContextFunction>> functions;
    private List<IXPathSerializer> serializers;
    private int prefixCount;

    public XPathContext()
      : this(new System.Xml.NameTable())
    {
    }

    public XPathContext(System.Xml.NameTable nameTable)
      : base(nameTable)
    {
      this.Arguments = new XsltArgumentList();
      this.functions = (IDictionary<string, Func<IXsltContextFunction>>) new Dictionary<string, Func<IXsltContextFunction>>();
      this.AddNamespace("xsi", "http://www.w3.org/2001/XMLSchema-instance");
      this.AddNamespace("xsd", "http://www.w3.org/2001/XMLSchema");
      this.AddNamespace("castle-da", "urn:castleproject.org:da");
      this.AddFunction("castle-da", "match", (IXsltContextFunction) XPathContext.MatchFunction.Instance);
    }

    public XPathContext(XPathContext parent)
      : base((System.Xml.NameTable) parent.NameTable)
    {
      this.parent = parent;
      this.Arguments = new XsltArgumentList();
      this.functions = (IDictionary<string, Func<IXsltContextFunction>>) new Dictionary<string, Func<IXsltContextFunction>>();
    }

    public override string DefaultNamespace
    {
      get
      {
        string defaultNamespace = base.DefaultNamespace;
        if (string.IsNullOrEmpty(defaultNamespace) && this.parent != null)
          defaultNamespace = this.parent.DefaultNamespace;
        return defaultNamespace;
      }
    }

    public XsltArgumentList Arguments { get; private set; }

    public IEnumerable<XmlArrayItemAttribute> ListItemMeta { get; private set; }

    public IEnumerable<IXPathSerializer> Serializers
    {
      get
      {
        return ((IEnumerable<IXPathSerializer>) this.serializers ?? Enumerable.Empty<IXPathSerializer>()).Union<IXPathSerializer>(this.parent != null ? this.parent.Serializers : Enumerable.Empty<IXPathSerializer>());
      }
    }

    public XPathContext ApplyBehaviors(IEnumerable behaviors)
    {
      new BehaviorVisitor().OfType<XmlTypeAttribute>((Action<XmlTypeAttribute>) (attrib =>
      {
        if (string.IsNullOrEmpty(attrib.Namespace))
          return;
        this.AddNamespace(string.Empty, attrib.Namespace);
      })).OfType<XmlNamespaceAttribute>((Action<XmlNamespaceAttribute>) (attrib =>
      {
        this.AddNamespace(attrib.Prefix, attrib.NamespaceUri);
        if (!attrib.Default)
          return;
        this.AddNamespace(string.Empty, attrib.NamespaceUri);
      })).OfType<XmlArrayItemAttribute>((Action<XmlArrayItemAttribute>) (attrib =>
      {
        this.ListItemMeta = this.ListItemMeta ?? (IEnumerable<XmlArrayItemAttribute>) new List<XmlArrayItemAttribute>();
        ((List<XmlArrayItemAttribute>) this.ListItemMeta).Add(attrib);
      })).OfType<XPathFunctionAttribute>((Action<XPathFunctionAttribute>) (attrib => this.AddFunction(attrib.Prefix, attrib.Name, attrib.Function))).OfType<IXPathSerializer>((Action<IXPathSerializer>) (attrib => this.AddSerializer(attrib))).Apply(behaviors);
      return this;
    }

    public XPathContext CreateChild(IEnumerable behaviors)
    {
      return new XPathContext(this).ApplyBehaviors(behaviors);
    }

    public XPathContext CreateChild(params object[] behaviors)
    {
      return this.CreateChild((IEnumerable) behaviors);
    }

    public override bool HasNamespace(string prefix)
    {
      if (base.HasNamespace(prefix))
        return true;
      return this.parent != null && this.parent.HasNamespace(prefix);
    }

    public override string LookupNamespace(string prefix)
    {
      string str = base.LookupNamespace(prefix);
      if (str == null && this.parent != null)
        str = this.parent.LookupNamespace(prefix);
      return str;
    }

    public override string LookupPrefix(string uri)
    {
      string str = base.LookupPrefix(uri);
      if (string.IsNullOrEmpty(str) && this.parent != null)
        str = this.parent.LookupPrefix(uri);
      return str;
    }

    public string AddNamespace(string namespaceUri)
    {
      string prefix = this.LookupPrefix(namespaceUri);
      if (string.IsNullOrEmpty(prefix))
      {
        prefix = this.GetUniquePrefix();
        this.AddNamespace(prefix, namespaceUri);
      }
      return prefix;
    }

    public XPathContext AddSerializer(IXPathSerializer serializer)
    {
      this.serializers = this.serializers ?? new List<IXPathSerializer>();
      this.serializers.Insert(0, serializer);
      return this;
    }

    public XPathContext AddFunction(string prefix, string name, IXsltContextFunction function)
    {
      this.functions[XPathContext.GetQualifiedName(prefix, name)] = (Func<IXsltContextFunction>) (() => function);
      return this;
    }

    public XPathContext AddFunction(
      string prefix,
      string name,
      Func<IXsltContextFunction> function)
    {
      this.functions[XPathContext.GetQualifiedName(prefix, name)] = function;
      return this;
    }

    public override IXsltContextFunction ResolveFunction(
      string prefix,
      string name,
      XPathResultType[] argTypes)
    {
      Func<IXsltContextFunction> func;
      if (this.functions.TryGetValue(XPathContext.GetQualifiedName(prefix, name), out func))
        return func();
      return this.parent == null ? (IXsltContextFunction) null : this.parent.ResolveFunction(prefix, name, argTypes);
    }

    public override IXsltContextVariable ResolveVariable(string prefix, string name)
    {
      return (IXsltContextVariable) new XPathContext.XPathVariable(name);
    }

    public bool Evaluate(XPathExpression xpath, XPathNavigator source, out object result)
    {
      xpath = xpath.Clone();
      xpath.SetContext((XmlNamespaceManager) this);
      result = source.Evaluate(xpath);
      if (xpath.ReturnType == XPathResultType.NodeSet && ((XPathNodeIterator) result).Count == 0)
        result = (object) null;
      return result != null;
    }

    public XPathNavigator SelectSingleNode(XPathExpression xpath, XPathNavigator source)
    {
      xpath = xpath.Clone();
      xpath.SetContext((XmlNamespaceManager) this);
      return source.SelectSingleNode(xpath);
    }

    public bool Matches(XPathExpression xpath, XPathNavigator source)
    {
      xpath = xpath.Clone();
      xpath.SetContext((XmlNamespaceManager) this);
      return source.Matches(xpath);
    }

    public void AddStandardNamespaces(XPathNavigator source)
    {
      this.CreateNamespace("xsi", "http://www.w3.org/2001/XMLSchema-instance", source);
      this.CreateNamespace("xsd", "http://www.w3.org/2001/XMLSchema", source);
    }

    public string CreateNamespace(string prefix, string namespaceUri, XPathNavigator source)
    {
      if (!string.IsNullOrEmpty(namespaceUri))
      {
        source = source.Clone();
        source.MoveToRoot();
        source.MoveToChild(XPathNodeType.Element);
        if (string.IsNullOrEmpty(prefix))
          prefix = this.AddNamespace(namespaceUri);
        string str = source.GetNamespace(prefix);
        if (str == namespaceUri)
          return prefix;
        if (!string.IsNullOrEmpty(str))
          return (string) null;
        source.CreateAttribute("xmlns", prefix, "", namespaceUri);
      }
      return prefix;
    }

    public XPathNavigator CreateAttribute(string name, string namespaceUri, XPathNavigator source)
    {
      source.CreateAttribute((string) null, name, namespaceUri, "");
      source.MoveToAttribute(name, namespaceUri ?? "");
      return source;
    }

    public XPathNavigator AppendElement(string name, string namespaceUri, XPathNavigator source)
    {
      namespaceUri = this.GetEffectiveNamespace(namespaceUri);
      source.AppendChildElement(this.LookupPrefix(namespaceUri), name, namespaceUri, "");
      return source.SelectSingleNode("*[position()=last()]");
    }

    public void SetXmlType(string name, string namespaceUri, XPathNavigator source)
    {
      namespaceUri = this.GetEffectiveNamespace(namespaceUri);
      string prefix = this.CreateNamespace((string) null, namespaceUri, source);
      source.CreateAttribute("xsi", "type", "http://www.w3.org/2001/XMLSchema-instance", XPathContext.GetQualifiedName(prefix, name));
    }

    public XmlQualifiedName GetXmlType(XPathNavigator source)
    {
      string attribute = source.GetAttribute("type", "http://www.w3.org/2001/XMLSchema-instance");
      if (string.IsNullOrEmpty(attribute))
        return (XmlQualifiedName) null;
      string ns = (string) null;
      string name1;
      string name2 = XPathContext.SplitQualifiedName(attribute, out name1);
      if (name2 != null)
        ns = source.GetNamespace(name2);
      return new XmlQualifiedName(name1, ns);
    }

    public string GetEffectiveNamespace(string namespaceUri)
    {
      return namespaceUri ?? this.DefaultNamespace;
    }

    public override int CompareDocument(string baseUri, string nextbaseUri) => 0;

    public override bool Whitespace => true;

    public override bool PreserveWhitespace(XPathNavigator node) => true;

    private string GetUniquePrefix()
    {
      return this.parent != null ? this.parent.GetUniquePrefix() : "da" + (object) ++this.prefixCount;
    }

    private static string GetQualifiedName(string prefix, string name)
    {
      return string.IsNullOrEmpty(prefix) ? name : string.Format("{0}:{1}", (object) prefix, (object) name);
    }

    private static string SplitQualifiedName(string qualifiedName, out string name)
    {
      string[] strArray = qualifiedName.Split(':');
      if (strArray.Length == 1)
      {
        name = strArray[0];
        return (string) null;
      }
      name = strArray.Length == 2 ? strArray[1] : throw new ArgumentException(string.Format("Invalid qualified name {0}.  Expected [prefix:]name format", (object) qualifiedName));
      return strArray[0];
    }

    public class XPathVariable : IXsltContextVariable
    {
      private readonly string name;

      public XPathVariable(string name) => this.name = name;

      public bool IsLocal => false;

      public bool IsParam => false;

      public XPathResultType VariableType => XPathResultType.Any;

      public object Evaluate(XsltContext xsltContext)
      {
        return ((XPathContext) xsltContext).Arguments.GetParam(this.name, (string) null);
      }
    }

    public class MatchFunction : IXsltContextFunction
    {
      public static readonly XPathContext.MatchFunction Instance = new XPathContext.MatchFunction();

      protected MatchFunction()
      {
      }

      public int Minargs => 1;

      public int Maxargs => 2;

      public XPathResultType[] ArgTypes
      {
        get
        {
          return new XPathResultType[2]
          {
            XPathResultType.String,
            XPathResultType.String
          };
        }
      }

      public XPathResultType ReturnType => XPathResultType.Boolean;

      public object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
      {
        if (!((string) args[0]).Equals(docContext.LocalName, StringComparison.OrdinalIgnoreCase))
          return (object) false;
        return args.Length > 1 && !args[1].Equals((object) "_") && !((string) args[1]).Equals(docContext.NamespaceURI, StringComparison.OrdinalIgnoreCase) ? (object) false : (object) true;
      }
    }
  }
}


--- XPathExtensions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.XPathExtensions
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public static class XPathExtensions
  {
    private const string XmlMetaKey = "XmlMeta";

    public static XmlMetadata GetXmlMeta(this IDictionaryAdapter dictionaryAdapter)
    {
      return dictionaryAdapter.GetXmlMeta((Type) null);
    }

    public static XmlMetadata GetXmlMeta(this IDictionaryAdapter dictionaryAdapter, Type otherType)
    {
      return otherType == null || otherType.IsInterface ? (XmlMetadata) XPathExtensions.GetDictionaryMeta(dictionaryAdapter, otherType).ExtendedProperties[(object) "XmlMeta"] : (XmlMetadata) null;
    }

    internal static XmlMetadata GetXmlMeta(this DictionaryAdapterMeta dictionaryAdapterMeta)
    {
      return (XmlMetadata) dictionaryAdapterMeta.ExtendedProperties[(object) "XmlMeta"];
    }

    internal static void SetXmlMeta(
      this DictionaryAdapterMeta dictionaryAdapterMeta,
      XmlMetadata xmlMeta)
    {
      dictionaryAdapterMeta.ExtendedProperties[(object) "XmlMeta"] = (object) xmlMeta;
    }

    public static Type GetXmlSubclass(
      this IDictionaryAdapter dictionaryAdapter,
      XmlQualifiedName xmlType,
      Type otherType)
    {
      if (xmlType == (XmlQualifiedName) null)
        return (Type) null;
      IEnumerable<Type> xmlIncludes = dictionaryAdapter.GetXmlMeta(otherType).XmlIncludes;
      return xmlIncludes != null ? xmlIncludes.Select(xmlInclude => new
      {
        xmlInclude = xmlInclude,
        xmlIncludeType = dictionaryAdapter.GetXmlMeta(xmlInclude).XmlType
      }).Where(_param1 => _param1.xmlIncludeType.TypeName == xmlType.Name && _param1.xmlIncludeType.Namespace == xmlType.Namespace).Select(_param0 => _param0.xmlInclude).FirstOrDefault<Type>() : (Type) null;
    }

    private static DictionaryAdapterMeta GetDictionaryMeta(
      IDictionaryAdapter dictionaryAdapter,
      Type otherType)
    {
      DictionaryAdapterMeta dictionaryMeta = dictionaryAdapter.Meta;
      if (otherType != null && otherType != dictionaryMeta.Type)
        dictionaryMeta = dictionaryAdapter.This.Factory.GetAdapterMeta(otherType, new DictionaryDescriptor().AddBehavior((IDictionaryBehavior) XPathBehavior.Instance));
      return dictionaryMeta;
    }
  }
}


--- XPathFunctionAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.XPathFunctionAttribute
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Xml.Xsl;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Interface, AllowMultiple = true)]
  public class XPathFunctionAttribute : Attribute
  {
    protected XPathFunctionAttribute(string name)
    {
      this.Name = !string.IsNullOrEmpty(name) ? name : throw new ArgumentException("Name cannot be empty", nameof (name));
    }

    public XPathFunctionAttribute(string name, Type functionType)
      : this(name)
    {
      if (!typeof (IXsltContextFunction).IsAssignableFrom(functionType))
        throw new ArgumentException("The functionType does not implement IXsltContextFunction");
      this.Function = functionType.GetConstructor(Type.EmptyTypes) != null ? (IXsltContextFunction) Activator.CreateInstance(functionType) : throw new ArgumentException("The functionType does not have a parameterless constructor");
    }

    public string Name { get; private set; }

    public IXsltContextFunction Function { get; protected set; }

    public string Prefix { get; set; }
  }
}


--- XPathPositionComparer.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.XPathPositionComparer
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System.Collections.Generic;
using System.Xml;
using System.Xml.XPath;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  internal class XPathPositionComparer : IComparer<XPathNavigator>
  {
    public static readonly XPathPositionComparer Instance = new XPathPositionComparer();

    private XPathPositionComparer()
    {
    }

    public int Compare(XPathNavigator x, XPathNavigator y)
    {
      switch (x.ComparePosition(y))
      {
        case XmlNodeOrder.Before:
          return -1;
        case XmlNodeOrder.After:
          return 1;
        default:
          return 0;
      }
    }
  }
}


--- XPathResult.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: Castle.Components.DictionaryAdapter.XPathResult
// Assembly: Castle.Core, Version=2.5.1.0, Culture=neutral, PublicKeyToken=407dd0808d44fbdc
// MVID: D1A7705D-6DF2-4847-8662-5721BEF57E6F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\Castle.Core.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Serialization;
using System.Xml.XPath;

#nullable disable
namespace Castle.Components.DictionaryAdapter
{
  public class XPathResult
  {
    public readonly bool CanWrite;
    public readonly PropertyDescriptor Property;
    private readonly object matchingBehavior;
    private readonly Func<XPathNavigator> create;
    private static readonly Dictionary<Type, string> XmlDataTypes = new Dictionary<Type, string>()
    {
      {
        typeof (int),
        "int"
      },
      {
        typeof (long),
        "long"
      },
      {
        typeof (short),
        "short"
      },
      {
        typeof (float),
        "float"
      },
      {
        typeof (double),
        "double"
      },
      {
        typeof (bool),
        "boolean"
      },
      {
        typeof (DateTime),
        "dateTime"
      },
      {
        typeof (byte),
        "byte"
      },
      {
        typeof (uint),
        "uint"
      },
      {
        typeof (ulong),
        "ulong"
      },
      {
        typeof (ushort),
        "ushort"
      }
    };

    public XPathResult(
      PropertyDescriptor property,
      object result,
      XPathContext context,
      object matchingBehavior)
      : this(property, result, context, matchingBehavior, (Func<XPathNavigator>) null)
    {
    }

    public XPathResult(Type type, object result, XPathContext context, object matchingBehavior)
      : this((PropertyDescriptor) null, result, context, matchingBehavior, (Func<XPathNavigator>) null)
    {
      this.Type = type;
    }

    public XPathResult(
      PropertyDescriptor property,
      object result,
      XPathContext context,
      object matchingBehavior,
      Func<XPathNavigator> create)
    {
      this.Result = result;
      this.Property = property;
      this.Type = property != null ? this.Property.PropertyType : (Type) null;
      this.Context = context;
      this.create = create;
      this.matchingBehavior = matchingBehavior;
      this.CanWrite = create != null || result is XPathNavigator;
    }

    public bool IsContainer
    {
      get => this.matchingBehavior == null || this.matchingBehavior is XmlArrayAttribute;
    }

    public Type Type { get; private set; }

    public object Result { get; private set; }

    public XPathContext Context { get; private set; }

    public XPathNavigator Container { get; private set; }

    public XmlMetadata XmlMeta { get; private set; }

    public bool OmitPolymorphism { get; private set; }

    public XPathNavigator GetNavigator(bool demand)
    {
      if (this.Result is XPathNavigator)
        return (XPathNavigator) this.Result;
      if (this.Result is XPathNodeIterator)
        return ((IEnumerable) this.Result).Cast<XPathNavigator>().FirstOrDefault<XPathNavigator>();
      if (!demand || this.create == null)
        return (XPathNavigator) null;
      XPathNavigator navigator = this.create();
      this.Result = (object) navigator;
      return navigator;
    }

    public XPathResult GetNodeAt(Type type, int index)
    {
      XPathNavigator result = this.Container;
      if (this.IsContainer)
      {
        if (result != null)
          result = this.Container.SelectSingleNode(string.Format("*[position()={0}]", (object) (index + 1)));
      }
      else if (this.Result is XPathNodeIterator)
        result = ((IEnumerable) this.Result).Cast<XPathNavigator>().ToArray<XPathNavigator>()[index];
      return new XPathResult(type, (object) result, this.Context, this.matchingBehavior);
    }

    public IEnumerable<XPathResult> GetNodes(Type type, Func<Type, XmlMetadata> getXmlMeta)
    {
      // ISSUE: object of a compiler-generated type is created
      // ISSUE: variable of a compiler-generated type
      XPathResult.\u003C\u003Ec__DisplayClassf cDisplayClassf1 = new XPathResult.\u003C\u003Ec__DisplayClassf();
      // ISSUE: reference to a compiler-generated field
      cDisplayClassf1.type = type;
      // ISSUE: reference to a compiler-generated field
      cDisplayClassf1.getXmlMeta = getXmlMeta;
      // ISSUE: reference to a compiler-generated field
      cDisplayClassf1.\u003C\u003E4__this = this;
      this.Container = (XPathNavigator) null;
      XPathNodeIterator result = this.Result as XPathNodeIterator;
      IEnumerable<XPathNavigator> source = Enumerable.Empty<XPathNavigator>();
      if (result == null)
      {
        this.Container = this.Result as XPathNavigator;
        if (this.IsContainer && this.Container != null)
        {
          if (this.Context.ListItemMeta != null)
          {
            // ISSUE: reference to a compiler-generated method
            return (IEnumerable<XPathResult>) this.Context.ListItemMeta.SelectMany<XmlArrayItemAttribute, XPathResult>(new Func<XmlArrayItemAttribute, IEnumerable<XPathResult>>(cDisplayClassf1.\u003CGetNodes\u003Eb__2)).OrderBy<XPathResult, XPathNavigator>((Func<XPathResult, XPathNavigator>) (r => (XPathNavigator) r.Result), (IComparer<XPathNavigator>) XPathPositionComparer.Instance);
          }
          source = this.Container.SelectChildren(XPathNodeType.Element).Cast<XPathNavigator>();
        }
      }
      else if (!this.IsContainer)
      {
        source = result.Cast<XPathNavigator>();
      }
      else
      {
        List<XPathNavigator> parents = result.Cast<XPathNavigator>().ToList<XPathNavigator>();
        this.Container = parents.FirstOrDefault<XPathNavigator>();
        if (this.Context.ListItemMeta != null)
          return (IEnumerable<XPathResult>) this.Context.ListItemMeta.SelectMany<XmlArrayItemAttribute, XPathResult>((Func<XmlArrayItemAttribute, IEnumerable<XPathResult>>) (item =>
          {
            // ISSUE: variable of a compiler-generated type
            XPathResult.\u003C\u003Ec__DisplayClassf cDisplayClassf = cDisplayClassf1;
            XmlArrayItemAttribute item1 = item;
            string name;
            string namespaceUri;
            XmlMetadata xmlMeta = this.GetItemQualifedName(type, item1, getXmlMeta, out name, out namespaceUri);
            // ISSUE: reference to a compiler-generated field
            // ISSUE: reference to a compiler-generated field
            // ISSUE: reference to a compiler-generated field
            return parents.SelectMany<XPathNavigator, XPathNavigator>((Func<XPathNavigator, IEnumerable<XPathNavigator>>) (p => p.SelectChildren(name, namespaceUri).Cast<XPathNavigator>())).Select<XPathNavigator, XPathResult>((Func<XPathNavigator, XPathResult>) (r => new XPathResult(item1.Type ?? cDisplayClassf.type, (object) r, cDisplayClassf.\u003C\u003E4__this.Context, cDisplayClassf.\u003C\u003E4__this.matchingBehavior)
            {
              XmlMeta = xmlMeta
            }));
          })).OrderBy<XPathResult, XPathNavigator>((Func<XPathResult, XPathNavigator>) (r => (XPathNavigator) r.Result), (IComparer<XPathNavigator>) XPathPositionComparer.Instance);
        source = parents.SelectMany<XPathNavigator, XPathNavigator>((Func<XPathNavigator, IEnumerable<XPathNavigator>>) (p => p.SelectChildren(XPathNodeType.Element).Cast<XPathNavigator>()));
      }
      // ISSUE: reference to a compiler-generated method
      return source.Select<XPathNavigator, XPathResult>(new Func<XPathNavigator, XPathResult>(cDisplayClassf1.\u003CGetNodes\u003Eb__a));
    }

    public bool ReadObject(out object value)
    {
      XPathNavigator navigator = this.GetNavigator(false);
      foreach (IXPathSerializer serializer in this.Context.Serializers)
      {
        if (serializer.ReadObject(this, navigator, out value))
          return true;
      }
      value = (object) null;
      return false;
    }

    public bool WriteObject(object value)
    {
      XPathNavigator navigator = this.GetNavigator(true);
      foreach (IXPathSerializer serializer in this.Context.Serializers)
      {
        if (serializer.WriteObject(this, navigator, value))
          return true;
      }
      return false;
    }

    private XmlMetadata GetItemQualifedName(
      Type type,
      XmlArrayItemAttribute item,
      Func<Type, XmlMetadata> getXmlMeta,
      out string name,
      out string namespaceUri)
    {
      name = item.ElementName;
      namespaceUri = item.Namespace;
      type = item.Type ?? type;
      XmlMetadata itemQualifedName = getXmlMeta(type);
      if (string.IsNullOrEmpty(name))
      {
        name = itemQualifedName == null ? XPathResult.GetDataType(type) : itemQualifedName.XmlType.TypeName;
        namespaceUri = (string) null;
      }
      namespaceUri = this.Context.GetEffectiveNamespace(namespaceUri);
      return itemQualifedName;
    }

    public XPathResult CreateNode(Type type, object value, Func<Type, XmlMetadata> getXmlMeta)
    {
      string name = (string) null;
      string namespaceUri1 = (string) null;
      string namespaceUri2 = (string) null;
      bool flag = false;
      Type baseType = type;
      XmlMetadata xmlMetadata = getXmlMeta(type);
      if (xmlMetadata != null)
      {
        name = xmlMetadata.XmlType.TypeName;
        namespaceUri2 = xmlMetadata.XmlType.Namespace;
      }
      if (value != null)
        type = !(value is IDictionaryAdapter) ? value.GetType() : ((IDictionaryAdapter) value).Meta.Type;
      if (xmlMetadata == null)
        name = XPathResult.GetDataType(type);
      if (this.Context.ListItemMeta != null)
      {
        Type actualType = type;
        XmlArrayItemAttribute arrayItemAttribute = this.Context.ListItemMeta.FirstOrDefault<XmlArrayItemAttribute>((Func<XmlArrayItemAttribute, bool>) (li => (li.Type ?? baseType) == actualType));
        if (arrayItemAttribute != null)
        {
          type = arrayItemAttribute.Type ?? baseType;
          if (string.IsNullOrEmpty(arrayItemAttribute.ElementName))
          {
            if (arrayItemAttribute.Type != null)
            {
              xmlMetadata = getXmlMeta(arrayItemAttribute.Type);
              if (xmlMetadata != null)
              {
                name = xmlMetadata.XmlType.TypeName;
                namespaceUri2 = xmlMetadata.XmlType.Namespace;
              }
              else
                name = XPathResult.GetDataType(arrayItemAttribute.Type);
            }
          }
          else
          {
            name = arrayItemAttribute.ElementName;
            namespaceUri1 = arrayItemAttribute.Namespace;
          }
          flag = true;
        }
      }
      XPathNavigator xpathNavigator = (XPathNavigator) null;
      if (this.IsContainer)
      {
        if (this.Container == null && this.create != null)
          this.Container = this.create();
        if (this.Container != null)
          xpathNavigator = this.Context.AppendElement(name, namespaceUri1, this.Container);
      }
      else if (this.create != null)
        xpathNavigator = this.create();
      if (!string.IsNullOrEmpty(namespaceUri2))
        this.Context.CreateNamespace((string) null, namespaceUri2, xpathNavigator);
      return new XPathResult(type, (object) xpathNavigator, this.Context, this.matchingBehavior)
      {
        XmlMeta = xmlMetadata,
        OmitPolymorphism = flag
      };
    }

    public void RemoveAt(int index) => this.GetNodeAt((Type) null, index).Remove();

    public void Remove()
    {
      if (this.Result is XPathNavigator)
        ((XPathNavigator) this.Result).DeleteSelf();
      else if (this.Result is XPathNodeIterator)
      {
        foreach (XPathNavigator xpathNavigator in ((IEnumerable) this.Result).Cast<XPathNavigator>().ToArray<XPathNavigator>())
          xpathNavigator.DeleteSelf();
      }
      this.Result = (object) null;
    }

    public XPathNavigator RemoveChildren()
    {
      XPathNavigator navigator = this.GetNavigator(true);
      if (navigator != null)
      {
        foreach (XPathNavigator xpathNavigator in navigator.SelectChildren(XPathNodeType.All).Cast<XPathNavigator>().ToArray<XPathNavigator>())
          xpathNavigator.DeleteSelf();
      }
      return navigator;
    }

    private static string GetDataType(Type type)
    {
      string lower;
      if (!XPathResult.XmlDataTypes.TryGetValue(type, out lower))
        lower = type.Name.ToLower();
      return lower;
    }
  }
}

