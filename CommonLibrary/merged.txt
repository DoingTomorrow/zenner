
--- AddressRange.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.AddressRange
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public class AddressRange : IComparable<AddressRange>
  {
    private uint startAddress = 0;
    private uint endAddress = uint.MaxValue;

    public uint StartAddress
    {
      get => this.startAddress;
      set
      {
        uint num = value - this.startAddress;
        this.startAddress = value;
        this.endAddress += num;
      }
    }

    public uint EndAddress
    {
      get => this.endAddress;
      set => this.endAddress = value;
    }

    public uint ByteSize
    {
      get => (uint) ((int) this.endAddress - (int) this.startAddress + 1);
      set => this.endAddress = (uint) ((int) this.startAddress + (int) value - 1);
    }

    public AddressRange(uint startAddress, uint size)
    {
      this.StartAddress = startAddress;
      this.ByteSize = size;
    }

    public AddressRange(uint startAddress)
    {
      this.StartAddress = startAddress;
      this.ByteSize = 1U;
    }

    public AddressRange(AddressRange theRange)
    {
      this.StartAddress = theRange.startAddress;
      this.ByteSize = theRange.ByteSize;
    }

    public bool IsInAdressRange(uint Address)
    {
      return this.StartAddress <= Address && Address <= this.EndAddress;
    }

    public void SetStartAddressHoldEndAddress(uint newStartAddress)
    {
      this.startAddress = newStartAddress <= this.endAddress ? newStartAddress : throw new Exception("try to set StartAddress higher then EndAddress");
    }

    public static bool IsInAddressRanges(List<AddressRange> adrRanges, uint address)
    {
      bool flag = false;
      if (adrRanges == null || adrRanges.Count <= 0)
        return true;
      foreach (AddressRange adrRange in adrRanges)
        flag |= adrRange.IsInAdressRange(address);
      return flag;
    }

    public AddressRange Clone() => new AddressRange(this.startAddress, this.ByteSize);

    public override string ToString()
    {
      return "0x" + this.StartAddress.ToString("X4") + "-0x" + this.EndAddress.ToString("X4") + " size:" + this.ByteSize.ToString();
    }

    public static List<AddressRange> GetRangesByExcludeRange(
      AddressRange theRange,
      AddressRange excludeRange)
    {
      List<AddressRange> rangesByExcludeRange = new List<AddressRange>();
      if (excludeRange.startAddress > theRange.endAddress && excludeRange.endAddress < theRange.startAddress)
      {
        rangesByExcludeRange.Add(theRange);
      }
      else
      {
        if (excludeRange.startAddress > theRange.startAddress && excludeRange.startAddress <= theRange.endAddress)
          rangesByExcludeRange.Add(new AddressRange(theRange.startAddress, excludeRange.startAddress - theRange.startAddress));
        if (excludeRange.endAddress >= theRange.startAddress && excludeRange.endAddress < theRange.endAddress)
          rangesByExcludeRange.Add(new AddressRange(excludeRange.endAddress + 1U, theRange.endAddress - excludeRange.endAddress));
      }
      return rangesByExcludeRange;
    }

    public int CompareTo(AddressRange obj)
    {
      if (obj == null)
        return 1;
      int num = this.startAddress.CompareTo(obj.startAddress);
      return num != 0 ? num : this.ByteSize.CompareTo(obj.ByteSize);
    }
  }
}


--- AssemblyInfo.cs ---

﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[assembly: Extension]
[assembly: AssemblyTitle("CommonLibrary")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("ZENNER")]
[assembly: AssemblyProduct("CommonLibrary")]
[assembly: AssemblyCopyright("Copyright ©  2014")]
[assembly: AssemblyTrademark("")]
[assembly: ComVisible(false)]
[assembly: Guid("662133cf-b9ca-4f60-95b4-39be42547ddf")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: AssemblyVersion("1.0.0.0")]


--- AsyncComConnectionType.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.AsyncComConnectionType
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public enum AsyncComConnectionType
  {
    COM,
    Remote,
    Remote_VPN,
  }
}


--- AsyncHelpers.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.AsyncHelpers
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public static class AsyncHelpers
  {
    [Obsolete]
    public static void RunSync(Func<Task> task)
    {
      SynchronizationContext current = SynchronizationContext.Current;
      AsyncHelpers.ExclusiveSynchronizationContext synch = new AsyncHelpers.ExclusiveSynchronizationContext();
      SynchronizationContext.SetSynchronizationContext((SynchronizationContext) synch);
      synch.Post((SendOrPostCallback) (async _ =>
      {
        try
        {
          await task();
        }
        catch (Exception ex)
        {
          synch.InnerException = ex;
          throw;
        }
        finally
        {
          synch.EndMessageLoop();
        }
      }), (object) null);
      synch.BeginMessageLoop();
      SynchronizationContext.SetSynchronizationContext(current);
    }

    [Obsolete]
    public static T RunSync<T>(Func<Task<T>> task)
    {
      SynchronizationContext current = SynchronizationContext.Current;
      AsyncHelpers.ExclusiveSynchronizationContext synch = new AsyncHelpers.ExclusiveSynchronizationContext();
      SynchronizationContext.SetSynchronizationContext((SynchronizationContext) synch);
      T ret = default (T);
      synch.Post((SendOrPostCallback) (async _ =>
      {
        try
        {
          T obj = await task();
          ret = obj;
          obj = default (T);
        }
        catch (Exception ex)
        {
          synch.InnerException = ex;
          throw;
        }
        finally
        {
          synch.EndMessageLoop();
        }
      }), (object) null);
      synch.BeginMessageLoop();
      SynchronizationContext.SetSynchronizationContext(current);
      return ret;
    }

    private class ExclusiveSynchronizationContext : SynchronizationContext
    {
      private bool done;
      private readonly AutoResetEvent workItemsWaiting = new AutoResetEvent(false);
      private readonly Queue<Tuple<SendOrPostCallback, object>> items = new Queue<Tuple<SendOrPostCallback, object>>();

      public Exception InnerException { get; set; }

      public override void Send(SendOrPostCallback d, object state)
      {
        throw new NotSupportedException("We cannot send to our same thread");
      }

      public override void Post(SendOrPostCallback d, object state)
      {
        lock (this.items)
          this.items.Enqueue(Tuple.Create<SendOrPostCallback, object>(d, state));
        this.workItemsWaiting.Set();
      }

      public void EndMessageLoop()
      {
        this.Post((SendOrPostCallback) (_ => this.done = true), (object) null);
      }

      public void BeginMessageLoop()
      {
        while (!this.done)
        {
          Tuple<SendOrPostCallback, object> tuple = (Tuple<SendOrPostCallback, object>) null;
          lock (this.items)
          {
            if (this.items.Count > 0)
              tuple = this.items.Dequeue();
          }
          if (tuple != null)
          {
            tuple.Item1(tuple.Item2);
            if (this.InnerException != null)
              throw new AggregateException("AsyncHelpers.Run method threw an exception.", this.InnerException);
          }
          else
            this.workItemsWaiting.WaitOne();
        }
      }

      public override SynchronizationContext CreateCopy() => (SynchronizationContext) this;
    }
  }
}


--- AsyncObservableCollection`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.AsyncObservableCollection`1
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Threading;

#nullable disable
namespace ZENNER.CommonLibrary
{
  [Serializable]
  public class AsyncObservableCollection<T> : ObservableCollection<T>
  {
    private SynchronizationContext synchronizationContext = SynchronizationContext.Current;

    public AsyncObservableCollection()
    {
    }

    public AsyncObservableCollection(IEnumerable<T> list)
      : base(list)
    {
    }

    public void AddRange(IEnumerable<T> items)
    {
      this.CheckReentrancy();
      foreach (T obj in items)
        this.Items.Add(obj);
      this.OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
    }

    protected override void OnCollectionChanged(NotifyCollectionChangedEventArgs e)
    {
      if (this.synchronizationContext == null)
        this.synchronizationContext = SynchronizationContext.Current;
      if (SynchronizationContext.Current == this.synchronizationContext)
        this.RaiseCollectionChanged((object) e);
      else
        this.synchronizationContext.Post(new SendOrPostCallback(this.RaiseCollectionChanged), (object) e);
    }

    private void RaiseCollectionChanged(object param)
    {
      using (this.BlockReentrancy())
        base.OnCollectionChanged((NotifyCollectionChangedEventArgs) param);
    }

    protected override void OnPropertyChanged(PropertyChangedEventArgs e)
    {
      if (this.synchronizationContext == null)
        this.synchronizationContext = SynchronizationContext.Current;
      if (SynchronizationContext.Current == this.synchronizationContext)
        this.RaisePropertyChanged((object) e);
      else
        this.synchronizationContext.Post(new SendOrPostCallback(this.RaisePropertyChanged), (object) e);
    }

    private void RaisePropertyChanged(object param)
    {
      using (this.BlockReentrancy())
        base.OnPropertyChanged((PropertyChangedEventArgs) param);
    }
  }
}


--- BusMode.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.BusMode
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public enum BusMode
  {
    MBusPointToPoint,
    MBus,
    WaveFlowRadio,
    MinomatV2,
    MinomatV3,
    MinomatV4,
    MinomatRadioTest,
    Minol_Device,
    RelayDevice,
    Radio2,
    Radio3,
    Radio4,
    wMBusS1,
    wMBusS1M,
    wMBusS2,
    wMBusT1,
    wMBusT2_meter,
    wMBusT2_other,
    wMBusC1A,
    wMBusC1B,
    Radio3_868_95_RUSSIA,
    RadioMS,
    SmokeDetector,
    NFC,
  }
}


--- ChannelLogger.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.ChannelLogger
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using NLog;
using System;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public class ChannelLogger
  {
    public Logger TheLogger;
    private ConfigList TheConfigList;
    private string ReadingChannelIdentification = (string) null;

    public ChannelLogger(Logger logger, ConfigList configList)
    {
      this.TheLogger = logger;
      this.TheConfigList = configList;
    }

    public ChannelLogger(Logger logger, string readingChannelIdentification)
    {
      this.TheLogger = logger;
      this.ReadingChannelIdentification = readingChannelIdentification;
    }

    public string ChannelInfo
    {
      get
      {
        if (this.TheConfigList != null)
          return this.TheConfigList.ReadingChannelIdentification + ": ";
        return this.ReadingChannelIdentification != null ? this.ReadingChannelIdentification + ": " : "NoChannel: ";
      }
    }

    public bool IsTraceEnabled => this.TheLogger.IsTraceEnabled;

    public void Trace(string info) => this.TheLogger.Trace(this.ChannelInfo + info);

    public void Debug(string info) => this.TheLogger.Debug(this.ChannelInfo + info);

    public void Info(string info) => this.TheLogger.Debug(this.ChannelInfo + info);

    public void Warn(string info) => this.TheLogger.Warn(this.ChannelInfo + info);

    public void Error(string info) => this.TheLogger.Error(this.ChannelInfo + info);

    public void Fatal(string info) => this.TheLogger.Fatal(this.ChannelInfo + info);

    public void Trace(string info, Exception ex)
    {
      this.TheLogger.Trace(this.ChannelInfo + info, ex);
    }

    public void Debug(string info, Exception ex)
    {
      this.TheLogger.Debug(this.ChannelInfo + info, ex);
    }

    public void Info(string info, Exception ex)
    {
      this.TheLogger.Debug(this.ChannelInfo + info, ex);
    }

    public void Warn(string info, Exception ex) => this.TheLogger.Warn(this.ChannelInfo + info, ex);

    public void Error(string info, Exception ex)
    {
      this.TheLogger.Error(this.ChannelInfo + info, ex);
    }

    public void Fatal(string info, Exception ex)
    {
      this.TheLogger.Fatal(this.ChannelInfo + info, ex);
    }
  }
}


--- CombiHeadSelection.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.CombiHeadSelection
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public enum CombiHeadSelection
  {
    UART,
    IrDA_DoveTailSide,
    IrDa_RoundSide,
    NFC,
  }
}


--- CommonTypeRange.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.CommonTypeRange
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public class CommonTypeRange
  {
    internal ulong RangeMin;
    internal ulong RangeMax;
    internal char DIN_Sparte;
    internal LoRa_ProtocolType ProtocolType;

    internal CommonTypeRange(
      ulong rangeMin,
      ulong rangeMax,
      char din_Sparte,
      LoRa_ProtocolType protocolType)
    {
      this.RangeMin = rangeMin;
      this.RangeMax = rangeMax;
      this.DIN_Sparte = din_Sparte;
      this.ProtocolType = protocolType;
    }
  }
}


--- Config.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.Config
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public static class Config
  {
    public static void SetParameter(
      SortedList<string, string> configList,
      ParameterKey key,
      object value)
    {
      if (configList == null)
        configList = new SortedList<string, string>();
      string empty = string.Empty;
      if (value != null)
        empty = value.ToString();
      string key1 = key.ToString();
      if (configList.IndexOfKey(key1) >= 0)
        configList[key1] = empty;
      else
        configList.Add(key1, empty);
    }

    public static T GetParameter<T>(SortedList<string, string> configList, ParameterKey key)
    {
      return Config.GetParameter<T>(configList, key, default (T));
    }

    public static T GetParameter<T>(
      SortedList<string, string> configList,
      ParameterKey key,
      T defaultValue)
    {
      int index = configList != null ? configList.IndexOfKey(key.ToString()) : throw new ArgumentNullException(nameof (configList));
      if (index < 0)
        return defaultValue;
      Type type1 = Nullable.GetUnderlyingType(typeof (T));
      if ((object) type1 == null)
        type1 = typeof (T);
      Type type2 = type1;
      string str = configList.Values[index];
      if (key == ParameterKey.ScanStartSerialnumber)
        str = Convert.ToUInt32(str.Insert(0, "0x"), 16).ToString();
      return type2.IsEnum ? (T) Enum.Parse(type2, str) : (T) Convert.ChangeType((object) str, type2);
    }
  }
}


--- ConfigList.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.ConfigList
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using ZENNER.CommonLibrary.Entities;

#nullable disable
namespace ZENNER.CommonLibrary
{
  [Serializable]
  public class ConfigList : 
    INotifyPropertyChanged,
    IEnumerable<KeyValuePair<string, string>>,
    IEnumerable,
    INotifyCollectionChanged
  {
    private static readonly object lockObj = new object();
    private SortedList<string, string> configList;
    private string readingChannelIdentification = "Common";

    public event PropertyChangedEventHandler PropertyChanged;

    public event NotifyCollectionChangedEventHandler CollectionChanged;

    public ConfigList() => this.configList = new SortedList<string, string>();

    public ConfigList(SortedList<string, string> configList)
      : this()
    {
      this.Reset(configList);
    }

    public string this[string key]
    {
      get => this.Get<string>(key);
      set => this.Set(key, value);
    }

    public bool ContainsKey(string key) => this.configList.ContainsKey(key);

    public IEnumerator<KeyValuePair<string, string>> GetEnumerator()
    {
      return this.configList.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator() => (IEnumerator) this.GetEnumerator();

    public static void Save(string path, ConfigList configList)
    {
      if (string.IsNullOrWhiteSpace(path))
        throw new ArgumentNullException(nameof (path));
      if (configList == null)
        throw new ArgumentNullException(nameof (configList));
      List<string> list = configList.Select<KeyValuePair<string, string>, string>((Func<KeyValuePair<string, string>, string>) (x => x.Key + "=" + x.Value)).ToList<string>();
      File.WriteAllLines(path, (IEnumerable<string>) list);
    }

    public static ConfigList Load(string path)
    {
      if (string.IsNullOrWhiteSpace(path))
        throw new ArgumentNullException(nameof (path));
      return new ConfigList(new SortedList<string, string>((IDictionary<string, string>) ((IEnumerable<string>) File.ReadAllLines(path)).ToDictionary<string, string, string>((Func<string, string>) (x => x.Split('=')[0]), (Func<string, string>) (x => x.Split('=')[1]))));
    }

    public void Reset(ConfigList newConfigList) => this.Reset(newConfigList.GetSortedList());

    public void Reset(SortedList<string, string> newConfigList)
    {
      this.configList = ConfigList.DeepCopy(newConfigList);
      foreach (string name in Enum.GetNames(typeof (ParameterKey)))
      {
        bool flag = newConfigList != null && newConfigList.ContainsKey(name);
        BrowsableAttribute attribute = (BrowsableAttribute) (TypeDescriptor.GetProperties(this.GetType())[name] ?? throw new NotImplementedException(name)).Attributes[typeof (BrowsableAttribute)];
        attribute.GetType().GetField("browsable", BindingFlags.Instance | BindingFlags.NonPublic).SetValue((object) attribute, (object) flag);
      }
      this.OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));
    }

    public SortedList<string, string> GetSortedList() => ConfigList.DeepCopy(this.configList);

    public string Name
    {
      get
      {
        StringBuilder stringBuilder = new StringBuilder();
        if (this.configList == null)
        {
          stringBuilder.Append("NotInitialised");
        }
        else
        {
          string str1 = "NoBusMode";
          SortedList<string, string> configList1 = this.configList;
          ParameterKey parameterKey = ParameterKey.BusMode;
          string key1 = parameterKey.ToString();
          int index1 = configList1.IndexOfKey(key1);
          if (index1 >= 0 && !string.IsNullOrEmpty(this.configList.Values[index1]))
            str1 = this.configList.Values[index1];
          stringBuilder.Append(str1);
          int index2 = this.configList.IndexOfKey("ID");
          if (index2 >= 0)
            stringBuilder.Append("_" + this.configList.Values[index2]);
          SortedList<string, string> configList2 = this.configList;
          parameterKey = ParameterKey.Baudrate;
          string key2 = parameterKey.ToString();
          int index3 = configList2.IndexOfKey(key2);
          if (index3 >= 0)
            stringBuilder.Append("_" + this.configList.Values[index3]);
          SortedList<string, string> configList3 = this.configList;
          parameterKey = ParameterKey.UseBreak;
          string key3 = parameterKey.ToString();
          int index4 = configList3.IndexOfKey(key3);
          if (index4 >= 0)
          {
            string str2 = this.configList.Values[index4];
            if (str2 != "None")
              stringBuilder.Append("_" + str2);
          }
          SortedList<string, string> configList4 = this.configList;
          parameterKey = ParameterKey.Wakeup;
          string key4 = parameterKey.ToString();
          int index5 = configList4.IndexOfKey(key4);
          if (index5 >= 0)
          {
            string str3 = this.configList.Values[index5];
            if (str3 != "None")
              stringBuilder.Append("_" + str3);
          }
          SortedList<string, string> configList5 = this.configList;
          parameterKey = ParameterKey.IrDaSelection;
          string key5 = parameterKey.ToString();
          int index6 = configList5.IndexOfKey(key5);
          if (index6 >= 0)
          {
            string str4 = this.configList.Values[index6];
            if (str4 != "None")
              stringBuilder.Append("_" + str4);
          }
          SortedList<string, string> configList6 = this.configList;
          parameterKey = ParameterKey.CombiHeadSelection;
          string key6 = parameterKey.ToString();
          int index7 = configList6.IndexOfKey(key6);
          if (index7 >= 0)
          {
            string str5 = this.configList.Values[index7];
            if (str5 != "None")
              stringBuilder.Append("_" + str5);
          }
          SortedList<string, string> configList7 = this.configList;
          parameterKey = ParameterKey.SelectedDeviceMBusType;
          string key7 = parameterKey.ToString();
          int index8 = configList7.IndexOfKey(key7);
          if (index8 >= 0)
          {
            string str6 = this.configList.Values[index8];
            stringBuilder.Append("_" + str6);
          }
          SortedList<string, string> configList8 = this.configList;
          parameterKey = ParameterKey.TransceiverType;
          string key8 = parameterKey.ToString();
          int index9 = configList8.IndexOfKey(key8);
          if (index9 >= 0)
          {
            string str7 = this.configList.Values[index9];
            stringBuilder.Append("_tt:" + str7);
          }
        }
        if (stringBuilder.Length == 0)
          stringBuilder.Append("NoParameters");
        return stringBuilder.ToString();
      }
    }

    [Browsable(true)]
    [ReadOnly(true)]
    [Category("ID")]
    public int ConnectionProfileID
    {
      get => this.Get<int>(ParameterKey.ConnectionProfileID);
      set => this.Set(ParameterKey.ConnectionProfileID, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("Connection type.")]
    public string Type
    {
      get => this.Get<string>(ParameterKey.Type);
      set => this.Set(ParameterKey.Type, value);
    }

    [Browsable(true)]
    [DefaultValue("COM1")]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("COM port number.")]
    public string Port
    {
      get => this.Get<string>(ParameterKey.Port);
      set => this.Set(ParameterKey.Port, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("Parity")]
    public string Parity
    {
      get => this.Get<string>(ParameterKey.Parity);
      set => this.Set(ParameterKey.Parity, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("THe Transceiver device used by communication.")]
    public string TransceiverDevice
    {
      get => this.Get<string>(ParameterKey.TransceiverDevice);
      set => this.Set(ParameterKey.TransceiverDevice, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("A unit used to measure the speed of data transfer, equal to the number of bits per second.")]
    public int Baudrate
    {
      get => this.Get<int>(ParameterKey.Baudrate);
      set => this.Set(ParameterKey.Baudrate, value);
    }

    [Browsable(true)]
    [DefaultValue(3)]
    [Category("Communication")]
    [Description("Number of repeats used by communication between master and slave.")]
    public int MaxRequestRepeat
    {
      get => this.Get<int>(ParameterKey.MaxRequestRepeat);
      set => this.Set(ParameterKey.MaxRequestRepeat, value);
    }

    [Browsable(true)]
    [DefaultValue(3600)]
    [Category("Communication")]
    [Description("")]
    public int MinoConnectPowerOffTime
    {
      get => this.Get<int>(ParameterKey.MinoConnectPowerOffTime);
      set => this.Set(ParameterKey.MinoConnectPowerOffTime, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public int MinoConnectIrDaPulseTime
    {
      get => this.Get<int>(ParameterKey.MinoConnectIrDaPulseTime);
      set => this.Set(ParameterKey.MinoConnectIrDaPulseTime, value);
    }

    [Browsable(true)]
    [DefaultValue(5)]
    [Category("Communication")]
    [Description("Cycle time used by readout in seconds.")]
    public int CycleTime
    {
      get => this.Get<int>(ParameterKey.CycleTime);
      set => this.Set(ParameterKey.CycleTime, value);
    }

    [Browsable(true)]
    [DefaultValue(false)]
    [Category("Communication")]
    [Description("")]
    public bool EchoOn
    {
      get => this.Get<bool>(ParameterKey.EchoOn);
      set => this.Set(ParameterKey.EchoOn, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public bool HardwareHandshake
    {
      get => this.Get<bool>(ParameterKey.HardwareHandshake);
      set => this.Set(ParameterKey.HardwareHandshake, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public bool TestEcho
    {
      get => this.Get<bool>(ParameterKey.TestEcho);
      set => this.Set(ParameterKey.TestEcho, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("COMserver managed by MeterVPN server.")]
    public string COMserver
    {
      get => this.Get<string>(ParameterKey.COMserver);
      set => this.Set(ParameterKey.COMserver, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public bool MinoConnectIsUSB
    {
      get => this.Get<bool>(ParameterKey.MinoConnectIsUSB);
      set => this.Set(ParameterKey.MinoConnectIsUSB, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("")]
    public string MinoConnectBaseState
    {
      get => this.Get<string>(ParameterKey.MinoConnectBaseState);
      set => this.Set(ParameterKey.MinoConnectBaseState, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public string MinoConnectTestFor
    {
      get => this.Get<string>(ParameterKey.MinoConnectTestFor);
      set => this.Set(ParameterKey.MinoConnectTestFor, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public string ForceMinoConnectState
    {
      get => this.Get<string>(ParameterKey.ForceMinoConnectState);
      set => this.Set(ParameterKey.ForceMinoConnectState, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("Bus mode used by DeviceCollector.")]
    public string BusMode
    {
      get => this.Get<string>(ParameterKey.BusMode);
      set => this.Set(ParameterKey.BusMode, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("Used handler for configuratin and reading")]
    public string UsedHandler
    {
      get => this.Get<string>(ParameterKey.UsedHandler);
      set => this.Set(ParameterKey.UsedHandler, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("AES protection key")]
    public string AES
    {
      get => this.Get<string>(ParameterKey.AES);
      set => this.Set(ParameterKey.AES, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("Wake up sequence.")]
    public string Wakeup
    {
      get => this.Get<string>(ParameterKey.Wakeup);
      set => this.Set(ParameterKey.Wakeup, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public bool UseBreak
    {
      get => this.Get<bool>(ParameterKey.UseBreak);
      set => this.Set(ParameterKey.UseBreak, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("MinoConnect IrDa selection.")]
    public string IrDaSelection
    {
      get => this.Get<string>(ParameterKey.IrDaSelection);
      set => this.Set(ParameterKey.IrDaSelection, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [TypeConverter(typeof (ConfigList.GmmSettingsConverter))]
    [Description("MinoConnect CombiHead selection.")]
    public string CombiHeadSelection
    {
      get => this.Get<string>(ParameterKey.CombiHeadSelection);
      set => this.Set(ParameterKey.CombiHeadSelection, value);
    }

    [Browsable(true)]
    [Category("M-Bus")]
    [Description("")]
    public bool KeepExistingDestinationAddress
    {
      get => this.Get<bool>(ParameterKey.KeepExistingDestinationAddress);
      set => this.Set(ParameterKey.KeepExistingDestinationAddress, value);
    }

    [Browsable(true)]
    [Category("M-Bus")]
    [Description("")]
    public bool SendFirstApplicationReset
    {
      get => this.Get<bool>(ParameterKey.SendFirstApplicationReset);
      set => this.Set(ParameterKey.SendFirstApplicationReset, value);
    }

    [Browsable(true)]
    [Category("M-Bus")]
    [Description("")]
    public bool SendFirstSND_NKE
    {
      get => this.Get<bool>(ParameterKey.SendFirstSND_NKE);
      set => this.Set(ParameterKey.SendFirstSND_NKE, value);
    }

    [Browsable(true)]
    [Category("M-Bus")]
    [Description("True will sends REQ_UD2 with 0x5B.")]
    public bool UseREQ_UD2_5B
    {
      get => this.Get<bool>(ParameterKey.UseREQ_UD2_5B);
      set => this.Set(ParameterKey.UseREQ_UD2_5B, value);
    }

    [Browsable(true)]
    [Category("M-Bus")]
    [Description("REQ_UD2 with Multi-telegram support.")]
    public bool IsMultiTelegrammEnabled
    {
      get => this.Get<bool>(ParameterKey.IsMultiTelegrammEnabled);
      set => this.Set(ParameterKey.IsMultiTelegrammEnabled, value);
    }

    [Browsable(true)]
    [DefaultValue(1)]
    [Category("M-Bus")]
    [Description("Start primary address used by scan.")]
    public byte ScanStartAddress
    {
      get => this.Get<byte>(ParameterKey.ScanStartAddress);
      set => this.Set(ParameterKey.ScanStartAddress, (int) value);
    }

    [Browsable(true)]
    [Category("M-Bus")]
    [Description("")]
    public bool ChangeInterfaceBaudrateToo
    {
      get => this.Get<bool>(ParameterKey.ChangeInterfaceBaudrateToo);
      set => this.Set(ParameterKey.ChangeInterfaceBaudrateToo, value);
    }

    [Browsable(true)]
    [Category("M-Bus")]
    [Description("")]
    public int OrganizeStartAddress
    {
      get => this.Get<int>(ParameterKey.OrganizeStartAddress);
      set => this.Set(ParameterKey.OrganizeStartAddress, value);
    }

    [Browsable(true)]
    [Category("M-Bus")]
    [Description("M-Bus primary address.")]
    public byte PrimaryAddress
    {
      get => this.Get<byte>(ParameterKey.PrimaryAddress);
      set => this.Set(ParameterKey.PrimaryAddress, (int) value);
    }

    [Browsable(true)]
    [Category("M-Bus")]
    [Description("M-Bus secondary address.")]
    public uint SecondaryAddress
    {
      get => this.Get<uint>(ParameterKey.SecondaryAddress);
      set => this.Set(ParameterKey.SecondaryAddress, value);
    }

    [Browsable(true)]
    [DefaultValue("FFFFFFF0")]
    [Category("M-Bus")]
    [Description("Start secondary address used by scan. 0fffffff = first to last. fffffff0 = last to first.")]
    public string ScanStartSerialnumber
    {
      get => this.Get<string>(ParameterKey.ScanStartSerialnumber);
      set => this.Set(ParameterKey.ScanStartSerialnumber, value);
    }

    [Browsable(true)]
    [Category("M-Bus")]
    [Description("Addressing mode used by REQ_UD2.")]
    public bool OnlySecondaryAddressing
    {
      get => this.Get<bool>(ParameterKey.OnlySecondaryAddressing);
      set => this.Set(ParameterKey.OnlySecondaryAddressing, value);
    }

    [Browsable(true)]
    [Category("M-Bus")]
    [Description("Start secondary address used by scan.")]
    public bool FastSecondaryAddressing
    {
      get => this.Get<bool>(ParameterKey.FastSecondaryAddressing);
      set => this.Set(ParameterKey.FastSecondaryAddressing, value);
    }

    [Browsable(true)]
    [Category("Timing")]
    [Description("")]
    public int TransTime_AfterBreak
    {
      get => this.Get<int>(ParameterKey.TransTime_AfterBreak);
      set => this.Set(ParameterKey.TransTime_AfterBreak, value);
    }

    [Browsable(true)]
    [Category("Timing")]
    [Description("")]
    public int TransTime_AfterOpen
    {
      get => this.Get<int>(ParameterKey.TransTime_AfterOpen);
      set => this.Set(ParameterKey.TransTime_AfterOpen, value);
    }

    [Browsable(true)]
    [Category("Timing")]
    [Description("")]
    public int TransTime_BreakTime
    {
      get => this.Get<int>(ParameterKey.TransTime_BreakTime);
      set => this.Set(ParameterKey.TransTime_BreakTime, value);
    }

    [Browsable(true)]
    [Category("Timing")]
    [Description("")]
    public int TransTime_GlobalOffset
    {
      get => this.Get<int>(ParameterKey.TransTime_GlobalOffset);
      set => this.Set(ParameterKey.TransTime_GlobalOffset, value);
    }

    [Browsable(true)]
    [Category("Timing")]
    [Description("")]
    public int RecTime_BeforFirstByte
    {
      get => this.Get<int>(ParameterKey.RecTime_BeforFirstByte);
      set => this.Set(ParameterKey.RecTime_BeforFirstByte, value);
    }

    [Browsable(true)]
    [Category("Timing")]
    [Description("")]
    public int RecTime_GlobalOffset
    {
      get => this.Get<int>(ParameterKey.RecTime_GlobalOffset);
      set => this.Set(ParameterKey.RecTime_GlobalOffset, value);
    }

    [Browsable(true)]
    [Category("Timing")]
    [Description("")]
    public int RecTime_OffsetPerBlock
    {
      get => this.Get<int>(ParameterKey.RecTime_OffsetPerBlock);
      set => this.Set(ParameterKey.RecTime_OffsetPerBlock, value);
    }

    [Browsable(true)]
    [Category("Timing")]
    [Description("")]
    public int RecTime_OffsetPerByte
    {
      get => this.Get<int>(ParameterKey.RecTime_OffsetPerByte);
      set => this.Set(ParameterKey.RecTime_OffsetPerByte, value);
    }

    [Browsable(true)]
    [Category("Timing")]
    [Description("")]
    public int RecTransTime
    {
      get => this.Get<int>(ParameterKey.RecTransTime);
      set => this.Set(ParameterKey.RecTransTime, value);
    }

    [Browsable(true)]
    [Category("Timing")]
    [Description("")]
    public int WaitBeforeRepeatTime
    {
      get => this.Get<int>(ParameterKey.WaitBeforeRepeatTime);
      set => this.Set(ParameterKey.WaitBeforeRepeatTime, value);
    }

    [Browsable(true)]
    [Category("Timing")]
    [Description("")]
    public int BreakIntervalTime
    {
      get => this.Get<int>(ParameterKey.BreakIntervalTime);
      set => this.Set(ParameterKey.BreakIntervalTime, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public string TransceiverType
    {
      get => this.Get<string>(ParameterKey.TransceiverType);
      set => this.Set(ParameterKey.TransceiverType, value);
    }

    [Browsable(true)]
    [Category("M-Bus")]
    [Description("")]
    public string SelectedDeviceMBusType
    {
      get => this.Get<string>(ParameterKey.SelectedDeviceMBusType);
      set => this.Set(ParameterKey.SelectedDeviceMBusType, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public DateTime FromTime
    {
      get => this.Get<DateTime>(ParameterKey.FromTime);
      set => this.Set(ParameterKey.FromTime, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public DateTime ToTime
    {
      get => this.Get<DateTime>(ParameterKey.ToTime);
      set => this.Set(ParameterKey.ToTime, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public bool BeepSignalOnReadResult
    {
      get => this.Get<bool>(ParameterKey.BeepSignalOnReadResult);
      set => this.Set(ParameterKey.BeepSignalOnReadResult, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public int DaKonId
    {
      get => this.Get<int>(ParameterKey.DaKonId);
      set => this.Set(ParameterKey.DaKonId, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public string LogFilePath
    {
      get => this.Get<string>(ParameterKey.LogFilePath);
      set => this.Set(ParameterKey.LogFilePath, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public string Password
    {
      get => this.Get<string>(ParameterKey.Password);
      set => this.Set(ParameterKey.Password, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public bool LogToFileEnabled
    {
      get => this.Get<bool>(ParameterKey.LogToFileEnabled);
      set => this.Set(ParameterKey.LogToFileEnabled, value);
    }

    [Browsable(true)]
    [Category("Communication")]
    [Description("")]
    public bool UseExternalKeyForReading
    {
      get => this.Get<bool>(ParameterKey.UseExternalKeyForReading);
      set => this.Set(ParameterKey.UseExternalKeyForReading, value);
    }

    public T Get<T>(ParameterKey key) => this.Get<T>(key.ToString());

    public T Get<T>(string key)
    {
      if (this.configList == null)
        return default (T);
      int index = this.configList.IndexOfKey(key);
      if (index < 0)
        return default (T);
      string str = this.configList.Values[index];
      return typeof (T).IsEnum ? (T) Enum.Parse(typeof (T), str) : (T) Convert.ChangeType((object) str, typeof (T), (IFormatProvider) CultureInfo.InvariantCulture);
    }

    private void Set(ParameterKey key, uint value) => this.Set(key, value.ToString());

    private void Set(ParameterKey key, int value) => this.Set(key, value.ToString());

    private void Set(ParameterKey key, bool value) => this.Set(key, value.ToString());

    private void Set(ParameterKey key, string value)
    {
      if (!string.IsNullOrEmpty(value))
        this.Set(key.ToString(), value.ToString());
      else
        this.Set(key.ToString(), string.Empty);
    }

    private void Set(ParameterKey key, DateTime value)
    {
      this.Set(key.ToString(), value.ToString((IFormatProvider) CultureInfo.InvariantCulture));
    }

    private void Set(string key, string value)
    {
      lock (ConfigList.lockObj)
      {
        if (this.configList == null)
          return;
        if ((key == ParameterKey.COMserver.ToString() || key == ParameterKey.Port.ToString()) && value.Contains("{"))
          value = value.Substring(0, value.IndexOf("{") - 1);
        if (this.configList.IndexOfKey(key) >= 0)
        {
          if (!(this.configList[key] != value))
            return;
          this.configList[key] = value;
          this.OnPropertyChanged(key);
        }
        else
        {
          this.configList.Add(key, value);
          this.OnPropertyChanged(key);
        }
      }
    }

    public void OnPropertyChanged(string propertyName)
    {
      if (this.PropertyChanged == null)
        return;
      this.PropertyChanged((object) this, new PropertyChangedEventArgs(propertyName));
    }

    public void OnCollectionChanged(NotifyCollectionChangedEventArgs e)
    {
      if (this.CollectionChanged == null)
        return;
      this.CollectionChanged((object) this, e);
    }

    private static SortedList<string, string> DeepCopy(SortedList<string, string> collection)
    {
      if (collection == null)
        return (SortedList<string, string>) null;
      SortedList<string, string> sortedList = new SortedList<string, string>();
      lock (ConfigList.lockObj)
      {
        using (IEnumerator<KeyValuePair<string, string>> enumerator = collection.GetEnumerator())
        {
          while (enumerator.MoveNext())
            sortedList.Add(enumerator.Current.Key, enumerator.Current.Value);
        }
      }
      return sortedList;
    }

    public bool Equal(SortedList<string, string> list)
    {
      foreach (KeyValuePair<string, string> config in this.configList)
      {
        if (!list.ContainsKey(config.Key) || list[config.Key] != config.Value)
          return false;
      }
      return true;
    }

    public static ConfigList CreateM8(string port)
    {
      return new ConfigList()
      {
        Baudrate = 9600,
        BreakIntervalTime = 10000,
        BusMode = "MBusPointToPoint",
        IrDaSelection = "RoundSide",
        MaxRequestRepeat = 3,
        MinoConnectBaseState = "IrCombiHead",
        MinoConnectIrDaPulseTime = 0,
        MinoConnectPowerOffTime = 3600,
        OnlySecondaryAddressing = false,
        Parity = "even",
        RecTime_BeforFirstByte = 1500,
        RecTime_OffsetPerBlock = 50,
        RecTransTime = 30,
        SelectedDeviceMBusType = "M8",
        TestEcho = false,
        TransceiverType = "Reader",
        TransTime_AfterBreak = 100,
        TransTime_AfterOpen = 200,
        TransTime_BreakTime = 2600,
        Type = "COM",
        Port = port,
        TransceiverDevice = "MinoConnect",
        Wakeup = "BaudrateCarrier",
        WaitBeforeRepeatTime = 200
      };
    }

    public string ReadingChannelIdentification
    {
      get => this.readingChannelIdentification;
      set
      {
        if (!(this.readingChannelIdentification != value))
          return;
        this.readingChannelIdentification = value;
        this.OnPropertyChanged(this.ReadingChannelIdentification);
      }
    }

    private class GmmSettingsConverter : TypeConverter
    {
      public override bool CanConvertFrom(ITypeDescriptorContext context, System.Type sourceType)
      {
        return context.PropertyDescriptor.Name == ParameterKey.Baudrate.ToString();
      }

      public override object ConvertFrom(
        ITypeDescriptorContext context,
        CultureInfo culture,
        object value)
      {
        string s = value as string;
        if (!(context.PropertyDescriptor.Name == ParameterKey.Baudrate.ToString()))
          return base.ConvertFrom(context, culture, value);
        int result;
        return int.TryParse(s, out result) ? (object) result : (object) 2400;
      }

      public override bool GetStandardValuesSupported(ITypeDescriptorContext context) => true;

      public override TypeConverter.StandardValuesCollection GetStandardValues(
        ITypeDescriptorContext context)
      {
        if (context.PropertyDescriptor.Name == ParameterKey.Baudrate.ToString())
        {
          List<ValueItem> availableBaudrates = Constants.GetAvailableBaudrates();
          if (availableBaudrates != null)
            return new TypeConverter.StandardValuesCollection((ICollection) availableBaudrates);
        }
        if (context.PropertyDescriptor.Name == ParameterKey.COMserver.ToString())
        {
          List<ValueItem> availableCoMserver = Constants.GetAvailableCOMserver();
          if (availableCoMserver != null)
            return new TypeConverter.StandardValuesCollection((ICollection) availableCoMserver);
        }
        if (context.PropertyDescriptor.Name == ParameterKey.BusMode.ToString())
        {
          List<ValueItem> availableBusMode = Constants.GetAvailableBusMode();
          if (availableBusMode != null)
            return new TypeConverter.StandardValuesCollection((ICollection) availableBusMode);
        }
        if (context.PropertyDescriptor.Name == ParameterKey.Type.ToString())
        {
          List<ValueItem> comConnectionType = Constants.GetAvailableAsyncComConnectionType();
          if (comConnectionType != null)
            return new TypeConverter.StandardValuesCollection((ICollection) comConnectionType);
        }
        if (context.PropertyDescriptor.Name == ParameterKey.Port.ToString())
        {
          List<ValueItem> availableComPorts = Constants.GetAvailableComPorts();
          if (availableComPorts != null)
            return new TypeConverter.StandardValuesCollection((ICollection) availableComPorts);
        }
        if (context.PropertyDescriptor.Name == ParameterKey.Parity.ToString())
        {
          List<ValueItem> availableParity = Constants.GetAvailableParity();
          if (availableParity != null)
            return new TypeConverter.StandardValuesCollection((ICollection) availableParity);
        }
        if (context.PropertyDescriptor.Name == ParameterKey.Wakeup.ToString())
        {
          List<ValueItem> availableWakeup = Constants.GetAvailableWakeup();
          if (availableWakeup != null)
            return new TypeConverter.StandardValuesCollection((ICollection) availableWakeup);
        }
        if (context.PropertyDescriptor.Name == ParameterKey.TransceiverDevice.ToString())
        {
          List<ValueItem> transceiverDevice = Constants.GetAvailableTransceiverDevice();
          if (transceiverDevice != null)
            return new TypeConverter.StandardValuesCollection((ICollection) transceiverDevice);
        }
        if (context.PropertyDescriptor.Name == ParameterKey.IrDaSelection.ToString())
        {
          List<ValueItem> availableIrDaSelection = Constants.GetAvailableIrDaSelection();
          if (availableIrDaSelection != null)
            return new TypeConverter.StandardValuesCollection((ICollection) availableIrDaSelection);
        }
        if (context.PropertyDescriptor.Name == ParameterKey.CombiHeadSelection.ToString())
        {
          List<ValueItem> combiHeadSelection = Constants.GetAvailableCombiHeadSelection();
          if (combiHeadSelection != null)
            return new TypeConverter.StandardValuesCollection((ICollection) combiHeadSelection);
        }
        if (context.PropertyDescriptor.Name == ParameterKey.MinoConnectBaseState.ToString())
        {
          List<ValueItem> connectBaseStates = Constants.GetAvailableMinoConnectBaseStates();
          if (connectBaseStates != null)
            return new TypeConverter.StandardValuesCollection((ICollection) connectBaseStates);
        }
        return base.GetStandardValues(context);
      }
    }
  }
}


--- ConfigurationParameterEnvironment.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.ConfigurationParameterEnvironment
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public enum ConfigurationParameterEnvironment
  {
    Obsolete,
    Readout,
    Info,
    Static,
    Structure,
    UI,
    Timing,
    Minomat,
    Protocol,
    Time,
    Address,
    Scanner,
  }
}


--- Constants.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.Constants
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Management;
using Windows.Devices.Bluetooth;
using Windows.Devices.Enumeration;
using ZENNER.CommonLibrary.Entities;
using ZENNER.CommonLibrary.MeterVPNServer;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public static class Constants
  {
    public static List<ValueItem> GetAvailableComPorts()
    {
      SortedList<int, ValueItem> sortedList = new SortedList<int, ValueItem>();
      using (ManagementObjectSearcher managementObjectSearcher = new ManagementObjectSearcher("root\\CIMV2", "SELECT Caption, Service, DeviceID FROM Win32_PnPEntity WHERE Caption LIKE '%(COM%' AND ConfigManagerErrorCode = 0"))
      {
        foreach (ManagementBaseObject managementBaseObject in managementObjectSearcher.Get())
        {
          string deviceID = managementBaseObject["DeviceID"].ToString();
          string service = managementBaseObject["Service"].ToString();
          string str1 = managementBaseObject["Caption"].ToString();
          int startIndex = str1.IndexOf("(") + 1;
          int num = str1.IndexOf(")");
          if (num >= 0)
          {
            string str2 = str1.Substring(startIndex, num - startIndex);
            int result;
            if (int.TryParse(str2.Replace("COM", ""), out result))
            {
              string hardwareId = Constants.TryParseHardwareID(service, deviceID);
              if (!(service == "BTHMODEM") || !(hardwareId == "000000000000"))
              {
                ValueItem valueItem = new ValueItem(str2);
                valueItem.AddAdditionalInfo(AdditionalInfoKey.HardwareType, Constants.Translate(service));
                valueItem.AddAdditionalInfo(AdditionalInfoKey.HardwareID, hardwareId);
                sortedList.Add(result, valueItem);
              }
            }
          }
        }
      }
      DeviceInformationCollection result1 = WindowsRuntimeSystemExtensions.GetAwaiter<DeviceInformationCollection>(DeviceInformation.FindAllAsync(BluetoothLEDevice.GetDeviceSelector())).GetResult();
      HashSet<string> MiConComPorts = new HashSet<string>();
      int num1 = 1000;
      foreach (DeviceInformation BLE_DeviceInfo in (IEnumerable<DeviceInformation>) result1)
      {
        BluetoothLEDevice bluetoothDevice;
        string miConBlePortName = Constants.GetMiConBLE_PortName(BLE_DeviceInfo, MiConComPorts, out bluetoothDevice);
        if (miConBlePortName != null)
        {
          ValueItem valueItem = new ValueItem(miConBlePortName);
          valueItem.AddAdditionalInfo(AdditionalInfoKey.HardwareType, "BluetoothLE");
          valueItem.AddAdditionalInfo(AdditionalInfoKey.BluetoothAddress, bluetoothDevice.BluetoothAddress.ToString("X012"));
          sortedList.Add(num1++, valueItem);
        }
      }
      return sortedList.Values.ToList<ValueItem>();
    }

    public static BluetoothLEDevice GetMiConBLE_DeviceFromPort(string port)
    {
      DeviceInformationCollection result = WindowsRuntimeSystemExtensions.GetAwaiter<DeviceInformationCollection>(DeviceInformation.FindAllAsync(BluetoothLEDevice.GetDeviceSelector())).GetResult();
      HashSet<string> MiConComPorts = new HashSet<string>();
      BluetoothLEDevice bluetoothDevice = (BluetoothLEDevice) null;
      foreach (DeviceInformation BLE_DeviceInfo in (IEnumerable<DeviceInformation>) result)
      {
        string miConBlePortName = Constants.GetMiConBLE_PortName(BLE_DeviceInfo, MiConComPorts, out bluetoothDevice);
        if (miConBlePortName != null && miConBlePortName == port)
          return bluetoothDevice;
      }
      throw new Exception("MinoConnect port not found");
    }

    private static string GetMiConBLE_PortName(
      DeviceInformation BLE_DeviceInfo,
      HashSet<string> MiConComPorts,
      out BluetoothLEDevice bluetoothDevice)
    {
      bluetoothDevice = (BluetoothLEDevice) null;
      string id = BLE_DeviceInfo.Id;
      string name = BLE_DeviceInfo.Name;
      if (!name.StartsWith("Mi"))
        return (string) null;
      string miConBlePortName;
      if (name.Contains("MinoConnectBLE"))
      {
        bluetoothDevice = WindowsRuntimeSystemExtensions.GetAwaiter<BluetoothLEDevice>(BluetoothLEDevice.FromIdAsync(id)).GetResult();
        if (bluetoothDevice == null)
          return (string) null;
        miConBlePortName = "Mi" + bluetoothDevice.BluetoothAddress.ToString("X012").Substring(9);
        if (miConBlePortName != name.Substring(0, 5))
          return (string) null;
      }
      else
      {
        if (name.Length == 6)
        {
          bluetoothDevice = WindowsRuntimeSystemExtensions.GetAwaiter<BluetoothLEDevice>(BluetoothLEDevice.FromIdAsync(id)).GetResult();
          if (bluetoothDevice == null)
            return (string) null;
          miConBlePortName = "Mi" + bluetoothDevice.BluetoothAddress.ToString("X012").Substring(8);
        }
        else
        {
          if (name.Length != 5)
            return (string) null;
          bluetoothDevice = WindowsRuntimeSystemExtensions.GetAwaiter<BluetoothLEDevice>(BluetoothLEDevice.FromIdAsync(id)).GetResult();
          if (bluetoothDevice == null)
            return (string) null;
          miConBlePortName = "Mi" + bluetoothDevice.BluetoothAddress.ToString("X012").Substring(9);
        }
        if (name != miConBlePortName)
          return (string) null;
      }
      int num = 1;
      string str = miConBlePortName;
      while (MiConComPorts.Contains(miConBlePortName))
      {
        miConBlePortName = str + "_" + num.ToString();
        ++num;
      }
      MiConComPorts.Add(miConBlePortName);
      return miConBlePortName;
    }

    private static string Translate(string service)
    {
      switch (service)
      {
        case "BTHMODEM":
          return "Bluetooth";
        case "FTSER2K":
        case "usbser":
          return "USB";
        default:
          return service;
      }
    }

    private static string TryParseHardwareID(string service, string deviceID)
    {
      try
      {
        switch (service)
        {
          case "Serial":
            int startIndex1 = deviceID.LastIndexOf("\\") + 1;
            return deviceID.Substring(startIndex1);
          case "BTHMODEM":
            int startIndex2 = deviceID.LastIndexOf("&") + 1;
            int num1 = deviceID.LastIndexOf("_");
            if (num1 >= 0)
              return deviceID.Substring(startIndex2, num1 - startIndex2);
            break;
          case "FTSER2K":
            int startIndex3 = deviceID.LastIndexOf("+") + 1;
            int num2 = deviceID.LastIndexOf("\\");
            if (num2 >= 0)
              return deviceID.Substring(startIndex3, num2 - startIndex3);
            break;
          case "usbser":
            int startIndex4 = deviceID.LastIndexOf("\\") + 1;
            return deviceID.Substring(startIndex4);
        }
      }
      catch
      {
      }
      return deviceID;
    }

    public static List<ValueItem> GetAvailableBaudrates()
    {
      return new List<ValueItem>()
      {
        new ValueItem("300"),
        new ValueItem("600"),
        new ValueItem("1200"),
        new ValueItem("2400"),
        new ValueItem("4800"),
        new ValueItem("9600"),
        new ValueItem("19200"),
        new ValueItem("38400"),
        new ValueItem("57600"),
        new ValueItem("115200")
      };
    }

    public static List<ValueItem> GetAvailableCOMserver()
    {
      List<ValueItem> availableCoMserver = new List<ValueItem>();
      availableCoMserver.Add(new ValueItem("-"));
      COMserver[] source = MeterVPN.ReadListOfCOMserver();
      if (source == null)
        return availableCoMserver;
      foreach (COMserver coMserver in (IEnumerable<COMserver>) ((IEnumerable<COMserver>) source).OrderBy<COMserver, int>((Func<COMserver, int>) (comServer => Convert.ToInt32(comServer.Cert.Replace("COMserver", string.Empty)))).OrderByDescending<COMserver, bool>((Func<COMserver, bool>) (comServer => comServer.Online)))
      {
        ValueItem valueItem = new ValueItem(coMserver.Cert)
        {
          AdditionalInfo = new Dictionary<AdditionalInfoKey, string>()
        };
        valueItem.AdditionalInfo.Add(AdditionalInfoKey.IpAddress, coMserver.IP);
        valueItem.AdditionalInfo.Add(AdditionalInfoKey.Name, coMserver.Name);
        valueItem.AdditionalInfo.Add(AdditionalInfoKey.IsOnline, coMserver.Online.ToString());
        valueItem.AdditionalInfo.Add(AdditionalInfoKey.LastSeen, coMserver.LastSeen);
        valueItem.AdditionalInfo.Add(AdditionalInfoKey.Traffic, coMserver.Traffic);
        availableCoMserver.Add(valueItem);
      }
      return availableCoMserver;
    }

    public static List<ValueItem> GetAvailableParity()
    {
      return new List<ValueItem>()
      {
        new ValueItem("no"),
        new ValueItem("odd"),
        new ValueItem("even")
      };
    }

    public static List<ValueItem> GetAvailableTestEcho()
    {
      return new List<ValueItem>()
      {
        new ValueItem(true.ToString()),
        new ValueItem(false.ToString())
      };
    }

    public static List<ValueItem> GetAvailableWakeup()
    {
      return Constants.GetEnumNames(typeof (WakeupSystem));
    }

    public static List<ValueItem> GetAvailableIrDaSelection()
    {
      return Constants.GetEnumNames(typeof (IrDaSelection));
    }

    public static List<ValueItem> GetAvailableCombiHeadSelection()
    {
      return Constants.GetEnumNames(typeof (CombiHeadSelection));
    }

    public static List<ValueItem> GetAvailableTransceiverDevice()
    {
      return Constants.GetEnumNames(typeof (TransceiverDevice));
    }

    public static List<ValueItem> GetAvailableAsyncComConnectionType()
    {
      return Constants.GetEnumNames(typeof (AsyncComConnectionType));
    }

    public static List<ValueItem> GetAvailableBusMode() => Constants.GetEnumNames(typeof (BusMode));

    public static List<ValueItem> GetAvailableMinoConnectBaseStates()
    {
      return Constants.GetEnumNames(typeof (MinoConnectBaseStates));
    }

    private static List<ValueItem> GetEnumNames(Type enumType)
    {
      List<ValueItem> enumNames = new List<ValueItem>();
      foreach (string name in Enum.GetNames(enumType))
        enumNames.Add(new ValueItem(name));
      return enumNames;
    }
  }
}


--- EnumExtensions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.EnumExtensions
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections.Generic;
using System.Linq;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public static class EnumExtensions
  {
    public static IEnumerable<Enum> GetFlags(this Enum value)
    {
      return EnumExtensions.GetFlags(value, Enum.GetValues(value.GetType()).Cast<Enum>().ToArray<Enum>());
    }

    public static IEnumerable<Enum> GetIndividualFlags(this Enum value)
    {
      return EnumExtensions.GetFlags(value, EnumExtensions.GetFlagValues(value.GetType()).ToArray<Enum>());
    }

    private static IEnumerable<Enum> GetFlags(Enum value, Enum[] values)
    {
      ulong uint64_1 = Convert.ToUInt64((object) value);
      List<Enum> source = new List<Enum>();
      for (int index = values.Length - 1; index >= 0; --index)
      {
        ulong uint64_2 = Convert.ToUInt64((object) values[index]);
        if (index != 0 || uint64_2 != 0UL)
        {
          if (((long) uint64_1 & (long) uint64_2) == (long) uint64_2)
          {
            source.Add(values[index]);
            uint64_1 -= uint64_2;
          }
        }
        else
          break;
      }
      if (uint64_1 > 0UL)
        return Enumerable.Empty<Enum>();
      if (Convert.ToUInt64((object) value) > 0UL)
        return source.Reverse<Enum>();
      return (long) uint64_1 == (long) Convert.ToUInt64((object) value) && values.Length != 0 && Convert.ToUInt64((object) values[0]) == 0UL ? ((IEnumerable<Enum>) values).Take<Enum>(1) : Enumerable.Empty<Enum>();
    }

    private static IEnumerable<Enum> GetFlagValues(Type enumType)
    {
      ulong flag = 1;
      foreach (Enum @enum in Enum.GetValues(enumType).Cast<Enum>())
      {
        Enum value = @enum;
        ulong bits = Convert.ToUInt64((object) value);
        if (bits != 0UL)
        {
          while (flag < bits)
            flag <<= 1;
          if ((long) flag == (long) bits)
            yield return value;
          value = (Enum) null;
        }
      }
    }
  }
}


--- FirmwareType.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.FirmwareType
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public enum FirmwareType
  {
    None = 0,
    C5 = 5,
    IUW = 6,
    NFC_MiCon_Connector = 7,
    WR3 = 8,
    WR4 = 9,
    Minoprotect_II = 14, // 0x0000000E
    Smoke_detector = 15, // 0x0000000F
    EDC_radio = 17, // 0x00000011
    EDC_MBus = 18, // 0x00000012
    PDC_wMBus = 19, // 0x00000013
    PDC_MBus = 20, // 0x00000014
    PDC_Radio3 = 21, // 0x00000015
    TH_sensor = 22, // 0x00000016
    EDC_SIGFOX = 23, // 0x00000017
    PDC_SIGFOX = 24, // 0x00000018
    EDC_LoRa = 25, // 0x00000019
    PDC_LoRa = 26, // 0x0000001A
    HCA_LoRa = 27, // 0x0000001B
    SD_LoRa = 28, // 0x0000001C
    micro_LoRa = 29, // 0x0000001D
    micro_wMBus = 30, // 0x0000001E
    EDC_wMBus_ST = 31, // 0x0000001F
    EDC_LoRa_470Mhz = 32, // 0x00000020
    EDC_ModBus = 33, // 0x00000021
    BootLoader = 34, // 0x00000022
    C5_LoRa = 35, // 0x00000023
    WR4_LoRa = 36, // 0x00000024
    micro_LoRa_LL = 37, // 0x00000025
    NFC_SENSUS_Connector = 38, // 0x00000026
    NFC_LoRa = 39, // 0x00000027
    TH_LoRa = 40, // 0x00000028
    EDC_LoRa_915MHz = 41, // 0x00000029
    EDC_NBIoT = 42, // 0x0000002A
    IDU = 43, // 0x0000002B
    micro_wMBus_LL = 44, // 0x0000002C
    TH_sensor_wMBus = 45, // 0x0000002D
    PDC_LoRa_915 = 46, // 0x0000002E
    UDC_LoRa_915 = 47, // 0x0000002F
    EDC_mBus_ModBus = 48, // 0x00000030
    IDUv1 = 49, // 0x00000031
    ODU = 50, // 0x00000032
    EDC_mBus_CJ188 = 51, // 0x00000033
    EDC_RS485_ModBus = 52, // 0x00000034
    EDC_RS485_CJ188 = 53, // 0x00000035
    EDC_NBIoT_LCSW = 54, // 0x00000036
    NFC_wMBus = 55, // 0x00000037
    NFC_LoRa_wMBus = 56, // 0x00000038
    EDC_NBIoT_YJSW = 57, // 0x00000039
    PDC_LoRa_868MHz_SD = 58, // 0x0000003A
    EDC_mBus_STM32 = 59, // 0x0000003B
    EDC_RS485_STM32 = 60, // 0x0000003C
    EDC_NBIoT_FSNH = 61, // 0x0000003D
    EDC_NBIoT_XM = 62, // 0x0000003E
    SD_wMBus = 63, // 0x0000003F
    CO2 = 64, // 0x00000040
    TH_LoRa_wMBus = 65, // 0x00000041
    WATER_8E_LoRa_wMBus = 66, // 0x00000042
    WATER_mBus = 67, // 0x00000043
    EDC_NBIoT_Israel = 68, // 0x00000044
    EDC_NBIoT_TaiWan = 69, // 0x00000045
    PDC_GAS = 70, // 0x00000046
    M7plus = 71, // 0x00000047
    micro_LL_radio3 = 72, // 0x00000048
    MinoConnect = 73, // 0x00000049
    EDC_LoRa_868_v3 = 74, // 0x0000004A
    EDC_LoRa_915_v2_US = 75, // 0x0000004B
    EDC_LoRa_915_v2_BR = 76, // 0x0000004C
    CommonLib = 77, // 0x0000004D
    ModulebusLib = 78, // 0x0000004E
    NfcTagLib = 79, // 0x0000004F
    RadioLib = 80, // 0x00000050
    IUW_ImpulseModule = 81, // 0x00000051
  }
}


--- FirmwareVersion.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.FirmwareVersion
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections.Generic;
using System.Globalization;

#nullable disable
namespace ZENNER.CommonLibrary
{
  [Serializable]
  public struct FirmwareVersion : IComparable
  {
    private static SortedList<ushort, string> TypeStrings = new SortedList<ushort, string>();

    static FirmwareVersion()
    {
      FirmwareVersion.TypeStrings.Add((ushort) 1, "C2 C3");
      FirmwareVersion.TypeStrings.Add((ushort) 2, "C2a");
      FirmwareVersion.TypeStrings.Add((ushort) 3, "Pulse");
      FirmwareVersion.TypeStrings.Add((ushort) 5, "C5");
      FirmwareVersion.TypeStrings.Add((ushort) 6, "IUW");
      FirmwareVersion.TypeStrings.Add((ushort) 7, "NFC_MiCon_Connector");
      FirmwareVersion.TypeStrings.Add((ushort) 8, "WR3");
      FirmwareVersion.TypeStrings.Add((ushort) 9, "WR4");
      FirmwareVersion.TypeStrings.Add((ushort) 14, "Minoprotect II");
      FirmwareVersion.TypeStrings.Add((ushort) 15, "Smoke detector");
      FirmwareVersion.TypeStrings.Add((ushort) 17, "EDC radio");
      FirmwareVersion.TypeStrings.Add((ushort) 18, "EDC M-Bus");
      FirmwareVersion.TypeStrings.Add((ushort) 19, "PDC wMBus");
      FirmwareVersion.TypeStrings.Add((ushort) 20, "PDC M-Bus");
      FirmwareVersion.TypeStrings.Add((ushort) 21, "PDC Radio3");
      FirmwareVersion.TypeStrings.Add((ushort) 22, "T&H sensor");
      FirmwareVersion.TypeStrings.Add((ushort) 23, "EDC SIGFOX");
      FirmwareVersion.TypeStrings.Add((ushort) 24, "PDC SIGFOX");
      FirmwareVersion.TypeStrings.Add((ushort) 25, "EDC LoRa");
      FirmwareVersion.TypeStrings.Add((ushort) 26, "PDC LoRa");
      FirmwareVersion.TypeStrings.Add((ushort) 27, "HCA LoRa");
      FirmwareVersion.TypeStrings.Add((ushort) 28, "SD LoRa");
      FirmwareVersion.TypeStrings.Add((ushort) 29, "micro LoRa");
      FirmwareVersion.TypeStrings.Add((ushort) 30, "micro wM-Bus");
      FirmwareVersion.TypeStrings.Add((ushort) 31, "EDC wM-Bus ST");
      FirmwareVersion.TypeStrings.Add((ushort) 32, "EDC LoRa 470 MHz");
      FirmwareVersion.TypeStrings.Add((ushort) 33, "EDC ModBus");
      FirmwareVersion.TypeStrings.Add((ushort) 34, "BootLoader");
      FirmwareVersion.TypeStrings.Add((ushort) 35, "C5 LoRa");
      FirmwareVersion.TypeStrings.Add((ushort) 36, "WR4 LoRa");
      FirmwareVersion.TypeStrings.Add((ushort) 37, "micro LoRa LL");
      FirmwareVersion.TypeStrings.Add((ushort) 38, "NFC SENSUS Connector");
      FirmwareVersion.TypeStrings.Add((ushort) 39, "NFC LoRa");
      FirmwareVersion.TypeStrings.Add((ushort) 40, "T&H LoRa");
      FirmwareVersion.TypeStrings.Add((ushort) 41, "EDC LoRa 915 MHz");
      FirmwareVersion.TypeStrings.Add((ushort) 42, "EDC NB-IoT");
      FirmwareVersion.TypeStrings.Add((ushort) 43, "IDU");
      FirmwareVersion.TypeStrings.Add((ushort) 44, "micro wM-Bus LL");
      FirmwareVersion.TypeStrings.Add((ushort) 45, "T&H sensor wMBus");
      FirmwareVersion.TypeStrings.Add((ushort) 46, "PDC LoRa 915 MHz");
      FirmwareVersion.TypeStrings.Add((ushort) 47, "UDC LoRa 915 MHz");
      FirmwareVersion.TypeStrings.Add((ushort) 48, "EDC mBus_Modbus");
      FirmwareVersion.TypeStrings.Add((ushort) 49, "IDU v1");
      FirmwareVersion.TypeStrings.Add((ushort) 50, "ODU");
      FirmwareVersion.TypeStrings.Add((ushort) 51, "EDC mBus_CJ188");
      FirmwareVersion.TypeStrings.Add((ushort) 52, "EDC RS485_Modbus");
      FirmwareVersion.TypeStrings.Add((ushort) 53, "EDC RS485_CJ188");
      FirmwareVersion.TypeStrings.Add((ushort) 54, "EDC NBIoT_LCSW");
      FirmwareVersion.TypeStrings.Add((ushort) 55, "NFC wMBus Connector");
      FirmwareVersion.TypeStrings.Add((ushort) 56, "NFC LoRa & wM-Bus Connector");
      FirmwareVersion.TypeStrings.Add((ushort) 57, "EDC NBIoT_YJSW");
      FirmwareVersion.TypeStrings.Add((ushort) 58, "PDC LoRa SD 868 MHz");
      FirmwareVersion.TypeStrings.Add((ushort) 59, "EDC MBus STM32 Controller");
      FirmwareVersion.TypeStrings.Add((ushort) 60, "EDC RS485 STM32 Controller");
      FirmwareVersion.TypeStrings.Add((ushort) 61, "EDC NBIoT_FSNH");
      FirmwareVersion.TypeStrings.Add((ushort) 62, "EDC NBIoT_XM");
      FirmwareVersion.TypeStrings.Add((ushort) 63, "SD wM-Bus");
      FirmwareVersion.TypeStrings.Add((ushort) 64, "CO2 Sensor");
      FirmwareVersion.TypeStrings.Add((ushort) 65, "T&H sensor radio(LoRa & wM-Bus)");
      FirmwareVersion.TypeStrings.Add((ushort) 66, "8E LoRa & wM-Bus");
      FirmwareVersion.TypeStrings.Add((ushort) 67, "8E M-Bus");
      FirmwareVersion.TypeStrings.Add((ushort) 68, "EDC NBIoT_Israel");
      FirmwareVersion.TypeStrings.Add((ushort) 69, "EDC NBIoT_TaiWan");
      FirmwareVersion.TypeStrings.Add((ushort) 70, "PDC GAS");
      FirmwareVersion.TypeStrings.Add((ushort) 71, "M7+");
      FirmwareVersion.TypeStrings.Add((ushort) 72, "micro radio3 LL");
      FirmwareVersion.TypeStrings.Add((ushort) 73, "MinoConnect");
      FirmwareVersion.TypeStrings.Add((ushort) 74, "EDC LoRa 868 v3");
      FirmwareVersion.TypeStrings.Add((ushort) 75, "EDC LoRa 915 v2 US");
      FirmwareVersion.TypeStrings.Add((ushort) 76, "EDC LoRa 915 v2 BR");
    }

    public uint Version { get; private set; }

    public byte Major => (byte) this.GetPartValue(VersionMasks.Major);

    public byte Minor => (byte) this.GetPartValue(VersionMasks.Minor);

    public ushort Revision => this.GetPartValue(VersionMasks.Revision);

    public ushort Type => this.GetPartValue(VersionMasks.Type);

    public ushort TypeBSL
    {
      get
      {
        if (!this.IsBootLoader)
          throw new Exception("TypeBSL only available for Bootloader firmware");
        return this.GetPartValue(VersionMasks.BSL_Type);
      }
    }

    public bool IsBootLoader => this.Type == (ushort) 34;

    public bool IsDebugVersion => (this.Version & 2147483648U) > 0U;

    public string TypeString => this.GetTypeString(this.Type);

    public string TypeBSLString => this.GetTypeString(this.TypeBSL);

    public string VersionString
    {
      get
      {
        return string.Format("{0}.{1}.{2}", (object) this.Major, (object) this.Minor, (object) this.Revision);
      }
    }

    private string GetTypeString(ushort uType)
    {
      int index = FirmwareVersion.TypeStrings.IndexOfKey(uType);
      return index >= 0 ? FirmwareVersion.TypeStrings.Values[index] : "Unknown type: " + this.Type.ToString();
    }

    private ushort GetPartValue(VersionMasks partMask)
    {
      uint partValue = (uint) ((VersionMasks) this.Version & partMask);
      for (uint index = (uint) partMask; ((int) index & 1) == 0; index >>= 1)
        partValue >>= 1;
      return (ushort) partValue;
    }

    private void SetPartValue(VersionMasks partMask, ushort theValue)
    {
      uint num = (uint) theValue;
      for (uint index = (uint) partMask; ((int) index & 1) == 0; index >>= 1)
        num <<= 1;
      if (((VersionMasks) num & ~partMask) > ~(VersionMasks.Type | VersionMasks.BSL_Type | VersionMasks.Major | VersionMasks.Debug))
        throw new Exception("Revision part out of range");
      this.Version |= num;
    }

    public override string ToString()
    {
      string str;
      if (this.IsBootLoader)
        str = string.Format("{0} {2} for {1}", (object) this.Major, (object) this.TypeBSLString, (object) this.TypeString);
      else
        str = string.Format("{0}.{1}.{2} {3}", (object) this.Major, (object) this.Minor, (object) this.Revision, (object) this.TypeString);
      if (this.IsDebugVersion)
        str += ":Debug";
      return str;
    }

    public FirmwareVersion(uint versionValue) => this.Version = versionValue;

    public FirmwareVersion(string versionString)
      : this()
    {
      this.NewFromString(versionString);
    }

    private FirmwareVersion(object version)
      : this()
    {
      switch (version)
      {
        case string _:
          this.NewFromString((string) version);
          break;
        case uint num:
          this.Version = num;
          break;
        case FirmwareVersion firmwareVersion:
          this.Version = firmwareVersion.Version;
          break;
        default:
          throw new Exception("Not supported initialisation type");
      }
    }

    private void NewFromString(string versionString)
    {
      versionString = versionString.Trim();
      this.Version = 0U;
      if (versionString.Contains("."))
      {
        try
        {
          string[] strArray = versionString.Split(new char[1]
          {
            '.'
          }, StringSplitOptions.RemoveEmptyEntries);
          if (strArray.Length == 3)
          {
            int length = strArray[2].IndexOf(' ');
            if (length > 0)
            {
              string s = strArray[2].Substring(0, length);
              int num = strArray[2].IndexOf(":Debug");
              string str;
              if (num > 0)
              {
                this.Version += 2147483648U;
                str = strArray[2].Substring(length + 1, num - length - 1);
              }
              else
                str = strArray[2].Substring(length + 1);
              int index = FirmwareVersion.TypeStrings.IndexOfValue(str);
              if (index >= 0)
              {
                this.SetPartValue(VersionMasks.Major, ushort.Parse(strArray[0]));
                this.SetPartValue(VersionMasks.Minor, ushort.Parse(strArray[1]));
                this.SetPartValue(VersionMasks.Revision, ushort.Parse(s));
                this.SetPartValue(VersionMasks.Type, FirmwareVersion.TypeStrings.Keys[index]);
                return;
              }
            }
          }
        }
        catch (Exception ex)
        {
          throw new Exception("Illegal firmware display string: " + versionString, ex);
        }
        throw new Exception("Illegal firmware display string: " + versionString);
      }
      uint result;
      if (!uint.TryParse(versionString, NumberStyles.HexNumber, (IFormatProvider) null, out result))
        throw new Exception("Illegal hex firmware version string: " + versionString);
      this.Version = result;
    }

    public int CompareTo(object compareObject)
    {
      FirmwareVersion firmwareVersion = new FirmwareVersion(compareObject);
      int num1 = this.TypeString.CompareTo(firmwareVersion.TypeString);
      byte num2;
      if (num1 == 0)
      {
        num2 = this.Major;
        num1 = num2.CompareTo(firmwareVersion.Major);
      }
      if (num1 == 0)
      {
        num2 = this.Minor;
        num1 = num2.CompareTo(firmwareVersion.Minor);
      }
      if (num1 == 0)
        num1 = this.Revision.CompareTo(firmwareVersion.Revision);
      return num1;
    }

    public static bool operator >(FirmwareVersion operand1, object operand2object)
    {
      FirmwareVersion compareObject = new FirmwareVersion(operand2object);
      return operand1.CompareTo((object) compareObject) > 0;
    }

    public static bool operator <(FirmwareVersion operand1, object operand2object)
    {
      FirmwareVersion compareObject = new FirmwareVersion(operand2object);
      return operand1.CompareTo((object) compareObject) < 0;
    }

    public static bool operator >=(FirmwareVersion operand1, object operand2object)
    {
      FirmwareVersion compareObject = new FirmwareVersion(operand2object);
      return operand1.CompareTo((object) compareObject) >= 0;
    }

    public static bool operator <=(FirmwareVersion operand1, object operand2object)
    {
      FirmwareVersion compareObject = new FirmwareVersion(operand2object);
      return operand1.CompareTo((object) compareObject) <= 0;
    }

    public static bool operator ==(FirmwareVersion operand1, object operand2object)
    {
      FirmwareVersion compareObject = new FirmwareVersion(operand2object);
      return operand1.CompareTo((object) compareObject) == 0;
    }

    public static bool operator !=(FirmwareVersion operand1, object operand2object)
    {
      FirmwareVersion compareObject = new FirmwareVersion(operand2object);
      return operand1.CompareTo((object) compareObject) != 0;
    }

    public bool IsInRange(object fromVersion, object toVersion)
    {
      return !(this < (object) new FirmwareVersion(fromVersion)) && !(this > (object) new FirmwareVersion(toVersion));
    }
  }
}


--- FixedSizedQueue`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.FixedSizedQueue`1
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System.Collections.Concurrent;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public class FixedSizedQueue<T>
  {
    private readonly object lockObj = new object();
    private ConcurrentQueue<T> q = new ConcurrentQueue<T>();

    public int Limit { get; set; }

    public void Enqueue(T obj)
    {
      this.q.Enqueue(obj);
      lock (this.lockObj)
      {
        do
          ;
        while (this.q.Count > this.Limit && this.q.TryDequeue(out T _));
      }
    }

    public T First()
    {
      T result;
      return this.q.TryDequeue(out result) ? result : default (T);
    }
  }
}


--- GMM_VersionInfo.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.GMM_VersionInfo
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections.Generic;
using System.Linq;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public class GMM_VersionInfo
  {
    private static List<GMM_VersionInfo> AllVersionInfos = new List<GMM_VersionInfo>();
    public readonly Version FromVersion;
    public readonly Version ToVersion;
    public readonly DateTime? StartDate;
    public readonly DateTime? EndDate;
    public readonly string ProductionLineKey;
    public readonly string Description;

    static GMM_VersionInfo()
    {
      GMM_VersionInfo.AllVersionInfos.Add(new GMM_VersionInfo(new Version(5, 51), (Version) null, new DateTime?(new DateTime(2019, 1, 28)), new DateTime?(new DateTime(2019, 5, 13)), "IUWB", "IUW production branch for bulk meters"));
      GMM_VersionInfo.AllVersionInfos.Add(new GMM_VersionInfo(new Version(5, 53), (Version) null, new DateTime?(new DateTime(2019, 5, 13)), new DateTime?(new DateTime(2020, 11, 5)), "IUWB", "IUW production branch for bulk meters"));
      GMM_VersionInfo.AllVersionInfos.Add(new GMM_VersionInfo(new Version(5, 71), (Version) null, new DateTime?(new DateTime(2020, 2, 26)), new DateTime?(), "IUWS", "IUW production branch for residential meters"));
      GMM_VersionInfo.AllVersionInfos.Add(new GMM_VersionInfo(new Version(5, 79), (Version) null, new DateTime?(new DateTime(2020, 11, 5)), new DateTime?(), "IUWB", "IUW production branch for bulk meters. MID"));
      GMM_VersionInfo.AllVersionInfos.Add(new GMM_VersionInfo(new Version(5, 91), (Version) null, new DateTime?(new DateTime(2021, 10, 1)), new DateTime?(), "IUW", "IUW production branch for bulk and residential meters. MID"));
    }

    public static string GetProductionLineKey(int major, int minor, bool markObsolete = true)
    {
      GMM_VersionInfo gmmVersionInfo = GMM_VersionInfo.AllVersionInfos.FirstOrDefault<GMM_VersionInfo>((Func<GMM_VersionInfo, bool>) (x => x.FromVersion.Major == major && x.FromVersion.Minor == minor && x.FromVersion.Revision == -1 && x.FromVersion.Build == -1 && x.ToVersion == (Version) null));
      if (gmmVersionInfo == null)
        return (string) null;
      string productionLineKey = gmmVersionInfo.ProductionLineKey;
      int num;
      if (markObsolete && gmmVersionInfo.EndDate.HasValue)
      {
        DateTime? endDate = gmmVersionInfo.EndDate;
        DateTime now = DateTime.Now;
        num = endDate.HasValue ? (endDate.GetValueOrDefault() < now ? 1 : 0) : 0;
      }
      else
        num = 0;
      return num != 0 ? productionLineKey + "-obsolet" : productionLineKey;
    }

    private GMM_VersionInfo(
      Version fromVersion,
      Version toVersion,
      DateTime? startDate,
      DateTime? endDate,
      string productionLineKey,
      string description)
    {
      this.FromVersion = fromVersion;
      this.ToVersion = toVersion;
      this.StartDate = startDate;
      this.EndDate = endDate;
      this.ProductionLineKey = productionLineKey;
      this.Description = description;
    }
  }
}


--- IdentificationMapping.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.IdentificationMapping
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public class IdentificationMapping
  {
    private static SortedList<string, ManufacturerDefinitions> ManufacturerList = new SortedList<string, ManufacturerDefinitions>();

    public string Manufacturer { get; private set; }

    public ulong RangeValue { get; private set; }

    public CommonTypeRange TypeRange { get; private set; }

    public LoRa_ProtocolType ProtocolType => this.TypeRange.ProtocolType;

    public char DIN_Sparte => this.TypeRange.DIN_Sparte;

    public uint ID_BCD => (uint) this.RangeValue;

    public byte FabricationBlock => (byte) (this.RangeValue >> 32);

    public byte[] OUI => IdentificationMapping.ManufacturerList[this.Manufacturer].OIU;

    public ulong OUI_value
    {
      get
      {
        byte[] oui = this.OUI;
        return (ulong) (((long) oui[0] << 40) + ((long) oui[1] << 48) + ((long) oui[2] << 56));
      }
    }

    static IdentificationMapping()
    {
      ManufacturerDefinitions manufacturerDefinitions1 = new ManufacturerDefinitions("ZRI", new byte[3]
      {
        (byte) 72,
        (byte) 182,
        (byte) 4
      });
      manufacturerDefinitions1.AddTypeRange(1088774209536UL, 1088935270809UL, '4', LoRa_ProtocolType.HeatCostAllocator);
      manufacturerDefinitions1.AddTypeRange(1084479242240UL, 1084640303513UL, '4', LoRa_ProtocolType.HeatCostAllocator);
      manufacturerDefinitions1.AddTypeRange(592705486848UL, 594745596313UL, '5', LoRa_ProtocolType.CoolingMeter);
      manufacturerDefinitions1.AddTypeRange(588410519552UL, 590450629017UL, '6', LoRa_ProtocolType.HeatMeter);
      manufacturerDefinitions1.AddTypeRange(597000454144UL, 599040563609UL, '6', LoRa_ProtocolType.HeatAndCoolingMeter);
      manufacturerDefinitions1.AddTypeRange(268435456UL, 429496729UL, '7', LoRa_ProtocolType.GasMeter);
      manufacturerDefinitions1.AddTypeRange(658740609024UL, 658884893081UL, '8', LoRa_ProtocolType.WaterMeter);
      manufacturerDefinitions1.AddTypeRange(658891603968UL, 658901670297UL, '9', LoRa_ProtocolType.WaterMeter);
      manufacturerDefinitions1.AddTypeRange(18522046464UL, 18683107737UL, 'E', LoRa_ProtocolType.EDC);
      manufacturerDefinitions1.AddTypeRange(108800245760UL, 108877420953UL, 'E', LoRa_ProtocolType.EDC);
      manufacturerDefinitions1.AddTypeRange(26843545600UL, 27004606873UL, 'E', LoRa_ProtocolType.PDC);
      manufacturerDefinitions1.AddTypeRange(489626271744UL, 492203252121UL, 'E', LoRa_ProtocolType.EDC);
      manufacturerDefinitions1.AddTypeRange(493921239040UL, 496498219417UL, 'E', LoRa_ProtocolType.EDC);
      manufacturerDefinitions1.AddTypeRange(499558383616UL, 499719444889UL, 'E', LoRa_ProtocolType.EDC);
      manufacturerDefinitions1.AddTypeRange(44291850240UL, 45526653337UL, 'E', LoRa_ProtocolType.EDC);
      manufacturerDefinitions1.AddTypeRange(507879882752UL, 508040944025UL, 'E', LoRa_ProtocolType.PDC);
      manufacturerDefinitions1.AddTypeRange(47244640256UL, 49821620633UL, 'F', LoRa_ProtocolType.SmokeDetectorRadio);
      manufacturerDefinitions1.AddTypeRange(65229815808UL, 65390877081UL, 'F', LoRa_ProtocolType.TempHumiditySensor);
      manufacturerDefinitions1.AddTypeRange(1031597457408UL, 1031758453145UL, 'F', LoRa_ProtocolType.TempHumiditySensor);
      manufacturerDefinitions1.AddTypeRange(1031758479360UL, 1031758518681UL, 'F', LoRa_ProtocolType.TempHumiditySensor);
      manufacturerDefinitions1.AddTypeRange(1035892424704UL, 1036053420441UL, 'F', LoRa_ProtocolType.TempHumiditySensor);
      manufacturerDefinitions1.AddTypeRange(1036053446656UL, 1036053485977UL, 'F', LoRa_ProtocolType.TempHumiditySensor);
      IdentificationMapping.ManufacturerList.Add("ZRI", manufacturerDefinitions1);
      ManufacturerDefinitions manufacturerDefinitions2 = new ManufacturerDefinitions("DEV", new byte[3]);
      IdentificationMapping.ManufacturerList.Add("DEV", manufacturerDefinitions2);
    }

    public IdentificationMapping(string fullSerialNumber)
    {
      this.Manufacturer = fullSerialNumber != null && fullSerialNumber.Length == 14 ? fullSerialNumber.Substring(1, 3) : throw new Exception("Illegal full serial number");
      if (this.Manufacturer != "DEV" && !IdentificationMapping.ManufacturerList.ContainsKey(this.Manufacturer))
        throw new NotSupportedException("Not supported manufacturer");
      uint result1;
      if (!uint.TryParse(fullSerialNumber.Substring(6), out result1))
        throw new NotSupportedException("Not a decimal number at last 8 digits");
      ulong result2;
      if (!ulong.TryParse(fullSerialNumber.Substring(4), NumberStyles.HexNumber, (IFormatProvider) null, out result2))
        throw new NotSupportedException("Illegal number format");
      this.RangeValue = result2;
      if (this.Manufacturer != "DEV")
      {
        this.TypeRange = result1 != 0U ? IdentificationMapping.ManufacturerList[this.Manufacturer].TypeRanges.Values.FirstOrDefault<CommonTypeRange>((Func<CommonTypeRange, bool>) (item => item.RangeMin <= this.RangeValue && item.RangeMax >= this.RangeValue)) : IdentificationMapping.ManufacturerList[this.Manufacturer].TypeRanges.Values.FirstOrDefault<CommonTypeRange>((Func<CommonTypeRange, bool>) (item => ((long) item.RangeMin & -4294967296L) == (long) this.RangeValue));
        if (this.TypeRange == null)
          throw new Exception("Number range not defined");
        if ((int) this.TypeRange.DIN_Sparte != (int) fullSerialNumber[0])
          throw new Exception("Sparte illegal for this fabrication block and number range");
      }
      else
      {
        if ((result2 & (ulong) uint.MaxValue) > 0UL)
          throw new Exception("Developer serial number has always to be 0");
        this.TypeRange = new CommonTypeRange(0UL, 0UL, fullSerialNumber[0], LoRa_ProtocolType.WaterMeter);
      }
    }

    public IdentificationMapping(ulong loRa_DevEUI)
    {
      this.RangeValue = loRa_DevEUI & 1099511627775UL;
      this.Manufacturer = (string) null;
      foreach (ManufacturerDefinitions manufacturerDefinitions in (IEnumerable<ManufacturerDefinitions>) IdentificationMapping.ManufacturerList.Values)
      {
        if ((int) manufacturerDefinitions.OIU[0] + ((int) manufacturerDefinitions.OIU[1] << 8) + ((int) manufacturerDefinitions.OIU[2] << 16) == (int) (uint) (loRa_DevEUI >> 40))
        {
          this.Manufacturer = manufacturerDefinitions.Manufacturer;
          this.TypeRange = manufacturerDefinitions.TypeRanges.Values.FirstOrDefault<CommonTypeRange>((Func<CommonTypeRange, bool>) (item => item.RangeMin <= this.RangeValue && item.RangeMax >= this.RangeValue));
          if (this.TypeRange == null)
            throw new Exception("Number range not defined");
          break;
        }
      }
      if (this.Manufacturer == null)
        throw new NotSupportedException("Not supported manufacturer");
    }

    public IdentificationMapping(byte[] loRa_DevEUI)
      : this(BitConverter.ToUInt64(loRa_DevEUI, 0))
    {
      if (loRa_DevEUI == null || loRa_DevEUI.Length != 8)
        throw new Exception("Illegal DevEUI");
    }

    public ulong GetAsDevEUI_Value() => this.OUI_value + this.RangeValue;

    public string GetAsDevEUI_string() => this.GetAsDevEUI_Value().ToString("X016");

    public byte[] GetAsDevEUI_bytes() => BitConverter.GetBytes(this.GetAsDevEUI_Value());

    public string GetAsFullSerialNumber()
    {
      return this.TypeRange.DIN_Sparte.ToString() + this.Manufacturer + this.RangeValue.ToString("X010");
    }
  }
}


--- IPort.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.IPort
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public interface IPort : IReadoutConfig
  {
    bool IsOpen { get; }

    void Open();

    void Close();

    void Dispose();

    void ForceWakeup();

    bool DiscardInBuffer();

    void Write(byte[] request);

    byte[] ReadHeader(int count);

    byte[] ReadEnd(int count);

    byte[] ReadExisting();

    event EventHandler<byte[]> OnRequest;

    event EventHandler<byte[]> OnResponse;
  }
}


--- IPrintable.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.IPrintable
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public interface IPrintable
  {
    string Print(int spaces = 0);
  }
}


--- IrDaSelection.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.IrDaSelection
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public enum IrDaSelection
  {
    None,
    DoveTailSide,
    RoundSide,
  }
}


--- IReadoutConfig.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.IReadoutConfig
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public interface IReadoutConfig
  {
    void SetReadoutConfiguration(ConfigList configList);

    ConfigList GetReadoutConfiguration();
  }
}


--- LoRa_ProtocolType.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.LoRa_ProtocolType
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public enum LoRa_ProtocolType
  {
    SmokeDetectorRadio,
    GasMeter,
    TempHumiditySensor,
    PDC,
    EDC,
    WaterMeter,
    HeatMeter,
    CoolingMeter,
    HeatAndCoolingMeter,
    HeatCostAllocator,
  }
}


--- ManufacturerDefinitions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.ManufacturerDefinitions
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System.Collections.Generic;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public class ManufacturerDefinitions
  {
    public string Manufacturer;
    public byte[] OIU;
    public SortedList<ulong, CommonTypeRange> TypeRanges;

    public ManufacturerDefinitions(string manufacturer, byte[] oui)
    {
      this.Manufacturer = manufacturer;
      this.OIU = oui;
      this.TypeRanges = new SortedList<ulong, CommonTypeRange>();
    }

    public void AddTypeRange(
      ulong rangeMin,
      ulong rangeMax,
      char din_Sparte,
      LoRa_ProtocolType deviceType)
    {
      this.TypeRanges.Add(rangeMin, new CommonTypeRange(rangeMin, rangeMax, din_Sparte, deviceType));
    }
  }
}


--- MeterVPN.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.MeterVPN
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Net;
using System.Net.Sockets;
using System.ServiceModel;
using System.ServiceModel.Channels;
using ZENNER.CommonLibrary.MeterVPNServer;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public static class MeterVPN
  {
    public static COMserver[] ReadListOfCOMserver()
    {
      if (!MeterVPN.Ping())
        return (COMserver[]) null;
      MeterVPNPortClient meterVpnPortClient = new MeterVPNPortClient((Binding) new BasicHttpBinding(), new EndpointAddress("http://1.0.0.1/server.php"));
      WebRequest.DefaultWebProxy = (IWebProxy) null;
      return meterVpnPortClient.GetCOMservers("test");
    }

    public static bool Ping()
    {
      using (Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp))
      {
        IPEndPoint remoteEP = new IPEndPoint(IPAddress.Parse("1.0.0.1"), 80);
        if (!socket.BeginConnect((EndPoint) remoteEP, (AsyncCallback) null, (object) null).AsyncWaitHandle.WaitOne(500, false))
          return false;
      }
      return true;
    }
  }
}


--- MinoConnectBaseStates.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.MinoConnectBaseStates
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public enum MinoConnectBaseStates
  {
    off,
    IrCombiHead,
    RS232,
    RS232_3V,
    RS232_7V,
    RS485,
    RS485_3V,
    RS485_7V,
    Radio2Receive,
    Radio3Receive,
    WirelessMBus,
    NDC_MiCon_Module,
    ZIN_CombiHead,
    undefined,
  }
}


--- NLogFileRecord.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.NLogFileRecord
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public class NLogFileRecord
  {
    public int Line { get; internal set; }

    public DateTime LogTime { get; internal set; }

    public int ThreadID { get; internal set; }

    public string LoggerName { get; internal set; }

    public string Level { get; internal set; }

    public string Message { get; internal set; }
  }
}


--- NLogSupport.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.NLogSupport
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using NLog;
using NLog.Config;
using NLog.Layouts;
using NLog.Targets;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public static class NLogSupport
  {
    private const string ReportTokensUsed = "{ \"Report\":";
    private const string NLogStartToken = "\"NLOG\":[";
    private const string ReportEndToken = "]}";
    public static string InstallationFolder;

    public static string NLogOutputFilePath { get; private set; }

    public static string NLogConfigFilePath { get; private set; }

    public static string[] NLogSetupFilePaths { get; private set; }

    public static string[] NLogSetupFileNames { get; private set; }

    public static string ActiveConfigFileName { get; private set; }

    public static string TemporaryConfigFileName { get; private set; }

    static NLogSupport()
    {
      NLogSupport.NLogOutputFilePath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData), "ZENNER", "GMM", "LoggData", "NLogOutput.json");
      NLogSupport.InstallationFolder = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
      NLogSupport.NLogConfigFilePath = Path.Combine(NLogSupport.InstallationFolder, "NLog.config");
      NLogSupport.NLogSetupFilePaths = Directory.GetFiles(NLogSupport.InstallationFolder, "NLog_*.config");
      Array.Sort<string>(NLogSupport.NLogSetupFilePaths);
      NLogSupport.NLogSetupFileNames = new string[NLogSupport.NLogSetupFilePaths.Length];
      for (int index = 0; index < NLogSupport.NLogSetupFilePaths.Length; ++index)
        NLogSupport.NLogSetupFileNames[index] = Path.GetFileNameWithoutExtension(NLogSupport.NLogSetupFilePaths[index]);
      NLogSupport.GetActiveNLogConfigurationFileName();
    }

    public static string GetActiveNLogConfigurationFileName()
    {
      byte[] second = File.ReadAllBytes(NLogSupport.NLogConfigFilePath);
      for (int index = 0; index < NLogSupport.NLogSetupFilePaths.Length; ++index)
      {
        if (((IEnumerable<byte>) File.ReadAllBytes(NLogSupport.NLogSetupFilePaths[index])).SequenceEqual<byte>((IEnumerable<byte>) second))
        {
          NLogSupport.ActiveConfigFileName = NLogSupport.NLogSetupFileNames[index];
          NLogSupport.TemporaryConfigFileName = string.Empty;
          return NLogSupport.ActiveConfigFileName;
        }
      }
      return string.Empty;
    }

    public static string GetCurrentNLogSetup()
    {
      if (!string.IsNullOrEmpty(NLogSupport.TemporaryConfigFileName))
        return NLogSupport.TemporaryConfigFileName;
      return !string.IsNullOrEmpty(NLogSupport.ActiveConfigFileName) ? NLogSupport.ActiveConfigFileName : string.Empty;
    }

    public static bool ChangeDefaultToSetupFile(string fileName)
    {
      try
      {
        if (!string.IsNullOrEmpty(fileName))
        {
          if (fileName == NLogSupport.ActiveConfigFileName)
            return true;
          string str = Path.Combine(NLogSupport.InstallationFolder, fileName + ".config");
          if (File.Exists(str))
          {
            File.Copy(str, NLogSupport.NLogConfigFilePath, true);
            NLogSupport.ActiveConfigFileName = fileName;
            NLogSupport.TemporaryConfigFileName = string.Empty;
            return true;
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool ChangeTemporaryToSetupFile(string fileName)
    {
      try
      {
        if (!string.IsNullOrEmpty(fileName))
        {
          if (fileName == NLogSupport.ActiveConfigFileName || fileName == NLogSupport.TemporaryConfigFileName)
            return true;
          string str = Path.Combine(NLogSupport.InstallationFolder, fileName + ".config");
          if (File.Exists(str))
          {
            LogManager.LoadConfiguration(str);
            LogManager.ReconfigExistingLoggers();
            NLogSupport.ActiveConfigFileName = string.Empty;
            NLogSupport.TemporaryConfigFileName = fileName;
            return true;
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static void GarantLogFileAndLoggerRule(
      string filename,
      string logger,
      NLog.LogLevel minLevel)
    {
      string path2 = Path.Combine("ZENNER", "GMM");
      string path1 = Path.Combine(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData), path2), "LoggData");
      if (LogManager.Configuration == null)
        LogManager.Configuration = new LoggingConfiguration();
      FileTarget fileTarget = (FileTarget) null;
      foreach (Target allTarget in LogManager.Configuration.AllTargets)
      {
        if (allTarget is FileTarget)
        {
          fileTarget = (FileTarget) allTarget;
          break;
        }
      }
      if (fileTarget == null)
      {
        fileTarget = new FileTarget();
        fileTarget.FileName = (Layout) Path.Combine(path1, filename);
        fileTarget.KeepFileOpen = true;
        LogManager.Configuration.AddTarget("AutoGeneratedFile", (Target) fileTarget);
      }
      LoggingRule loggingRule1 = (LoggingRule) null;
      foreach (LoggingRule loggingRule2 in (IEnumerable<LoggingRule>) LogManager.Configuration.LoggingRules)
      {
        if (loggingRule2.NameMatches(logger) && loggingRule2.Targets.Contains((Target) fileTarget))
        {
          loggingRule1 = loggingRule2;
          break;
        }
      }
      if (loggingRule1 == null)
        LogManager.Configuration.LoggingRules.Add(new LoggingRule(logger, minLevel, (Target) fileTarget));
      LogManager.ReconfigExistingLoggers();
      LogManager.EnableLogging();
    }

    public static void TestBenchTraceActivate()
    {
      string[] strArray = new string[4]
      {
        "PlugInLoader",
        "LicenseManager",
        "Runtime",
        "OnlineTranslator"
      };
      try
      {
        if (File.Exists(NLogSupport.NLogOutputFilePath))
          File.Delete(NLogSupport.NLogOutputFilePath);
        LogManager.Configuration.LoggingRules.Clear();
        Target target1 = LogManager.Configuration.AllTargets.FirstOrDefault<Target>((Func<Target, bool>) (x => x.Name == "File"));
        Target target2 = LogManager.Configuration.AllTargets.FirstOrDefault<Target>((Func<Target, bool>) (x => x.Name == "UdpOutlet"));
        LoggingRule loggingRule1 = new LoggingRule()
        {
          LoggerNamePattern = "MiConPollingThread",
          Final = true
        };
        loggingRule1.EnableLoggingForLevel(NLog.LogLevel.Trace);
        LogManager.Configuration.LoggingRules.Add(loggingRule1);
        LoggingRule loggingRule2 = new LoggingRule()
        {
          LoggerNamePattern = "CommunicationByMinoConnect",
          Final = true
        };
        loggingRule2.EnableLoggingForLevel(NLog.LogLevel.Trace);
        LogManager.Configuration.LoggingRules.Add(loggingRule2);
        foreach (string str in strArray)
        {
          LoggingRule loggingRule3 = new LoggingRule()
          {
            LoggerNamePattern = str,
            Final = true
          };
          loggingRule3.EnableLoggingForLevels(NLog.LogLevel.Trace, NLog.LogLevel.Fatal);
          LogManager.Configuration.LoggingRules.Add(loggingRule3);
        }
        if (target1 != null)
          LogManager.Configuration.LoggingRules.Add(new LoggingRule("*", NLog.LogLevel.Trace, target1));
        if (target2 != null)
          LogManager.Configuration.LoggingRules.Add(new LoggingRule("*", NLog.LogLevel.Trace, target2));
        LogManager.Configuration.Reload();
      }
      catch
      {
      }
    }

    public static void TestBenchTraceStop(string filePath)
    {
      try
      {
        NLogSupport.SaveLogFile(filePath);
        LogManager.LoadConfiguration(NLogSupport.NLogConfigFilePath);
        LogManager.ReconfigExistingLoggers();
      }
      catch
      {
      }
    }

    public static bool IsLogFileAvailable() => File.Exists(NLogSupport.NLogOutputFilePath);

    public static void SaveLogFile(string filePath)
    {
      if (!File.Exists(NLogSupport.NLogOutputFilePath))
        return;
      File.Copy(NLogSupport.NLogOutputFilePath, filePath, true);
    }

    public static void DeleteNLogOutputFile()
    {
      if (!File.Exists(NLogSupport.NLogOutputFilePath))
        return;
      File.Delete(NLogSupport.NLogOutputFilePath);
    }

    public static void AddNlogOutputfileContent(StringBuilder fileContent)
    {
      try
      {
        fileContent.Insert(0, "{ \"Report\":" + Environment.NewLine);
        fileContent.AppendLine(",");
        fileContent.AppendLine("\"NLOG\":[");
        if (File.Exists(NLogSupport.NLogOutputFilePath))
        {
          using (StreamReader streamReader = new StreamReader(NLogSupport.NLogOutputFilePath))
          {
            int num = 0;
            string str;
            while ((str = streamReader.ReadLine()) != null)
            {
              if (streamReader.EndOfStream)
                fileContent.AppendLine(str);
              else
                fileContent.AppendLine(str + ",");
              ++num;
            }
            streamReader.Close();
          }
        }
        fileContent.AppendLine("]}");
      }
      catch
      {
      }
    }

    public static List<NLogFileRecord> GetNLogOutputfileRecords()
    {
      return !File.Exists(NLogSupport.NLogOutputFilePath) ? new List<NLogFileRecord>() : NLogSupport.GetNLogRecords(File.ReadAllText(NLogSupport.NLogOutputFilePath));
    }

    public static List<NLogFileRecord> GetNLogOutputfileRecords(string filePath)
    {
      return !File.Exists(filePath) ? new List<NLogFileRecord>() : NLogSupport.GetNLogRecords(File.ReadAllText(filePath));
    }

    public static List<NLogFileRecord> GetNLogRecords(string fileContent)
    {
      List<NLogFileRecord> nlogRecords = new List<NLogFileRecord>();
      using (StringReader stringReader = new StringReader(fileContent))
      {
        int num1 = 0;
        bool flag = true;
        while (true)
        {
          string str1;
          int num2;
          int length1;
          do
          {
            do
            {
              ++num1;
              str1 = stringReader.ReadLine();
              if (str1 != null)
              {
                if (num1 == 1 && str1.Trim() == "{ \"Report\":")
                  flag = false;
                if (flag)
                {
                  num2 = str1.IndexOf("{");
                  length1 = str1.IndexOf("}") - num2 - 1;
                  if (num2 >= 0 && length1 >= 5)
                    goto label_9;
                }
                else
                  goto label_5;
              }
              else
                break;
            }
            while (!str1.Contains("]}"));
            goto label_27;
label_5:;
          }
          while (!str1.Contains("\"NLOG\":["));
          flag = true;
          continue;
label_9:
          str1.Substring(num2 + 1, length1);
          NLogFileRecord nlogFileRecord = new NLogFileRecord();
          nlogFileRecord.Line = num1;
          int startIndex = num2 + 1;
          while (true)
          {
            int num3 = str1.IndexOf('"', startIndex);
            int num4 = str1.IndexOf('"', num3 + 1);
            int length2 = num4 - num3 - 1;
            if (length2 >= 1)
            {
              string str2 = str1.Substring(num3 + 1, length2);
              if (str1[num4 + 1] == ':')
              {
                int num5 = str1.IndexOf('"', num4 + 2);
                int num6 = str1.IndexOf('"', num5 + 1);
                int length3 = num6 - num5 - 1;
                if (length3 >= 0)
                {
                  string s = str1.Substring(num5 + 1, length3);
                  try
                  {
                    switch (str2)
                    {
                      case "time":
                        string[] strArray1 = s.Split(' ');
                        string[] strArray2 = strArray1[0].Split('-');
                        DateTime dateTime = new DateTime(int.Parse(strArray2[0]), int.Parse(strArray2[1]), int.Parse(strArray2[2]));
                        nlogFileRecord.LogTime = dateTime.Add(TimeSpan.Parse(strArray1[1]));
                        break;
                      case "logger":
                        nlogFileRecord.LoggerName = s;
                        break;
                      case "threadid":
                        nlogFileRecord.ThreadID = int.Parse(s);
                        break;
                      case "level":
                        nlogFileRecord.Level = s;
                        break;
                      case "message":
                        nlogFileRecord.Message = s;
                        break;
                    }
                  }
                  catch
                  {
                  }
                  startIndex = num6 + 1;
                }
                else
                  break;
              }
              else
                break;
            }
            else
              break;
          }
          nlogRecords.Add(nlogFileRecord);
        }
      }
label_27:
      return nlogRecords;
    }
  }
}


--- NotepadHelper.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.NotepadHelper
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public static class NotepadHelper
  {
    [DllImport("user32.dll")]
    private static extern int SetWindowText(IntPtr hWnd, string text);

    [DllImport("user32.dll")]
    private static extern IntPtr FindWindowEx(
      IntPtr hwndParent,
      IntPtr hwndChildAfter,
      string lpszClass,
      string lpszWindow);

    [DllImport("User32.dll")]
    private static extern int SendMessage(IntPtr hWnd, int uMsg, int wParam, string lParam);

    public static void ShowMessage(string message = null, string title = null)
    {
      Process process = Process.Start(new ProcessStartInfo("notepad.exe"));
      if (process == null)
        return;
      process.WaitForInputIdle();
      if (!string.IsNullOrEmpty(title))
        NotepadHelper.SetWindowText(process.MainWindowHandle, title);
      if (!string.IsNullOrEmpty(message))
        NotepadHelper.SendMessage(NotepadHelper.FindWindowEx(process.MainWindowHandle, new IntPtr(0), "Edit", (string) null), 12, 0, message);
    }
  }
}


--- ParameterKey.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.ParameterKey
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public enum ParameterKey
  {
    BusMode,
    Type,
    COMserver,
    Port,
    Parity,
    Baudrate,
    UseBreak,
    MinoConnectPowerOffTime,
    TransceiverDevice,
    ForceMinoConnectState,
    IrDaSelection,
    HardwareHandshake,
    EchoOn,
    TestEcho,
    RecTime_BeforFirstByte,
    RecTime_OffsetPerByte,
    RecTime_GlobalOffset,
    TransTime_GlobalOffset,
    RecTransTime,
    TransTime_BreakTime,
    TransTime_AfterOpen,
    TransTime_AfterBreak,
    WaitBeforeRepeatTime,
    BreakIntervalTime,
    MinoConnectTestFor,
    Wakeup,
    MinoConnectIsUSB,
    MinoConnectIrDaPulseTime,
    RecTime_OffsetPerBlock,
    MinoConnectBaseState,
    PrimaryAddress,
    SecondaryAddress,
    UseREQ_UD2_5B,
    IsMultiTelegrammEnabled,
    MaxRequestRepeat,
    OnlySecondaryAddressing,
    ScanStartAddress,
    ScanStartSerialnumber,
    FastSecondaryAddressing,
    KeepExistingDestinationAddress,
    SendFirstApplicationReset,
    SendFirstSND_NKE,
    OrganizeStartAddress,
    ChangeInterfaceBaudrateToo,
    CycleTime,
    ConnectionProfileID,
    TransceiverType,
    SelectedDeviceMBusType,
    FromTime,
    ToTime,
    BeepSignalOnReadResult,
    DaKonId,
    LogFilePath,
    LogToFileEnabled,
    Password,
    UseExternalKeyForReading,
    UsedHandler,
    AES,
    CombiHeadSelection,
  }
}


--- ProgressArg.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.ProgressArg
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public sealed class ProgressArg
  {
    public double ProgressPercentage { get; private set; }

    public string Message { get; private set; }

    public object Tag { get; private set; }

    public ProgressArg(double progressPercentage, string message)
    {
      this.ProgressPercentage = progressPercentage;
      this.Message = message;
    }

    public ProgressArg(double progressPercentage, string message, object tag)
    {
      this.ProgressPercentage = progressPercentage;
      this.Message = message;
      this.Tag = tag;
    }
  }
}


--- ProgressHandler.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.ProgressHandler
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public sealed class ProgressHandler : Progress<ProgressArg>
  {
    private int index;
    private List<double> parts;
    private string baseMessage;
    private string baseMessageOwner;
    private bool ReportLoggerTimesUsed = false;
    private Stopwatch reportStopwatch;
    private uint markCount;
    private List<ProgressSplitArg> splitInfo;
    public List<ProgressTimeArg> ReportLogger;

    public string BaseMessage
    {
      get => this.baseMessage;
      [MethodImpl(MethodImplOptions.NoInlining)] set
      {
        string name = new StackFrame(1, true).GetMethod().Name;
        if (string.IsNullOrEmpty(this.baseMessage))
        {
          this.baseMessage = value;
          this.baseMessageOwner = name;
        }
        else
        {
          if (this.baseMessageOwner != name)
            return;
          this.baseMessage = value;
        }
      }
    }

    public ProgressHandler(Action<ProgressArg> handler)
      : base(handler)
    {
      this.parts = new List<double>((IEnumerable<double>) new double[1]
      {
        100.0
      });
      this.index = 0;
      this.baseMessage = "";
    }

    public override string ToString()
    {
      StringBuilder stringBuilder = new StringBuilder();
      if (this.ReportLogger != null)
      {
        stringBuilder.AppendLine("*** Progress report log ***");
        foreach (ProgressTimeArg progressTimeArg in this.ReportLogger)
          stringBuilder.AppendLine(progressTimeArg.ToString());
        stringBuilder.AppendLine();
        stringBuilder.AppendLine("*** Progress logger time string ***");
        stringBuilder.AppendLine(this.GetReportLoggerTimesString());
        return stringBuilder.ToString();
      }
      if (this.splitInfo == null)
        return string.Format("{0} of {1}", (object) (this.index + 1), (object) this.parts.Count);
      stringBuilder.AppendLine("*** Split information ***");
      foreach (ProgressSplitArg progressSplitArg in this.splitInfo)
        stringBuilder.AppendLine(progressSplitArg.ToString());
      return stringBuilder.ToString();
    }

    public void Reset(string message) => this.Reset(1, message);

    public void Reset(int newParts = 1, string message = "")
    {
      if (this.ReportLoggerTimesUsed)
      {
        if (message.Length <= 0)
          return;
        this.Report(message);
      }
      else
      {
        this.splitInfo = (List<ProgressSplitArg>) null;
        if (this.reportStopwatch != null)
        {
          this.reportStopwatch.Reset();
          this.reportStopwatch = (Stopwatch) null;
        }
        if (newParts <= 0)
          newParts = 1;
        this.parts.Clear();
        this.baseMessage = "";
        this.index = 0;
        double num = 100.0 / (double) newParts;
        for (int index = 0; index < newParts; ++index)
          this.parts.Add(num);
        this.ReportProgressArg(new ProgressArg(0.0, message));
      }
    }

    public void Split(int subParts)
    {
      if (this.ReportLoggerTimesUsed || subParts <= 0)
        return;
      double num = this.parts[this.index] / (double) subParts;
      List<double> collection = new List<double>(subParts);
      for (int index = 0; index < subParts; ++index)
        collection.Add(num);
      this.parts.RemoveAt(this.index);
      this.parts.InsertRange(this.index, (IEnumerable<double>) collection);
    }

    public void SplitByCountPlusInit(int subPartsCount)
    {
      if (this.ReportLoggerTimesUsed || subPartsCount <= 0)
        return;
      double part = this.parts[this.index];
      double num1 = part / 100.0;
      double num2 = (part - num1) / (double) subPartsCount;
      List<double> collection = new List<double>(subPartsCount + 1);
      collection.Add(num1);
      for (int index = 0; index < subPartsCount; ++index)
        collection.Add(num2);
      this.parts.RemoveAt(this.index);
      this.parts.InsertRange(this.index, (IEnumerable<double>) collection);
    }

    public void Split(double[] subParts)
    {
      if (this.ReportLoggerTimesUsed || subParts == null || subParts.Length == 0)
        return;
      double part = this.parts[this.index];
      double a = 0.0;
      List<double> collection = new List<double>(subParts.Length);
      foreach (double subPart in subParts)
      {
        a += subPart;
        collection.Add(part / 100.0 * subPart);
      }
      if (Math.Round(a) != 100.0)
        throw new ArgumentOutOfRangeException("The sum of the sub parts is not 100%!");
      this.parts.RemoveAt(this.index);
      this.parts.InsertRange(this.index, (IEnumerable<double>) collection);
    }

    public void SplitScaled(double[] subParts)
    {
      if (this.ReportLoggerTimesUsed || subParts == null || subParts.Length == 0)
        return;
      double part = this.parts[this.index];
      double num1 = 0.0;
      List<double> doubleList = new List<double>(subParts.Length);
      foreach (double subPart in subParts)
      {
        num1 += subPart;
        doubleList.Add(part / 100.0 * subPart);
      }
      double num2 = 100.0 / num1;
      double[] subParts1 = new double[subParts.Length];
      for (int index = 0; index < subParts.Length; ++index)
        subParts1[index] = subParts[index] * num2;
      this.Split(subParts1);
    }

    public void Report(string message = "", object tag = null)
    {
      double progressPercentage;
      if (this.ReportLoggerTimesUsed)
      {
        if (this.reportStopwatch != null || this.splitInfo == null)
        {
          progressPercentage = (this.index & 1) != 0 ? 66.0 : 33.0;
          ++this.index;
        }
        else if (this.index >= this.splitInfo.Count)
          progressPercentage = 100.0;
        else if ((int) this.splitInfo[this.index].ReportMark == (int) this.markCount)
        {
          progressPercentage = this.splitInfo[this.index].ProgressPercentage;
          ++this.index;
        }
        else if (this.splitInfo[this.index].ReportMark > this.markCount)
        {
          progressPercentage = this.index <= 0 ? this.splitInfo[this.index].ProgressPercentage : this.splitInfo[this.index - 1].ProgressPercentage;
        }
        else
        {
          do
          {
            ++this.index;
            if (this.index >= this.splitInfo.Count)
              goto label_9;
          }
          while (this.splitInfo[this.index].ReportMark < this.markCount);
          goto label_11;
label_9:
          progressPercentage = 100.0;
          goto label_13;
label_11:
          progressPercentage = this.splitInfo[this.index].ProgressPercentage;
label_13:;
        }
      }
      else
      {
        double a = 0.0;
        for (int index = 0; index <= this.index; ++index)
          a += this.parts[index];
        progressPercentage = Math.Ceiling(a);
        if (this.parts.Count > this.index + 1)
          ++this.index;
      }
      if (tag == null)
        this.ReportProgressArg(new ProgressArg(progressPercentage, (this.baseMessage + " " + message).Trim()));
      else
        this.ReportProgressArg(new ProgressArg(progressPercentage, (this.baseMessage + " " + message).Trim(), tag));
    }

    public void Report(int progress, string message = "")
    {
      this.ReportProgressArg(new ProgressArg((double) progress, (this.baseMessage + " " + message).Trim()));
    }

    private void ReportProgressArg(ProgressArg progressArg)
    {
      if (this.reportStopwatch != null)
      {
        this.ReportLogger.Add(new ProgressTimeArg(this.reportStopwatch.ElapsedMilliseconds, progressArg.Message, progressArg.Tag));
        this.reportStopwatch.Restart();
      }
      this.OnReport(progressArg);
    }

    public void SplitByReportLoggerTimesString(string recordLoggerTimesString = null)
    {
      this.ReportLoggerTimesUsed = true;
      this.index = 0;
      this.markCount = 0U;
      if (string.IsNullOrEmpty(recordLoggerTimesString))
      {
        this.ReportLogger = new List<ProgressTimeArg>();
        this.reportStopwatch = new Stopwatch();
      }
      else
      {
        this.ReportLogger = (List<ProgressTimeArg>) null;
        if (this.reportStopwatch != null)
          this.reportStopwatch.Reset();
        this.reportStopwatch = (Stopwatch) null;
        string[] strArray = recordLoggerTimesString.Split(new char[1]
        {
          ';'
        }, StringSplitOptions.RemoveEmptyEntries);
        if (strArray.Length < 2)
          return;
        StringBuilder stringBuilder = new StringBuilder();
        uint num1 = 0;
        uint num2 = 0;
        this.splitInfo = new List<ProgressSplitArg>();
        foreach (string s in strArray)
        {
          if (s.StartsWith("M"))
          {
            ++num2;
            int num3 = int.Parse(s.Substring(1));
            if ((long) num2 != (long) num3)
              throw new Exception("Illegal mark number: " + s);
          }
          else
          {
            uint num4 = uint.Parse(s);
            num1 += num4;
            this.splitInfo.Add(new ProgressSplitArg()
            {
              ProgressPercentage = (double) num4,
              ReportMark = num2
            });
          }
        }
        double num5 = 100.0 / (double) num1;
        double num6 = 0.0;
        foreach (ProgressSplitArg progressSplitArg in this.splitInfo)
        {
          num6 += progressSplitArg.ProgressPercentage * num5;
          progressSplitArg.ProgressPercentage = num6;
        }
      }
    }

    public string GetReportLoggerTimesString()
    {
      this.ReportLoggerTimesUsed = false;
      this.index = 0;
      if (this.ReportLogger == null || this.ReportLogger.Count < 2)
        return (string) null;
      if (this.reportStopwatch != null)
      {
        this.reportStopwatch.Reset();
        this.reportStopwatch = (Stopwatch) null;
      }
      StringBuilder stringBuilder = new StringBuilder();
      foreach (ProgressTimeArg progressTimeArg in this.ReportLogger)
      {
        if (progressTimeArg.ReportMarkCounter > 0U)
          stringBuilder.Append("M" + progressTimeArg.ReportMarkCounter.ToString());
        else if (progressTimeArg.PrograssTime_ms > 0L)
          stringBuilder.Append(progressTimeArg.PrograssTime_ms.ToString());
        else
          stringBuilder.Append('1');
        stringBuilder.Append(';');
      }
      --stringBuilder.Length;
      stringBuilder.AppendLine();
      int index = 120;
      while (index < stringBuilder.Length - 20)
      {
        for (; index < stringBuilder.Length - 10; ++index)
        {
          if (stringBuilder[index] == ';')
          {
            stringBuilder.Insert(index + 1, Environment.NewLine);
            index += 120;
            break;
          }
        }
      }
      return stringBuilder.ToString();
    }

    public void LoggerMark()
    {
      ++this.markCount;
      if (this.reportStopwatch == null)
        return;
      this.ReportLogger.Add(new ProgressTimeArg(this.markCount));
    }
  }
}


--- ProgressSplitArg.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.ProgressSplitArg
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public sealed class ProgressSplitArg
  {
    public uint ReportMark;
    public double ProgressPercentage;

    public override string ToString()
    {
      return "Mark:" + this.ReportMark.ToString() + "; " + this.ProgressPercentage.ToString("0.00") + "%";
    }
  }
}


--- ProgressTimeArg.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.ProgressTimeArg
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public sealed class ProgressTimeArg
  {
    public uint ReportMarkCounter = 0;

    public long PrograssTime_ms { get; private set; }

    public string Message { get; private set; }

    public object Tag { get; private set; }

    public ProgressTimeArg(uint reportMarkCounter) => this.ReportMarkCounter = reportMarkCounter;

    public ProgressTimeArg(long progressTime_ms, string message, object tag)
    {
      this.PrograssTime_ms = progressTime_ms;
      this.Message = message;
      this.Tag = tag;
    }

    public override string ToString()
    {
      if (this.ReportMarkCounter > 0U)
        return "LoggerMark: " + this.ReportMarkCounter.ToString();
      return this.Message != null ? this.PrograssTime_ms.ToString("d06") + "ms: " + this.Message : this.PrograssTime_ms.ToString("d06") + "ms: ";
    }
  }
}


--- Scheduler.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.Scheduler
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using NLog;
using System;
using System.Collections.Generic;
using System.Timers;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public sealed class Scheduler : IDisposable
  {
    private List<Scheduler.TriggerItem> _triggerItems;
    private Timer _triggerTimer;
    private static Logger logger = LogManager.GetLogger(nameof (Scheduler));

    public double TriggerTimerInterval
    {
      get => this._triggerTimer.Interval;
      set => this._triggerTimer.Interval = value;
    }

    public Scheduler()
      : this(1000.0)
    {
    }

    public Scheduler(double interval)
    {
      this._triggerItems = new List<Scheduler.TriggerItem>();
      this._triggerTimer = new Timer();
      this._triggerTimer.Interval = interval;
      this._triggerTimer.Elapsed += new ElapsedEventHandler(this._triggerTimer_Elapsed);
    }

    public List<Scheduler.TriggerItem> TriggerItems => this._triggerItems;

    public void AddTrigger(Scheduler.TriggerItem item)
    {
      this._triggerItems.Add(item);
      if (this._triggerItems.Count != 1)
        return;
      this.Start();
    }

    public void RemoveTrigger(Scheduler.TriggerItem item)
    {
      Scheduler.logger.Info("[GMM] RemoveTrigger: " + item?.ToString());
      this._triggerItems.Remove(item);
      if (this._triggerItems.Count != 0)
        return;
      this.Stop();
    }

    private void Start()
    {
      Scheduler.logger.Info("[GMM] triggerTimer.Start");
      this._triggerTimer.Start();
    }

    private void Stop()
    {
      Scheduler.logger.Info("[GMM] triggerTimer.Stop");
      this._triggerTimer.Stop();
    }

    private void _triggerTimer_Elapsed(object sender, ElapsedEventArgs e)
    {
      this._triggerTimer.Stop();
      if (this.TriggerItems.Count == 0)
        return;
      foreach (Scheduler.TriggerItem triggerItem in this.TriggerItems)
      {
        if (triggerItem.Enabled)
        {
          while (triggerItem.TriggerTime <= DateTime.Now)
            triggerItem.RunCheck(DateTime.Now);
        }
      }
      this._triggerTimer.Start();
    }

    public void Dispose()
    {
      Scheduler.logger.Info("[GMM] Dispose _triggerTimer");
      this._triggerTimer.Stop();
      this._triggerTimer.Dispose();
      this._triggerItems.Clear();
    }

    public enum DayOccurrence
    {
      First,
      Second,
      Third,
      Fourth,
      Last,
    }

    public enum MonthOfTheYeay
    {
      January,
      February,
      March,
      April,
      May,
      June,
      July,
      August,
      September,
      October,
      November,
      December,
    }

    public sealed class TriggerSettingsOneTimeOnly
    {
      public DateTime? Date { get; set; }
    }

    public sealed class TriggerSettingsFixedInterval
    {
      public TimeSpan Interval { get; set; }

      public TriggerSettingsFixedInterval() => this.Interval = TimeSpan.Zero;
    }

    public sealed class TriggerSettingsDaily
    {
      public ushort Interval { get; set; }
    }

    public sealed class TriggerSettingsWeekly
    {
      public bool[] DaysOfWeek { get; set; }

      public TriggerSettingsWeekly() => this.DaysOfWeek = new bool[7];
    }

    public sealed class TriggerSettingsMonthlyWeekDay
    {
      public bool[] WeekNumber { get; set; }

      public bool[] DayOfWeek { get; set; }

      public TriggerSettingsMonthlyWeekDay()
      {
        this.WeekNumber = new bool[5];
        this.DayOfWeek = new bool[7];
      }
    }

    public sealed class TriggerSettingsMonthly
    {
      public bool[] Month { get; set; }

      public bool[] DaysOfMonth { get; set; }

      public Scheduler.TriggerSettingsMonthlyWeekDay WeekDay { get; set; }

      public TriggerSettingsMonthly()
      {
        this.Month = new bool[12];
        this.DaysOfMonth = new bool[32];
        this.WeekDay = new Scheduler.TriggerSettingsMonthlyWeekDay();
      }
    }

    public sealed class TriggerSettings
    {
      public Scheduler.TriggerSettingsOneTimeOnly OneTimeOnly { get; set; }

      public Scheduler.TriggerSettingsFixedInterval FixedInterval { get; set; }

      public Scheduler.TriggerSettingsDaily Daily { get; set; }

      public Scheduler.TriggerSettingsWeekly Weekly { get; set; }

      public Scheduler.TriggerSettingsMonthly Monthly { get; set; }

      public TriggerSettings()
      {
        this.OneTimeOnly = new Scheduler.TriggerSettingsOneTimeOnly();
        this.FixedInterval = new Scheduler.TriggerSettingsFixedInterval();
        this.Daily = new Scheduler.TriggerSettingsDaily();
        this.Weekly = new Scheduler.TriggerSettingsWeekly();
        this.Monthly = new Scheduler.TriggerSettingsMonthly();
      }
    }

    public sealed class OnTriggerEventArgs : EventArgs
    {
      public OnTriggerEventArgs(Scheduler.TriggerItem item, DateTime triggerDate)
      {
        this.Item = item;
        this.TriggerDate = triggerDate;
      }

      public Scheduler.TriggerItem Item { get; private set; }

      public DateTime TriggerDate { get; private set; }
    }

    public sealed class TriggerItem
    {
      private static Logger logger = LogManager.GetLogger(nameof (TriggerItem));
      private const byte LastDayOfMonthID = 31;
      private DateTime startDate = DateTime.MinValue;
      private DateTime endDate = DateTime.MaxValue;
      private DateTime triggerTime;
      private DateTime? lastTriggerTime;
      private bool enabled;

      public event Scheduler.TriggerItem.OnTriggerEventHandler OnTrigger;

      public TriggerItem() => this.TriggerSettings = new Scheduler.TriggerSettings();

      public Scheduler.TriggerSettings TriggerSettings { get; set; }

      public object Tag { get; set; }

      public bool Enabled
      {
        get => this.enabled;
        set
        {
          this.enabled = value;
          if (this.enabled)
          {
            if (this.TriggerSettings.FixedInterval.Interval != TimeSpan.Zero)
            {
              this.startDate = new DateTime(this.startDate.Year, this.startDate.Month, this.startDate.Day, this.triggerTime.Hour, this.triggerTime.Minute, this.triggerTime.Second);
              if (this.startDate.Add(this.TriggerSettings.FixedInterval.Interval) < DateTime.Now)
              {
                while (this.startDate.Add(this.TriggerSettings.FixedInterval.Interval) < DateTime.Now)
                  this.startDate = this.startDate.Add(this.TriggerSettings.FixedInterval.Interval);
                this.startDate = this.startDate.Add(this.TriggerSettings.FixedInterval.Interval);
              }
            }
            else if (!this.TriggerSettings.OneTimeOnly.Date.HasValue && this.startDate.AddDays(1.0) < DateTime.Now)
            {
              while (this.startDate.AddDays(1.0) < DateTime.Now)
                this.startDate = this.startDate.AddDays(1.0);
            }
            this.triggerTime = this.FindNextTriggerDate(this.startDate);
          }
          else
            this.triggerTime = new DateTime(1, 1, 1, this.triggerTime.Hour, this.triggerTime.Minute, this.triggerTime.Second);
        }
      }

      public DateTime StartDate
      {
        get => this.startDate;
        set
        {
          this.startDate = new DateTime(value.Year, value.Month, value.Day, value.Hour, value.Minute, value.Second);
          if (!(this.endDate < this.startDate))
            return;
          this.endDate = this.startDate;
        }
      }

      public DateTime EndDate
      {
        get => this.endDate;
        set => this.endDate = value.Date;
      }

      public DateTime TriggerTime
      {
        get => this.triggerTime;
        set
        {
          this.triggerTime = new DateTime(this.triggerTime.Year, this.triggerTime.Month, this.triggerTime.Day, value.Hour, value.Minute, value.Second);
        }
      }

      private DateTime LastDayOfMonth(DateTime date)
      {
        DateTime dateTime = new DateTime(date.Year, date.Month, 1);
        dateTime = dateTime.AddMonths(1);
        return dateTime.AddDays(-1.0);
      }

      private int WeekDayOccurInMonth(DateTime date)
      {
        byte num = 0;
        for (int day = 1; day <= date.Day; ++day)
        {
          if (new DateTime(date.Year, date.Month, day).DayOfWeek == date.DayOfWeek)
            ++num;
        }
        return (int) num - 1;
      }

      private bool IsLastWeekDayInMonth(DateTime date)
      {
        return this.WeekDayOccurInMonth(date.AddDays(7.0)) == 0;
      }

      private bool TriggerOneTimeOnly(DateTime date)
      {
        int num;
        if (this.TriggerSettings.OneTimeOnly.Date.HasValue)
        {
          DateTime? date1 = this.TriggerSettings.OneTimeOnly.Date;
          DateTime dateTime = date;
          num = date1.HasValue ? (date1.HasValue ? (date1.GetValueOrDefault() == dateTime ? 1 : 0) : 1) : 0;
        }
        else
          num = 0;
        return num != 0;
      }

      private bool TriggerFixInterval(DateTime lastTriggerDate)
      {
        if (lastTriggerDate < this.startDate || lastTriggerDate > this.endDate || this.TriggerSettings.FixedInterval.Interval == TimeSpan.Zero)
          return false;
        DateTime dateTime = this.startDate;
        while (dateTime < lastTriggerDate)
          dateTime = dateTime.Add(this.TriggerSettings.FixedInterval.Interval);
        return dateTime == lastTriggerDate;
      }

      private bool TriggerDaily(DateTime date)
      {
        if (date < this.startDate.Date || date > this.endDate.Date || this.TriggerSettings.Daily.Interval == (ushort) 0)
          return false;
        DateTime dateTime = this.startDate.Date;
        while (dateTime.Date < date)
          dateTime = dateTime.AddDays((double) this.TriggerSettings.Daily.Interval);
        return dateTime == date;
      }

      private bool TriggerWeekly(DateTime date)
      {
        return !(date < this.startDate.Date) && !(date > this.endDate.Date) && this.TriggerSettings.Weekly.DaysOfWeek[(int) date.DayOfWeek];
      }

      private bool TriggerMonthly(DateTime date)
      {
        if (date < this.startDate.Date || date > this.endDate.Date)
          return false;
        bool flag = false;
        if (this.TriggerSettings.Monthly.Month[date.Month - 1])
        {
          if (this.TriggerSettings.Monthly.DaysOfMonth[31])
            flag = flag || date == this.LastDayOfMonth(date);
          flag = flag || this.TriggerSettings.Monthly.DaysOfMonth[date.Day - 1];
          if (this.TriggerSettings.Monthly.WeekDay.DayOfWeek[(int) date.DayOfWeek])
          {
            if (this.TriggerSettings.Monthly.WeekDay.WeekNumber[4])
              flag = flag || this.IsLastWeekDayInMonth(date);
            flag = flag || this.TriggerSettings.Monthly.WeekDay.WeekNumber[this.WeekDayOccurInMonth(date)];
          }
        }
        return flag;
      }

      public bool CheckDate(DateTime lastTriggerDate)
      {
        return this.TriggerOneTimeOnly(lastTriggerDate) || this.TriggerFixInterval(lastTriggerDate) || this.TriggerDaily(lastTriggerDate) || this.TriggerWeekly(lastTriggerDate) || this.TriggerMonthly(lastTriggerDate);
      }

      public bool RunCheck(DateTime dateTimeToCheck)
      {
        if (this.enabled && dateTimeToCheck >= this.triggerTime)
        {
          this.lastTriggerTime = new DateTime?(this.triggerTime);
          Scheduler.OnTriggerEventArgs e = new Scheduler.OnTriggerEventArgs(this, this.triggerTime);
          this.triggerTime = !(this.TriggerSettings.FixedInterval.Interval != TimeSpan.Zero) ? this.FindNextTriggerDate(this.triggerTime.AddDays(1.0)) : this.FindNextTriggerDate(this.triggerTime.Add(this.TriggerSettings.FixedInterval.Interval));
          if (this.OnTrigger != null)
            this.OnTrigger((object) this, e);
          Scheduler.TriggerItem.logger.Info("[GMM] RunCheck == true, triggerTime = " + this.triggerTime.ToString("G"));
          return true;
        }
        Scheduler.TriggerItem.logger.Info("[GMM] RunCheck == false, triggerTime = " + this.triggerTime.ToString("G"));
        return false;
      }

      public void RevertToLastTriggerTime()
      {
        if (!this.lastTriggerTime.HasValue)
          return;
        this.triggerTime = this.lastTriggerTime.Value;
        Scheduler.TriggerItem.logger.Info("[GMM] RevertToLastTriggerTime, triggerTime = " + this.triggerTime.ToString("G") + "lastTriggerTime: " + this.lastTriggerTime.ToString());
      }

      private DateTime FindNextTriggerDate(DateTime lastTriggerDate)
      {
        if (!this.enabled)
          return DateTime.MaxValue;
        if (this.TriggerSettings.FixedInterval.Interval != TimeSpan.Zero)
        {
          for (DateTime lastTriggerDate1 = lastTriggerDate; lastTriggerDate1 <= this.endDate; lastTriggerDate1 = lastTriggerDate1.Add(this.TriggerSettings.FixedInterval.Interval))
          {
            if (this.CheckDate(lastTriggerDate1))
              return lastTriggerDate1;
          }
          return DateTime.MaxValue;
        }
        for (DateTime dateTime = lastTriggerDate.Date; dateTime <= this.endDate; dateTime = dateTime.AddDays(1.0))
        {
          if (this.CheckDate(dateTime.Date))
            return new DateTime(dateTime.Year, dateTime.Month, dateTime.Day, this.triggerTime.Hour, this.triggerTime.Minute, this.triggerTime.Second);
        }
        return DateTime.MaxValue;
      }

      public DateTime GetNextTriggerTime() => this.enabled ? this.triggerTime : DateTime.MaxValue;

      public delegate void OnTriggerEventHandler(object sender, Scheduler.OnTriggerEventArgs e);
    }
  }
}


--- SingletonRepository.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.SingletonRepository
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public sealed class SingletonRepository
  {
    private readonly SortedList<string, object> list = new SortedList<string, object>();

    private SingletonRepository()
    {
    }

    public static SingletonRepository Instance => SingletonRepository.Nested.instance;

    public T Get<T>(string key) => this.list.ContainsKey(key) ? (T) this.list[key] : default (T);

    public void Add<T>(string key, object obj)
    {
      if (this.list.ContainsKey(key))
        throw new Exception("Object already exists");
      this.list.Add(key, obj);
    }

    private class Nested
    {
      internal static readonly SingletonRepository instance = new SingletonRepository();
    }
  }
}


--- TransceiverDevice.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.TransceiverDevice
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public enum TransceiverDevice
  {
    None,
    MinoConnect,
    Wavenis,
    MinoHead,
    MinoIR,
  }
}


--- Utility.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.Utility
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security.Cryptography;
using System.Text;

#nullable disable
namespace ZENNER.CommonLibrary
{
  public static class Utility
  {
    public static byte[] GetRandomAppKey()
    {
      byte[] data = new byte[16];
      new RNGCryptoServiceProvider().GetBytes(data);
      return data;
    }

    public static string ConvertSerialNumberToEUI64(Utility.LoraDevice device, int serialnumber)
    {
      List<byte> byteList = new List<byte>()
      {
        (byte) 4,
        (byte) 182,
        (byte) 72,
        (byte) 0
      };
      byteList.AddRange((IEnumerable<byte>) ((IEnumerable<byte>) BitConverter.GetBytes(Utility.ConvertUnt32ToBcdUInt32((uint) serialnumber))).Reverse<byte>().ToArray<byte>());
      switch (device)
      {
        case Utility.LoraDevice.M8:
          byteList[3] = (byte) 253;
          byteList[4] |= (byte) 128;
          return Utility.ByteArrayToHexString(byteList.ToArray());
        case Utility.LoraDevice.EDC:
          byteList[3] = (byte) 4;
          byteList[4] |= (byte) 80;
          return Utility.ByteArrayToHexString(byteList.ToArray());
        default:
          throw new NotImplementedException();
      }
    }

    public static string ConvertSerialNumberToFullserialNumber(
      Utility.LoraDevice device,
      int serialnumber)
    {
      switch (device)
      {
        case Utility.LoraDevice.M8:
          return "4ZRIFD8" + Utility.ByteArrayToHexString(((IEnumerable<byte>) BitConverter.GetBytes(Utility.ConvertUnt32ToBcdUInt32((uint) serialnumber))).Reverse<byte>().ToArray<byte>()).Substring(1);
        case Utility.LoraDevice.EDC:
          return "EZRI045" + Utility.ByteArrayToHexString(((IEnumerable<byte>) BitConverter.GetBytes(Utility.ConvertUnt32ToBcdUInt32((uint) serialnumber))).Reverse<byte>().ToArray<byte>()).Substring(1);
        default:
          throw new NotImplementedException();
      }
    }

    public static string ByteArrayToFullSerialNumber_V1(byte[] buffer)
    {
      if (buffer == null)
        throw new ArgumentNullException(nameof (buffer));
      if (buffer.Length != 8)
        throw new ArgumentOutOfRangeException(nameof (buffer), "Expected 8 bytes");
      if (buffer[0] == byte.MaxValue && buffer[1] == byte.MaxValue && buffer[2] == byte.MaxValue && buffer[3] == byte.MaxValue && buffer[4] == byte.MaxValue && buffer[5] == byte.MaxValue && buffer[6] == byte.MaxValue && buffer[7] == byte.MaxValue)
        return string.Empty;
      if (buffer[0] == (byte) 0 && buffer[1] == (byte) 0 && buffer[2] == (byte) 0 && buffer[3] == (byte) 0 && buffer[4] == (byte) 0 && buffer[5] == (byte) 0 && buffer[6] == (byte) 0 && buffer[7] == (byte) 0)
        return string.Empty;
      try
      {
        string str = Encoding.ASCII.GetString(buffer, 0, 1);
        string manufacturer = Utility.GetManufacturer(BitConverter.ToUInt16(buffer, 1));
        byte num = buffer[3];
        uint uint32 = BitConverter.ToUInt32(new byte[4]
        {
          buffer[7],
          buffer[6],
          buffer[5],
          buffer[4]
        }, 0);
        return string.Format("{0}{1}{2}{3}", (object) str, (object) manufacturer, (object) num.ToString("X2"), (object) uint32.ToString("X8"));
      }
      catch
      {
        return string.Empty;
      }
    }

    public static string ByteArrayToFullSerialNumber_V2(byte[] buffer)
    {
      if (buffer == null)
        throw new ArgumentNullException(nameof (buffer));
      int index = buffer.Length - 1;
      while (index >= 0 && buffer[index] == (byte) 0)
        --index;
      byte[] numArray = new byte[index + 1];
      Array.Copy((Array) buffer, (Array) numArray, index + 1);
      return Encoding.ASCII.GetString(numArray);
    }

    public static byte[] FullSerialNumberToByteArray_V1(string value)
    {
      if (string.IsNullOrEmpty(value))
        return new byte[8]
        {
          byte.MaxValue,
          byte.MaxValue,
          byte.MaxValue,
          byte.MaxValue,
          byte.MaxValue,
          byte.MaxValue,
          byte.MaxValue,
          byte.MaxValue
        };
      string s = value.Length == 14 ? value.Substring(0, 1) : throw new ArgumentException("Wrong length of the full serialnumber detected! Expected 14, Value: " + value);
      string manufacturer = value.Substring(1, 3);
      byte num = byte.Parse(value.Substring(4, 2), NumberStyles.HexNumber);
      string str = value.Substring(6);
      if (!Utility.IsValidBCD(str))
        throw new ArgumentException("Wrong full serialnumber detected! The last 8 chars should contains only numbers. Value: " + value);
      List<byte> byteList = new List<byte>(8);
      byteList.AddRange((IEnumerable<byte>) Encoding.ASCII.GetBytes(s));
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(Utility.GetManufacturerCode(manufacturer)));
      byteList.Add(num);
      byteList.AddRange((IEnumerable<byte>) ((IEnumerable<byte>) BitConverter.GetBytes(Utility.ConvertUnt32ToBcdUInt32(uint.Parse(str)))).Reverse<byte>().ToArray<byte>());
      return byteList.Count == 8 ? byteList.ToArray() : throw new ArgumentOutOfRangeException("Wrong full serialnumber was generated!");
    }

    public static byte[] FullSerialNumberToByteArray_V2(string value)
    {
      if (string.IsNullOrEmpty(value))
        return new byte[20];
      byte[] src = value.Length <= 16 ? Encoding.ASCII.GetBytes(value + " ") : throw new ArgumentException("Printed_serialnumber must be less as 16 characters.");
      src[src.Length - 1] = (byte) 0;
      byte[] dst = new byte[20];
      Buffer.BlockCopy((Array) src, 0, (Array) dst, 0, src.Length);
      return dst;
    }

    public static string GetManufacturer(ushort code)
    {
      return "" + ((char) (((int) code >> 10 & 31) + 64)).ToString() + ((char) (((int) code >> 5 & 31) + 64)).ToString() + ((char) (((int) code & 31) + 64)).ToString();
    }

    public static bool IsValidBCD(string bcdStr)
    {
      foreach (char ch in bcdStr)
      {
        if (ch < '0' || ch > '9')
          return false;
      }
      return true;
    }

    public static ushort GetManufacturerCode(string manufacturer)
    {
      if (string.IsNullOrEmpty(manufacturer))
        manufacturer = string.Empty;
      manufacturer = manufacturer.PadRight(3);
      return (ushort) ((uint) (ushort) ((uint) (ushort) (0U + (uint) (ushort) ((uint) (byte) manufacturer[2] - 64U)) + (uint) (ushort) ((uint) (ushort) ((uint) (byte) manufacturer[1] - 64U) << 5)) + (uint) (ushort) ((uint) (ushort) ((uint) (byte) manufacturer[0] - 64U) << 10));
    }

    public static string PrintObject(object obj, int spaces = 0)
    {
      StringBuilder stringBuilder = new StringBuilder();
      foreach (PropertyDescriptor property in TypeDescriptor.GetProperties(obj))
      {
        string name = property.Name;
        object buffer = property.GetValue(obj);
        string str = string.Empty;
        if (buffer != null)
        {
          if (buffer.GetType() == typeof (byte[]))
          {
            str = Utility.ByteArrayToHexString((byte[]) buffer);
          }
          else
          {
            switch (buffer)
            {
              case IPrintable _:
                str = ((IPrintable) buffer).Print();
                break;
              case IList _:
                IEnumerator enumerator = ((IEnumerable) buffer).GetEnumerator();
                try
                {
                  while (enumerator.MoveNext())
                  {
                    object current = enumerator.Current;
                    str += Utility.PrintObject(current, spaces + 4);
                  }
                  break;
                }
                finally
                {
                  if (enumerator is IDisposable disposable)
                    disposable.Dispose();
                }
              default:
                str = buffer.ToString();
                break;
            }
          }
        }
        stringBuilder.Append(' ', spaces).AppendFormat("{0}={1}", (object) name, (object) str).AppendLine();
      }
      return stringBuilder.ToString();
    }

    public static string PrintAvailableObjectProperties(object obj, int spaces = 0)
    {
      StringBuilder stringBuilder = new StringBuilder();
      foreach (PropertyDescriptor property in TypeDescriptor.GetProperties(obj))
      {
        string name = property.Name;
        object buffer = property.GetValue(obj);
        if (buffer != null)
        {
          string str = string.Empty;
          if (buffer != null)
          {
            if (buffer.GetType() == typeof (byte[]))
            {
              str = Utility.ByteArrayToHexString((byte[]) buffer);
            }
            else
            {
              switch (buffer)
              {
                case IPrintable _:
                  str = ((IPrintable) buffer).Print();
                  break;
                case IList _:
                  IEnumerator enumerator = ((IEnumerable) buffer).GetEnumerator();
                  try
                  {
                    while (enumerator.MoveNext())
                    {
                      object current = enumerator.Current;
                      str += Utility.PrintObject(current, spaces + 4);
                    }
                    break;
                  }
                  finally
                  {
                    if (enumerator is IDisposable disposable)
                      disposable.Dispose();
                  }
                default:
                  str = buffer.ToString();
                  break;
              }
            }
          }
          stringBuilder.Append(' ', spaces).AppendFormat("{0}={1}", (object) name, (object) str).AppendLine();
        }
      }
      return stringBuilder.ToString();
    }

    public static T DeepCopy<T>(T obj)
    {
      if ((object) obj == null)
        throw new ArgumentNullException(nameof (obj));
      using (MemoryStream serializationStream = new MemoryStream())
      {
        BinaryFormatter binaryFormatter = new BinaryFormatter();
        binaryFormatter.Serialize((Stream) serializationStream, (object) obj);
        serializationStream.Position = 0L;
        return (T) binaryFormatter.Deserialize((Stream) serializationStream);
      }
    }

    public static string ByteArrayToAsciiString(byte[] ba)
    {
      StringBuilder stringBuilder = new StringBuilder();
      foreach (byte num in ba)
        stringBuilder.Append((char) num);
      return stringBuilder.ToString();
    }

    public static string ByteArrayToHexString(byte[] buffer)
    {
      return buffer == null ? string.Empty : Utility.ByteArrayToHexString(buffer, 0, buffer.Length);
    }

    public static string ByteArrayToHexString(byte[] buffer, int startIndex)
    {
      return buffer == null ? string.Empty : Utility.ByteArrayToHexString(buffer, startIndex, buffer.Length - startIndex);
    }

    public static string ByteArrayToHexString(byte[] buffer, int startIndex, int length)
    {
      if (buffer == null)
        return string.Empty;
      char[] chArray = new char[length * 2];
      int num1 = 0;
      int index = 0;
      while (num1 < length)
      {
        byte num2 = (byte) ((uint) buffer[startIndex + num1] >> 4);
        chArray[index] = num2 > (byte) 9 ? (char) ((int) num2 + 55) : (char) ((int) num2 + 48);
        byte num3 = (byte) ((uint) buffer[startIndex + num1] & 15U);
        int num4;
        chArray[num4 = index + 1] = num3 > (byte) 9 ? (char) ((int) num3 + 55) : (char) ((int) num3 + 48);
        ++num1;
        index = num4 + 1;
      }
      return new string(chArray, 0, chArray.Length);
    }

    public static string ByteArrayToHexStringFormated(
      byte[] arr,
      string leftSpacesString,
      int maxLineBytes,
      uint? startAddress = null)
    {
      StringBuilder stringBuilder = new StringBuilder();
      uint num1 = 0;
      int num2 = 0;
      for (int index = 0; index < arr.Length; ++index)
      {
        if (index % maxLineBytes == 0)
        {
          num2 = 0;
          if (num1 > 0U)
            stringBuilder.AppendLine();
          if (leftSpacesString != null)
            stringBuilder.Append(leftSpacesString);
          if (startAddress.HasValue)
          {
            uint num3 = startAddress.Value + num1;
            stringBuilder.Append(num3.ToString("x08") + ": ");
          }
        }
        if (num2 > 0)
        {
          if ((num2 & 7) == 0)
            stringBuilder.Append(':');
          else if ((num2 & 3) == 0)
            stringBuilder.Append('.');
          else
            stringBuilder.Append(' ');
        }
        stringBuilder.Append(arr[index].ToString("x02"));
        ++num1;
        ++num2;
      }
      return stringBuilder.ToString();
    }

    public static string ReverseString(string s)
    {
      char[] charArray = s.ToCharArray();
      Array.Reverse((Array) charArray);
      return new string(charArray);
    }

    public static uint ReverseBytes(uint value)
    {
      return (uint) (((int) value & (int) byte.MaxValue) << 24 | ((int) value & 65280) << 8) | (value & 16711680U) >> 8 | (value & 4278190080U) >> 24;
    }

    public static ulong ReverseBytes(ulong value)
    {
      return (ulong) (((long) value & (long) byte.MaxValue) << 56 | ((long) value & 65280L) << 40 | ((long) value & 16711680L) << 24 | ((long) value & 4278190080L) << 8) | (value & 1095216660480UL) >> 8 | (value & 280375465082880UL) >> 24 | (value & 71776119061217280UL) >> 40 | (value & 18374686479671623680UL) >> 56;
    }

    public static uint ConvertUnt32ToBcdUInt32(uint value)
    {
      uint bcdUint32 = 0;
      for (int index = 0; index < 8; ++index)
      {
        uint num = value % 10U;
        bcdUint32 |= num << index * 4;
        value /= 10U;
      }
      return bcdUint32;
    }

    public static uint ConvertBcdUInt32ToUInt32(uint bcd)
    {
      uint num = 1;
      uint uint32 = 0;
      for (; bcd > 0U; bcd >>= 4)
      {
        uint32 += (bcd & 15U) * num;
        num *= 10U;
      }
      return uint32;
    }

    public static long DecodeBcd(byte[] data, int size)
    {
      if (data == null)
        throw new ArgumentNullException(nameof (data));
      long num = 0;
      for (int index = size; index > 0; --index)
        num = (index != 0 || (int) data[0] >> 4 != 15 ? num * 10L + (long) ((int) data[index - 1] >> 4 & 15) : num * -1L) * 10L + (long) ((int) data[index - 1] & 15);
      return num;
    }

    public static byte[] HexStringToByteArray(string hex)
    {
      hex = hex.Replace(" ", string.Empty);
      hex = hex.Replace("-", string.Empty);
      hex = hex.Replace(":", string.Empty);
      int length = hex.Length;
      byte[] byteArray = length % 2 == 0 ? new byte[length / 2] : throw new ArgumentException("Hex-string is invalid!");
      for (int startIndex = 0; startIndex < length; startIndex += 2)
        byteArray[startIndex / 2] = Convert.ToByte(hex.Substring(startIndex, 2), 16);
      return byteArray;
    }

    public static string ElapsedToString(TimeSpan elapsed)
    {
      if ((long) elapsed.TotalHours > 0L)
        return string.Format("{0:0}h {1:0}m {2:0}s {3:0}ms", (object) elapsed.TotalHours, (object) elapsed.Minutes, (object) elapsed.Seconds, (object) elapsed.Milliseconds);
      if ((long) elapsed.TotalMinutes > 0L)
        return string.Format("{0:0}m {1:0}s {2:0}ms", (object) elapsed.TotalMinutes, (object) elapsed.Seconds, (object) elapsed.Milliseconds);
      if ((long) elapsed.TotalSeconds > 0L)
        return string.Format("{0:0}s {1:0}ms", (object) elapsed.TotalSeconds, (object) elapsed.Milliseconds);
      return (long) elapsed.TotalMilliseconds > 0L ? string.Format("{0:0}ms", (object) elapsed.TotalMilliseconds) : string.Empty;
    }

    public static DateTime? ConvertToDateTime_SystemTime64(byte[] buffer, int startIndex)
    {
      int num1 = startIndex;
      byte[] numArray1 = buffer;
      int index1 = num1;
      int num2 = index1 + 1;
      byte num3 = numArray1[index1];
      byte[] numArray2 = buffer;
      int index2 = num2;
      int num4 = index2 + 1;
      byte month = numArray2[index2];
      byte[] numArray3 = buffer;
      int index3 = num4;
      int num5 = index3 + 1;
      byte day = numArray3[index3];
      byte[] numArray4 = buffer;
      int index4 = num5;
      int num6 = index4 + 1;
      byte hour = numArray4[index4];
      byte[] numArray5 = buffer;
      int index5 = num6;
      int num7 = index5 + 1;
      byte minute = numArray5[index5];
      byte[] numArray6 = buffer;
      int index6 = num7;
      int num8 = index6 + 1;
      byte second = numArray6[index6];
      byte[] numArray7 = buffer;
      int index7 = num8;
      int num9 = index7 + 1;
      byte num10 = numArray7[index7];
      byte[] numArray8 = buffer;
      int index8 = num9;
      int num11 = index8 + 1;
      byte num12 = numArray8[index8];
      if (month == (byte) 0 || day == (byte) 0)
        return new DateTime?();
      try
      {
        return new DateTime?(new DateTime(2000 + (int) num3, (int) month, (int) day, (int) hour, (int) minute, (int) second));
      }
      catch
      {
        return new DateTime?();
      }
    }

    public static string ZeroTerminatedAsciiStringToString(byte[] zeroTerminatedAsciiString)
    {
      if (zeroTerminatedAsciiString == null)
        return (string) null;
      int count = -1;
      for (int index = 0; index < zeroTerminatedAsciiString.Length; ++index)
      {
        if (zeroTerminatedAsciiString[index] == (byte) 0)
        {
          count = index;
          break;
        }
      }
      return count <= 0 ? (string) null : Encoding.ASCII.GetString(zeroTerminatedAsciiString, 0, count);
    }

    public static byte[] StringToZeroTerminatedAsciiString(string theString, int maxLength)
    {
      if (string.IsNullOrEmpty(theString))
        return new byte[1];
      if (theString.Length >= maxLength)
        throw new Exception("StringToZeroTerminatedAsciiString: string to long for byte[] maxLength");
      byte[] bytes = Encoding.ASCII.GetBytes(theString);
      if (bytes.Length != theString.Length)
        throw new Exception("Illegal ASCII characters");
      Array.Resize<byte>(ref bytes, bytes.Length + 1);
      bytes[bytes.Length - 1] = (byte) 0;
      return bytes;
    }

    public enum LoraDevice
    {
      M8,
      EDC,
      PDC,
      THL,
      NFCL,
    }
  }
}


--- VersionMasks.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.VersionMasks
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public enum VersionMasks : uint
  {
    Type = 4095, // 0x00000FFF
    Revision = 61440, // 0x0000F000
    Minor = 16711680, // 0x00FF0000
    BSL_Type = 16773120, // 0x00FFF000
    Major = 2130706432, // 0x7F000000
    Debug = 2147483648, // 0x80000000
  }
}


--- WakeupSystem.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: ZENNER.CommonLibrary.WakeupSystem
// Assembly: CommonLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 53447886-5C7B-49AE-B18C-3692A1E343CC
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommonLibrary.dll

#nullable disable
namespace ZENNER.CommonLibrary
{
  public enum WakeupSystem
  {
    None,
    Break,
    BaudrateCarrier,
    MinoHead,
  }
}

