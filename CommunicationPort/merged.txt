
--- AssemblyInfo.cs ---

﻿using System.Reflection;
using System.Runtime.InteropServices;
using System.Windows;

[assembly: AssemblyTitle("S4_Handler")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("S4_Handler")]
[assembly: AssemblyCopyright("Copyright ©  2016")]
[assembly: AssemblyTrademark("")]
[assembly: ComVisible(false)]
[assembly: ThemeInfo(ResourceDictionaryLocation.None, ResourceDictionaryLocation.SourceAssembly)]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: AssemblyVersion("1.0.0.0")]


--- BluetoothChannel.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: CommunicationPort.BluetoothChannel
// Assembly: CommunicationPort, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 4F7EB5DB-4517-47DC-B5F2-757F0B03AE01
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommunicationPort.dll

using InTheHand.Net;
using InTheHand.Net.Bluetooth;
using InTheHand.Net.Sockets;
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Net.Sockets;
using System.Security;
using System.Text;

#nullable disable
namespace CommunicationPort
{
  public sealed class BluetoothChannel : BluetoothClient, IChannel, IDisposable
  {
    private object _syncLock = new object();
    private NetworkStream stream;

    public string PortName { get; set; }

    public bool IsOpen => this.Connected;

    public int BytesToRead => this.Available;

    public BluetoothChannel(string portName) => this.PortName = portName;

    public void Open()
    {
      if (this.IsOpen)
        return;
      BluetoothAddress bluetoothAddress = !string.IsNullOrEmpty(this.PortName) ? BluetoothChannel.GetBluetoothAddressByPortName(this.PortName) : throw new ArgumentNullException("PortName");
      if (bluetoothAddress == (BluetoothAddress) null)
        throw new ArgumentException("address");
      this.Connect(bluetoothAddress, (Guid) BluetoothService.L2CapProtocol);
      this.stream = this.GetStream();
    }

    public void Write(byte[] buffer, int offset, int count)
    {
      if (this.stream == null)
        throw new NullReferenceException("stream");
      if (!this.stream.CanWrite)
        return;
      lock (this._syncLock)
      {
        this.stream.Write(buffer, offset, count);
        this.stream.Flush();
      }
    }

    public void Write(string text)
    {
      if (this.stream == null)
        throw new NullReferenceException("stream");
      switch (text)
      {
        case null:
          throw new ArgumentNullException(nameof (text));
        case "":
          break;
        default:
          byte[] bytes = Encoding.ASCII.GetBytes(text);
          if (!this.stream.CanWrite)
            break;
          lock (this._syncLock)
          {
            this.stream.Write(bytes, 0, bytes.Length);
            break;
          }
      }
    }

    public void WriteBaudrateCarrier(int numberOfBytes)
    {
      byte[] buffer = new byte[numberOfBytes];
      for (int index = 0; index < buffer.Length; ++index)
        buffer[index] = (byte) 85;
      this.Write(buffer, 0, buffer.Length);
    }

    public int Read(byte[] buffer, int offset, int count)
    {
      if (this.stream == null)
        throw new NullReferenceException("stream");
      if (!this.stream.CanRead)
        return 0;
      lock (this._syncLock)
        return this.stream.Read(buffer, offset, count);
    }

    public int ReadByte()
    {
      if (this.stream == null)
        throw new NullReferenceException("stream");
      if (!this.stream.CanRead)
        return 0;
      lock (this._syncLock)
        return this.stream.ReadByte();
    }

    public void DiscardInBuffer()
    {
      if (this.stream == null)
        throw new NullReferenceException("stream");
      lock (this._syncLock)
        this.stream.Flush();
    }

    public void DiscardOutBuffer()
    {
      if (this.stream == null)
        throw new NullReferenceException("stream");
      lock (this._syncLock)
        this.stream.Flush();
    }

    public static bool IsBluetooth(string portName)
    {
      if (string.IsNullOrEmpty(portName))
        throw new ArgumentNullException(nameof (portName));
      return BluetoothChannel.GetBluetoothAddressByPortName(portName) != (BluetoothAddress) null;
    }

    private static BluetoothAddress GetBluetoothAddressByPortName(string portName)
    {
      return BluetoothChannel.SearchRegistryForPortName("SYSTEM\\CurrentControlSet\\Enum", portName);
    }

    private static BluetoothAddress SearchRegistryForPortName(string startKey, string portName)
    {
      if (string.IsNullOrEmpty(portName))
        return (BluetoothAddress) null;
      RegistryKey localMachine = Registry.LocalMachine;
      RegistryKey registryKey;
      try
      {
        if (startKey.Contains("ACPI") || startKey.Contains("MS_BTHBRB") || startKey.Contains("Root\\SYSTEM") || startKey.Contains("COMPOSITE_BATTERY") || startKey.Contains("mssmbios") || startKey.Contains("VMUSBCONNECTOR") || startKey.Contains("RDPBUS") || startKey.Contains("blbdrive") || startKey.Contains("volmgr") || startKey.Contains("STORAGE") || startKey.Contains("Enum\\SW") || startKey.Contains("USB") || startKey.Contains("ScFilter") || startKey.Contains("0350278f-3dca-4e62-831d-a41165ff906c"))
          return (BluetoothAddress) null;
        registryKey = localMachine.OpenSubKey(startKey);
        if (registryKey == null)
          return (BluetoothAddress) null;
      }
      catch (SecurityException ex)
      {
        return (BluetoothAddress) null;
      }
      List<string> stringList = new List<string>((IEnumerable<string>) registryKey.GetSubKeyNames());
      if (stringList.Contains("Device Parameters") && startKey != "SYSTEM\\CurrentControlSet\\Enum")
      {
        object obj = Registry.GetValue("HKEY_LOCAL_MACHINE\\" + startKey + "\\Device Parameters", "PortName", (object) null);
        if (obj == null)
          return (BluetoothAddress) null;
        string str = obj.ToString();
        if (!str.StartsWith("COM") || !(portName == str.ToString()))
          return (BluetoothAddress) null;
        string name = registryKey.Name;
        if (name.IndexOf("BTHENUM") > 0)
        {
          int num1 = name.LastIndexOf('&');
          int num2 = name.LastIndexOf('_');
          string bluetoothString = name.Substring(num1 + 1, num2 - num1 - 1);
          if (bluetoothString != "000000000000")
            return BluetoothAddress.Parse(bluetoothString);
        }
      }
      else
      {
        foreach (string str in stringList)
        {
          BluetoothAddress bluetoothAddress = BluetoothChannel.SearchRegistryForPortName(startKey + "\\" + str, portName);
          if (bluetoothAddress != (BluetoothAddress) null)
            return bluetoothAddress;
        }
      }
      return (BluetoothAddress) null;
    }

    public new void Dispose() => base.Dispose();

    void IChannel.Close() => this.Close();
  }
}


--- BluetoothChannel_LE.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: CommunicationPort.BluetoothChannel_LE
// Assembly: CommunicationPort, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 4F7EB5DB-4517-47DC-B5F2-757F0B03AE01
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommunicationPort.dll

using NLog;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices.WindowsRuntime;
using System.Text;
using System.Threading.Tasks;
using Windows.Devices.Bluetooth;
using Windows.Devices.Bluetooth.GenericAttributeProfile;
using Windows.Devices.Enumeration;
using Windows.Foundation;
using Windows.Storage.Streams;
using ZENNER.CommonLibrary;

#nullable disable
namespace CommunicationPort
{
  public sealed class BluetoothChannel_LE : IChannel, IDisposable
  {
    private static Logger MiConLE_Logger = LogManager.GetLogger("MiConLE");
    public static readonly Guid PROTEUS_Base_UUID = new Guid("6E400000-C352-11E5-953D-0002A5D5C51B");
    public static readonly Guid PROTEUS_PrimaryService_UUID = new Guid("6E400001-C352-11E5-953D-0002A5D5C51B");
    public static readonly Guid PROTEUS_TX_CHARACTERISTIC_UUID = new Guid("6E400002-C352-11E5-953D-0002A5D5C51B");
    public static readonly Guid PROTEUS_RX_CHARACTERISTIC_UUID = new Guid("6E400003-C352-11E5-953D-0002A5D5C51B");
    public static readonly int E_BLUETOOTH_ATT_INVALID_PDU = -2140864508;
    public static readonly uint PROTEUS_MTU = 247;
    public static readonly uint PROTEUS_FRAME_SIZE = 5;
    public static readonly uint PROTEUS_MAX_PAYLOAD = BluetoothChannel_LE.PROTEUS_MTU - BluetoothChannel_LE.PROTEUS_FRAME_SIZE;
    private object _syncLock = new object();
    private Queue<byte> ReceivedData;
    internal string WindowsVersion;
    private BluetoothLEDevice SelectedMiCon;
    private GattCharacteristic ToMinoConnect;
    private GattCharacteristic FromMinoConnect;
    public uint MaxDataLength;

    public string PortName { get; set; }

    public bool IsOpen => this.IsConnected;

    public int BytesToRead
    {
      get
      {
        int count = this.ReceivedData.Count;
        if (count > 0 && BluetoothChannel_LE.MiConLE_Logger.IsTraceEnabled)
          BluetoothChannel_LE.MiConLE_Logger.Trace("CheckBytesToRead: " + this.ReceivedData.Count.ToString());
        return count;
      }
    }

    internal event EventHandler OnDataReceived;

    public ulong BTMAC { get; private set; }

    public uint MaxTransmitDataLength { get; private set; }

    public uint MaxReceiveDataLength { get; private set; }

    public bool IsConnected => this.ToMinoConnect != null && this.FromMinoConnect != null;

    private BluetoothChannel_LE()
    {
      this.WindowsVersion = Environment.OSVersion.ToString();
      this.ReceivedData = new Queue<byte>();
      this.MaxTransmitDataLength = BluetoothChannel_LE.PROTEUS_MAX_PAYLOAD;
      this.MaxReceiveDataLength = BluetoothChannel_LE.PROTEUS_MAX_PAYLOAD;
    }

    public BluetoothChannel_LE(ulong BTMAC)
      : this()
    {
      this.PortName = "Mi" + BTMAC.ToString("X06").Substring(6);
      this.BTMAC = BTMAC;
    }

    public BluetoothChannel_LE(string portName)
      : this()
    {
      this.PortName = portName;
    }

    internal async Task ConnectAsync()
    {
      GattDeviceService service = (GattDeviceService) null;
      try
      {
        DeviceInformationCollection devices = await DeviceInformation.FindAllAsync(BluetoothLEDevice.GetDeviceSelectorFromPairingState(true));
        DeviceInformation deviceInfo = ((IEnumerable<DeviceInformation>) devices).FirstOrDefault<DeviceInformation>((Func<DeviceInformation, bool>) (x => x.Name.StartsWith(this.PortName)));
        if (deviceInfo == null)
          throw new Exception(this.PortName + " was not found!");
        if (this.SelectedMiCon == null)
        {
          BluetoothLEDevice bluetoothLeDevice = await BluetoothLEDevice.FromIdAsync(deviceInfo.Id);
          this.SelectedMiCon = bluetoothLeDevice;
          bluetoothLeDevice = (BluetoothLEDevice) null;
        }
        if (this.SelectedMiCon != null)
        {
          service = this.SelectedMiCon.GetGattService(BluetoothChannel_LE.PROTEUS_PrimaryService_UUID);
          this.ToMinoConnect = service != null ? service.GetCharacteristics(BluetoothChannel_LE.PROTEUS_TX_CHARACTERISTIC_UUID).FirstOrDefault<GattCharacteristic>() : throw new Exception("Failed to open the connection with MinoConnect!");
          if (this.ToMinoConnect == null)
            throw new Exception("TX is null.");
          this.FromMinoConnect = service.GetCharacteristics(BluetoothChannel_LE.PROTEUS_RX_CHARACTERISTIC_UUID).FirstOrDefault<GattCharacteristic>();
          if (this.FromMinoConnect == null)
            throw new Exception("RX is null.");
          int attempt = 3;
          GattCommunicationStatus statusStartNotifications = (GattCommunicationStatus) 1;
          do
          {
            try
            {
              statusStartNotifications = await this.FromMinoConnect.WriteClientCharacteristicConfigurationDescriptorAsync((GattClientCharacteristicConfigurationDescriptorValue) 1);
              if (statusStartNotifications > 0)
                BluetoothChannel_LE.MiConLE_Logger.Error(string.Format("Failed to start RX notification! Error: {0}", (object) statusStartNotifications));
            }
            catch (Exception ex)
            {
              BluetoothChannel_LE.MiConLE_Logger.Error("Failed to start RX notification! Error: " + ex.Message);
            }
            await Task.Delay(100);
          }
          while (statusStartNotifications != null && attempt-- > 0);
          if (statusStartNotifications > 0)
            throw new Exception(string.Format("Failed to start RX notification! Error: {0}", (object) statusStartNotifications));
          GattCharacteristic fromMinoConnect = this.FromMinoConnect;
          // ISSUE: method pointer
          WindowsRuntimeMarshal.AddEventHandler<TypedEventHandler<GattCharacteristic, GattValueChangedEventArgs>>(new Func<TypedEventHandler<GattCharacteristic, GattValueChangedEventArgs>, EventRegistrationToken>(fromMinoConnect.add_ValueChanged), new Action<EventRegistrationToken>(fromMinoConnect.remove_ValueChanged), new TypedEventHandler<GattCharacteristic, GattValueChangedEventArgs>((object) this, __methodptr(DataFromMiConReceived)));
          if (!this.IsConnected)
          {
            string m = "Connection to MinoConnect not possible.";
            BluetoothChannel_LE.MiConLE_Logger.Error(m);
            throw new Exception(m);
          }
        }
        devices = (DeviceInformationCollection) null;
        deviceInfo = (DeviceInformation) null;
      }
      catch (Exception ex1)
      {
        try
        {
          service?.Dispose();
          service = (GattDeviceService) null;
        }
        catch (Exception ex2)
        {
          BluetoothChannel_LE.MiConLE_Logger.Error(ex2, "Failed to dispose GATT service!");
        }
        this.FromMinoConnect = (GattCharacteristic) null;
        this.ToMinoConnect = (GattCharacteristic) null;
        string m = "Bluetooth connection to MinoConnect fails";
        BluetoothChannel_LE.MiConLE_Logger.Error(m);
        throw new Exception(m, ex1);
      }
      service = (GattDeviceService) null;
    }

    private void DataFromMiConReceived(GattCharacteristic sender, GattValueChangedEventArgs args)
    {
      DataReader dataReader = DataReader.FromBuffer(args.CharacteristicValue);
      byte[] source = new byte[(int) dataReader.UnconsumedBufferLength];
      dataReader.ReadBytes(source);
      DateTimeOffset timestamp = args.Timestamp;
      byte num = source[0];
      for (int index = 1; index < source.Length; ++index)
        this.ReceivedData.Enqueue(source[index]);
      if (BluetoothChannel_LE.MiConLE_Logger.IsTraceEnabled)
      {
        byte[] array = ((IEnumerable<byte>) source).Skip<byte>(1).ToArray<byte>();
        string str = Utility.ByteArrayToHexString(array) + " ASCII'" + Utility.ByteArrayToAsciiString(array) + "'";
        BluetoothChannel_LE.MiConLE_Logger.Trace("BLE RX (" + array.Length.ToString() + "): " + str);
      }
      if (this.OnDataReceived != null && source.Length > 1)
        this.OnDataReceived((object) this, (EventArgs) new ReceivedCountEventArgs(source.Length - 1));
      switch (num)
      {
        case 1:
          break;
        case 4:
          BluetoothChannel_LE.MiConLE_Logger.Trace("data + high throughput mode");
          break;
        default:
          BluetoothChannel_LE.MiConLE_Logger.Trace("data + other");
          break;
      }
    }

    internal async Task SendData(byte[] sendData)
    {
      if (this.ToMinoConnect == null)
        return;
      int offset = 0;
      try
      {
        while (offset < sendData.Length)
        {
          int blockSize = sendData.Length - offset;
          if ((long) blockSize > (long) this.MaxTransmitDataLength)
            blockSize = (int) this.MaxTransmitDataLength;
          DataWriter writer = new DataWriter();
          byte[] payload = new byte[blockSize + 1];
          payload[0] = (byte) 1;
          Array.ConstrainedCopy((Array) sendData, offset, (Array) payload, 1, blockSize);
          writer.WriteBytes(payload);
          int attempt = 3;
          IBuffer detachedBuffer = writer.DetachBuffer();
          GattCommunicationStatus result;
          do
          {
            result = await this.ToMinoConnect.WriteValueAsync(detachedBuffer, (GattWriteOption) 0);
            if (result > 0)
              BluetoothChannel_LE.MiConLE_Logger.Error("Failed to write chunk! Reason: " + result.ToString());
          }
          while (result != null && attempt-- > 0);
          if (result == 0)
          {
            if (BluetoothChannel_LE.MiConLE_Logger.IsTraceEnabled)
            {
              string traceData = Utility.ByteArrayToHexString(payload) + " ASCII'" + Utility.ByteArrayToAsciiString(payload) + "'";
              BluetoothChannel_LE.MiConLE_Logger.Trace("BLE TX: " + traceData);
              traceData = (string) null;
            }
            offset += blockSize;
            writer = (DataWriter) null;
            payload = (byte[]) null;
            detachedBuffer = (IBuffer) null;
          }
          else
          {
            string m = "TX not successfully. GattCommunicationStatus: " + result.ToString();
            BluetoothChannel_LE.MiConLE_Logger.Error(m);
            throw new Exception(m);
          }
        }
      }
      catch (Exception ex) when (ex.HResult == BluetoothChannel_LE.E_BLUETOOTH_ATT_INVALID_PDU)
      {
        string m = ex.HResult != BluetoothChannel_LE.E_BLUETOOTH_ATT_INVALID_PDU ? "Transmit exception." : "Transmit exception. E_BLUETOOTH_ATT_INVALID_PDU";
        BluetoothChannel_LE.MiConLE_Logger.Error(m);
        throw new Exception(m, ex);
      }
    }

    public void Open()
    {
      if (this.IsOpen)
        return;
      BluetoothChannel_LE.MiConLE_Logger.Trace(nameof (Open));
      Task task = Task.Run((Func<Task>) (() => this.ConnectAsync()));
      if (!task.Wait(5000))
      {
        BluetoothChannel_LE.MiConLE_Logger.Trace("Open timeout");
        task.Dispose();
        throw new Exception("Bluetooth connection error. (timeout)");
      }
    }

    public void Close()
    {
      BluetoothChannel_LE.MiConLE_Logger.Trace(nameof (Close));
      if (this.ToMinoConnect != null)
      {
        if (this.ToMinoConnect.Service != null)
          this.ToMinoConnect.Service.Dispose();
        this.ToMinoConnect = (GattCharacteristic) null;
      }
      if (this.FromMinoConnect != null)
        this.FromMinoConnect = (GattCharacteristic) null;
      if (this.SelectedMiCon == null)
        return;
      this.SelectedMiCon.Dispose();
      this.SelectedMiCon = (BluetoothLEDevice) null;
    }

    public void Write(byte[] buffer, int offset, int count)
    {
      if (this.ToMinoConnect == null)
        throw new NullReferenceException("ToMinoConnect");
      if (offset + count > buffer.Length)
        throw new ArgumentException("offset + count > length");
      byte[] bytesToWrite = new byte[count];
      Buffer.BlockCopy((Array) buffer, offset, (Array) bytesToWrite, 0, count);
      lock (this._syncLock)
      {
        Task task = Task.Run((Func<Task>) (() => this.SendData(bytesToWrite)));
        if (!task.Wait(5000))
        {
          BluetoothChannel_LE.MiConLE_Logger.Trace("Close");
          task.Dispose();
          throw new Exception("Bluetooth write error. (timeout)");
        }
      }
    }

    public void Write(string text)
    {
      if (this.ToMinoConnect == null)
        throw new NullReferenceException("ToMinoConnect");
      switch (text)
      {
        case null:
          throw new ArgumentNullException(nameof (text));
        case "":
          break;
        default:
          byte[] bytesToWrite = Encoding.ASCII.GetBytes(text);
          lock (this._syncLock)
          {
            Task task = Task.Run((Func<Task>) (() => this.SendData(bytesToWrite)));
            if (task.Wait(5000))
              break;
            task.Dispose();
            throw new Exception("Bluetooth write error. (timeout)");
          }
      }
    }

    public void WriteBaudrateCarrier(int numberOfBytes)
    {
      this.Write("#bc " + numberOfBytes.ToString() + "\n");
    }

    internal string GetReceivedDataAsString()
    {
      StringBuilder stringBuilder = new StringBuilder();
      while (this.ReceivedData.Count > 0)
        stringBuilder.Append((char) this.ReceivedData.Dequeue());
      return stringBuilder.ToString();
    }

    internal List<byte> GetReceivedData()
    {
      List<byte> receivedData = new List<byte>();
      while (this.ReceivedData.Count > 0)
        receivedData.Add(this.ReceivedData.Dequeue());
      return receivedData;
    }

    internal byte[] GetReceivedData(int count)
    {
      if (this.ReceivedData.Count < count)
        throw new Exception("Count bytes not available");
      byte[] receivedData = new byte[count];
      for (int index = 0; index < count; ++index)
        receivedData[index] = this.ReceivedData.Dequeue();
      return receivedData;
    }

    public int Read(byte[] buffer, int offset, int count)
    {
      int count1 = count;
      if (this.ReceivedData.Count < count1)
        count1 = this.ReceivedData.Count;
      if (count1 > buffer.Length - offset)
        count1 = buffer.Length - offset;
      if (count1 < 0)
        count1 = 0;
      for (int index = 0; index < count1; ++index)
        buffer[offset++] = this.ReceivedData.Dequeue();
      if (BluetoothChannel_LE.MiConLE_Logger.IsTraceEnabled)
      {
        byte[] numArray = new byte[count1];
        Buffer.BlockCopy((Array) buffer, offset - count1, (Array) numArray, 0, count1);
        string hexString = Utility.ByteArrayToHexString(numArray);
        BluetoothChannel_LE.MiConLE_Logger.Trace("ReadPoll: " + count1.ToString() + " of " + count.ToString() + ": " + hexString);
      }
      return count;
    }

    public int ReadByte()
    {
      if (this.ReceivedData.Count < 1)
      {
        BluetoothChannel_LE.MiConLE_Logger.Trace("ReadByte, but no data");
        return 0;
      }
      byte num = this.ReceivedData.Dequeue();
      if (BluetoothChannel_LE.MiConLE_Logger.IsTraceEnabled)
        BluetoothChannel_LE.MiConLE_Logger.Trace("ReadByte: 0x" + num.ToString("x02"));
      return (int) num;
    }

    public void DiscardInBuffer()
    {
      BluetoothChannel_LE.MiConLE_Logger.Trace(nameof (DiscardInBuffer));
      this.ReceivedData.Clear();
    }

    public void DiscardOutBuffer()
    {
      BluetoothChannel_LE.MiConLE_Logger.Trace(nameof (DiscardOutBuffer));
    }

    public static bool IsBluetooth(string portName)
    {
      if (string.IsNullOrEmpty(portName))
        throw new ArgumentNullException(nameof (portName));
      return false;
    }

    public void Dispose()
    {
      BluetoothChannel_LE.MiConLE_Logger.Trace(nameof (Dispose));
      this.Close();
    }
  }
}


--- IChannel.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: CommunicationPort.IChannel
// Assembly: CommunicationPort, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 4F7EB5DB-4517-47DC-B5F2-757F0B03AE01
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommunicationPort.dll

using System;

#nullable disable
namespace CommunicationPort
{
  internal interface IChannel : IDisposable
  {
    string PortName { get; set; }

    bool IsOpen { get; }

    int BytesToRead { get; }

    void Open();

    void Close();

    void DiscardInBuffer();

    void DiscardOutBuffer();

    int ReadByte();

    int Read(byte[] buffer, int offset, int count);

    void Write(byte[] buffer, int offset, int count);

    void Write(string text);

    void WriteBaudrateCarrier(int numberOfBytes);
  }
}


--- ICommunicationFunctions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: CommunicationPort.ICommunicationFunctions
// Assembly: CommunicationPort, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 4F7EB5DB-4517-47DC-B5F2-757F0B03AE01
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommunicationPort.dll

using ZENNER.CommonLibrary;

#nullable disable
namespace CommunicationPort
{
  public interface ICommunicationFunctions
  {
    void RaiseMessageEvent(string theMessage);

    void RaiseAliveEvent(int aliveCounter);

    void RaiseBatteryLowEvent();

    void RaiseKeyEvent();

    ConfigList GetReadoutConfiguration();

    string TransceiverDeviceInfo { get; set; }
  }
}


--- PlugInAnchor.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: CommunicationPort.PlugInAnchor
// Assembly: CommunicationPort, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 4F7EB5DB-4517-47DC-B5F2-757F0B03AE01
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommunicationPort.dll

using CommunicationPort.UserInterface;
using PlugInLib;
using StartupLib;
using System.Windows;
using ZENNER.CommonLibrary;

#nullable disable
namespace CommunicationPort
{
  [ComponentPath("Reading")]
  public class PlugInAnchor : GmmPlugInByOwner, IReadoutConfig
  {
    internal static string[] UsedRights = new string[0];
    private CommunicationPortWindowFunctions MyWindowFunctions;

    public PlugInAnchor()
    {
      if (!PlugInLoader.IsPluginLoaderInitialised())
        return;
      this.MyWindowFunctions = new CommunicationPortWindowFunctions();
      this.MyWindowFunctions.portFunctions.IsPluginObject = true;
      this.MyWindowFunctions.IsPluginObject = true;
    }

    public override void Dispose() => this.MyWindowFunctions.DisposeComponent();

    public override string ShowMainWindow() => this.MyWindowFunctions.ShowMainWindow(true);

    public override string ShowMainWindow(Window owner)
    {
      return this.MyWindowFunctions.ShowMainWindow(true, owner);
    }

    public override PlugInInfo GetPluginInfo()
    {
      return new PlugInInfo("CommunicationPort", "NotUsed", "Central component for byte transfer to devices", "Includes communication by SerialPort and other different byte transfere streams", new string[0], PlugInAnchor.UsedRights, (object) this.MyWindowFunctions);
    }

    public void SetReadoutConfiguration(ConfigList configList)
    {
      this.MyWindowFunctions.SetReadoutConfiguration(configList);
    }

    public ConfigList GetReadoutConfiguration() => this.MyWindowFunctions.GetReadoutConfiguration();
  }
}


--- RadioTestResult.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: CommunicationPort.RadioTestResult
// Assembly: CommunicationPort, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 4F7EB5DB-4517-47DC-B5F2-757F0B03AE01
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommunicationPort.dll

#nullable disable
namespace CommunicationPort
{
  public sealed class RadioTestResult
  {
    public byte[] Payload { get; set; }

    public byte LQI { get; set; }

    public int RSSI { get; set; }

    public uint MCT { get; set; }

    public byte[] ReceiveBuffer { get; set; }
  }
}


--- ReceivedCountEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: CommunicationPort.ReceivedCountEventArgs
// Assembly: CommunicationPort, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 4F7EB5DB-4517-47DC-B5F2-757F0B03AE01
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommunicationPort.dll

using System;

#nullable disable
namespace CommunicationPort
{
  public class ReceivedCountEventArgs : EventArgs
  {
    public int Count { get; set; }

    public ReceivedCountEventArgs(int count) => this.Count = count;
  }
}


--- SerialPortChannel.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: CommunicationPort.SerialPortChannel
// Assembly: CommunicationPort, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 4F7EB5DB-4517-47DC-B5F2-757F0B03AE01
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommunicationPort.dll

using System;
using System.IO.Ports;

#nullable disable
namespace CommunicationPort
{
  public sealed class SerialPortChannel : SerialPort, IChannel, IDisposable
  {
    public SerialPortChannel(string portName)
    {
      this.PortName = portName;
      this.BaudRate = 115200;
      this.Parity = Parity.None;
      this.Handshake = Handshake.RequestToSend;
      this.ReadTimeout = 0;
      this.WriteTimeout = 5000;
    }

    public void WriteBaudrateCarrier(int numberOfBytes)
    {
      byte[] buffer = new byte[numberOfBytes];
      for (int index = 0; index < buffer.Length; ++index)
        buffer[index] = (byte) 85;
      this.Write(buffer, 0, buffer.Length);
    }

    string IChannel.get_PortName() => this.PortName;

    void IChannel.set_PortName(string value) => this.PortName = value;

    bool IChannel.get_IsOpen() => this.IsOpen;

    int IChannel.get_BytesToRead() => this.BytesToRead;

    void IChannel.Open() => this.Open();

    void IChannel.Close() => this.Close();

    void IChannel.DiscardInBuffer() => this.DiscardInBuffer();

    void IChannel.DiscardOutBuffer() => this.DiscardOutBuffer();

    int IChannel.ReadByte() => this.ReadByte();

    int IChannel.Read(byte[] buffer, int offset, int count) => this.Read(buffer, offset, count);

    void IChannel.Write(byte[] buffer, int offset, int count) => this.Write(buffer, offset, count);

    void IChannel.Write(string text) => this.Write(text);
  }
}


--- UserInterfaceCommunicationPortWindow.xaml.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: CommunicationPort.UserInterface.CommunicationPortWindow
// Assembly: CommunicationPort, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 4F7EB5DB-4517-47DC-B5F2-757F0B03AE01
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommunicationPort.dll

using CommonWPF;
using CommunicationPort.Functions;
using GmmDbLib;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO.Ports;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZENNER.CommonLibrary.Entities;

#nullable disable
namespace CommunicationPort.UserInterface
{
  public partial class CommunicationPortWindow : Window, IComponentConnector
  {
    private const string otKey = "ComPortUI_";
    private static int[] BaudrateTable = new int[10]
    {
      300,
      600,
      1200,
      2400,
      4800,
      9600,
      19200,
      38400,
      57600,
      115200
    };
    private static string[] ParityTable = new string[3]
    {
      "None",
      "Even",
      "Odd"
    };
    private static List<CommunicationPortWindow.MiConSetupElement> MiConSetupList;
    private static string[] WakeupTable = new string[3]
    {
      "None",
      "BaudrateCarrier",
      "Break"
    };
    private static string[] EchoTable = new string[2]
    {
      "None",
      "Suppress echo"
    };
    private CommunicationPortWindowFunctions myWindowFunctions;
    internal string NextPlugin = "";
    private string PortTypeCom;
    private string PortTypeMinoConnect;
    private string PortTypeRemote;
    private CommunicationPortFunctions thePort;
    private bool controlInit = true;
    internal Menu menuMain;
    internal MenuItem MenuItemComponents;
    internal MenuItem MenuItemMiConBLE_TEST;
    internal StartupLib.GmmCorporateControl gmmCorporateControl1;
    internal GroupBox GroupBoxComState;
    internal TextBlock TextBlockComState;
    internal GroupBox GroupBoxDeviceInof;
    internal TextBox TextBoxDeviceInfo;
    internal StackPanel StackPanalSetup;
    internal Grid GridPortType;
    internal Label LabelPortType;
    internal ComboBox ComboBoxPortType;
    internal Grid GridPort;
    internal Label LabelPort;
    internal ComboBox ComboBoxPort;
    internal Grid GridBaudrateParity;
    internal Label LabelBaudrate;
    internal ComboBox ComboBoxBaudrate;
    internal Label LabelParity;
    internal ComboBox ComboBoxParity;
    internal Grid GridWakeupEcho;
    internal Label LabelWakeup;
    internal ComboBox ComboBoxWakeup;
    internal Label LabelEcho;
    internal ComboBox ComboBoxEcho;
    internal Grid GridMiConSetup;
    internal Label LabelMiConSetup;
    internal ComboBox ComboBoxMiConSetup;
    internal Button ButtonOpenClose;
    internal Button ButtonTiming;
    internal TextBox TextBoxChannel;
    internal TextBlock TextBlockMessages;
    internal TextBlock TextBlockAlive;
    private bool _contentLoaded;

    private static void AddSetupElement(
      CommunicationPortWindow.MiConSetupEnum theEnum,
      string theText)
    {
      CommunicationPortWindow.MiConSetupList.Add(new CommunicationPortWindow.MiConSetupElement()
      {
        SetupEnum = theEnum,
        SetupText = theText
      });
    }

    static CommunicationPortWindow()
    {
      CommunicationPortWindow.MiConSetupList = new List<CommunicationPortWindow.MiConSetupElement>();
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.IrDaCombiHeadRoundSideInfrared, "IrDaCombiHead round side infrared");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.IrDaCombiHeadRoundSideIrDA, "IrDaCombiHead round side IrDA");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.IrDaCombiHeadDoveTailSideIrDA, "IrDaCombiHead dove tail side IrDA");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.ZIN_CombiHead_RoundSideZVEI, "ZIN_CombiHead round side infrared");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.ZIN_CombiHead_RoundSideIrDA, "ZIN_CombiHead round side side IrDA");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.ZIN_CombiHead_DoveTailSideIrDA, "ZIN_CombiHead dove tail side IrDA");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.ZIN_CombiHead_RoundSideNFC, "ZIN_CombiHead round side NFC");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.Radio2_receive, "Radio2 receive");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.Radio3_receive, "Radio3 receive");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.WirelessMBusReceive, "Wireless MBus receive");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.NDC_MiCon_Module, "NDC MiCon Module");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.RS232_PowerOff, "RS232 power off");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.RS232_3_3V, "RS232 3.3V");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.RS232_7V, "RS232 7V");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.RS485_PowerOff, "RS485 power off");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.RS485_3_3V, "RS485 3.3V");
      CommunicationPortWindow.AddSetupElement(CommunicationPortWindow.MiConSetupEnum.RS485_7V, "RS485 7V");
    }

    public CommunicationPortWindow(
      CommunicationPortWindowFunctions myWindowFunctions,
      bool isPlugin)
    {
      this.myWindowFunctions = myWindowFunctions;
      this.InitializeComponent();
      WpfTranslatorSupport.TranslateWindow(Tg.CommunicationPortWindow, (Window) this);
      if (isPlugin)
      {
        MenuItem componentsMenuItem = (MenuItem) this.menuMain.Items[0];
        componentsMenuItem.Visibility = Visibility.Visible;
        UserInterfaceServices.AddDefaultMenu(componentsMenuItem, new RoutedEventHandler(this.componentsClick));
        componentsMenuItem.Items.Add((object) new Separator());
        UserInterfaceServices.AddMenuItem("ReadoutConfiguration", componentsMenuItem, new RoutedEventHandler(this.componentsClick));
      }
      this.PortTypeCom = Ot.Gtt(Tg.Communication_UI, "ComPortUI_PortTypeCom", "COM port");
      this.PortTypeMinoConnect = Ot.Gtt(Tg.Communication_UI, "ComPortUI_PortTypeMinoConnect", "MinoConnect");
      this.PortTypeRemote = Ot.Gtt(Tg.Communication_UI, "ComPortUI_PortTypeRemote", "Remote connection");
      this.ComboBoxPortType.Items.Add((object) this.PortTypeCom);
      this.ComboBoxPortType.Items.Add((object) this.PortTypeMinoConnect);
      this.ComboBoxPortType.Items.Add((object) this.PortTypeRemote);
      switch (this.myWindowFunctions.portFunctions.communicationObject)
      {
        case CommunicationByComPort _:
          this.ComboBoxPortType.SelectedIndex = 0;
          break;
        case CommunicationByMinoConnect _:
          this.ComboBoxPortType.SelectedIndex = 1;
          break;
        default:
          this.ComboBoxPortType.SelectedIndex = 2;
          break;
      }
      this.ShowPort();
      for (int index = 0; index < CommunicationPortWindow.BaudrateTable.Length; ++index)
        this.ComboBoxBaudrate.Items.Add((object) CommunicationPortWindow.BaudrateTable[index].ToString());
      this.ShowBaudrate();
      for (int index = 0; index < CommunicationPortWindow.ParityTable.Length; ++index)
        this.ComboBoxParity.Items.Add((object) CommunicationPortWindow.ParityTable[index]);
      this.ShowParity();
      for (int index = 0; index < CommunicationPortWindow.WakeupTable.Length; ++index)
        this.ComboBoxWakeup.Items.Add((object) CommunicationPortWindow.WakeupTable[index]);
      this.ShowWakeup();
      for (int index = 0; index < CommunicationPortWindow.EchoTable.Length; ++index)
        this.ComboBoxEcho.Items.Add((object) CommunicationPortWindow.EchoTable[index]);
      this.ShowEcho();
      foreach (CommunicationPortWindow.MiConSetupElement miConSetup in CommunicationPortWindow.MiConSetupList)
        this.ComboBoxMiConSetup.Items.Add((object) miConSetup.SetupText);
      this.ShowMiConSetup();
      this.myWindowFunctions.portFunctions.OnAliveEvent += new EventHandler<int>(this.AliveEventReceived);
      this.myWindowFunctions.portFunctions.OnMessageEvent += new EventHandler<string>(this.MessageEventReceived);
      this.ShowCurrentState();
      this.controlInit = false;
    }

    public string ReadingChannelIdentification
    {
      get => this.myWindowFunctions.portFunctions.configList.ReadingChannelIdentification;
      set => this.myWindowFunctions.portFunctions.configList.ReadingChannelIdentification = value;
    }

    private void componentsClick(object sender, RoutedEventArgs e)
    {
      this.NextPlugin = ((HeaderedItemsControl) sender).Header.ToString();
      this.Close();
    }

    private void AliveEventReceived(object sender, int aliveCounter)
    {
      if (this.Dispatcher.Thread != Thread.CurrentThread)
      {
        try
        {
          this.Dispatcher.BeginInvoke((Delegate) new EventHandler<int>(this.AliveEventReceived), sender, (object) aliveCounter);
        }
        catch
        {
        }
      }
      else
        this.TextBlockAlive.Text = aliveCounter.ToString();
    }

    private void MessageEventReceived(object sender, string theMessage)
    {
      if (this.Dispatcher.Thread != Thread.CurrentThread)
      {
        try
        {
          this.Dispatcher.BeginInvoke((Delegate) new EventHandler<string>(this.MessageEventReceived), sender, (object) theMessage);
        }
        catch
        {
        }
      }
      else
      {
        if (Ot.GetMessageNumberFromLanguageText(theMessage).HasValue)
          theMessage = Ot.GetMessageTextWithoutNumber(theMessage);
        this.TextBlockMessages.Text = theMessage;
        this.ShowCurrentState();
      }
    }

    private void ComboBoxPortType_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.controlInit || this.ComboBoxPortType.SelectedIndex < 0)
        return;
      if (this.ComboBoxPortType.SelectedIndex == 0)
        this.myWindowFunctions.portFunctions.PortType = PortTypes.COM;
      else if (this.ComboBoxPortType.SelectedIndex == 1)
      {
        this.myWindowFunctions.portFunctions.PortType = PortTypes.MinoConnect;
      }
      else
      {
        if (this.ComboBoxPortType.SelectedIndex != 2)
          return;
        this.myWindowFunctions.portFunctions.PortType = PortTypes.AsynchronIP;
      }
      this.ShowMiConSetup();
    }

    private void ComboBoxPort_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.controlInit || this.ComboBoxPort.SelectedIndex < 0)
        return;
      if (this.ComboBoxPort.SelectedItem is ValueItem selectedItem)
      {
        this.myWindowFunctions.portFunctions.configList.Port = selectedItem.Value;
        if (selectedItem.Value.StartsWith("Mi"))
          this.MenuItemMiConBLE_TEST.IsEnabled = true;
        else
          this.MenuItemMiConBLE_TEST.IsEnabled = false;
      }
      else
        this.ShowPort();
    }

    private void ComboBoxPort_DropDownOpened(object sender, EventArgs e)
    {
      List<ValueItem> availableComPorts = Constants.GetAvailableComPorts();
      ValueItem selectedItem = this.ComboBoxPort.SelectedItem as ValueItem;
      string selectedText = this.ComboBoxPort.Text;
      if (this.ComboBoxPort.ItemsSource == null)
        this.ComboBoxPort.Items.Clear();
      this.ComboBoxPort.ItemsSource = (IEnumerable) availableComPorts;
      if (selectedItem != null)
      {
        int index = availableComPorts.FindIndex((Predicate<ValueItem>) (item => item.Value == selectedItem.Value));
        if (index < 0)
          return;
        this.ComboBoxPort.SelectedIndex = index;
      }
      else
      {
        if (string.IsNullOrEmpty(selectedText))
          return;
        int index = availableComPorts.FindIndex((Predicate<ValueItem>) (item => item.Value == selectedText));
        if (index >= 0)
          this.ComboBoxPort.SelectedIndex = index;
      }
    }

    private void ComboBoxBaudrate_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.controlInit || this.ComboBoxBaudrate.SelectedItem == null || this.myWindowFunctions.portFunctions.communicationObject == null)
        return;
      this.myWindowFunctions.portFunctions.configList.Baudrate = int.Parse(this.ComboBoxBaudrate.SelectedItem.ToString());
    }

    private void ComboBoxParity_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.controlInit || this.ComboBoxParity.SelectedItem == null || this.myWindowFunctions.portFunctions.communicationObject == null)
        return;
      this.myWindowFunctions.portFunctions.communicationObject.Parity = (Parity) Enum.Parse(typeof (Parity), this.ComboBoxParity.SelectedItem.ToString());
    }

    private void ComboBoxEcho_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.controlInit || this.ComboBoxEcho.SelectedItem == null || this.myWindowFunctions.portFunctions.communicationObject == null)
        return;
      this.myWindowFunctions.portFunctions.configList.EchoOn = !(this.ComboBoxEcho.SelectedItem.ToString() == "None");
    }

    private void ComboBoxWakeup_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.controlInit || this.ComboBoxWakeup.SelectedItem == null || this.myWindowFunctions.portFunctions.communicationObject == null)
        return;
      this.myWindowFunctions.portFunctions.communicationObject.Wakeup = (WakeupSystem) Enum.Parse(typeof (WakeupSystem), this.ComboBoxWakeup.SelectedItem.ToString());
    }

    private void ComboBoxMiConSetup_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.controlInit || this.ComboBoxMiConSetup.SelectedIndex < 0)
        return;
      CommunicationByMinoConnect communicationObject = this.myWindowFunctions.portFunctions.communicationObject as CommunicationByMinoConnect;
      communicationObject.IrDaSelection = IrDaSelection.None;
      communicationObject.CombiHeadSelection = CombiHeadSelection.UART;
      switch (CommunicationPortWindow.MiConSetupList[this.ComboBoxMiConSetup.SelectedIndex].SetupEnum)
      {
        case CommunicationPortWindow.MiConSetupEnum.IrDaCombiHeadRoundSideInfrared:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.IrCombiHead;
          break;
        case CommunicationPortWindow.MiConSetupEnum.IrDaCombiHeadDoveTailSideIrDA:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.IrCombiHead;
          communicationObject.IrDaSelection = IrDaSelection.DoveTailSide;
          break;
        case CommunicationPortWindow.MiConSetupEnum.IrDaCombiHeadRoundSideIrDA:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.IrCombiHead;
          communicationObject.IrDaSelection = IrDaSelection.RoundSide;
          break;
        case CommunicationPortWindow.MiConSetupEnum.RS232_PowerOff:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.RS232;
          break;
        case CommunicationPortWindow.MiConSetupEnum.RS232_3_3V:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.RS232_3V;
          break;
        case CommunicationPortWindow.MiConSetupEnum.RS232_7V:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.RS232_7V;
          break;
        case CommunicationPortWindow.MiConSetupEnum.RS485_PowerOff:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.RS485;
          break;
        case CommunicationPortWindow.MiConSetupEnum.RS485_3_3V:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.RS485_3V;
          break;
        case CommunicationPortWindow.MiConSetupEnum.RS485_7V:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.RS485_7V;
          break;
        case CommunicationPortWindow.MiConSetupEnum.Radio2_receive:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.Radio2Receive;
          break;
        case CommunicationPortWindow.MiConSetupEnum.Radio3_receive:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.Radio3Receive;
          break;
        case CommunicationPortWindow.MiConSetupEnum.WirelessMBusReceive:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.WirelessMBus;
          break;
        case CommunicationPortWindow.MiConSetupEnum.NDC_MiCon_Module:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.NDC_MiCon_Module;
          break;
        case CommunicationPortWindow.MiConSetupEnum.ZIN_CombiHead_RoundSideZVEI:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.ZIN_CombiHead;
          communicationObject.CombiHeadSelection = CombiHeadSelection.UART;
          break;
        case CommunicationPortWindow.MiConSetupEnum.ZIN_CombiHead_RoundSideIrDA:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.ZIN_CombiHead;
          communicationObject.CombiHeadSelection = CombiHeadSelection.IrDa_RoundSide;
          break;
        case CommunicationPortWindow.MiConSetupEnum.ZIN_CombiHead_DoveTailSideIrDA:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.ZIN_CombiHead;
          communicationObject.CombiHeadSelection = CombiHeadSelection.IrDA_DoveTailSide;
          break;
        case CommunicationPortWindow.MiConSetupEnum.ZIN_CombiHead_RoundSideNFC:
          communicationObject.MinoConnectBaseState = MinoConnectBaseStates.ZIN_CombiHead;
          communicationObject.CombiHeadSelection = CombiHeadSelection.NFC;
          break;
      }
    }

    private void ButtonTiming_Click(object sender, RoutedEventArgs e)
    {
      new TimingWindow(this.myWindowFunctions).ShowDialog();
    }

    private void ButtonOpenClose_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        if (this.ButtonOpenClose.Content.ToString() == "Open")
          this.myWindowFunctions.portFunctions.Open();
        else
          this.myWindowFunctions.portFunctions.Close();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex, "Open error");
      }
      this.ShowCurrentState();
    }

    private void ShowPort()
    {
      if (this.myWindowFunctions.portFunctions.communicationObject == null)
        return;
      string port = this.myWindowFunctions.portFunctions.configList.Port;
      if (port.StartsWith("Mi"))
        this.MenuItemMiConBLE_TEST.IsEnabled = true;
      else
        this.MenuItemMiConBLE_TEST.IsEnabled = false;
      for (int index = 0; index < this.ComboBoxPort.Items.Count; ++index)
      {
        if ((this.ComboBoxPort.Items[index] as ValueItem).Value == port)
        {
          this.ComboBoxPort.SelectedIndex = index;
          return;
        }
      }
      this.ComboBoxPort.Items.Add((object) port);
      this.ComboBoxPort.SelectedIndex = 0;
    }

    private void ShowBaudrate()
    {
      if (this.myWindowFunctions.portFunctions.communicationObject == null)
        return;
      if (this.ComboBoxBaudrate.Items.Count > 0)
      {
        for (int index = 0; index < this.ComboBoxBaudrate.Items.Count; ++index)
        {
          if (this.ComboBoxBaudrate.Items[index].ToString() == this.myWindowFunctions.portFunctions.configList.Baudrate.ToString())
          {
            this.ComboBoxBaudrate.SelectedIndex = index;
            return;
          }
        }
      }
      this.ComboBoxBaudrate.SelectedIndex = -1;
    }

    private void ShowParity()
    {
      if (this.myWindowFunctions.portFunctions.communicationObject == null)
        return;
      if (this.ComboBoxParity.Items.Count > 0)
      {
        for (int index = 0; index < this.ComboBoxParity.Items.Count; ++index)
        {
          if (this.ComboBoxParity.Items[index].ToString() == this.myWindowFunctions.portFunctions.communicationObject.Parity.ToString())
          {
            this.ComboBoxParity.SelectedIndex = index;
            return;
          }
        }
      }
      this.ComboBoxParity.SelectedIndex = -1;
    }

    private void ShowWakeup()
    {
      if (this.myWindowFunctions.portFunctions.communicationObject == null)
        return;
      if (this.ComboBoxWakeup.Items.Count > 0)
      {
        for (int index = 0; index < this.ComboBoxWakeup.Items.Count; ++index)
        {
          if (this.ComboBoxWakeup.Items[index].ToString() == this.myWindowFunctions.portFunctions.communicationObject.Wakeup.ToString())
          {
            this.ComboBoxWakeup.SelectedIndex = index;
            return;
          }
        }
      }
      this.ComboBoxWakeup.SelectedIndex = -1;
    }

    private void ShowEcho()
    {
      if (this.myWindowFunctions.portFunctions.communicationObject == null)
        return;
      if (this.ComboBoxEcho.Items.Count > 0)
      {
        if (this.myWindowFunctions.portFunctions.configList.EchoOn)
          this.ComboBoxEcho.SelectedIndex = 1;
        else
          this.ComboBoxEcho.SelectedIndex = 0;
      }
      else
        this.ComboBoxEcho.SelectedIndex = -1;
    }

    private void ShowMiConSetup()
    {
      if (this.myWindowFunctions.portFunctions.communicationObject is CommunicationByMinoConnect)
      {
        this.GridMiConSetup.Visibility = Visibility.Visible;
        CommunicationByMinoConnect communicationObject = this.myWindowFunctions.portFunctions.communicationObject as CommunicationByMinoConnect;
        if (communicationObject.MinoConnectBaseState >= MinoConnectBaseStates.undefined || communicationObject.MinoConnectBaseState <= MinoConnectBaseStates.off)
        {
          this.ComboBoxMiConSetup.SelectedIndex = -1;
        }
        else
        {
          switch (communicationObject.MinoConnectBaseState)
          {
            case MinoConnectBaseStates.IrCombiHead:
              switch (communicationObject.IrDaSelection)
              {
                case IrDaSelection.None:
                  this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.IrDaCombiHeadRoundSideInfrared);
                  break;
                case IrDaSelection.DoveTailSide:
                  this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.IrDaCombiHeadDoveTailSideIrDA);
                  break;
                case IrDaSelection.RoundSide:
                  this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.IrDaCombiHeadRoundSideInfrared);
                  break;
                default:
                  this.ComboBoxMiConSetup.SelectedIndex = -1;
                  break;
              }
              break;
            case MinoConnectBaseStates.RS232:
              this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.RS232_PowerOff);
              break;
            case MinoConnectBaseStates.RS232_3V:
              this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.RS232_3_3V);
              break;
            case MinoConnectBaseStates.RS232_7V:
              this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.RS232_7V);
              break;
            case MinoConnectBaseStates.RS485:
              this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.RS485_PowerOff);
              break;
            case MinoConnectBaseStates.RS485_3V:
              this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.RS485_3_3V);
              break;
            case MinoConnectBaseStates.RS485_7V:
              this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.RS485_7V);
              break;
            case MinoConnectBaseStates.Radio2Receive:
              this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.Radio2_receive);
              break;
            case MinoConnectBaseStates.Radio3Receive:
              this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.Radio3_receive);
              break;
            case MinoConnectBaseStates.WirelessMBus:
              this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.WirelessMBusReceive);
              break;
            case MinoConnectBaseStates.NDC_MiCon_Module:
              this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.NDC_MiCon_Module);
              break;
            case MinoConnectBaseStates.ZIN_CombiHead:
              switch (communicationObject.CombiHeadSelection)
              {
                case CombiHeadSelection.UART:
                  this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.ZIN_CombiHead_RoundSideZVEI);
                  break;
                case CombiHeadSelection.IrDA_DoveTailSide:
                  this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.ZIN_CombiHead_DoveTailSideIrDA);
                  break;
                case CombiHeadSelection.IrDa_RoundSide:
                  this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.ZIN_CombiHead_RoundSideIrDA);
                  break;
                case CombiHeadSelection.NFC:
                  this.SetMiConIndex(CommunicationPortWindow.MiConSetupEnum.ZIN_CombiHead_RoundSideNFC);
                  break;
                default:
                  this.ComboBoxMiConSetup.SelectedIndex = -1;
                  break;
              }
              break;
            default:
              this.ComboBoxMiConSetup.SelectedIndex = -1;
              break;
          }
        }
      }
      else
        this.GridMiConSetup.Visibility = Visibility.Collapsed;
    }

    private void SetMiConIndex(CommunicationPortWindow.MiConSetupEnum setupEnum)
    {
      this.ComboBoxMiConSetup.SelectedIndex = CommunicationPortWindow.MiConSetupList.FindIndex((Predicate<CommunicationPortWindow.MiConSetupElement>) (item => item.SetupEnum == setupEnum));
    }

    private void ShowCurrentState()
    {
      this.thePort = this.myWindowFunctions.portFunctions;
      if (this.thePort.IsOpen)
        this.ButtonOpenClose.Content = (object) "Close";
      else
        this.ButtonOpenClose.Content = (object) "Open";
      this.TextBlockComState.Text = this.myWindowFunctions.portFunctions.communicationObject.ToString();
      this.TextBoxDeviceInfo.Text = !(this.myWindowFunctions.portFunctions.communicationObject is CommunicationByMinoConnect) ? "" : ((CommunicationByMinoConnect) this.myWindowFunctions.portFunctions.communicationObject).GetDeviceInfo();
      this.EnableControls(this.thePort.IsOpen);
    }

    private void EnableControls(bool isOpen)
    {
      this.StackPanalSetup.IsEnabled = !isOpen;
      this.ButtonTiming.IsEnabled = !isOpen;
    }

    private void MiConBLE_Test_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        ulong BTMAC = 0;
        if (this.ComboBoxPort.SelectedItem != null)
        {
          if (this.ComboBoxPort.SelectedItem is ValueItem)
          {
            ValueItem selectedItem = this.ComboBoxPort.SelectedItem as ValueItem;
            if (selectedItem.AdditionalInfo.ContainsKey(AdditionalInfoKey.BluetoothAddress))
              BTMAC = ulong.Parse(selectedItem.AdditionalInfo[AdditionalInfoKey.BluetoothAddress], NumberStyles.HexNumber);
          }
          else if (this.ComboBoxPort.SelectedItem is string)
          {
            string selectedItem = (string) this.ComboBoxPort.SelectedItem;
            if (selectedItem.StartsWith("Mi"))
              BTMAC = Constants.GetMiConBLE_DeviceFromPort(selectedItem).BluetoothAddress;
          }
        }
        BluetoothChannel_LE BLE_Channel = (BluetoothChannel_LE) null;
        try
        {
          BLE_Channel = (BluetoothChannel_LE) this.myWindowFunctions.portFunctions.GetCommunicationByMinoConnect().channel;
          if (BLE_Channel != null)
            BTMAC = BLE_Channel.BTMAC;
        }
        catch
        {
        }
        MiConTestWindow miConTestWindow = new MiConTestWindow(this.myWindowFunctions, BTMAC, BLE_Channel);
        miConTestWindow.Owner = (Window) this;
        miConTestWindow.Show();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/CommunicationPort;component/userinterface/communicationportwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.menuMain = (Menu) target;
          break;
        case 2:
          this.MenuItemComponents = (MenuItem) target;
          break;
        case 3:
          this.MenuItemMiConBLE_TEST = (MenuItem) target;
          this.MenuItemMiConBLE_TEST.Click += new RoutedEventHandler(this.MiConBLE_Test_Click);
          break;
        case 4:
          this.gmmCorporateControl1 = (StartupLib.GmmCorporateControl) target;
          break;
        case 5:
          this.GroupBoxComState = (GroupBox) target;
          break;
        case 6:
          this.TextBlockComState = (TextBlock) target;
          break;
        case 7:
          this.GroupBoxDeviceInof = (GroupBox) target;
          break;
        case 8:
          this.TextBoxDeviceInfo = (TextBox) target;
          break;
        case 9:
          this.StackPanalSetup = (StackPanel) target;
          break;
        case 10:
          this.GridPortType = (Grid) target;
          break;
        case 11:
          this.LabelPortType = (Label) target;
          break;
        case 12:
          this.ComboBoxPortType = (ComboBox) target;
          this.ComboBoxPortType.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxPortType_SelectionChanged);
          break;
        case 13:
          this.GridPort = (Grid) target;
          break;
        case 14:
          this.LabelPort = (Label) target;
          break;
        case 15:
          this.ComboBoxPort = (ComboBox) target;
          this.ComboBoxPort.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxPort_SelectionChanged);
          this.ComboBoxPort.DropDownOpened += new EventHandler(this.ComboBoxPort_DropDownOpened);
          break;
        case 16:
          this.GridBaudrateParity = (Grid) target;
          break;
        case 17:
          this.LabelBaudrate = (Label) target;
          break;
        case 18:
          this.ComboBoxBaudrate = (ComboBox) target;
          this.ComboBoxBaudrate.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxBaudrate_SelectionChanged);
          break;
        case 19:
          this.LabelParity = (Label) target;
          break;
        case 20:
          this.ComboBoxParity = (ComboBox) target;
          this.ComboBoxParity.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxParity_SelectionChanged);
          break;
        case 21:
          this.GridWakeupEcho = (Grid) target;
          break;
        case 22:
          this.LabelWakeup = (Label) target;
          break;
        case 23:
          this.ComboBoxWakeup = (ComboBox) target;
          this.ComboBoxWakeup.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxWakeup_SelectionChanged);
          break;
        case 24:
          this.LabelEcho = (Label) target;
          break;
        case 25:
          this.ComboBoxEcho = (ComboBox) target;
          this.ComboBoxEcho.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxEcho_SelectionChanged);
          break;
        case 26:
          this.GridMiConSetup = (Grid) target;
          break;
        case 27:
          this.LabelMiConSetup = (Label) target;
          break;
        case 28:
          this.ComboBoxMiConSetup = (ComboBox) target;
          this.ComboBoxMiConSetup.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxMiConSetup_SelectionChanged);
          break;
        case 29:
          this.ButtonOpenClose = (Button) target;
          this.ButtonOpenClose.Click += new RoutedEventHandler(this.ButtonOpenClose_Click);
          break;
        case 30:
          this.ButtonTiming = (Button) target;
          this.ButtonTiming.Click += new RoutedEventHandler(this.ButtonTiming_Click);
          break;
        case 31:
          this.TextBoxChannel = (TextBox) target;
          break;
        case 32:
          this.TextBlockMessages = (TextBlock) target;
          break;
        case 33:
          this.TextBlockAlive = (TextBlock) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }

    internal class MiConSetupElement
    {
      internal CommunicationPortWindow.MiConSetupEnum SetupEnum;
      internal string SetupText;
    }

    internal enum MiConSetupEnum
    {
      IrDaCombiHeadRoundSideInfrared,
      IrDaCombiHeadDoveTailSideIrDA,
      IrDaCombiHeadRoundSideIrDA,
      RS232_PowerOff,
      RS232_3_3V,
      RS232_7V,
      RS485_PowerOff,
      RS485_3_3V,
      RS485_7V,
      Radio2_receive,
      Radio3_receive,
      WirelessMBusReceive,
      NDC_MiCon_Module,
      ZIN_CombiHead_RoundSideZVEI,
      ZIN_CombiHead_RoundSideIrDA,
      ZIN_CombiHead_DoveTailSideIrDA,
      ZIN_CombiHead_RoundSideNFC,
    }
  }
}


--- UserInterfaceMiConTestWindow.xaml.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: CommunicationPort.UserInterface.MiConTestWindow
// Assembly: CommunicationPort, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 4F7EB5DB-4517-47DC-B5F2-757F0B03AE01
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommunicationPort.dll

using CommonWPF;
using Microsoft.Win32;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.Ports;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using Windows.Devices.Enumeration;
using ZENNER.CommonLibrary;
using ZENNER.CommonLibrary.Entities;

#nullable disable
namespace CommunicationPort.UserInterface
{
  public partial class MiConTestWindow : Window, IComponentConnector
  {
    internal BluetoothChannel_LE BLE_Channel;
    internal CommunicationPortWindowFunctions MyWindowFunctions;
    private string TestPort;
    private SerialPort SerialTestPort;
    private ObservableCollection<BluetoothLEDeviceDisplay> KnownDevices = new ObservableCollection<BluetoothLEDeviceDisplay>();
    private List<DeviceInformation> UnknownDevices = new List<DeviceInformation>();
    private string SingleIndentString = "   ";
    private string IndentString = string.Empty;
    private int AsciiCommandStartIndex = -1;
    private Queue<byte> BluetoothReceiveQueue = new Queue<byte>();
    private List<string> CommandHistory = new List<string>();
    private int CommandHistoryIndex = 0;
    private Random BcTestCharacters = new Random();
    private Random BcTestWait = new Random();
    private Random BcTestDataCount = new Random();
    private Random BcTestData = new Random();
    private bool AutoTestOn = false;
    private ConcurrentQueue<byte> AutoReceiveQueue;
    private bool breakLoop;
    internal TabItem TabItemBasicCommands;
    internal StackPanel StackPanelBoxes;
    internal TextBox TextBoxOwnBLMAC;
    internal TextBox TextBoxMiConBLMAC;
    internal GroupBox GroupBoxInsertCommandTemplates;
    internal Button ButtonTypeCom115200;
    internal Button ButtonTypeBcTest;
    internal StackPanel StackPanelButtons;
    internal Button ButtonClear;
    internal Button ButtonConnectClose;
    internal TabItem TabItemAutoTests;
    internal Button ButtonBcRandomTest;
    internal Button ButtonBcRandomLoop;
    internal Button ButtonBreak;
    internal ComboBox ComboBoxTestComPort;
    internal Button ButtonTestCOM_open;
    internal Button ButtonTestCOM_open96;
    internal Button ButtonTestCOM_close;
    internal Button ButtonTestCOM_check;
    internal Button ButtonLoadHTermCommandLog;
    internal Button ButtonSendMany;
    internal Button ButtonSendParityError;
    internal Button ButtonSendFramingError;
    internal Button ButtonReceiveMany;
    internal TextBox TextBoxTerminal;
    internal TextBox TextBoxBinary;
    internal TextBox TextBoxTest;
    private bool _contentLoaded;

    public MiConTestWindow(
      CommunicationPortWindowFunctions comPortWindowsFunctions,
      ulong BTMAC,
      BluetoothChannel_LE BLE_Channel = null)
    {
      this.InitializeComponent();
      this.MyWindowFunctions = comPortWindowsFunctions;
      if (BTMAC > 0UL)
        this.TextBoxMiConBLMAC.Text = BTMAC.ToString("X");
      if (BLE_Channel != null)
      {
        this.BLE_Channel = BLE_Channel;
        if (BLE_Channel.IsConnected)
        {
          this.WriteTerminalLine("Device is connected. Use ASCII commands");
          this.StartCommandLine();
        }
      }
      if (this.MyWindowFunctions.IsPluginObject)
        this.TestPort = PlugInLoader.GmmConfiguration.GetValue("CommunicationPort", CommunicationPortWindowFunctions.ConfigVariables.MiConBLE_TestPort.ToString());
      this.SetComPortList();
      this.SetButtonConnectCloseState();
    }

    private void Window_Loaded(object sender, RoutedEventArgs e)
    {
      try
      {
        DateTime.Now.AddSeconds(5.0);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void Window_Closing(object sender, CancelEventArgs e)
    {
      try
      {
        if (this.MyWindowFunctions.portFunctions.IsOpen)
          this.MyWindowFunctions.Close();
        if (this.SerialTestPort == null || !this.SerialTestPort.IsOpen)
          return;
        this.SerialTestPort.Close();
      }
      catch
      {
      }
    }

    private void BluetootDataReceived(object sender, object parameter)
    {
      if (this.Dispatcher.Thread != Thread.CurrentThread)
      {
        try
        {
          this.Dispatcher.BeginInvoke((Delegate) new System.EventHandler(this.BluetootDataReceived), sender, parameter);
        }
        catch
        {
        }
      }
      else
      {
        if (!(parameter is ReceivedCountEventArgs))
          return;
        byte[] receivedData = this.BLE_Channel.GetReceivedData(((ReceivedCountEventArgs) parameter).Count);
        StringBuilder stringBuilder = new StringBuilder();
        foreach (byte num in receivedData)
        {
          stringBuilder.Append((char) num);
          this.BluetoothReceiveQueue.Enqueue(num);
        }
        this.DeleteCommandLine();
        this.WriteTerminalData("Data received (" + stringBuilder.Length.ToString() + "Byte):" + Environment.NewLine);
        string singleIndentString = this.SingleIndentString;
        this.SingleIndentString = " -> ";
        this.Indent();
        this.WriteTerminalData(stringBuilder.ToString());
        this.Unindent();
        this.SingleIndentString = singleIndentString;
        this.ShowBinaryData(receivedData, true);
        this.StartCommandLine();
      }
    }

    private void ShowBinaryData(byte[] data, bool received)
    {
      string hexStringFormated = ZR_ClassLibrary.Util.ByteArrayToHexStringFormated(data);
      if (received)
        this.TextBoxBinary.AppendText(Environment.NewLine + "<-" + DateTime.Now.ToString("mm:ss.fff") + ": " + hexStringFormated);
      else
        this.TextBoxBinary.AppendText(Environment.NewLine + "->" + DateTime.Now.ToString("mm:ss.fff") + ": " + hexStringFormated);
    }

    private async void ButtonConnectClose_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        if (this.ButtonConnectClose.Content.ToString() == "Connect to MiCon")
        {
          if (this.BLE_Channel == null)
          {
            ulong MiConBLMAC = ulong.Parse(this.TextBoxMiConBLMAC.Text, NumberStyles.HexNumber);
            this.BLE_Channel = new BluetoothChannel_LE(MiConBLMAC);
          }
          else
            this.BLE_Channel.OnDataReceived -= new System.EventHandler(this.BluetootDataReceived);
          this.BLE_Channel.OnDataReceived += new System.EventHandler(this.BluetootDataReceived);
          if (!this.BLE_Channel.IsConnected)
            await this.BLE_Channel.ConnectAsync();
          this.WriteTerminalLine("Device connected. Use ASCII commands");
          this.TabItemAutoTests.IsEnabled = true;
          this.GroupBoxInsertCommandTemplates.IsEnabled = true;
          this.StartCommandLine();
        }
        else
        {
          this.BLE_Channel.Close();
          this.WriteTerminalLine();
          this.WriteTerminalLine("Closed");
          this.TabItemAutoTests.IsEnabled = false;
          this.GroupBoxInsertCommandTemplates.IsEnabled = false;
        }
      }
      catch (Exception ex)
      {
        this.WriteTerminalLine("Bluetooth connection error");
        ExceptionViewer.Show(ex);
      }
      this.SetButtonConnectCloseState();
    }

    private void SetButtonConnectCloseState()
    {
      if (this.BLE_Channel == null || !this.BLE_Channel.IsConnected)
        this.ButtonConnectClose.Content = (object) "Connect to MiCon";
      else
        this.ButtonConnectClose.Content = (object) "Break MiCon connection";
    }

    private void StartCommandLine()
    {
      if (!this.TextBoxTerminal.Text.EndsWith(Environment.NewLine))
        this.TextBoxTerminal.AppendText(Environment.NewLine);
      this.SingleIndentString = "   ";
      this.IndentString = string.Empty;
      this.AsciiCommandStartIndex = this.TextBoxTerminal.Text.Length;
      this.TextBoxTerminal.AppendText("#");
      this.TextBoxTerminal.CaretIndex = this.TextBoxTerminal.Text.Length;
      this.TextBoxTerminal.ScrollToEnd();
      this.TextBoxTerminal.Focus();
    }

    private void DeleteCommandLine()
    {
      if (this.TextBoxTerminal.Text.Length <= this.AsciiCommandStartIndex)
        return;
      this.TextBoxTerminal.Select(this.AsciiCommandStartIndex, this.TextBoxTerminal.Text.Length - this.AsciiCommandStartIndex);
      this.TextBoxTerminal.SelectedText = "";
      this.AsciiCommandStartIndex = -1;
    }

    private void Indent() => this.IndentString += this.SingleIndentString;

    private void Unindent()
    {
      if (this.IndentString.Length > this.SingleIndentString.Length)
        this.IndentString = this.IndentString.Substring(this.SingleIndentString.Length);
      else
        this.IndentString = string.Empty;
    }

    private void WriteTerminalLine(string theLine = "")
    {
      this.AsciiCommandStartIndex = -1;
      this.TextBoxTerminal.AppendText(this.IndentString + theLine + Environment.NewLine);
      this.TextBoxTerminal.Focus();
      this.TextBoxTerminal.CaretIndex = this.TextBoxTerminal.Text.Length;
    }

    private void WriteTerminalData(string theData = "")
    {
      this.TextBoxTerminal.AppendText(this.IndentString + theData);
    }

    private static string ByteArrayToString(byte[] data)
    {
      if (data == null)
        return "<NULL>";
      StringBuilder stringBuilder = new StringBuilder();
      foreach (byte num in data)
        stringBuilder.Append(num.ToString("X"));
      return stringBuilder.ToString();
    }

    private async void TextBoxTerminal_KeyDown(object sender, KeyEventArgs e)
    {
      if (e.Key != Key.Return)
        return;
      if (this.BLE_Channel != null && this.BLE_Channel.IsConnected && this.AsciiCommandStartIndex < this.TextBoxTerminal.Text.Length)
      {
        e.Handled = true;
        try
        {
          if (this.BLE_Channel.IsConnected && this.AsciiCommandStartIndex >= 0)
          {
            string commandString = this.TextBoxTerminal.Text.Substring(this.AsciiCommandStartIndex);
            this.CommandHistory.Add(commandString);
            this.CommandHistoryIndex = this.CommandHistory.Count;
            byte[] data = (byte[]) null;
            int endIndex = commandString.IndexOf("\\n");
            if (endIndex >= 0)
            {
              string hexDataString = commandString.Substring(endIndex + 2);
              data = ZR_ClassLibrary.Util.HexStringToByteArray(hexDataString);
              commandString = commandString.Substring(0, endIndex);
              hexDataString = (string) null;
            }
            byte[] commandBytes = Encoding.ASCII.GetBytes(commandString + "\r\n");
            if (data != null)
            {
              int length = commandBytes.Length;
              Array.Resize<byte>(ref commandBytes, commandBytes.Length + data.Length);
              data.CopyTo((Array) commandBytes, length);
              this.ShowBinaryData(data, false);
            }
            this.StartCommandLine();
            await this.BLE_Channel.SendData(commandBytes);
            commandString = (string) null;
            data = (byte[]) null;
            commandBytes = (byte[]) null;
          }
          else
            this.WriteTerminalLine("Command not prepared. Data not send.");
        }
        catch (Exception ex)
        {
          this.WriteTerminalLine("Bluetooth send command error");
          ExceptionViewer.Show(ex);
        }
      }
      else
        e.Handled = false;
    }

    private void TextBoxTerminal_PreviewKeyDown(object sender, KeyEventArgs e)
    {
      if (this.AsciiCommandStartIndex < 0)
        return;
      if (e.Key == Key.Up)
      {
        e.Handled = true;
        if (this.AsciiCommandStartIndex < this.TextBoxTerminal.Text.Length && this.CommandHistory.Count > 0)
        {
          this.TextBoxTerminal.Select(this.AsciiCommandStartIndex, this.TextBoxTerminal.Text.Length - this.AsciiCommandStartIndex);
          this.TextBoxTerminal.SelectedText = "";
          --this.CommandHistoryIndex;
          if (this.CommandHistoryIndex < 0)
            this.CommandHistoryIndex = this.CommandHistory.Count - 1;
          this.TextBoxTerminal.AppendText(this.CommandHistory[this.CommandHistoryIndex]);
        }
      }
      if (e.Key == Key.Down)
      {
        e.Handled = true;
        if (this.AsciiCommandStartIndex < this.TextBoxTerminal.Text.Length && this.CommandHistory.Count > 0)
        {
          this.TextBoxTerminal.Select(this.AsciiCommandStartIndex, this.TextBoxTerminal.Text.Length - this.AsciiCommandStartIndex);
          this.TextBoxTerminal.SelectedText = "";
          ++this.CommandHistoryIndex;
          if (this.CommandHistoryIndex >= this.CommandHistory.Count)
            this.CommandHistoryIndex = 0;
          this.TextBoxTerminal.AppendText(this.CommandHistory[this.CommandHistoryIndex]);
        }
      }
    }

    private void ButtonTypeCom115200_Click(object sender, RoutedEventArgs e)
    {
      this.DeleteCommandLine();
      this.StartCommandLine();
      this.TextBoxTerminal.AppendText("com rs232 115200 8e1");
      this.TextBoxTerminal.Focus();
    }

    private void ButtonTypeBcTest_Click(object sender, RoutedEventArgs e)
    {
      this.DeleteCommandLine();
      this.StartCommandLine();
      this.TextBoxTerminal.AppendText("bc 1000,10,3\\n010203");
      this.TextBoxTerminal.Focus();
    }

    private async void ButtonBcRandomLoop_Click(object sender, RoutedEventArgs e)
    {
      this.DeleteCommandLine();
      this.IndentString = string.Empty;
      this.WriteTerminalLine("*** Random bc test loop ***");
      this.Indent();
      this.AutoTestOn = true;
      this.AutoReceiveQueue = new ConcurrentQueue<byte>();
      this.breakLoop = false;
      while (!this.breakLoop)
        await this.BcRandomTest();
      this.AutoTestOn = false;
      this.Unindent();
      this.StartCommandLine();
    }

    private async void ButtonBcRandomTest_Click(object sender, RoutedEventArgs e)
    {
      this.DeleteCommandLine();
      this.IndentString = string.Empty;
      this.WriteTerminalLine("*** Random bc test ***");
      this.Indent();
      this.AutoTestOn = true;
      this.AutoReceiveQueue = new ConcurrentQueue<byte>();
      await this.BcRandomTest();
      this.AutoTestOn = false;
      this.Unindent();
      this.StartCommandLine();
    }

    private async Task BcRandomTest()
    {
      byte[] data = (byte[]) null;
      byte[] wakeupData;
      try
      {
        int WakeupChars = this.BcTestCharacters.Next(1, 3000);
        wakeupData = new byte[WakeupChars];
        for (int i = 0; i < wakeupData.Length; ++i)
          wakeupData[i] = (byte) 85;
        int Wait_10ms = this.BcTestWait.Next(1, 30);
        int DataCount = this.BcTestDataCount.Next(0, 500);
        data = new byte[DataCount];
        for (int i = 0; i < DataCount; ++i)
        {
          byte nextByte;
          do
          {
            nextByte = (byte) this.BcTestData.Next(0, (int) byte.MaxValue);
          }
          while (nextByte == (byte) 35);
          data[i] = nextByte;
        }
        string command = "#bc " + WakeupChars.ToString() + "," + Wait_10ms.ToString() + "," + DataCount.ToString() + "\r\n";
        this.WriteTerminalLine(command);
        byte[] commandBytes = Encoding.ASCII.GetBytes(command);
        int commandLength = commandBytes.Length;
        Array.Resize<byte>(ref commandBytes, commandLength + data.Length);
        data.CopyTo((Array) commandBytes, commandLength);
        int command_ms = (int) (0.0 * (double) commandBytes.Length + (double) (Wait_10ms * 10));
        DateTime startTime = DateTime.Now;
        DateTime errorTime = startTime.AddSeconds(10.0);
        await this.BLE_Channel.SendData(commandBytes);
        while (this.AutoReceiveQueue.Count == 0)
        {
          if (DateTime.Now > errorTime)
            throw new TimeoutException();
        }
        DateTime firstWakeupByteTime = DateTime.Now;
        for (int i = 0; i < WakeupChars; ++i)
        {
          while (this.AutoReceiveQueue.Count == 0)
          {
            if (DateTime.Now > errorTime)
              throw new TimeoutException();
            await Task.Delay(1);
          }
          byte nextByte;
          if (!this.AutoReceiveQueue.TryDequeue(out nextByte))
            throw new Exception("Unexpected dequeue result");
          if (nextByte != (byte) 85)
            throw new Exception("Illegal wakeup byte! index:" + i.ToString() + " req:0x55 rec:0x" + nextByte.ToString("x02"));
        }
        DateTime wakeupEndTime = DateTime.Now;
        while (this.AutoReceiveQueue.Count == 0)
        {
          if (DateTime.Now > errorTime)
            throw new TimeoutException();
        }
        DateTime firstDataByteTime = DateTime.Now;
        for (int i = 0; i < data.Length; ++i)
        {
          while (this.AutoReceiveQueue.Count == 0)
          {
            if (DateTime.Now > errorTime)
              throw new TimeoutException();
            await Task.Delay(1);
          }
          byte nextByte;
          if (!this.AutoReceiveQueue.TryDequeue(out nextByte))
            throw new Exception("Unexpected dequeue result");
          if ((int) nextByte != (int) data[i])
            throw new Exception("Illegal date byte! index:" + i.ToString() + " req:0x" + data[i].ToString("x02") + " rec:0x" + nextByte.ToString("x02"));
        }
        this.WriteTerminalLine("Random bc test ok");
        command = (string) null;
        commandBytes = (byte[]) null;
        wakeupData = (byte[]) null;
        data = (byte[]) null;
      }
      catch (Exception ex)
      {
        this.WriteTerminalLine("Random bc test Exception: " + ex.Message);
        if (data == null)
        {
          wakeupData = (byte[]) null;
          data = (byte[]) null;
        }
        else
        {
          string dataString = ZR_ClassLibrary.Util.ByteArrayToHexStringFormated(data);
          this.WriteTerminalLine("data: " + dataString);
          dataString = (string) null;
          wakeupData = (byte[]) null;
          data = (byte[]) null;
        }
      }
    }

    private void ButtonClear_Click(object sender, RoutedEventArgs e)
    {
      this.TextBoxTerminal.Clear();
      this.TextBoxBinary.Clear();
      this.TextBoxTest.Clear();
    }

    private void ButtonLoadHTermCommandLog_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        OpenFileDialog openFileDialog = new OpenFileDialog();
        openFileDialog.DefaultExt = ".log";
        openFileDialog.Filter = "HTerm log file (.log)|*.log";
        openFileDialog.CheckFileExists = true;
        openFileDialog.Multiselect = false;
        bool? nullable = openFileDialog.ShowDialog();
        bool flag = true;
        if (!(nullable.GetValueOrDefault() == flag & nullable.HasValue))
          return;
        string end;
        using (StreamReader streamReader = new StreamReader(openFileDialog.FileName, Encoding.ASCII))
          end = streamReader.ReadToEnd();
        if (string.IsNullOrEmpty(end))
          throw new Exception("No data");
        this.WriteTerminalLine();
        this.WriteTerminalLine("HTerm command log");
        MiConTestWindow.readState readState = MiConTestWindow.readState.Wait02;
        ushort num1 = 0;
        int num2 = 0;
        StringBuilder stringBuilder1 = new StringBuilder();
        StringBuilder stringBuilder2 = new StringBuilder();
        StringBuilder stringBuilder3 = new StringBuilder();
        byte num3 = 0;
        foreach (char ch in end)
        {
          byte num4 = (byte) ch;
          if (readState != MiConTestWindow.readState.CS)
            num3 ^= num4;
          switch (readState)
          {
            case MiConTestWindow.readState.Wait02:
              stringBuilder1.Clear();
              stringBuilder2.Clear();
              if (num4 != (byte) 2)
              {
                this.WriteTerminalLine("Illegal start byte: 0x" + num4.ToString("x02"));
                break;
              }
              stringBuilder1.Append("02 ");
              readState = MiConTestWindow.readState.Command;
              break;
            case MiConTestWindow.readState.Command:
              stringBuilder1.Append(num4.ToString("x02") + " ");
              readState = MiConTestWindow.readState.LengthLow;
              break;
            case MiConTestWindow.readState.LengthLow:
              num1 = (ushort) num4;
              readState = MiConTestWindow.readState.LengthHigh;
              break;
            case MiConTestWindow.readState.LengthHigh:
              num1 += (ushort) ((uint) num4 << 8);
              stringBuilder1.Append(num1.ToString("d4") + " ");
              num2 = 0;
              readState = MiConTestWindow.readState.Data;
              break;
            case MiConTestWindow.readState.Data:
              stringBuilder2.Append(ch);
              stringBuilder1.Append(num4.ToString("x02"));
              ++num2;
              if (num2 >= (int) num1)
              {
                readState = MiConTestWindow.readState.CS;
                break;
              }
              break;
            case MiConTestWindow.readState.CS:
              stringBuilder1.Append(" CS:" + num4.ToString("x02"));
              if ((int) num4 == (int) num3)
                stringBuilder1.Append("->OK");
              else
                stringBuilder1.Append("->Error");
              num3 = (byte) 0;
              this.WriteTerminalLine(stringBuilder1.ToString());
              stringBuilder3.AppendLine(stringBuilder2.ToString());
              readState = MiConTestWindow.readState.Wait02;
              break;
          }
        }
        this.WriteTerminalLine();
        this.WriteTerminalLine("ASCII data from HTerm log");
        this.WriteTerminalLine(stringBuilder3.ToString());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ComboBoxTestComPort_DropDownOpened(object sender, EventArgs e)
    {
      this.SetComPortList();
    }

    private void SetComPortList()
    {
      string mainPort = this.MyWindowFunctions.GetReadoutConfiguration().Port;
      List<ValueItem> availableComPorts = Constants.GetAvailableComPorts();
      int index1 = availableComPorts.FindIndex((Predicate<ValueItem>) (item => item.Value == mainPort));
      if (index1 >= 0)
        availableComPorts.RemoveAt(index1);
      if (availableComPorts.Count == 0)
      {
        this.ComboBoxTestComPort.Items.Clear();
        this.ComboBoxTestComPort.Items.Add((object) "Test COM port not available");
        this.StackPanelButtons.IsEnabled = false;
      }
      else if (this.ComboBoxTestComPort.SelectedItem == null || !(this.ComboBoxTestComPort.SelectedItem is ValueItem))
      {
        this.ComboBoxTestComPort.ItemsSource = (IEnumerable) availableComPorts;
        if (this.TestPort != null)
        {
          int index2 = availableComPorts.FindIndex((Predicate<ValueItem>) (item => item.Value == this.TestPort));
          if (index2 >= 0)
            this.ComboBoxTestComPort.SelectedIndex = index2;
        }
        if (this.ComboBoxTestComPort.SelectedIndex >= 0)
          return;
        this.ComboBoxTestComPort.SelectedIndex = 0;
      }
      else
      {
        ValueItem selectedItemBefore = this.ComboBoxTestComPort.SelectedItem as ValueItem;
        this.ComboBoxTestComPort.ItemsSource = (IEnumerable) availableComPorts;
        int index3 = availableComPorts.FindIndex((Predicate<ValueItem>) (item => item.Value == selectedItemBefore.Value));
        if (index3 >= 0)
          this.ComboBoxTestComPort.SelectedIndex = index3;
      }
    }

    private void ComboBoxMinoConnectComPort_SelectionChanged(
      object sender,
      SelectionChangedEventArgs e)
    {
      this.TestPort = (string) null;
      if (this.ComboBoxTestComPort.SelectedIndex < 0 || !(this.ComboBoxTestComPort.SelectedItem is ValueItem))
        return;
      this.TestPort = ((ValueItem) this.ComboBoxTestComPort.SelectedItem).Value;
      if (!this.MyWindowFunctions.IsPluginObject)
        return;
      PlugInLoader.GmmConfiguration.SetOrUpdateValue("CommunicationPort", CommunicationPortWindowFunctions.ConfigVariables.MiConBLE_TestPort.ToString(), this.TestPort);
    }

    private void ButtonTestCOM_open_Click(object sender, RoutedEventArgs e) => this.OpenCom(115200);

    private void ButtonTestCOM_open96_Click(object sender, RoutedEventArgs e) => this.OpenCom(9600);

    private void OpenCom(int baud)
    {
      try
      {
        if (this.SerialTestPort == null)
        {
          this.SerialTestPort = new SerialPort();
          this.SerialTestPort.PortName = this.TestPort;
          this.SerialTestPort.BaudRate = baud;
          this.SerialTestPort.Parity = Parity.Even;
          this.SerialTestPort.WriteTimeout = 5000;
          this.SerialTestPort.DtrEnable = true;
          this.SerialTestPort.ParityReplace = (byte) 0;
        }
        if (!this.SerialTestPort.IsOpen)
          this.SerialTestPort.Open();
        this.SerialTestPort.DataReceived -= new System.IO.Ports.SerialDataReceivedEventHandler(this.SerialDataReceivedEventHandler);
        this.SerialTestPort.DataReceived += new System.IO.Ports.SerialDataReceivedEventHandler(this.SerialDataReceivedEventHandler);
        this.DeleteCommandLine();
        this.WriteTerminalLine("Test COM opened: " + this.SerialTestPort.PortName);
        this.ButtonSendFramingError.IsEnabled = true;
        this.ButtonSendMany.IsEnabled = true;
        this.ButtonSendParityError.IsEnabled = true;
        this.ButtonReceiveMany.IsEnabled = true;
        this.ButtonBcRandomLoop.IsEnabled = true;
        this.ButtonBcRandomTest.IsEnabled = true;
        this.ButtonTestCOM_close.IsEnabled = true;
        this.ButtonTestCOM_check.IsEnabled = true;
        this.StartCommandLine();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonTestCOM_close_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        if (this.SerialTestPort != null)
        {
          this.SerialTestPort.Close();
          this.SerialTestPort = (SerialPort) null;
        }
      }
      catch
      {
      }
      this.ButtonSendFramingError.IsEnabled = false;
      this.ButtonSendMany.IsEnabled = false;
      this.ButtonSendParityError.IsEnabled = false;
      this.ButtonReceiveMany.IsEnabled = false;
      this.ButtonBcRandomLoop.IsEnabled = false;
      this.ButtonBcRandomTest.IsEnabled = false;
      this.ButtonTestCOM_close.IsEnabled = false;
      this.ButtonTestCOM_check.IsEnabled = false;
    }

    private void SerialDataReceivedEventHandler(object sender, SerialDataReceivedEventArgs e)
    {
      int bytesToRead = this.SerialTestPort.BytesToRead;
      byte[] numArray = new byte[bytesToRead];
      this.SerialTestPort.Read(numArray, 0, bytesToRead);
      if (this.AutoTestOn)
      {
        for (int index = 0; index < numArray.Length; ++index)
          this.AutoReceiveQueue.Enqueue(numArray[index]);
      }
      this.TestDataReceived((object) this, numArray);
    }

    private void TestDataReceived(object sender, byte[] byteData)
    {
      if (this.Dispatcher.Thread != Thread.CurrentThread)
      {
        try
        {
          this.Dispatcher.BeginInvoke((Delegate) new EventHandler<byte[]>(this.TestDataReceived), sender, (object) byteData);
        }
        catch
        {
        }
      }
      else
      {
        string hexStringFormated = ZR_ClassLibrary.Util.ByteArrayToHexStringFormated(byteData);
        this.TextBoxTest.AppendText(DateTime.Now.ToString("mm:ss.fff;") + byteData.Length.ToString() + ": " + hexStringFormated + Environment.NewLine);
      }
    }

    private void ButtonTestCOM_check_Click(object sender, RoutedEventArgs e)
    {
      this.DeleteCommandLine();
      this.WriteTerminalLine("Test COM check:");
      this.Indent();
      if (this.SerialTestPort == null)
        this.WriteTerminalLine("Port object not evailable");
      else if (!this.SerialTestPort.IsOpen)
      {
        this.WriteTerminalLine("Test port not open");
      }
      else
      {
        int bytesToRead = this.SerialTestPort.BytesToRead;
        this.WriteTerminalLine("BytesToRead: " + bytesToRead.ToString());
        if (bytesToRead > 0)
        {
          byte[] buffer = new byte[bytesToRead];
          this.SerialTestPort.Read(buffer, 0, bytesToRead);
          this.WriteTerminalLine("Received bytes: " + ZR_ClassLibrary.Util.ByteArrayToHexString(buffer));
        }
        this.StartCommandLine();
      }
    }

    private void ButtonBreak_Click(object sender, RoutedEventArgs e) => this.breakLoop = true;

    private void ButtonSendMany_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        byte[] numArray = new byte[20000];
        for (int index = 0; index < numArray.Length; ++index)
          numArray[index] = (byte) (index + 85 & (int) byte.MaxValue);
        this.SerialTestPort.Write(numArray, 0, numArray.Length);
        this.ShowBinaryData(numArray, false);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonSendParityError_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.SerialTestPort.Close();
        this.SerialTestPort.Parity = Parity.Odd;
        this.SerialTestPort.Open();
        byte[] numArray = new byte[10];
        for (int index = 0; index < numArray.Length; ++index)
          numArray[index] = (byte) (index + 85 & (int) byte.MaxValue);
        this.SerialTestPort.Write(numArray, 0, numArray.Length);
        this.ShowBinaryData(numArray, false);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.SerialTestPort.Close();
      this.SerialTestPort.Parity = Parity.Even;
      this.SerialTestPort.Open();
    }

    private void ButtonSendFramingError_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.SerialTestPort.Close();
        this.SerialTestPort.DataBits = 7;
        this.SerialTestPort.Open();
        byte[] numArray = new byte[10];
        for (int index = 0; index < numArray.Length; ++index)
          numArray[index] = (byte) (index + 85 & (int) byte.MaxValue);
        this.SerialTestPort.Write(numArray, 0, numArray.Length);
        this.ShowBinaryData(numArray, false);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.SerialTestPort.Close();
      this.SerialTestPort.DataBits = 8;
      this.SerialTestPort.Open();
    }

    private async void ButtonReceiveMany_Click(object sender, RoutedEventArgs e)
    {
      this.DeleteCommandLine();
      this.IndentString = string.Empty;
      this.WriteTerminalLine("*** ReceiveMany ***");
      this.Indent();
      this.AutoTestOn = true;
      this.AutoReceiveQueue = new ConcurrentQueue<byte>();
      try
      {
        List<byte> dataList = new List<byte>();
        byte[] byteArray = new byte[20000];
        for (int i = 0; i < 20000; ++i)
        {
          byte theByte = (byte) (i + 85 & (int) byte.MaxValue);
          byteArray[i] = theByte;
          dataList.Add(theByte);
          if (theByte == (byte) 35)
            dataList.Add(theByte);
        }
        byte[] buffer = dataList.ToArray();
        this.ShowBinaryData(buffer, true);
        int num = byteArray.Length;
        this.WriteTerminalLine("Transmit byte count: " + num.ToString());
        await this.BLE_Channel.SendData(buffer);
        int receiceCount = 0;
        while (true)
        {
          await Task.Delay(2000);
          if (this.AutoReceiveQueue.Count != receiceCount)
            receiceCount = this.AutoReceiveQueue.Count;
          else
            break;
        }
        this.WriteTerminalLine("Receive byte count: " + receiceCount.ToString());
        for (int i = 0; i < receiceCount; num = i++)
        {
          byte qb = 0;
          if (!this.AutoReceiveQueue.TryDequeue(out qb))
            throw new Exception("TryDequeue error");
          if ((int) qb != (int) byteArray[i])
          {
            this.WriteTerminalLine("First difference at index: " + i.ToString());
            this.WriteTerminalLine("  Transmit byte: 0x: " + byteArray[i].ToString("x02"));
            this.WriteTerminalLine("  Receive  byte: 0x: " + qb.ToString("x02"));
            break;
          }
        }
        dataList = (List<byte>) null;
        byteArray = (byte[]) null;
        buffer = (byte[]) null;
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.AutoTestOn = false;
      this.Unindent();
      this.StartCommandLine();
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/CommunicationPort;component/userinterface/micontestwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          ((FrameworkElement) target).Loaded += new RoutedEventHandler(this.Window_Loaded);
          ((Window) target).Closing += new CancelEventHandler(this.Window_Closing);
          break;
        case 2:
          this.TabItemBasicCommands = (TabItem) target;
          break;
        case 3:
          this.StackPanelBoxes = (StackPanel) target;
          break;
        case 4:
          this.TextBoxOwnBLMAC = (TextBox) target;
          break;
        case 5:
          this.TextBoxMiConBLMAC = (TextBox) target;
          break;
        case 6:
          this.GroupBoxInsertCommandTemplates = (GroupBox) target;
          break;
        case 7:
          this.ButtonTypeCom115200 = (Button) target;
          this.ButtonTypeCom115200.Click += new RoutedEventHandler(this.ButtonTypeCom115200_Click);
          break;
        case 8:
          this.ButtonTypeBcTest = (Button) target;
          this.ButtonTypeBcTest.Click += new RoutedEventHandler(this.ButtonTypeBcTest_Click);
          break;
        case 9:
          this.StackPanelButtons = (StackPanel) target;
          break;
        case 10:
          this.ButtonClear = (Button) target;
          this.ButtonClear.Click += new RoutedEventHandler(this.ButtonClear_Click);
          break;
        case 11:
          this.ButtonConnectClose = (Button) target;
          this.ButtonConnectClose.Click += new RoutedEventHandler(this.ButtonConnectClose_Click);
          break;
        case 12:
          this.TabItemAutoTests = (TabItem) target;
          break;
        case 13:
          this.ButtonBcRandomTest = (Button) target;
          this.ButtonBcRandomTest.Click += new RoutedEventHandler(this.ButtonBcRandomTest_Click);
          break;
        case 14:
          this.ButtonBcRandomLoop = (Button) target;
          this.ButtonBcRandomLoop.Click += new RoutedEventHandler(this.ButtonBcRandomLoop_Click);
          break;
        case 15:
          this.ButtonBreak = (Button) target;
          this.ButtonBreak.Click += new RoutedEventHandler(this.ButtonBreak_Click);
          break;
        case 16:
          this.ComboBoxTestComPort = (ComboBox) target;
          this.ComboBoxTestComPort.DropDownOpened += new System.EventHandler(this.ComboBoxTestComPort_DropDownOpened);
          this.ComboBoxTestComPort.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxMinoConnectComPort_SelectionChanged);
          break;
        case 17:
          this.ButtonTestCOM_open = (Button) target;
          this.ButtonTestCOM_open.Click += new RoutedEventHandler(this.ButtonTestCOM_open_Click);
          break;
        case 18:
          this.ButtonTestCOM_open96 = (Button) target;
          this.ButtonTestCOM_open96.Click += new RoutedEventHandler(this.ButtonTestCOM_open96_Click);
          break;
        case 19:
          this.ButtonTestCOM_close = (Button) target;
          this.ButtonTestCOM_close.Click += new RoutedEventHandler(this.ButtonTestCOM_close_Click);
          break;
        case 20:
          this.ButtonTestCOM_check = (Button) target;
          this.ButtonTestCOM_check.Click += new RoutedEventHandler(this.ButtonTestCOM_check_Click);
          break;
        case 21:
          this.ButtonLoadHTermCommandLog = (Button) target;
          this.ButtonLoadHTermCommandLog.Click += new RoutedEventHandler(this.ButtonLoadHTermCommandLog_Click);
          break;
        case 22:
          this.ButtonSendMany = (Button) target;
          this.ButtonSendMany.Click += new RoutedEventHandler(this.ButtonSendMany_Click);
          break;
        case 23:
          this.ButtonSendParityError = (Button) target;
          this.ButtonSendParityError.Click += new RoutedEventHandler(this.ButtonSendParityError_Click);
          break;
        case 24:
          this.ButtonSendFramingError = (Button) target;
          this.ButtonSendFramingError.Click += new RoutedEventHandler(this.ButtonSendFramingError_Click);
          break;
        case 25:
          this.ButtonReceiveMany = (Button) target;
          this.ButtonReceiveMany.Click += new RoutedEventHandler(this.ButtonReceiveMany_Click);
          break;
        case 26:
          this.TextBoxTerminal = (TextBox) target;
          this.TextBoxTerminal.KeyDown += new KeyEventHandler(this.TextBoxTerminal_KeyDown);
          this.TextBoxTerminal.PreviewKeyDown += new KeyEventHandler(this.TextBoxTerminal_PreviewKeyDown);
          break;
        case 27:
          this.TextBoxBinary = (TextBox) target;
          break;
        case 28:
          this.TextBoxTest = (TextBox) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }

    private enum readState
    {
      Wait02,
      Command,
      LengthLow,
      LengthHigh,
      Data,
      CS,
    }
  }
}


--- UserInterfaceTimingWindow.xaml.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: CommunicationPort.UserInterface.TimingWindow
// Assembly: CommunicationPort, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 4F7EB5DB-4517-47DC-B5F2-757F0B03AE01
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\CommunicationPort.dll

using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;

#nullable disable
namespace CommunicationPort.UserInterface
{
  public partial class TimingWindow : Window, IComponentConnector
  {
    private CommunicationPortWindowFunctions myWindowFunctions;
    private bool formInit;
    internal GmmCorporateControl gmmCorporateControl1;
    internal TextBox TextBoxWakeup;
    internal TextBlock TextBlockWakeup;
    internal TextBox TextBoxAfterWaktup;
    internal TextBlock TextBlockAfterWaktup;
    internal TextBox TextBoxBeforFirstByte;
    internal TextBlock TextBlockBeforFirstByte;
    internal TextBox TextBoxByteOffset;
    internal TextBlock TextBlockByteOffset;
    internal TextBox TextBoxBlockOffset;
    internal TextBlock TextBlockBlockOffset;
    internal TextBox TextBoxWakeupIntervall;
    internal TextBlock TextBlockWakeupRepeat;
    internal TextBox TextBoxOffset;
    internal TextBlock TextBlockOffset;
    internal TextBox TextBoxBeforNextRequest;
    internal TextBlock TextBlockBeforNextRequest;
    internal TextBox TextBoxAfterOpen;
    internal TextBlock TextBlockAfterOpen;
    internal TextBox TextBoxBeforeRepeat;
    internal TextBlock TextBlockBeforeRepeat;
    internal TextBox TextBoxMiConPowerOffTime;
    internal TextBlock TextBlockMiConPowerOffTime;
    internal TextBox TextBoxIrDaPulsLength;
    internal TextBlock TextBlockIrDaPulsLength;
    internal TextBox TextBoxMiConStateTimeout;
    internal TextBlock TextBlockMiConStateTimeout;
    internal Button ButtonShowConfig;
    internal Button ButtonShowChanges;
    private bool _contentLoaded;

    public TimingWindow(CommunicationPortWindowFunctions myWindowFunctions)
    {
      this.myWindowFunctions = myWindowFunctions;
      this.formInit = true;
      this.InitializeComponent();
      this.RefreshAll();
      this.formInit = false;
    }

    private void RefreshAll()
    {
      this.TextBoxAfterOpen.Text = this.myWindowFunctions.portFunctions.configList.TransTime_AfterOpen.ToString();
      this.TextBoxBeforFirstByte.Text = this.myWindowFunctions.portFunctions.configList.RecTime_BeforFirstByte.ToString();
      this.TextBoxByteOffset.Text = this.myWindowFunctions.portFunctions.configList.RecTime_OffsetPerByte.ToString();
      this.TextBoxBlockOffset.Text = this.myWindowFunctions.portFunctions.configList.RecTime_OffsetPerBlock.ToString();
      this.TextBoxOffset.Text = this.myWindowFunctions.portFunctions.configList.RecTime_GlobalOffset.ToString();
      this.TextBoxBeforNextRequest.Text = this.myWindowFunctions.portFunctions.configList.RecTransTime.ToString();
      this.TextBoxBeforeRepeat.Text = this.myWindowFunctions.portFunctions.configList.WaitBeforeRepeatTime.ToString();
      this.TextBoxWakeup.Text = this.myWindowFunctions.portFunctions.configList.TransTime_BreakTime.ToString();
      this.TextBoxAfterWaktup.Text = this.myWindowFunctions.portFunctions.configList.TransTime_AfterBreak.ToString();
      this.TextBoxWakeupIntervall.Text = this.myWindowFunctions.portFunctions.configList.BreakIntervalTime.ToString();
      this.TextBoxMiConPowerOffTime.Text = this.myWindowFunctions.portFunctions.configList.MinoConnectPowerOffTime.ToString();
      this.TextBoxIrDaPulsLength.Text = this.myWindowFunctions.portFunctions.configList.MinoConnectIrDaPulseTime.ToString();
      this.TextBoxMiConStateTimeout.Text = this.myWindowFunctions.portFunctions.communicationObject.PollingErrorTime_ms.ToString();
    }

    private void TextBoxRefreshAllOn_LostFocus(object sender, RoutedEventArgs e)
    {
      if (this.formInit)
        return;
      this.RefreshAll();
    }

    private void TextBoxAfterOpen_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxAfterOpen.Text, out result))
        this.myWindowFunctions.portFunctions.configList.TransTime_AfterOpen = result;
      else
        this.TextBoxAfterOpen.Text = "";
    }

    private void TextBoxWakeup_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxWakeup.Text, out result))
        this.myWindowFunctions.portFunctions.configList.TransTime_BreakTime = result;
      else
        this.TextBoxWakeup.Text = "";
    }

    private void TextBoxAfterWaktup_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxAfterWaktup.Text, out result))
        this.myWindowFunctions.portFunctions.configList.TransTime_AfterBreak = result;
      else
        this.TextBoxAfterWaktup.Text = "";
    }

    private void TextBoxBeforFirstByte_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxBeforFirstByte.Text, out result))
        this.myWindowFunctions.portFunctions.configList.RecTime_BeforFirstByte = result;
      else
        this.TextBoxBeforFirstByte.Text = "";
    }

    private void TextBoxByteOffset_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxByteOffset.Text, out result))
        this.myWindowFunctions.portFunctions.configList.RecTime_OffsetPerByte = result;
      else
        this.TextBoxByteOffset.Text = "";
    }

    private void TextBoxBlockOffset_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxBlockOffset.Text, out result))
        this.myWindowFunctions.portFunctions.configList.RecTime_OffsetPerBlock = result;
      else
        this.TextBoxBlockOffset.Text = "";
    }

    private void TextBoxWakeupIntervall_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxWakeupIntervall.Text, out result))
        this.myWindowFunctions.portFunctions.configList.BreakIntervalTime = result;
      else
        this.TextBoxWakeupIntervall.Text = "";
    }

    private void TextBoxOffset_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxOffset.Text, out result))
        this.myWindowFunctions.portFunctions.configList.RecTime_GlobalOffset = result;
      else
        this.TextBoxOffset.Text = "";
    }

    private void TextBoxBeforNextRequest_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxBeforNextRequest.Text, out result))
        this.myWindowFunctions.portFunctions.configList.RecTransTime = result;
      else
        this.TextBoxBeforNextRequest.Text = "";
    }

    private void TextBoxBeforeRepeat_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxBeforeRepeat.Text, out result))
        this.myWindowFunctions.portFunctions.configList.WaitBeforeRepeatTime = result;
      else
        this.TextBoxBeforeRepeat.Text = "";
    }

    private void TextBoxMiConPowerOffTime_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxMiConPowerOffTime.Text, out result))
        this.myWindowFunctions.portFunctions.configList.MinoConnectPowerOffTime = result;
      else
        this.TextBoxMiConPowerOffTime.Text = "";
    }

    private void TextBoxIrDaPulsLength_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxIrDaPulsLength.Text, out result))
        this.myWindowFunctions.portFunctions.configList.MinoConnectIrDaPulseTime = result;
      else
        this.TextBoxIrDaPulsLength.Text = "";
    }

    private void TextBoxMiConStateTimeout_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.formInit)
        return;
      int result;
      if (int.TryParse(this.TextBoxMiConStateTimeout.Text, out result))
        this.myWindowFunctions.portFunctions.communicationObject.PollingErrorTime_ms = result;
      else
        this.TextBoxMiConStateTimeout.Text = "";
    }

    private void ButtonShowChanges_Click(object sender, RoutedEventArgs e)
    {
    }

    private void ButtonShowConfig_Click(object sender, RoutedEventArgs e)
    {
      ConfigList readoutConfiguration = this.myWindowFunctions.portFunctions.GetReadoutConfiguration();
      StringBuilder stringBuilder = new StringBuilder();
      foreach (KeyValuePair<string, string> keyValuePair in readoutConfiguration)
        stringBuilder.AppendLine(keyValuePair.Key + ": " + keyValuePair.Value);
      int num = (int) MessageBox.Show(stringBuilder.ToString(), "Current settings");
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/CommunicationPort;component/userinterface/timingwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.gmmCorporateControl1 = (GmmCorporateControl) target;
          break;
        case 2:
          this.TextBoxWakeup = (TextBox) target;
          this.TextBoxWakeup.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          this.TextBoxWakeup.TextChanged += new TextChangedEventHandler(this.TextBoxWakeup_TextChanged);
          break;
        case 3:
          this.TextBlockWakeup = (TextBlock) target;
          break;
        case 4:
          this.TextBoxAfterWaktup = (TextBox) target;
          this.TextBoxAfterWaktup.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          this.TextBoxAfterWaktup.TextChanged += new TextChangedEventHandler(this.TextBoxAfterWaktup_TextChanged);
          break;
        case 5:
          this.TextBlockAfterWaktup = (TextBlock) target;
          break;
        case 6:
          this.TextBoxBeforFirstByte = (TextBox) target;
          this.TextBoxBeforFirstByte.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          this.TextBoxBeforFirstByte.TextChanged += new TextChangedEventHandler(this.TextBoxBeforFirstByte_TextChanged);
          break;
        case 7:
          this.TextBlockBeforFirstByte = (TextBlock) target;
          break;
        case 8:
          this.TextBoxByteOffset = (TextBox) target;
          this.TextBoxByteOffset.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          this.TextBoxByteOffset.TextChanged += new TextChangedEventHandler(this.TextBoxByteOffset_TextChanged);
          break;
        case 9:
          this.TextBlockByteOffset = (TextBlock) target;
          break;
        case 10:
          this.TextBoxBlockOffset = (TextBox) target;
          this.TextBoxBlockOffset.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          this.TextBoxBlockOffset.TextChanged += new TextChangedEventHandler(this.TextBoxBlockOffset_TextChanged);
          break;
        case 11:
          this.TextBlockBlockOffset = (TextBlock) target;
          break;
        case 12:
          this.TextBoxWakeupIntervall = (TextBox) target;
          this.TextBoxWakeupIntervall.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          this.TextBoxWakeupIntervall.TextChanged += new TextChangedEventHandler(this.TextBoxWakeupIntervall_TextChanged);
          break;
        case 13:
          this.TextBlockWakeupRepeat = (TextBlock) target;
          break;
        case 14:
          this.TextBoxOffset = (TextBox) target;
          this.TextBoxOffset.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          this.TextBoxOffset.TextChanged += new TextChangedEventHandler(this.TextBoxOffset_TextChanged);
          break;
        case 15:
          this.TextBlockOffset = (TextBlock) target;
          break;
        case 16:
          this.TextBoxBeforNextRequest = (TextBox) target;
          this.TextBoxBeforNextRequest.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          this.TextBoxBeforNextRequest.TextChanged += new TextChangedEventHandler(this.TextBoxBeforNextRequest_TextChanged);
          break;
        case 17:
          this.TextBlockBeforNextRequest = (TextBlock) target;
          break;
        case 18:
          this.TextBoxAfterOpen = (TextBox) target;
          this.TextBoxAfterOpen.TextChanged += new TextChangedEventHandler(this.TextBoxAfterOpen_TextChanged);
          this.TextBoxAfterOpen.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          break;
        case 19:
          this.TextBlockAfterOpen = (TextBlock) target;
          break;
        case 20:
          this.TextBoxBeforeRepeat = (TextBox) target;
          this.TextBoxBeforeRepeat.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          this.TextBoxBeforeRepeat.TextChanged += new TextChangedEventHandler(this.TextBoxBeforeRepeat_TextChanged);
          break;
        case 21:
          this.TextBlockBeforeRepeat = (TextBlock) target;
          break;
        case 22:
          this.TextBoxMiConPowerOffTime = (TextBox) target;
          this.TextBoxMiConPowerOffTime.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          this.TextBoxMiConPowerOffTime.TextChanged += new TextChangedEventHandler(this.TextBoxMiConPowerOffTime_TextChanged);
          break;
        case 23:
          this.TextBlockMiConPowerOffTime = (TextBlock) target;
          break;
        case 24:
          this.TextBoxIrDaPulsLength = (TextBox) target;
          this.TextBoxIrDaPulsLength.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          this.TextBoxIrDaPulsLength.TextChanged += new TextChangedEventHandler(this.TextBoxIrDaPulsLength_TextChanged);
          break;
        case 25:
          this.TextBlockIrDaPulsLength = (TextBlock) target;
          break;
        case 26:
          this.TextBoxMiConStateTimeout = (TextBox) target;
          this.TextBoxMiConStateTimeout.LostFocus += new RoutedEventHandler(this.TextBoxRefreshAllOn_LostFocus);
          this.TextBoxMiConStateTimeout.TextChanged += new TextChangedEventHandler(this.TextBoxMiConStateTimeout_TextChanged);
          break;
        case 27:
          this.TextBlockMiConStateTimeout = (TextBlock) target;
          break;
        case 28:
          this.ButtonShowConfig = (Button) target;
          this.ButtonShowConfig.Click += new RoutedEventHandler(this.ButtonShowConfig_Click);
          break;
        case 29:
          this.ButtonShowChanges = (Button) target;
          this.ButtonShowChanges.Click += new RoutedEventHandler(this.ButtonShowChanges_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}

