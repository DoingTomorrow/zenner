// Decompiled with JetBrains decompiler
// Type: HandlerLib.MapManagement.MapReaderARMv6
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Windows;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib.MapManagement
{
  public class MapReaderARMv6 : MapReader
  {
    private List<string> RequiredSections;

    public MapReaderARMv6()
    {
      this.ReaderName = nameof (MapReaderARMv6);
      this.ReaderDescription = "This READER is actually only for Handler with their map file generated by the IAR ELF Linker.This Reader should be used for ARMv6 CPU's. ";
    }

    public override void ReadMap(string mapPath, MapClassManager mapClassMgr = null)
    {
      this.RequiredSections = mapClassMgr.RequiredSections;
      using (StreamReader streamReader = new StreamReader(mapPath))
      {
        this.LineNumber = 0;
        string str1 = "";
        string Name = (string) null;
        bool flag1 = false;
        bool flag2 = false;
        bool flag3 = false;
        this.Clear();
        while (true)
        {
          string info;
          string[] strArray1;
          do
          {
            do
            {
              string ActualLine;
              do
              {
                string str2 = streamReader.ReadLine();
                if (str2 != null)
                {
                  ++this.LineNumber;
                  if (this.LinkerTypeAndVersion == string.Empty && str2.ToUpper().IndexOf("LINKER") >= 0)
                  {
                    this.LinkerTypeAndVersion = this.RemoveMultipleSpaces(str2.Replace('#', ' ').Trim());
                    if (this.LinkerTypeAndVersion.IndexOf("ELF") < 0 && this.LinkerTypeAndVersion.IndexOf("ARM") < 0)
                      goto label_4;
                  }
                  if (str2.IndexOf("*** PLACEMENT SUMMARY") >= 0)
                  {
                    flag2 = true;
                    flag3 = true;
                  }
                  if (str2.IndexOf("*** INIT TABLE") >= 0)
                    flag2 = false;
                  if (str2.Contains("Section") && str2.Contains("Kind") && str2.Contains("Address") && str2.Contains("Size") && str2.Contains("Object"))
                    flag3 = false;
                  if (str2.IndexOf("ENTRY LIST") >= 0)
                  {
                    flag1 = true;
                    str2 = "Start der Map Information";
                  }
                  if (str2.IndexOf(" {Abs}") >= 0 && !str2.Contains("FWVersion"))
                    str2 = str2.Replace(" {Abs}", "");
                  if (flag2 && !flag1 && !flag3)
                  {
                    string empty1 = string.Empty;
                    string empty2 = string.Empty;
                    string[] strArray2 = this.RemoveMultipleSpaces(str2.Trim()).Replace("[", "").Replace("]", "").Replace("{", "").Replace("}", "").Split(' ');
                    string SectionName = strArray2[0];
                    int num1 = this.checkArrayOfStringsForValue(strArray2, "<Block>");
                    if (num1 != -1)
                    {
                      short index = 1;
                      if (num1 == 2)
                      {
                        SectionName = str1.Trim();
                        index = (short) 0;
                      }
                      string s1 = strArray2[(int) index].Substring(2);
                      string s2 = strArray2[(int) (short) ((int) index + 1)].Substring(2);
                      uint num2 = uint.Parse(s1, NumberStyles.HexNumber);
                      uint BlockSize = uint.Parse(s2, NumberStyles.HexNumber);
                      if (AddressRange.IsInAddressRanges(this.AddressRanges, num2))
                        this.NewSection(num2, BlockSize, SectionName);
                    }
                  }
                  str1 = str2;
                  if (str2.ToUpper().IndexOf(" CODE ") + str2.ToUpper().IndexOf(" STM32L0 ") + str2.ToUpper().IndexOf(" LINKER CREATED ") < 0 && flag1)
                  {
                    int length = str2.IndexOfAny(new char[2]
                    {
                      '#',
                      '*'
                    });
                    if (length >= 0)
                      str2 = str2.Substring(0, length);
                    if (str2.IndexOf('(') >= 0)
                      str2 = string.Empty;
                    ActualLine = str2.Trim();
                  }
                  else
                    goto label_24;
                }
                else
                  goto label_54;
              }
              while (ActualLine.Length == 0);
              info = this.RemoveMultipleSpaces(ActualLine);
            }
            while (info[0] == '?' || info[0] == '_' || info[0] == '-');
            strArray1 = info.Split(' ');
            if (Name == null)
            {
              if (strArray1.Length < 2)
                goto label_48;
            }
            else
              goto label_32;
          }
          while (strArray1[1] == "-");
          goto label_40;
label_24:
          Name = (string) null;
          continue;
label_32:
          try
          {
            string s3 = strArray1[0].Substring(2);
            string s4 = strArray1[1].Substring(2);
            uint num = uint.Parse(s3, NumberStyles.HexNumber);
            uint BytesSize1 = 0;
            if (strArray1[1] != "--")
            {
              uint BytesSize2 = uint.Parse(s4, NumberStyles.HexNumber);
              if (AddressRange.IsInAddressRanges(this.AddressRanges, num))
              {
                string sectionForAddress = this.getSectionForAddress(num);
                string SectionName = string.IsNullOrEmpty(sectionForAddress) ? "UNKNOWN" : sectionForAddress;
                this.NewVariable(num, Name, BytesSize2, SectionName);
              }
            }
            else
              this.NewVariable(num, Name, BytesSize1);
          }
          catch
          {
            info += "###! Hex-Format-Error on follow Line";
          }
          Name = (string) null;
          goto label_52;
label_40:
          if (this.FirmwareVersion == string.Empty && strArray1[0].ToUpper().IndexOf("FWVERSION") >= 0)
            this.FirmwareVersion = uint.Parse(strArray1[2].Substring(2), NumberStyles.HexNumber).ToString();
          try
          {
            string s5 = strArray1[1].Substring(2);
            string s6 = strArray1[2].Substring(2);
            uint num = uint.Parse(s5, NumberStyles.HexNumber);
            uint BytesSize3 = 0;
            if (strArray1[2] != "--")
            {
              uint BytesSize4 = uint.Parse(s6, NumberStyles.HexNumber);
              if (AddressRange.IsInAddressRanges(this.AddressRanges, num))
              {
                string sectionForAddress = this.getSectionForAddress(num);
                string SectionName = string.IsNullOrEmpty(sectionForAddress) ? "UNKNOWN" : sectionForAddress;
                this.NewVariable(num, strArray1[0], BytesSize4, SectionName);
                goto label_52;
              }
              else
                goto label_52;
            }
            else
            {
              this.NewVariable(num, strArray1[0], BytesSize3);
              goto label_52;
            }
          }
          catch
          {
            info += "###! Hex-Format-Error";
            goto label_52;
          }
label_48:
          if (strArray1[0].Length > 0)
            Name = strArray1[0];
          else
            info += "#### leere Zeile";
label_52:
          this.AddInfo(info);
        }
label_4:
        throw new Exception("This file is not supported by this READER!!!\nPlease use another Reader for this linker file.");
label_54:
        streamReader.Close();
      }
    }

    public override void GenerateByteArray(string classNameSpace, string className, string path)
    {
      string[] usedFieldes = new string[5]
      {
        "Name",
        "Address",
        "Size",
        "Section",
        "Typ"
      };
      List<string> source1 = new List<string>()
      {
        "UNKNOWN"
      };
      List<string> source2 = new List<string>()
      {
        "UNKNOWN"
      };
      List<uint> source3 = new List<uint>() { 0U };
      List<uint> source4 = new List<uint>() { 0U };
      foreach (MapParameterInfo mapParameterInfo in (IEnumerable<MapParameterInfo>) this.FirmwareParameterList.Values)
      {
        if (!source2.Contains(mapParameterInfo.Typ))
          source2.Add(mapParameterInfo.Typ);
        if (!source1.Contains(mapParameterInfo.Section))
        {
          source1.Add(mapParameterInfo.Section);
          source3.Add(this.SectionList[mapParameterInfo.Section].StartAddress);
          source4.Add(this.SectionList[mapParameterInfo.Section].BlockSize);
        }
      }
      if (this.RequiredSections != null)
      {
        foreach (MapSectionInfo mapSectionInfo in (IEnumerable<MapSectionInfo>) this.SectionList.Values)
        {
          if (this.RequiredSections.Contains(mapSectionInfo.SectionName))
          {
            try
            {
              if (!source1.Contains(mapSectionInfo.SectionName))
              {
                source1.Add(mapSectionInfo.SectionName);
                source3.Add(this.SectionList[mapSectionInfo.SectionName].StartAddress);
                source4.Add((uint) ((int) this.SectionList[mapSectionInfo.SectionName].EndAddress - (int) this.SectionList[mapSectionInfo.SectionName].StartAddress + 1));
              }
            }
            catch
            {
            }
          }
        }
      }
      MapClassGenerator mapClassGenerator = new MapClassGenerator();
      mapClassGenerator.StartClassGeneration((byte) 0, classNameSpace, className, usedFieldes, source1.ToArray<string>(), source2.ToArray<string>(), source3.ToArray<uint>(), source4.ToArray<uint>());
      SortedList<uint, string> sortedList = new SortedList<uint, string>();
      foreach (MapParameterInfo mapParameterInfo in (IEnumerable<MapParameterInfo>) this.FirmwareParameterList.Values)
      {
        MapParameterInfo parameterInfo = mapParameterInfo;
        try
        {
          mapClassGenerator.InsertComment(parameterInfo.FirmwareName);
          mapClassGenerator.AddAsByteListForced(parameterInfo.FirmwareName);
          mapClassGenerator.InsertComment("Address: 0x" + parameterInfo.MapAddress.ToString("x8"));
          mapClassGenerator.AddAsByteListForced(parameterInfo.MapAddress);
          mapClassGenerator.InsertComment("Size: " + parameterInfo.ByteSize.ToString());
          mapClassGenerator.AddAsByteListForced(parameterInfo.ByteSize);
          mapClassGenerator.InsertComment("Section: " + parameterInfo.Section);
          mapClassGenerator.AddAsByteListForced((ushort) source1.FindIndex((Predicate<string>) (x => x.Equals(parameterInfo.Section))));
          mapClassGenerator.InsertComment("Typ: " + parameterInfo.Typ);
          mapClassGenerator.AddAsByteListForced((ushort) source2.FindIndex((Predicate<string>) (x => x.Equals(parameterInfo.Typ))));
          mapClassGenerator.NewLine();
          if (!sortedList.ContainsKey(parameterInfo.MapAddress))
            sortedList.Add(parameterInfo.MapAddress, parameterInfo.FirmwareName);
          else
            sortedList[parameterInfo.MapAddress] = sortedList[parameterInfo.MapAddress] + "; " + parameterInfo.FirmwareName;
        }
        catch (Exception ex)
        {
          int num = (int) MessageBox.Show(ex.Message);
        }
      }
      mapClassGenerator.FinaliseClassGeneraton();
      mapClassGenerator.StartCommentBlock("Parameter by address");
      foreach (KeyValuePair<uint, string> keyValuePair in sortedList)
        mapClassGenerator.AddAddressParameterLineToCommentBlock(keyValuePair.Key, keyValuePair.Value);
      mapClassGenerator.FinishCommentBlock();
      mapClassGenerator.SaveClass(path);
    }

    private int checkArrayOfStringsForValue(string[] strArray, string value)
    {
      int num1 = 0;
      int num2 = -1;
      foreach (string str in strArray)
      {
        if (str.Contains(value))
        {
          num2 = num1;
          break;
        }
        ++num1;
      }
      return num2;
    }

    private uint GetSizeOfSection(string SectionName)
    {
      uint sizeOfSection = 0;
      foreach (MapSectionParameters sectionParameters in this.SectionParameterList.Values.Where<MapSectionParameters>((Func<MapSectionParameters, bool>) (x => x.SectionName == SectionName)))
        sizeOfSection += sectionParameters.Size;
      return sizeOfSection;
    }

    public override void ReadLists(string mapPath, MapClassManager mapClassMgr = null)
    {
      DirectoryInfo directoryInfo = new DirectoryInfo(Path.GetDirectoryName(mapPath));
      string[] extensions = new string[1]{ ".lst" };
      FileInfo[] array = directoryInfo.EnumerateFiles().Where<FileInfo>((Func<FileInfo, bool>) (f => ((IEnumerable<string>) extensions).Contains<string>(f.Extension.ToLower()) && !f.Name.Contains("stm32"))).ToArray<FileInfo>();
      List<string> list = this.FirmwareParameterList.Keys.ToList<string>();
      foreach (FileInfo fileInfo in array)
      {
        mapClassMgr?.SetStatusString("reading from File: " + fileInfo.Name);
        StreamReader streamReader = fileInfo.OpenText();
        string empty1 = string.Empty;
        string empty2 = string.Empty;
        bool flag1 = false;
        bool flag2 = false;
        while (!streamReader.EndOfStream)
        {
          string ActualLine = streamReader.ReadLine();
          if (ActualLine.Equals(string.Empty) && !flag1)
          {
            flag1 = true;
            flag2 = false;
            empty2 = string.Empty;
          }
          else
          {
            if (ActualLine.Equals(string.Empty) & flag1)
              flag2 = true;
            if (flag1 && !flag2)
            {
              string str = this.RemoveMultipleSpaces(ActualLine);
              if (!str[0].Equals('#'))
              {
                if (str.Length > 1)
                  empty2 += str;
                else if (empty2.Length > 1)
                  flag2 = true;
                else
                  flag1 = false;
              }
            }
            if (flag1 & flag2 && empty2.Length > 1)
            {
              if (empty2.Contains("section") && empty2.Contains("align") && empty2.Contains("00000000") && empty2.IndexOf("??DataTable") < 0 && empty2.IndexOf("{") < 0 && empty2.IndexOf("}") < 0)
              {
                foreach (string str1 in list)
                {
                  string AttributName = str1;
                  if (Regex.IsMatch(empty2, string.Format("\\b{0}\\b", (object) Regex.Escape(AttributName))))
                  {
                    string[] strArray = empty2.Split(' ');
                    if (strArray.Length <= 15 || Array.FindIndex<string>(strArray, (Predicate<string>) (x => x.Contains(AttributName))) <= 15)
                    {
                      ListFileParameter LFP = new ListFileParameter();
                      LFP.Section = this.GetValueFromArray(strArray, "section", (short) 1);
                      string s1 = Regex.Match(this.GetValueFromArray(strArray, "align", (short) 1).Trim(), "\\d+").Value;
                      LFP.Align = !string.IsNullOrEmpty(s1) ? (uint) ushort.Parse(s1) : 0U;
                      LFP.Type = this.GetValueFromArray(strArray, "__absolute", (short) 1);
                      LFP.Type_add = this.GetValueFromArray(strArray, "__absolute", (short) 2);
                      if (LFP.Type != null && LFP.Type == string.Empty)
                        LFP.Type = this.GetValueFromArray(strArray, AttributName, (short) -1, false);
                      if (LFP.Type == "\\")
                        LFP.Type = string.Empty;
                      string empty3 = string.Empty;
                      string source1 = !string.IsNullOrEmpty(LFP.Type) ? this.GetValueFromArray(strArray, "__absolute", (short) 3) : this.GetValueFromArray(strArray, "00000000", (short) 3);
                      LFP.Type = !string.IsNullOrEmpty(LFP.Type) ? LFP.Type : "UNKNOWN";
                      LFP.FieldName = AttributName;
                      LFP.ArraySize = 1;
                      LFP.IsArray = false;
                      if (!string.IsNullOrEmpty(source1))
                      {
                        if (source1.Contains<char>('['))
                        {
                          int num1 = 1;
                          string[] source2 = source1.Split('[');
                          empty3 = source2[0];
                          if (((IEnumerable<string>) source2).Count<string>() == 2)
                          {
                            string s2 = Regex.Match(source2[1], "\\d+").Value;
                            num1 = !string.IsNullOrEmpty(s2) ? (int) ushort.Parse(s2) : 1;
                          }
                          if (((IEnumerable<string>) source2).Count<string>() == 3)
                          {
                            string s3 = Regex.Match(source2[1], "\\d+").Value;
                            int num2 = !string.IsNullOrEmpty(s3) ? (int) ushort.Parse(s3) : 1;
                            string s4 = Regex.Match(source2[2], "\\d+").Value;
                            num1 = num2 * (!string.IsNullOrEmpty(s4) ? (int) ushort.Parse(s4) : 1);
                          }
                          LFP.IsArray = true;
                          LFP.ArraySize = num1;
                          LFP.InitValues = new string[LFP.ArraySize];
                        }
                        if (LFP.InitValues != null)
                        {
                          int num = 0;
                          for (int Position = 0; Position < ((IEnumerable<string>) strArray).Count<string>(); ++Position)
                          {
                            string valueFromArray = this.GetValueFromArray(strArray, "00000000", (short) Position);
                            if (!string.IsNullOrEmpty(valueFromArray))
                            {
                              if (valueFromArray.Contains("0x") && !valueFromArray.Contains("........"))
                              {
                                string str2 = valueFromArray.Trim().Replace("\\", "");
                                LFP.InitValues[num++] = str2;
                              }
                              if (num == LFP.ArraySize)
                                break;
                            }
                            else
                              break;
                          }
                        }
                      }
                      try
                      {
                        if (LFP != null)
                        {
                          this.NewOrUpdateFieldTypeParameter(LFP);
                          break;
                        }
                        break;
                      }
                      catch (Exception ex)
                      {
                        ex.ToString();
                        break;
                      }
                    }
                  }
                }
              }
              flag2 = false;
              empty2 = string.Empty;
            }
          }
        }
      }
    }
  }
}
