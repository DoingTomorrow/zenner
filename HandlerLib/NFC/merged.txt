
--- CR95_RESULTCODE.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.CR95_RESULTCODE
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib.NFC
{
  internal enum CR95_RESULTCODE
  {
    Command_Success = 0,
    Response_Success = 128, // 0x00000080
    Command_Len_Invalid = 130, // 0x00000082
    Protocol_Invalid = 131, // 0x00000083
    Communication_Error = 134, // 0x00000086
    Frame_Wait_Timeout = 135, // 0x00000087
    SOF_Invalid = 136, // 0x00000088
    Receive_Overflow = 137, // 0x00000089
    Framing_Error = 138, // 0x0000008A
    EGT_Timeout = 139, // 0x0000008B
    Length_Invalid = 140, // 0x0000008C
    CRC_Error = 141, // 0x0000008D
    Reception_Lost = 142, // 0x0000008E
    Ack_Nack = 144, // 0x00000090
  }
}


--- CR95_RESULTCODE_90.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.CR95_RESULTCODE_90
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib.NFC
{
  internal enum CR95_RESULTCODE_90
  {
    RF_ERROR_PARITY = 16, // 0x00000010
    RF_ERROR_CRC = 32, // 0x00000020
    NOT_USED = 64, // 0x00000040
    RF_ERROR_COLLISION = 128, // 0x00000080
  }
}


--- MiConConnector.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.MiConConnector
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib.NFC
{
  public class MiConConnector
  {
    private NfcSubunitCommands mySubCmds;
    private NfcDeviceCommands myCmds;
    public string MiConConnectorIdentification;

    public MiConConnector(NfcDeviceCommands myCommands)
    {
      this.myCmds = myCommands;
      this.mySubCmds = myCommands.mySubunitCommands;
    }

    public async Task<NfcCouplerCurrents> GetNFC_CouplerCurrent(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      NfcCouplerCurrents couplerCurrents = new NfcCouplerCurrents();
      ushort valueCounts = 250;
      byte[] numArray1 = await this.mySubCmds.StartCouplerCurrentMeasurement((ushort) 20, (ushort) 2, valueCounts, progress, cancelToken);
      await Task.Delay(10);
      byte[] numArray2 = await this.mySubCmds.SetRfOffAsync(progress, cancelToken);
      await Task.Delay(450);
      byte[] numArray3 = await this.mySubCmds.SetRfOnAsync(progress, cancelToken);
      await Task.Delay(450);
      DeviceIdentification deviceIdentification = await this.myCmds.ReadVersionAsync(progress, cancelToken);
      await Task.Delay(750);
      byte[] numArray4 = await this.mySubCmds.SetRfOffAsync(progress, cancelToken);
      await Task.Delay(1500);
      List<ushort> currentSamples = new List<ushort>();
      while (currentSamples.Count < (int) valueCounts)
      {
        ushort[] samples = await this.mySubCmds.GetCouplerCurrentValues(progress, cancelToken);
        if (samples.Length != 0)
        {
          currentSamples.AddRange((IEnumerable<ushort>) samples);
          samples = (ushort[]) null;
        }
        else
          break;
      }
      int i = currentSamples.Count;
      couplerCurrents.CurrentSamples = new float[currentSamples.Count];
      while (i-- > 0)
      {
        float item = (float) (1.0 - (double) currentSamples[i] / 4096.0);
        couplerCurrents.CurrentSamples[i] = item;
      }
      i = 0;
      int j = 0;
      while (i < currentSamples.Count - 1)
      {
        couplerCurrents.NfcFieldOffCurrent += (double) couplerCurrents.CurrentSamples[i];
        ++j;
        ++i;
        if ((short) ((double) couplerCurrents.CurrentSamples[i] * 100.0) > (short) 0)
          break;
      }
      couplerCurrents.NfcFieldOffCurrent /= (double) j;
      j = 0;
      while (i < currentSamples.Count - 1)
      {
        couplerCurrents.NfcFieldOnCurrent += (double) couplerCurrents.CurrentSamples[i];
        ++j;
        ++i;
        if ((short) ((double) couplerCurrents.CurrentSamples[i] * 100.0) == (short) 0)
          break;
      }
      couplerCurrents.NfcFieldOnCurrent /= (double) j;
      j = 0;
      while (i < currentSamples.Count - 1)
      {
        couplerCurrents.StandbyCurrent += (double) couplerCurrents.CurrentSamples[i];
        ++j;
        ++i;
        if ((short) ((double) couplerCurrents.CurrentSamples[i] * 100.0) > (short) 0)
          break;
      }
      couplerCurrents.StandbyCurrent /= (double) j;
      NfcCouplerCurrents nfcCouplerCurrent = couplerCurrents;
      couplerCurrents = (NfcCouplerCurrents) null;
      currentSamples = (List<ushort>) null;
      return nfcCouplerCurrent;
    }

    public async Task ResetDevice(ProgressHandler progress, CancellationToken cancelToken)
    {
      await this.mySubCmds.MiConConnector_Reset(progress, cancelToken);
    }

    public async Task ReadMemory(
      AddressRange addressRange,
      DeviceMemory deviceMemory,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] data = await this.mySubCmds.ReadNdcMemory_Async(addressRange.StartAddress, addressRange.ByteSize, progress, cancelToken);
      deviceMemory.GarantMemoryAvailable(addressRange);
      deviceMemory.SetData(addressRange.StartAddress, data);
      data = (byte[]) null;
    }

    public async Task WriteMemory(
      AddressRange addressRange,
      DeviceMemory deviceMemory,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] writeData = deviceMemory.GetData(addressRange);
      byte[] numArray = await this.mySubCmds.SubUnit_WriteMemory_Async(addressRange.StartAddress, writeData, progress, cancelToken);
      writeData = (byte[]) null;
    }
  }
}


--- MiConConnectorVersion.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.MiConConnectorVersion
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using MBusLib;
using System;

#nullable disable
namespace HandlerLib.NFC
{
  public class MiConConnectorVersion : NfcDeviceIdentification
  {
    public MiConConnectorVersion()
    {
    }

    public MiConConnectorVersion(byte[] buffer)
    {
      int index1 = 3;
      this.nfcIdentFrameVersion = new byte?(buffer[index1]);
      int index2 = index1 + 1;
      byte? identFrameVersion1 = this.nfcIdentFrameVersion;
      int? nullable = identFrameVersion1.HasValue ? new int?((int) identFrameVersion1.GetValueOrDefault()) : new int?();
      int num1 = 0;
      if (nullable.GetValueOrDefault() == num1 & nullable.HasValue)
      {
        this.nfcProtocolVersion = new byte?(buffer[index2]);
        int index3 = index2 + 1;
        this.generation = new byte?(buffer[index3]);
        int startIndex1 = index3 + 1;
        this.iD_BCD = new uint?(BitConverter.ToUInt32(buffer, startIndex1));
        int startIndex2 = startIndex1 + 4;
        this.hardwareID = new uint?(BitConverter.ToUInt32(buffer, startIndex2));
        int startIndex3 = startIndex2 + 4;
        uint uint32 = BitConverter.ToUInt32(buffer, startIndex3);
        int startIndex4 = startIndex3 + 4;
        this.firmwareVersion = new uint?(uint32);
        this.svnRevision = new uint?(BitConverter.ToUInt32(buffer, startIndex4));
        int srcOffset1 = startIndex4 + 4;
        byte[] numArray = new byte[4];
        Buffer.BlockCopy((Array) buffer, srcOffset1, (Array) numArray, 0, 4);
        int startIndex5 = srcOffset1 + 4;
        this.buildTime = MBusUtil.ConvertToDateTime_MBus_CP32_TypeF(numArray);
        this.compilerVersion = new uint?(BitConverter.ToUInt32(buffer, startIndex5));
        int srcOffset2 = startIndex5 + 4;
        this.unique_ID = new byte[12];
        Buffer.BlockCopy((Array) buffer, srcOffset2, (Array) this.unique_ID, 0, 12);
      }
      else
      {
        byte? identFrameVersion2 = this.nfcIdentFrameVersion;
        nullable = identFrameVersion2.HasValue ? new int?((int) identFrameVersion2.GetValueOrDefault()) : new int?();
        int num2 = 1;
        int num3;
        if (!(nullable.GetValueOrDefault() == num2 & nullable.HasValue))
        {
          identFrameVersion2 = this.nfcIdentFrameVersion;
          nullable = identFrameVersion2.HasValue ? new int?((int) identFrameVersion2.GetValueOrDefault()) : new int?();
          int num4 = 2;
          num3 = nullable.GetValueOrDefault() == num4 & nullable.HasValue ? 1 : 0;
        }
        else
          num3 = 1;
        if (num3 == 0)
          return;
        this.nfcProtocolVersion = new byte?(buffer[index2]);
        int startIndex6 = index2 + 1;
        this.iD_BCD = new uint?(BitConverter.ToUInt32(buffer, startIndex6));
        int index4 = startIndex6 + 4;
        this.generation = new byte?(buffer[index4]);
        int startIndex7 = index4 + 1;
        this.manufacturer = new ushort?(BitConverter.ToUInt16(buffer, startIndex7));
        int index5 = startIndex7 + 2;
        this.medium = new byte?(buffer[index5]);
        int index6 = index5 + 1;
        this.obisMedium = new char?((char) buffer[index6]);
        int startIndex8 = index6 + 1;
        this.sAP_MaterialNumber = new uint?(BitConverter.ToUInt32(buffer, startIndex8));
        int num5 = startIndex8 + 4;
        this.sAP_ProductionOrderNumber = (string) null;
        int startIndex9 = num5 + 4;
        this.meterID = new uint?(BitConverter.ToUInt32(buffer, startIndex9));
        int startIndex10 = startIndex9 + 4 + 4;
        this.hardwareID = new uint?(BitConverter.ToUInt32(buffer, startIndex10));
        int startIndex11 = startIndex10 + 4;
        uint uint32_1 = BitConverter.ToUInt32(buffer, startIndex11);
        int startIndex12 = startIndex11 + 4;
        this.firmwareVersion = new uint?(uint32_1);
        this.svnRevision = new uint?(BitConverter.ToUInt32(buffer, startIndex12));
        int srcOffset3 = startIndex12 + 4;
        byte[] numArray = new byte[4];
        Buffer.BlockCopy((Array) buffer, srcOffset3, (Array) numArray, 0, 4);
        int startIndex13 = srcOffset3 + 4;
        this.buildTime = MBusUtil.ConvertToDateTime_MBus_CP32_TypeF(numArray);
        this.compilerVersion = new uint?(BitConverter.ToUInt32(buffer, startIndex13));
        int srcOffset4 = startIndex13 + 4;
        this.unique_ID = new byte[12];
        Buffer.BlockCopy((Array) buffer, srcOffset4, (Array) this.unique_ID, 0, 12);
        int startIndex14 = srcOffset4 + 12;
        identFrameVersion2 = this.nfcIdentFrameVersion;
        nullable = identFrameVersion2.HasValue ? new int?((int) identFrameVersion2.GetValueOrDefault()) : new int?();
        int num6 = 2;
        if (nullable.GetValueOrDefault() == num6 & nullable.HasValue)
        {
          uint uint32_2 = BitConverter.ToUInt32(buffer, startIndex14);
          int num7 = startIndex14 + 4;
          this.NDC_Lib_Version = new uint?(uint32_2);
        }
      }
    }

    public Version GetFirmwareVersion()
    {
      return new Version(new ZENNER.CommonLibrary.FirmwareVersion(this.firmwareVersion.Value).VersionString + "." + this.svnRevision.Value.ToString());
    }
  }
}


--- NDC_ModuleConfiguration.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NDC_ModuleConfiguration
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib.NFC
{
  public enum NDC_ModuleConfiguration : byte
  {
    NotDefined,
    NDC_LoRa_Configuration,
    NDC_wMBus_Configuration,
  }
}


--- NDC_ModuleTypes.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NDC_ModuleTypes
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib.NFC
{
  public enum NDC_ModuleTypes : byte
  {
    NotDefined,
    NDC_LoRa_Module,
    NDC_wMBus_Module,
    NDC_Impulse_Module,
    NDC_NB_IoT_Module,
    NDC_LoRa_wMBus_Module,
  }
}


--- NdcMiConModuleHardwareIds.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NdcMiConModuleHardwareIds
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib.NFC
{
  public class NdcMiConModuleHardwareIds
  {
    public string MiConConnectorID;
    public string NfcCouplerID;
  }
}


--- NFC_DEVICE_ERROR.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NFC_DEVICE_ERROR
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib.NFC
{
  internal enum NFC_DEVICE_ERROR
  {
    NFC_OK,
    NFC_ERR_SIZE,
    NFC_ERR_CRC,
    NFC_ERR_CMD,
    NFC_ERR_WRTPRM,
    NFC_ERR_HAL,
    NFC_ERR_RDPRM,
    NFC_ERR_ISPROTECTED,
    NFC_ERR_PARAM,
  }
}


--- NFC_TRANSMISSION_STATE.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NFC_TRANSMISSION_STATE
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib.NFC
{
  internal enum NFC_TRANSMISSION_STATE
  {
    NFC_Ready,
    NFC_RF_ON,
    NFC_RF_OFF,
    NFC_Anticollision,
    NFC_Read_Status,
    NFC_Get_Status,
    NFC_Write_RAM,
    NFC_Read_RAM,
    NFC_Read_RAM_Fast,
  }
}


--- NFC_Versions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NFC_Versions
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.Functions;
using GmmDbLib;
using GmmDbLib.DataSets;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib.NFC
{
  public class NFC_Versions
  {
    private static SortedList<string, NFC_Versions.FirmwareVersionsInfo> VersionList = new SortedList<string, NFC_Versions.FirmwareVersionsInfo>();

    public static async Task<string> GetVersionInfoText(
      FirmwareVersion deviceFirmware,
      CommunicationPortFunctions thePort,
      NfcDeviceCommands nfcCommands,
      ProgressHandler progress,
      CancellationToken token)
    {
      Version MiConFirmwareVersion = thePort.GetTransceiverVersion();
      MiConConnectorVersion connectorVersion = await nfcCommands.mySubunitCommands.ReadMiConIdentificationAsync(progress, token);
      StringBuilder result = new StringBuilder();
      result.AppendLine("Device firmware version: " + deviceFirmware.ToString());
      result.AppendLine("MinoConnect firmware version: " + MiConFirmwareVersion.ToString());
      result.AppendLine("MiConConnector firmware version: " + connectorVersion.GetFirmwareVersion().ToString());
      string versionInfoText = result.ToString();
      MiConFirmwareVersion = (Version) null;
      connectorVersion = (MiConConnectorVersion) null;
      result = (StringBuilder) null;
      return versionInfoText;
    }

    public static async Task CheckVersions(
      FirmwareVersion deviceFirmware,
      CommunicationPortFunctions thePort,
      NfcDeviceCommands nfcCommands,
      ProgressHandler progress,
      CancellationToken token)
    {
      Version MiConFirmwareVersion = thePort.GetTransceiverVersion();
      MiConConnectorVersion connectorVersion = await nfcCommands.mySubunitCommands.ReadMiConIdentificationAsync(progress, token);
      Version MiConConnectorFirmwareVersion = connectorVersion.GetFirmwareVersion();
      string firmwareString = deviceFirmware.ToString();
      int listIndex = -1;
      lock (NFC_Versions.VersionList)
      {
        listIndex = NFC_Versions.VersionList.IndexOfKey(deviceFirmware.ToString());
        if (listIndex < 0)
        {
          try
          {
            using (DbConnection myConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
            {
              string sql = "SELECT MapId,FirmwareVersion,Options FROM ProgFiles WHERE FirmwareVersion = " + deviceFirmware.Version.ToString();
              DbDataAdapter ProgFilesDataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(sql.ToString(), myConnection);
              HardwareTypeTables.ProgFilesDataTable ProgFilesTable = new HardwareTypeTables.ProgFilesDataTable();
              ProgFilesDataAdapter.Fill((DataTable) ProgFilesTable);
              if (ProgFilesTable.Count == 1 && !ProgFilesTable[0].IsOptionsNull())
              {
                List<KeyValuePair<string, string>> theOptions = DbUtil.KeyValueStringListToKeyValuePairList(ProgFilesTable[0].Options);
                KeyValuePair<string, string> keyValuePair = theOptions.First<KeyValuePair<string, string>>((System.Func<KeyValuePair<string, string>, bool>) (x => x.Key == "MiConFw"));
                string miConFw = keyValuePair.Value;
                keyValuePair = theOptions.First<KeyValuePair<string, string>>((System.Func<KeyValuePair<string, string>, bool>) (x => x.Key == "MiConConFw"));
                string miConConFw = keyValuePair.Value;
                NFC_Versions.VersionList.Add(firmwareString, new NFC_Versions.FirmwareVersionsInfo()
                {
                  MinoConnect = new Version(miConFw),
                  MiConConnector = new Version(miConConFw)
                });
                listIndex = NFC_Versions.VersionList.IndexOfKey(deviceFirmware.ToString());
                theOptions = (List<KeyValuePair<string, string>>) null;
                miConFw = (string) null;
                miConConFw = (string) null;
              }
              sql = (string) null;
              ProgFilesDataAdapter = (DbDataAdapter) null;
              ProgFilesTable = (HardwareTypeTables.ProgFilesDataTable) null;
            }
          }
          catch
          {
            NFC_Versions.VersionList.Add(firmwareString, (NFC_Versions.FirmwareVersionsInfo) null);
          }
        }
      }
      if (listIndex < 0 || NFC_Versions.VersionList.Values[listIndex] == null)
      {
        MiConFirmwareVersion = (Version) null;
        connectorVersion = (MiConConnectorVersion) null;
        MiConConnectorFirmwareVersion = (Version) null;
        firmwareString = (string) null;
      }
      else
      {
        StringBuilder message = new StringBuilder();
        message.AppendLine("Device firmware version: " + firmwareString);
        message.AppendLine("MinoConnect firmware version: " + MiConFirmwareVersion.ToString());
        message.AppendLine("MiConConnector firmware version: " + MiConConnectorFirmwareVersion.ToString());
        message.AppendLine();
        NFC_Versions.FirmwareVersionsInfo versionInfo = NFC_Versions.VersionList.Values[listIndex];
        bool update = false;
        if (MiConFirmwareVersion < versionInfo.MinoConnect)
        {
          update = true;
          message.AppendLine("Minimal MinoConnect firmware version: " + versionInfo.MinoConnect.ToString());
        }
        if (MiConConnectorFirmwareVersion < versionInfo.MiConConnector)
        {
          update = true;
          message.AppendLine("Minimal MiConConnector firmware version: " + versionInfo.MiConConnector.ToString());
        }
        if (update)
        {
          message.AppendLine();
          message.AppendLine("Please update the firmware version(s)");
          throw new Exception(message.ToString());
        }
        message = (StringBuilder) null;
        versionInfo = (NFC_Versions.FirmwareVersionsInfo) null;
        MiConFirmwareVersion = (Version) null;
        connectorVersion = (MiConConnectorVersion) null;
        MiConConnectorFirmwareVersion = (Version) null;
        firmwareString = (string) null;
      }
    }

    private class FirmwareVersionsInfo
    {
      internal Version MinoConnect;
      internal Version MiConConnector;
    }
  }
}


--- NfcCommands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NfcCommands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib.NFC
{
  public enum NfcCommands : byte
  {
    GetIdentification = 1,
    GetAvailableParameterGroupSettings = 2,
    GetSelectedParameterGroupSettings = 3,
    ClearAllConfigurableParameterGroups = 4,
    AddConfigurableParameterGroup = 5,
    GetAvailableParameterGroupData = 6,
    GetSelectedParameterGroupData = 7,
    AddManagedParameter = 10, // 0x0A
    WriteMemory = 11, // 0x0B
    ReadMemory = 12, // 0x0C
    SetTestMode = 14, // 0x0E
    GetSystemState = 15, // 0x0F
    GetChallengeResponseRandomValue = 16, // 0x10
    GetDeviceAesKey = 17, // 0x11
    SetRtcCalibrationValue = 20, // 0x14
    SaveBackup = 21, // 0x15
    GetSystemDateTime = 22, // 0x16
    SetSystemDateTime = 23, // 0x17
    UnlockDevice = 24, // 0x18
    LockDevice = 25, // 0x19
    ResetDevice = 26, // 0x1A
    GetModuleConfiguration = 27, // 0x1B
    GetMeterConfiguration = 28, // 0x1C
    SetMeterConfiguration = 29, // 0x1D
    GetBatteryEndDate = 30, // 0x1E
    SetBatteryEndDate = 31, // 0x1F
    IrDa_Compatible_Command = 32, // 0x20
    GetLoggerList = 33, // 0x21
    ReadLogger = 34, // 0x22
    GetSmartFunctionsList = 35, // 0x23
    GetSmartFunction = 36, // 0x24
    LoadSmartFunction = 37, // 0x25
    DeleteAllSmartFunctions = 38, // 0x26
    GetSmartFunctionParameters = 39, // 0x27
    SetSmartFunctionParameters = 40, // 0x28
    GetVolumeAndFlow = 41, // 0x29
    ChecksumManagement = 42, // 0x2A
    SetModuleConfiguration = 43, // 0x2B
    GetAliveAndStatus = 44, // 0x2C
    SimulateLoggerEvent = 45, // 0x2D
    GetStateCounters = 46, // 0x2E
    SetGroupsForScenario = 47, // 0x2F
    GetSmartFunctionInfo = 48, // 0x30
    ReInitMeasurement = 49, // 0x31
    SetNDC_ModuleState = 50, // 0x32
    GetAvailableModuleConfigurations = 51, // 0x33
    UpdateNdef = 52, // 0x34
    ClearEventLogger = 53, // 0x35
    SetAccumulatedValues = 54, // 0x36
    SetSmartFunctionActivation = 55, // 0x37
    GetBusModuleList = 56, // 0x38
    SendToBusModule = 57, // 0x39
    CallTestFunction = 58, // 0x3A
    ErrorCommand = 254, // 0xFE
    SubUnitCommand = 255, // 0xFF
  }
}


--- NfcCouplerCurrents.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NfcCouplerCurrents
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib.NFC
{
  public class NfcCouplerCurrents
  {
    public double StandbyCurrent;
    public double NfcFieldOffCurrent;
    public double NfcFieldOnCurrent;
    public float[] CurrentSamples;
    public string CouplerIDN = string.Empty;
  }
}


--- NfcFrame.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NfcFrame
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using NLog;
using System;
using System.Security.Cryptography;
using System.Text;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib.NFC
{
  public class NfcFrame
  {
    private static Logger Base_NfcFrameLogger = LogManager.GetLogger(nameof (NfcFrameLogger));
    internal ChannelLogger NfcFrameLogger;
    public NfcCommands NfcCommand;
    public string ProgressParameter = (string) null;
    public object Tag;
    private ushort? CrcInitValue;
    private static byte[] InitVector = new byte[6]
    {
      (byte) 32,
      (byte) 32,
      (byte) 32,
      (byte) 32,
      (byte) 32,
      (byte) 32
    };

    public byte[] NfcRequestFrame { get; private set; }

    public byte[] NfcResponseFrame { get; set; }

    public byte[] EncryptedNfcFrame { get; private set; }

    public NfcFrame(
      NfcCommands nfcCommand,
      string readingChannelIdentification,
      ushort? crcInitValue = null)
    {
      this.CrcInitValue = crcInitValue;
      this.NfcFrameLogger = new ChannelLogger(NfcFrame.Base_NfcFrameLogger, readingChannelIdentification);
      this.NfcCommand = nfcCommand;
      this.NfcRequestFrame = new byte[6];
      this.NfcRequestFrame[0] = (byte) (this.NfcRequestFrame.Length - 3);
      this.NfcRequestFrame[1] = (byte) nfcCommand;
      this.NfcRequestFrame[2] = (byte) 90;
      this.NfcRequestFrame[3] = (byte) 165;
      this.AddCrc();
    }

    public NfcFrame(
      NfcCommands nfcCommand,
      byte[] frameData,
      string readingChannelIdentification,
      ushort? crcInitValue = null)
    {
      this.CrcInitValue = crcInitValue;
      this.NfcFrameLogger = new ChannelLogger(NfcFrame.Base_NfcFrameLogger, readingChannelIdentification);
      this.NfcCommand = nfcCommand;
      if (frameData.Length < 60)
      {
        this.NfcRequestFrame = new byte[frameData.Length + 4];
        this.NfcRequestFrame[0] = (byte) (frameData.Length + 1);
        this.NfcRequestFrame[1] = (byte) nfcCommand;
        Buffer.BlockCopy((Array) frameData, 0, (Array) this.NfcRequestFrame, 2, frameData.Length);
      }
      else
      {
        this.NfcRequestFrame = new byte[frameData.Length + 6];
        ushort num = (ushort) (frameData.Length + 1);
        this.NfcRequestFrame[0] = byte.MaxValue;
        this.NfcRequestFrame[1] = (byte) num;
        this.NfcRequestFrame[2] = (byte) ((uint) num >> 8);
        this.NfcRequestFrame[3] = (byte) nfcCommand;
        Buffer.BlockCopy((Array) frameData, 0, (Array) this.NfcRequestFrame, 4, frameData.Length);
      }
      this.AddCrc();
    }

    public NfcFrame(byte[] poorFrame, string readingChannelIdentification)
    {
      this.NfcFrameLogger = new ChannelLogger(NfcFrame.Base_NfcFrameLogger, readingChannelIdentification);
      this.NfcRequestFrame = poorFrame;
    }

    public NfcFrame(byte[] encryptedFrame, byte[] aesKey, string readingChannelIdentification)
    {
      this.NfcFrameLogger = new ChannelLogger(NfcFrame.Base_NfcFrameLogger, readingChannelIdentification);
      this.EncryptedNfcFrame = encryptedFrame;
      this.DecryptFrame(aesKey);
    }

    private void DecryptFrame(byte[] aesKey)
    {
      using (ICryptoTransform decryptor = this.GetEncryptionObject(aesKey).CreateDecryptor())
        this.NfcRequestFrame = decryptor.TransformFinalBlock(this.EncryptedNfcFrame, 0, this.EncryptedNfcFrame.Length);
    }

    private void EncryptFrame(byte[] aesKey)
    {
      this.GetEncryptionObject(aesKey).CreateEncryptor().TransformFinalBlock(this.NfcRequestFrame, 0, this.NfcRequestFrame.Length);
    }

    private RijndaelManaged GetEncryptionObject(byte[] aesKey)
    {
      RijndaelManaged encryptionObject = new RijndaelManaged();
      encryptionObject.Mode = CipherMode.CBC;
      encryptionObject.IV = NfcFrame.InitVector;
      encryptionObject.Key = aesKey;
      encryptionObject.Padding = PaddingMode.Zeros;
      return encryptionObject;
    }

    private void AddCrc()
    {
      ushort crc = NfcFrame.createCRC(this.NfcRequestFrame, this.CrcInitValue);
      this.NfcRequestFrame[this.NfcRequestFrame.Length - 2] = (byte) crc;
      this.NfcRequestFrame[this.NfcRequestFrame.Length - 1] = (byte) ((uint) crc >> 8);
    }

    public void IsResponseCrcOk()
    {
      ushort crc = NfcFrame.createCRC(this.NfcResponseFrame, this.CrcInitValue);
      if ((int) this.NfcResponseFrame[this.NfcResponseFrame.Length - 2] != (int) (byte) crc || (int) this.NfcResponseFrame[this.NfcResponseFrame.Length - 1] != (int) (byte) ((uint) crc >> 8))
      {
        this.NfcFrameLogger.Error("NFC_CRC error: " + Util.ByteArrayToHexStringFormated(this.NfcResponseFrame));
        throw new NfcFrameException("NFC_CRC Error: " + Util.ByteArrayToHexStringFormated(this.NfcResponseFrame));
      }
      this.NfcFrameLogger.Trace("CRC OK!");
    }

    public static ushort createCRC(byte[] frameBuffer, ushort? crcInitValue = null)
    {
      return crcInitValue.HasValue ? HandlerLib.CRC.CRC_CCITT(frameBuffer, (ushort) 0, (ushort) (frameBuffer.Length - 2), crcInitValue.Value) : HandlerLib.CRC.CRC_CCITT(frameBuffer, (ushort) 0, (ushort) (frameBuffer.Length - 2));
    }

    public void IsResponseErrorMsg()
    {
      byte num = this.NfcResponseFrame[0] == byte.MaxValue ? this.NfcResponseFrame[3] : this.NfcResponseFrame[1];
      if (this.NfcResponseFrame[0] == byte.MaxValue || num != (byte) 254)
        return;
      this.NfcFrameLogger.Error("NFC_Error Frame: " + Util.ByteArrayToHexStringFormated(this.NfcResponseFrame));
      this.ThrowErrorException(this.NfcResponseFrame);
    }

    private void ThrowErrorException(byte[] frameBuffer)
    {
      bool flag = true;
      StringBuilder stringBuilder = new StringBuilder();
      if (frameBuffer[2] == byte.MaxValue)
      {
        stringBuilder.Append("SubUnit_Device error: \r\n");
        stringBuilder.Append(frameBuffer[3].ToString("X02") + " -> Device Command: " + frameBuffer[3].ToString("x") + "\r\n");
        if (frameBuffer[4] < (byte) 128)
          stringBuilder.Append(frameBuffer[4].ToString("X02") + " -> " + ((NFC_DEVICE_ERROR) frameBuffer[4]).ToString() + "r\n");
        else
          stringBuilder.Append(frameBuffer[4].ToString("X02") + " -> " + ((CR95_RESULTCODE) frameBuffer[4]).ToString() + "\r\n");
      }
      else if (((int) frameBuffer[2] & 128) == 128)
      {
        frameBuffer[2] = (byte) ((uint) frameBuffer[2] & 4294967167U);
        stringBuilder.Append("Nfc_Device error: \r\n");
        stringBuilder.Append(frameBuffer[2].ToString("X02") + " -> " + ((NfcCommands) frameBuffer[2]).ToString() + "\r\n");
        stringBuilder.Append(frameBuffer[3].ToString("X02") + " -> Nfc_Version: " + frameBuffer[3].ToString() + "\r\n");
        stringBuilder.Append(frameBuffer[4].ToString("X02") + " -> " + ((NFC_DEVICE_ERROR) frameBuffer[4]).ToString() + "\r\n");
        NFC_DEVICE_ERROR nfcDeviceError = (NFC_DEVICE_ERROR) frameBuffer[4];
        flag = false;
        switch (nfcDeviceError)
        {
          case NFC_DEVICE_ERROR.NFC_ERR_CMD:
            stringBuilder.Insert(0, "The command is not supported by this firmware" + Environment.NewLine + Environment.NewLine);
            break;
          case NFC_DEVICE_ERROR.NFC_ERR_WRTPRM:
            stringBuilder.Insert(0, "Write access not allowed" + Environment.NewLine + Environment.NewLine);
            break;
          case NFC_DEVICE_ERROR.NFC_ERR_ISPROTECTED:
            stringBuilder.Insert(0, "Write access to protected area" + Environment.NewLine + Environment.NewLine);
            break;
          default:
            flag = true;
            break;
        }
      }
      else
      {
        stringBuilder.Append("Communication error: \r\n");
        stringBuilder.Append(frameBuffer[2].ToString("X02") + " -> " + ((NfcCommands) frameBuffer[2]).ToString() + "\r\n");
        stringBuilder.Append(frameBuffer[3].ToString("X02") + " -> " + ((NFC_TRANSMISSION_STATE) frameBuffer[3]).ToString() + "\r\n");
        stringBuilder.Append(frameBuffer[4].ToString("X02") + " -> " + ((CR95_RESULTCODE) frameBuffer[4]).ToString() + "\r\n");
        if (frameBuffer[4] == (byte) 144)
        {
          if (frameBuffer[5] != (byte) 4)
          {
            byte num = frameBuffer[frameBuffer.Length - 5];
            stringBuilder.Append(num.ToString("X02") + " -> ");
            if (((int) num & 128) == 128)
              stringBuilder.Append(CR95_RESULTCODE_90.RF_ERROR_COLLISION.ToString() + "\r\n");
            if (((int) num & 32) == 32)
              stringBuilder.Append(CR95_RESULTCODE_90.RF_ERROR_CRC.ToString() + "\r\n");
            if (((int) num & 16) == 16)
              stringBuilder.Append(CR95_RESULTCODE_90.RF_ERROR_PARITY.ToString() + "\r\n");
          }
          else
          {
            stringBuilder.Append(frameBuffer[6].ToString("X02"));
            if (frameBuffer[6] == (byte) 10)
              stringBuilder.Append(" -> ACK \r\n");
            else
              stringBuilder.Append(" -> NACK \r\n");
          }
        }
      }
      stringBuilder.Append(Util.ByteArrayToHexString(frameBuffer) + "\r\n");
      this.NfcFrameLogger.Error(stringBuilder.ToString());
      if (flag)
        throw new NfcFrameException(stringBuilder.ToString());
      throw new DeviceMessageException(stringBuilder.ToString());
    }

    public static byte[] GetFrameData(byte[] frame)
    {
      ushort frameLength = NfcFrame.GetFrameLength(frame);
      byte[] dst = new byte[(int) frameLength];
      if (frame[0] == byte.MaxValue)
        Buffer.BlockCopy((Array) frame, 3, (Array) dst, 0, (int) frameLength);
      else
        Buffer.BlockCopy((Array) frame, 1, (Array) dst, 0, (int) frameLength);
      return dst;
    }

    public static ushort GetFrameLength(byte[] frame)
    {
      return frame[0] != byte.MaxValue ? (ushort) frame[0] : (ushort) ((uint) frame[1] + ((uint) frame[2] << 8));
    }
  }
}


--- NfcFrameException.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NfcFrameException
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib.NFC
{
  public class NfcFrameException : Exception
  {
    public NfcFrameException()
    {
    }

    public NfcFrameException(string message)
      : base(message)
    {
    }

    public NfcFrameException(string message, Exception inner)
      : base(message, inner)
    {
    }
  }
}


--- NfcMemoryTransceiver.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NfcMemoryTransceiver
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib.NFC
{
  public class NfcMemoryTransceiver
  {
    private NfcRepeater myRepeater;
    private uint maxBufferSize = 64;

    public uint MaxBufferSize
    {
      get => this.maxBufferSize;
      set
      {
        this.maxBufferSize = value >= 64U && value <= 512U ? value : throw new Exception("Illegal MaxBufferSize: " + value.ToString());
      }
    }

    private uint MaxBlockSize
    {
      get => this.MaxBufferSize <= 64U ? this.MaxBufferSize - 9U : this.MaxBufferSize - 11U;
    }

    public NfcMemoryTransceiver(NfcRepeater myRepeater) => this.myRepeater = myRepeater;

    public async Task<byte[]> ReadMemoryAsync(
      uint startAddress,
      uint byteSize,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (byteSize == 0U)
        return new byte[0];
      int count = (int) (byteSize / this.MaxBlockSize);
      if (byteSize % this.MaxBlockSize > 0U)
        ++count;
      progress.Split(count);
      uint readAddress = startAddress;
      byte[] ReceivedMemory = new byte[(int) byteSize];
      do
      {
        uint blockSize = byteSize - (readAddress - startAddress);
        if (blockSize > this.MaxBlockSize)
          blockSize = this.MaxBlockSize;
        byte[] NfcResponseFrame = await this.ReadMemoryBlockAsync(readAddress, blockSize, progress, cancelToken);
        if ((long) NfcResponseFrame.Length == (long) (blockSize + 8U))
          Buffer.BlockCopy((Array) NfcResponseFrame, 6, (Array) ReceivedMemory, (int) readAddress - (int) startAddress, (int) blockSize);
        else if ((long) NfcResponseFrame.Length == (long) (blockSize + 10U))
        {
          if (NfcResponseFrame[0] != byte.MaxValue)
          {
            string ErrorText = "Read memory block failed. Long frame data length without 16 bit address coding";
            this.myRepeater.NfcRepeaterLogger.Error(ErrorText);
            throw new Exception(ErrorText);
          }
          Buffer.BlockCopy((Array) NfcResponseFrame, 8, (Array) ReceivedMemory, (int) readAddress - (int) startAddress, (int) blockSize);
        }
        else
        {
          string ErrorText = "Read memory block failed. Illegal result data length.";
          this.myRepeater.NfcRepeaterLogger.Error(ErrorText);
          throw new Exception(ErrorText);
        }
        readAddress += blockSize;
        NfcResponseFrame = (byte[]) null;
      }
      while (readAddress < startAddress + byteSize);
      return ReceivedMemory;
    }

    private async Task<byte[]> ReadMemoryBlockAsync(
      uint readAddress,
      uint blockSize,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] addr = BitConverter.GetBytes(readAddress);
      byte[] size = BitConverter.GetBytes(blockSize);
      byte[] frameData = new byte[6];
      Buffer.BlockCopy((Array) addr, 0, (Array) frameData, 0, 4);
      Buffer.BlockCopy((Array) size, 0, (Array) frameData, 4, 2);
      NfcFrame nfcFrame = new NfcFrame(NfcCommands.ReadMemory, frameData, this.myRepeater.myConfig.ReadingChannelIdentification, this.myRepeater.CrcInitValue);
      nfcFrame.ProgressParameter = " 0x" + readAddress.ToString("x08");
      int readTimeOffset = ((int) blockSize - 64) * 2;
      await this.myRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken, readTimeOffset);
      byte[] nfcResponseFrame = nfcFrame.NfcResponseFrame;
      addr = (byte[]) null;
      size = (byte[]) null;
      frameData = (byte[]) null;
      nfcFrame = (NfcFrame) null;
      return nfcResponseFrame;
    }

    public async Task<byte[]> WriteMemoryAsync(
      uint startAddress,
      byte[] WriteMemory,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (WriteMemory == null || WriteMemory.Length == 0)
        throw new Exception("No data defined for write operation");
      if (startAddress > 134742016U)
        this.maxBufferSize = 64U;
      uint writeAddress = startAddress;
      byte[] NfcResponseFrame = new byte[(int) this.MaxBufferSize];
      byte[] MemoryToTransmit = new byte[(int) this.MaxBufferSize];
      do
      {
        uint blockSize = (uint) (WriteMemory.Length - ((int) writeAddress - (int) startAddress));
        if (blockSize > this.MaxBlockSize)
          blockSize = this.MaxBlockSize;
        Buffer.BlockCopy((Array) WriteMemory, (int) writeAddress - (int) startAddress, (Array) MemoryToTransmit, 0, (int) blockSize);
        NfcResponseFrame = await this.WriteMemoryBlockAsync(writeAddress, MemoryToTransmit, blockSize, progress, cancelToken);
        int lenData = (int) NfcResponseFrame[0];
        if (lenData != 7)
          throw new Exception("Write failed!!!");
        writeAddress += blockSize;
      }
      while ((long) writeAddress < (long) startAddress + (long) WriteMemory.Length);
      byte[] numArray = NfcResponseFrame;
      NfcResponseFrame = (byte[]) null;
      MemoryToTransmit = (byte[]) null;
      return numArray;
    }

    private async Task<byte[]> WriteMemoryBlockAsync(
      uint writeAddress,
      byte[] MemoryToTransmit,
      uint blockSize,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] addr = BitConverter.GetBytes(writeAddress);
      byte[] frameData = new byte[(int) blockSize + 4];
      Buffer.BlockCopy((Array) addr, 0, (Array) frameData, 0, 4);
      Buffer.BlockCopy((Array) MemoryToTransmit, 0, (Array) frameData, 4, (int) blockSize);
      NfcFrame nfcFrame = new NfcFrame(NfcCommands.WriteMemory, frameData, this.myRepeater.myConfig.ReadingChannelIdentification, this.myRepeater.CrcInitValue);
      nfcFrame.ProgressParameter = " 0x" + writeAddress.ToString("x08");
      await this.myRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      byte[] nfcResponseFrame = nfcFrame.NfcResponseFrame;
      addr = (byte[]) null;
      frameData = (byte[]) null;
      nfcFrame = (NfcFrame) null;
      return nfcResponseFrame;
    }
  }
}


--- NfcRepeater.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NfcRepeater
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.Functions;
using GmmDbLib;
using NLog;
using System;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib.NFC
{
  public class NfcRepeater
  {
    private static Logger BaseNfcRepeaterLogger = LogManager.GetLogger(nameof (NfcRepeaterLogger));
    public ChannelLogger NfcRepeaterLogger;
    internal CommunicationPortFunctions ci;
    private ushort? CrcInitValueSaved;
    public readonly ConfigList myConfig;
    public Common32BitCommands IrDaCommands = (Common32BitCommands) null;
    public NfcRepeater.IrDaCommandWrapper IrDaWrapper = NfcRepeater.IrDaCommandWrapper.Non;
    public DownLinkTestWindow DownLinkWindow;

    public ushort? CrcInitValue { get; private set; }

    public int TotalDeviceRepeats { get; private set; }

    public NfcRepeater(CommunicationPortFunctions myPort)
    {
      this.ci = myPort;
      this.myConfig = myPort.GetReadoutConfiguration();
      this.NfcRepeaterLogger = new ChannelLogger(NfcRepeater.BaseNfcRepeaterLogger, this.myConfig);
    }

    public void ClearCrcInitValue()
    {
      this.CrcInitValue = new ushort?();
      this.TotalDeviceRepeats = 0;
    }

    public void SetCrcInitValue(uint MeterID)
    {
      this.CrcInitValue = new ushort?((ushort) (MeterID ^ MeterID >> 16));
      this.CrcInitValueSaved = this.CrcInitValue;
      this.TotalDeviceRepeats = 0;
    }

    public async Task GetResultFrameAsync(
      NfcFrame nfcFrame,
      ProgressHandler progress,
      CancellationToken cancelToken,
      int readTimeOffset = 0)
    {
      if (cancelToken.IsCancellationRequested)
        throw new TaskCanceledException();
      await Task.Run((Action) (() => this.GetResultFrame(nfcFrame, progress, cancelToken, readTimeOffset)));
    }

    public void GetResultFrame(
      NfcFrame nfcFrame,
      ProgressHandler progres,
      CancellationToken cancelToken,
      int readTimeOffset = 0)
    {
      if (readTimeOffset < 0)
        readTimeOffset = 0;
      if (this.IrDaCommands != null)
        this.GetIrDaResultFrame(nfcFrame, progres, cancelToken, readTimeOffset);
      else if (this.IrDaWrapper == NfcRepeater.IrDaCommandWrapper.DownlinkTest && this.DownLinkWindow != null)
      {
        byte[] numArray;
        if (nfcFrame.NfcCommand == NfcCommands.IrDa_Compatible_Command)
        {
          numArray = new byte[nfcFrame.NfcRequestFrame.Length - 4];
          Buffer.BlockCopy((Array) nfcFrame.NfcRequestFrame, 2, (Array) numArray, 0, numArray.Length);
        }
        else
        {
          byte[] frameData = NfcFrame.GetFrameData(nfcFrame.NfcRequestFrame);
          numArray = new byte[frameData.Length + 1];
          numArray[0] = (byte) 56;
          Buffer.BlockCopy((Array) frameData, 0, (Array) numArray, 1, frameData.Length);
        }
        if (!this.CrcInitValueSaved.HasValue)
          throw new Exception("CrcInitValueSaved not prepared for DownlinkTest");
        byte[] byteArray = Util.HexStringToByteArray("FFA55AF5AF");
        byte[] frameData1 = new byte[2 + byteArray.Length];
        frameData1[0] = (byte) 53;
        frameData1[1] = (byte) 9;
        byteArray.CopyTo((Array) frameData1, 2);
        NfcFrame nfcFrame1 = new NfcFrame(NfcCommands.IrDa_Compatible_Command, frameData1, "Send confirmed data", this.CrcInitValueSaved);
        byte[] uplinkBytes = this.DownLinkWindow.GetUplinkBytes(numArray, new DownLinkTestWindow.SendProtocol(this.TransmitAndGetResultFrame), nfcFrame1, progres, cancelToken);
        if (uplinkBytes == null)
          throw new OperationCanceledException();
        if (nfcFrame.NfcCommand == NfcCommands.IrDa_Compatible_Command)
        {
          nfcFrame.NfcResponseFrame = new byte[uplinkBytes.Length + 4];
          uplinkBytes.CopyTo((Array) nfcFrame.NfcResponseFrame, 2);
          nfcFrame.NfcResponseFrame[0] = (byte) (nfcFrame.NfcResponseFrame.Length - 3);
          nfcFrame.NfcResponseFrame[1] = (byte) 32;
          BitConverter.GetBytes(NfcFrame.createCRC(nfcFrame.NfcResponseFrame, this.CrcInitValue)).CopyTo((Array) nfcFrame.NfcResponseFrame, nfcFrame.NfcResponseFrame.Length - 2);
        }
        else
        {
          nfcFrame.NfcResponseFrame = new byte[uplinkBytes.Length + 2];
          nfcFrame.NfcResponseFrame[0] = (byte) (nfcFrame.NfcResponseFrame.Length - 3);
          Buffer.BlockCopy((Array) uplinkBytes, 1, (Array) nfcFrame.NfcResponseFrame, 1, uplinkBytes.Length - 1);
          BitConverter.GetBytes(NfcFrame.createCRC(nfcFrame.NfcResponseFrame, this.CrcInitValue)).CopyTo((Array) nfcFrame.NfcResponseFrame, nfcFrame.NfcResponseFrame.Length - 2);
        }
      }
      else
      {
        if (nfcFrame.NfcCommand != NfcCommands.IrDa_Compatible_Command)
        {
          NfcFrame nfcFrame2 = (NfcFrame) null;
          if (this.IrDaWrapper == NfcRepeater.IrDaCommandWrapper.SendNfcCommand)
          {
            byte[] frameData = NfcFrame.GetFrameData(nfcFrame.NfcRequestFrame);
            byte[] numArray = new byte[frameData.Length + 1];
            numArray[0] = (byte) 56;
            Buffer.BlockCopy((Array) frameData, 0, (Array) numArray, 1, frameData.Length);
            nfcFrame2 = frameData[0] != (byte) 1 ? new NfcFrame(NfcCommands.IrDa_Compatible_Command, numArray, this.myConfig.ReadingChannelIdentification, this.CrcInitValue) : new NfcFrame(NfcCommands.IrDa_Compatible_Command, numArray, this.myConfig.ReadingChannelIdentification, this.CrcInitValueSaved);
            nfcFrame2.ProgressParameter = nfcFrame.ProgressParameter;
          }
          else if (this.IrDaWrapper == NfcRepeater.IrDaCommandWrapper.SendToNfcDevice)
          {
            byte[] nfcRequestFrame = nfcFrame.NfcRequestFrame;
            byte[] numArray = new byte[nfcRequestFrame.Length + 2];
            numArray[0] = (byte) 54;
            numArray[1] = (byte) 11;
            Buffer.BlockCopy((Array) nfcRequestFrame, 0, (Array) numArray, 2, nfcRequestFrame.Length);
            nfcFrame2 = new NfcFrame(NfcCommands.IrDa_Compatible_Command, numArray, this.myConfig.ReadingChannelIdentification, this.CrcInitValue);
          }
          if (nfcFrame2 != null)
          {
            this.TransmitAndGetResultFrame(nfcFrame2, progres, cancelToken, readTimeOffset);
            nfcFrame.NfcResponseFrame = new byte[nfcFrame2.NfcResponseFrame.Length - 2];
            if (nfcFrame2.NfcResponseFrame[0] == byte.MaxValue)
            {
              ushort num = (ushort) ((uint) BitConverter.ToUInt16(nfcFrame2.NfcResponseFrame, 1) - 2U);
              nfcFrame.NfcResponseFrame[0] = byte.MaxValue;
              Buffer.BlockCopy((Array) BitConverter.GetBytes(num), 0, (Array) nfcFrame.NfcResponseFrame, 1, 2);
              Buffer.BlockCopy((Array) nfcFrame2.NfcResponseFrame, 5, (Array) nfcFrame.NfcResponseFrame, 3, nfcFrame.NfcResponseFrame.Length - 3);
              return;
            }
            nfcFrame.NfcResponseFrame[0] = (byte) ((uint) nfcFrame2.NfcResponseFrame[0] - 2U);
            Buffer.BlockCopy((Array) nfcFrame2.NfcResponseFrame, 3, (Array) nfcFrame.NfcResponseFrame, 1, nfcFrame.NfcResponseFrame.Length - 1);
            return;
          }
        }
        this.TransmitAndGetResultFrame(nfcFrame, progres, cancelToken, readTimeOffset);
      }
    }

    public void TransmitAndGetResultFrame(
      NfcFrame nfcFrame,
      ProgressHandler progres,
      CancellationToken cancelToken,
      int readTimeOffset = 0)
    {
      int? nullable = new int?();
      try
      {
        int num1 = (nfcFrame.NfcRequestFrame.Length - 64) * 2;
        if (num1 < 0)
          num1 = 0;
        if (num1 > 0 || readTimeOffset > 0)
        {
          nullable = new int?(num1 + readTimeOffset);
          this.ci.GetReadoutConfiguration().RecTime_BeforFirstByte += nullable.Value;
        }
        for (int index = 0; index < this.myConfig.MaxRequestRepeat; ++index)
        {
          if (cancelToken.IsCancellationRequested)
            throw new TaskCanceledException();
          try
          {
            this.NfcRepeaterLogger.Trace("NFC transmit: " + Util.ByteArrayToHexStringFormated(nfcFrame.NfcRequestFrame));
            this.ci.DiscardInBuffer();
            this.ci.Write(nfcFrame.NfcRequestFrame);
            int num2 = 3;
            byte[] numArray = this.ci.ReadHeader(num2);
            this.NfcRepeaterLogger.Trace("NFC header received: " + Util.ByteArrayToHexStringFormated(numArray));
            int length = numArray[0] == byte.MaxValue ? (int) BitConverter.ToUInt16(numArray, 1) + 5 : (int) numArray[0] + 3;
            byte[] src = this.ci.ReadEnd(length - num2);
            nfcFrame.NfcResponseFrame = new byte[length];
            Buffer.BlockCopy((Array) numArray, 0, (Array) nfcFrame.NfcResponseFrame, 0, numArray.Length);
            Buffer.BlockCopy((Array) src, 0, (Array) nfcFrame.NfcResponseFrame, num2, src.Length);
            this.NfcRepeaterLogger.Trace("NFC frame received: " + Util.ByteArrayToHexStringFormated(nfcFrame.NfcResponseFrame));
            nfcFrame.IsResponseErrorMsg();
            nfcFrame.IsResponseCrcOk();
            if (nfcFrame.ProgressParameter == null)
              break;
            progres.Report(nfcFrame.NfcCommand.ToString() + nfcFrame.ProgressParameter);
            break;
          }
          catch (TaskCanceledException ex)
          {
            throw ex;
          }
          catch (DeviceMessageException ex)
          {
            this.NfcRepeaterLogger.Error("DeviceMessageException");
            throw ex;
          }
          catch (NfcFrameException ex)
          {
            this.NfcRepeaterLogger.Error("NFC_Frame Exception");
            if (index >= this.myConfig.MaxRequestRepeat - 1)
              throw ex;
          }
          catch (TimeoutException ex)
          {
            this.NfcRepeaterLogger.Info("Timeout", (Exception) ex);
            if (index >= this.myConfig.MaxRequestRepeat - 1)
              throw new TimeoutException(Ot.Gtm(Tg.CommunicationLogic, "NfcReadTimeout", "Nfc read timeout"), (Exception) ex);
          }
          catch (Exception ex)
          {
            this.NfcRepeaterLogger.Trace("NfcRepeaterException: " + ex.ToString());
            if (index >= this.myConfig.MaxRequestRepeat - 1)
              throw new Exception("NfcRepeaterException", ex);
          }
          Thread.Sleep(this.myConfig.WaitBeforeRepeatTime);
          ++this.TotalDeviceRepeats;
        }
      }
      finally
      {
        if (nullable.HasValue)
          this.ci.GetReadoutConfiguration().RecTime_BeforFirstByte -= nullable.Value;
      }
    }

    public async Task TransmitFrameAsync(
      NfcFrame nfcFrame,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitFrameFromTask(nfcFrame, progress, cancelToken)));
    }

    private void TransmitFrameFromTask(
      NfcFrame nfcFrame,
      ProgressHandler progres,
      CancellationToken cancelToken)
    {
      this.NfcRepeaterLogger.Trace("NFC transmit: " + Util.ByteArrayToHexStringFormated(nfcFrame.NfcRequestFrame));
      this.ci.Write(nfcFrame.NfcRequestFrame);
    }

    private void GetIrDaResultFrame(
      NfcFrame nfcFrame,
      ProgressHandler progress,
      CancellationToken cancelToken,
      int readTimeOffset)
    {
      byte[] nfcRequestFrame = nfcFrame.NfcRequestFrame;
      if (this.IrDaCommands.DeviceCMD.ConnectedReducedID == null)
        this.IrDaCommands.DeviceCMD.ReadVersion(progress, cancelToken);
      byte[] data = this.IrDaCommands.TransmitAndGetData(Manufacturer_FC.SpecialCommands_0x36, new byte?((byte) 11), nfcRequestFrame, false, progress, cancelToken);
      nfcFrame.NfcResponseFrame = data;
    }

    private enum UsedConfigSettings
    {
      MaxRequestRepeat,
      WaitBeforeRepeatTime,
    }

    public enum IrDaCommandWrapper
    {
      Non,
      SendToNfcDevice,
      SendNfcCommand,
      DownlinkTest,
    }
  }
}


--- NfcSubunitCommands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.NfcSubunitCommands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.Functions;
using NLog;
using System;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib.NFC
{
  public class NfcSubunitCommands
  {
    protected static Logger MiConConnectorLogger = LogManager.GetLogger("MiConConnector");
    private NfcRepeater myRepeater;
    public string MiConConnectorIdentification;

    public NfcSubunitCommands(CommunicationPortFunctions port)
    {
      this.myRepeater = new NfcRepeater(port);
    }

    private async Task<byte[]> WorkSubunitCommand(
      SubunitCommands command,
      ProgressHandler progress,
      CancellationToken cancelToken,
      byte?[] data = null)
    {
      byte[] cmd;
      if (data == null)
      {
        cmd = new byte[1]{ (byte) command };
      }
      else
      {
        cmd = new byte[data.Length + 1];
        for (int i = 0; i < data.Length; ++i)
          cmd[i + 1] = data[i].Value;
        cmd[0] = (byte) command;
      }
      string str = command.ToString();
      NfcFrame nfcFrame = new NfcFrame(NfcCommands.SubUnitCommand, cmd, this.myRepeater.myConfig.ReadingChannelIdentification);
      NfcSubunitCommands.MiConConnectorLogger.Trace("Send " + str + " frame: " + Util.ByteArrayToHexStringFormated(nfcFrame.NfcRequestFrame));
      await this.myRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      byte[] nfcResponseFrame = nfcFrame.NfcResponseFrame;
      cmd = (byte[]) null;
      str = (string) null;
      nfcFrame = (NfcFrame) null;
      return nfcResponseFrame;
    }

    public async Task<string> GetEchoAsync(ProgressHandler progress, CancellationToken cancelToken)
    {
      byte[] NfcResponseFrame = await this.WorkSubunitCommand(SubunitCommands.Coup_Echo, progress, cancelToken);
      string hexString = Util.ByteArrayToHexString(NfcResponseFrame);
      NfcResponseFrame = (byte[]) null;
      return hexString;
    }

    public async Task<string> ReadIdentificationAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] NfcResponseFrame = await this.WorkSubunitCommand(SubunitCommands.Con_GetIdent, progress, cancelToken);
      this.MiConConnectorIdentification = Util.ByteArrayToHexString(NfcResponseFrame);
      string connectorIdentification = this.MiConConnectorIdentification;
      NfcResponseFrame = (byte[]) null;
      return connectorIdentification;
    }

    public async Task<MiConConnectorVersion> ReadMiConIdentificationAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] NfcResponseFrame = await this.WorkSubunitCommand(SubunitCommands.Con_GetIdent, progress, cancelToken);
      MiConConnectorVersion nfcDI = new MiConConnectorVersion(NfcResponseFrame);
      MiConConnectorVersion connectorVersion = nfcDI;
      NfcResponseFrame = (byte[]) null;
      nfcDI = (MiConConnectorVersion) null;
      return connectorVersion;
    }

    public async Task WriteMiConIdentificationAsync(
      byte?[] ident,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] NfcResponseFrame = await this.WorkSubunitCommand(SubunitCommands.Con_SetIdent, progress, cancelToken, ident);
      NfcResponseFrame = (byte[]) null;
    }

    public async Task WriteMiConMeterIDAsync(
      uint meterID,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Delay(1);
      throw new Exception("Not Implemented YET !!!");
    }

    public async Task<string> ReadCouplerIdentificationAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] NfcResponseFrame = await this.WorkSubunitCommand(SubunitCommands.Coup_Ident, progress, cancelToken);
      this.MiConConnectorIdentification = Util.ByteArrayToHexString(NfcResponseFrame);
      string str = Util.ByteArrayToString(Util.HexStringToByteArray(this.MiConConnectorIdentification)).Substring(7, 8);
      NfcResponseFrame = (byte[]) null;
      return str;
    }

    public async Task<NdcMiConModuleHardwareIds> ReadNdcMiConModuleHardwareIds(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      NdcMiConModuleHardwareIds theIds = new NdcMiConModuleHardwareIds();
      NdcMiConModuleHardwareIds moduleHardwareIds1 = theIds;
      MiConConnectorVersion connectorVersion = await this.ReadMiConIdentificationAsync(progress, cancelToken);
      moduleHardwareIds1.MiConConnectorID = Util.ByteArrayToHexString(connectorVersion.Unique_ID);
      moduleHardwareIds1 = (NdcMiConModuleHardwareIds) null;
      connectorVersion = (MiConConnectorVersion) null;
      NdcMiConModuleHardwareIds moduleHardwareIds2 = theIds;
      string str = await this.ReadCouplerIdentificationAsync(progress, cancelToken);
      moduleHardwareIds2.NfcCouplerID = str;
      moduleHardwareIds2 = (NdcMiConModuleHardwareIds) null;
      str = (string) null;
      NdcMiConModuleHardwareIds moduleHardwareIds = theIds;
      theIds = (NdcMiConModuleHardwareIds) null;
      return moduleHardwareIds;
    }

    public async Task<byte[]> SetRfOnAsync(ProgressHandler progress, CancellationToken cancelToken)
    {
      byte?[] rfOn = new byte?[1]{ new byte?((byte) 2) };
      byte[] numArray = await this.WorkSubunitCommand(SubunitCommands.Coup_SetRF, progress, cancelToken, rfOn);
      rfOn = (byte?[]) null;
      return numArray;
    }

    public async Task<byte[]> SetRfOffAsync(ProgressHandler progress, CancellationToken cancelToken)
    {
      byte?[] rfOff = new byte?[1]{ new byte?((byte) 0) };
      byte[] numArray = await this.WorkSubunitCommand(SubunitCommands.Coup_SetRF, progress, cancelToken, rfOff);
      rfOff = (byte?[]) null;
      return numArray;
    }

    public async Task<byte[]> NFC_AnticollisionAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] numArray = await this.WorkSubunitCommand(SubunitCommands.NFC_Anticollision, progress, cancelToken);
      return numArray;
    }

    public async Task<byte[]> NFC_GetTagIdentAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] tagIdentAsync = await this.WorkSubunitCommand(SubunitCommands.NFC_GetTagIdent, progress, cancelToken);
      return tagIdentAsync;
    }

    public async Task<byte[]> NFC_GetTagStatusAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte?[] getStatus = new byte?[2]
      {
        new byte?((byte) 248),
        new byte?((byte) 3)
      };
      byte[] tagStatusAsync = await this.WorkSubunitCommand(SubunitCommands.NFC_GetTagStatus, progress, cancelToken, getStatus);
      getStatus = (byte?[]) null;
      return tagStatusAsync;
    }

    public async Task<byte[]> SetTestOff(ProgressHandler progress, CancellationToken cancelToken)
    {
      byte?[] testOff = new byte?[1]{ new byte?((byte) 0) };
      byte[] numArray = await this.WorkSubunitCommand(SubunitCommands.Con_SetTest, progress, cancelToken, testOff);
      testOff = (byte?[]) null;
      return numArray;
    }

    public async Task<byte[]> SetTestStart(
      byte[] NFC_Frame,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte?[] testStart = new byte?[NFC_Frame.Length + 1];
      for (int i = 0; i < NFC_Frame.Length; ++i)
        testStart[i + 1] = new byte?(NFC_Frame[i]);
      testStart[0] = new byte?((byte) 1);
      byte[] numArray = await this.WorkSubunitCommand(SubunitCommands.Con_SetTest, progress, cancelToken, testStart);
      testStart = (byte?[]) null;
      return numArray;
    }

    public async Task<byte[]> SetTestStop(
      byte[] NFC_Frame,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte?[] testStop = new byte?[NFC_Frame.Length + 1];
      for (int i = 0; i < NFC_Frame.Length; ++i)
        testStop[i + 1] = new byte?(NFC_Frame[i]);
      testStop[0] = new byte?((byte) 2);
      byte[] numArray = await this.WorkSubunitCommand(SubunitCommands.Con_SetTest, progress, cancelToken, testStop);
      testStop = (byte?[]) null;
      return numArray;
    }

    public async Task<byte[]> StartCouplerCurrentMeasurement(
      ushort cycleTime,
      ushort startCycleOffset,
      ushort logCycles,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte?[] startCurrMeas = new byte?[6]
      {
        new byte?((byte) cycleTime),
        new byte?((byte) ((uint) cycleTime >> 8)),
        new byte?((byte) startCycleOffset),
        new byte?((byte) ((uint) startCycleOffset >> 8)),
        new byte?((byte) logCycles),
        new byte?((byte) ((uint) logCycles >> 8))
      };
      byte[] numArray = await this.WorkSubunitCommand(SubunitCommands.Con_MeasCouplerCurrent, progress, cancelToken, startCurrMeas);
      startCurrMeas = (byte?[]) null;
      return numArray;
    }

    public async Task<ushort[]> GetCouplerCurrentValues(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] resultBytes = await this.WorkSubunitCommand(SubunitCommands.Con_GetCurrentValues, progress, cancelToken);
      ushort offset = 3;
      ushort size = (ushort) ((resultBytes.Length - 5) / 2);
      ushort[] currentSamples = new ushort[(int) size];
      for (ushort i = 0; (int) size - (int) i > 0; ++i)
        currentSamples[(int) i] = (ushort) ((uint) resultBytes[(int) offset + (2 * (int) i + 1)] << 8 | (uint) resultBytes[(int) offset + 2 * (int) i]);
      ushort[] couplerCurrentValues = currentSamples;
      resultBytes = (byte[]) null;
      currentSamples = (ushort[]) null;
      return couplerCurrentValues;
    }

    public async Task MiConConnector_Reset(ProgressHandler progress, CancellationToken cancelToken)
    {
      byte[] numArray = await this.WorkSubunitCommand(SubunitCommands.Con_ResetDevice, progress, cancelToken);
    }

    public async Task<byte[]> ReadNdcMemory_Async(
      uint startAddress,
      uint byteSize,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (byteSize <= 0U)
        throw new Exception("Please Check MemoryAddresses. The Endaddress is lower or equal to Startaddress!!!");
      int count = (int) (byteSize / 55U);
      if (byteSize % 55U > 0U)
        ++count;
      progress.Split(count);
      uint readAddress = startAddress;
      byte[] ReceivedMemory = new byte[(int) byteSize];
      do
      {
        uint blockSize = byteSize - (readAddress - startAddress);
        if (blockSize > 55U)
          blockSize = 55U;
        byte[] NfcResponseFrame = await this.ReadNdcMemoryBlock_Async(readAddress, blockSize, progress, cancelToken);
        Buffer.BlockCopy((Array) NfcResponseFrame, 7, (Array) ReceivedMemory, (int) readAddress - (int) startAddress, (int) blockSize);
        readAddress += blockSize;
        NfcResponseFrame = (byte[]) null;
      }
      while (readAddress < startAddress + byteSize);
      byte[] numArray = ReceivedMemory;
      ReceivedMemory = (byte[]) null;
      return numArray;
    }

    private async Task<byte[]> ReadNdcMemoryBlock_Async(
      uint readAddress,
      uint blockSize,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] addr = BitConverter.GetBytes(readAddress);
      byte[] size = BitConverter.GetBytes(blockSize);
      byte[] frameData = new byte[6];
      Buffer.BlockCopy((Array) addr, 0, (Array) frameData, 0, 4);
      Buffer.BlockCopy((Array) size, 0, (Array) frameData, 4, 2);
      byte[] numArray = await this.WorkSubunitCommand(SubunitCommands.Con_ReadMemory, progress, cancelToken, Enumerable.Cast<byte?>(frameData).ToArray<byte?>());
      addr = (byte[]) null;
      size = (byte[]) null;
      frameData = (byte[]) null;
      return numArray;
    }

    public async Task<byte[]> SubUnit_WriteMemory_Async(
      uint startAddress,
      byte[] WriteMemory,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (WriteMemory == null || WriteMemory.Length == 0)
        throw new Exception("No data defined for write operation");
      uint writeAddress = startAddress;
      byte[] NfcResponseFrame = new byte[64];
      byte[] MemoryToTransmit = new byte[64];
      do
      {
        uint blockSize = (uint) (WriteMemory.Length - ((int) writeAddress - (int) startAddress));
        if (blockSize > 50U)
          blockSize = 50U;
        Buffer.BlockCopy((Array) WriteMemory, (int) writeAddress - (int) startAddress, (Array) MemoryToTransmit, 0, (int) blockSize);
        NfcResponseFrame = await this.SubUnit_WriteMemoryBlock_Async(writeAddress, MemoryToTransmit, blockSize, progress, cancelToken);
        int lenData = (int) NfcResponseFrame[0];
        if (lenData != 8)
          throw new Exception("Write failed!!!");
        writeAddress += blockSize;
      }
      while ((long) writeAddress < (long) startAddress + (long) WriteMemory.Length);
      byte[] numArray = NfcResponseFrame;
      NfcResponseFrame = (byte[]) null;
      MemoryToTransmit = (byte[]) null;
      return numArray;
    }

    private async Task<byte[]> SubUnit_WriteMemoryBlock_Async(
      uint writeAddress,
      byte[] MemoryToTransmit,
      uint blockSize,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] addr = BitConverter.GetBytes(writeAddress);
      byte[] frameData = new byte[(int) blockSize + 4];
      Buffer.BlockCopy((Array) addr, 0, (Array) frameData, 0, 4);
      Buffer.BlockCopy((Array) MemoryToTransmit, 0, (Array) frameData, 4, (int) blockSize);
      byte[] numArray = await this.WorkSubunitCommand(SubunitCommands.Con_WriteMemory, progress, cancelToken, Enumerable.Cast<byte?>(frameData).ToArray<byte?>());
      addr = (byte[]) null;
      frameData = (byte[]) null;
      return numArray;
    }

    public async Task<byte[]> NDC_USB_StartBootloader(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] numArray = await this.WorkSubunitCommand(SubunitCommands.Con_NDC_USB_StartBootloader, progress, cancelToken);
      return numArray;
    }
  }
}


--- SubunitCommands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC.SubunitCommands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib.NFC
{
  internal enum SubunitCommands
  {
    Con_SetTest = 0,
    Con_MeasCouplerCurrent = 1,
    Con_GetCurrentValues = 2,
    Con_GetIdent = 3,
    Con_ResetDevice = 4,
    Con_SetIdent = 5,
    Con_NDC_USB_StartBootloader = 6,
    Con_WriteMemory = 11, // 0x0000000B
    Con_ReadMemory = 12, // 0x0000000C
    Coup_Echo = 16, // 0x00000010
    Coup_Ident = 17, // 0x00000011
    Coup_SetRF = 18, // 0x00000012
    NFC_Anticollision = 32, // 0x00000020
    NFC_GetTagIdent = 33, // 0x00000021
    NFC_GetTagStatus = 34, // 0x00000022
  }
}

