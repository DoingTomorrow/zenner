
--- AccessHandlerFromHandlerName.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.AccessHandlerFromHandlerName
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using PlugInLib;
using StartupLib;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

#nullable disable
namespace HandlerLib
{
  public static class AccessHandlerFromHandlerName
  {
    public static IHandler CreateHandlerAndGetIHandlerInterface(string handlerName)
    {
      Assembly assembly = Assembly.LoadFrom(handlerName + ".dll");
      Type type = ((IEnumerable<Type>) assembly.GetTypes()).Where<Type>((Func<Type, bool>) (x => x.GetInterface("IHandler") != (Type) null)).First<Type>((Func<Type, bool>) (x => x.Name == handlerName + "Functions"));
      return assembly.CreateInstance(type.ToString()) as IHandler;
    }

    public static HandlerFunctionsForProduction CreateHandlerAndGetProductionInterface(
      string handlerName)
    {
      Assembly assembly = Assembly.LoadFrom(handlerName + ".dll");
      Type type = ((IEnumerable<Type>) assembly.GetTypes()).First<Type>((Func<Type, bool>) (x => x.BaseType == typeof (HandlerFunctionsForProduction)));
      return assembly.CreateInstance(type.ToString()) as HandlerFunctionsForProduction;
    }

    public static HandlerFunctionsForProduction GetProductionInterfaceFromIWindowFunctionsInterface(
      IWindowFunctions iWindowfunctions)
    {
      object functions = iWindowfunctions.GetFunctions();
      if (functions == null)
        throw new Exception("HandlerFunctions not available");
      return functions is HandlerFunctionsForProduction ? functions as HandlerFunctionsForProduction : throw new Exception("HandlerFunctionsForProduction not supported");
    }

    public static HandlerFunctionsForProduction GetProductionInterfaceFromHandlerPlugin(
      GmmPlugIn plugIn)
    {
      object obj1 = plugIn.GetPluginInfo().Interface;
      object obj2 = !(obj1.GetType().GetInterface("IWindowFunctions") == (Type) null) ? (obj1 as IWindowFunctions).GetFunctions() : throw new Exception("IWindowFunctions not supported");
      return obj2 is HandlerFunctionsForProduction ? obj2 as HandlerFunctionsForProduction : throw new Exception("HandlerFunctionsForProduction not supported");
    }
  }
}


--- AddressRangeInfo.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.AddressRangeInfo
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System.Collections.Generic;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class AddressRangeInfo : AddressRange
  {
    public string RangeInfo;
    public int Order;

    public AddressRangeInfo(string rangeInfo, AddressRange theRange)
      : base(theRange)
    {
      this.RangeInfo = rangeInfo;
    }

    public static List<AddressRangeInfo> GetRangeInfos(
      string rangeInfo,
      List<AddressRange> theRanges)
    {
      List<AddressRangeInfo> rangeInfos = new List<AddressRangeInfo>();
      if (theRanges != null)
      {
        foreach (AddressRange theRange in theRanges)
          rangeInfos.Add(new AddressRangeInfo(rangeInfo, theRange));
      }
      return rangeInfos;
    }

    public static void AddGaps(List<AddressRangeInfo> theList)
    {
      for (int index = 0; index < theList.Count - 1; ++index)
      {
        int size = (int) theList[index + 1].StartAddress - (int) theList[index].EndAddress - 1;
        if (size > 0)
          theList.Insert(index + 1, new AddressRangeInfo("   *** gap", new AddressRange(theList[index].EndAddress + 1U, (uint) size)));
      }
    }
  }
}


--- AES_ENCRYPTION_MODE.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.AES_ENCRYPTION_MODE
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum AES_ENCRYPTION_MODE
  {
    OFF = 0,
    MODE_5 = 5,
    MODE_7 = 7,
  }
}


--- AssemblyInfo.cs ---

﻿using System.Reflection;
using System.Runtime.InteropServices;
using System.Windows;

[assembly: AssemblyTitle("HandlerLib")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("ZENNER")]
[assembly: AssemblyProduct("HandlerLib")]
[assembly: AssemblyCopyright("Copyright ©  2015")]
[assembly: AssemblyTrademark("")]
[assembly: ComVisible(false)]
[assembly: ThemeInfo(ResourceDictionaryLocation.None, ResourceDictionaryLocation.SourceAssembly)]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: AssemblyVersion("1.0.0.0")]


--- BackupWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.BackupWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using GmmDbLib;
using GmmDbLib.DataSets;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class BackupWindow : Window, IComponentConnector, IStyleConnector
  {
    private FirmwareType[] fwType;
    private static BackupWindow window;
    private ICreateMeter handler;
    private string[] hardwareName;
    private ObservableCollection<BaseTables.MeterRow> listMeter;
    private ObservableCollection<BaseTables.MeterDataRow> listMeterData;
    private bool isV2;
    private bool useDataFilter;
    private bool useSecondDB;
    internal TextBox txtInfo;
    internal DatePicker DatePickerProductionStartDate;
    internal DatePicker DatePickerProductionEndDate;
    internal TimeControl txtProductionStartTime;
    internal TimeControl txtProductionEndTime;
    internal Button ButtonStartSearch;
    internal Button ButtonStop;
    internal TextBox txtSerialnumber;
    internal TextBox txtMeterID;
    internal TextBox txtOrderNumber;
    internal DatePicker DatePickerApprovalStartDate;
    internal DatePicker DatePickerApprovalEndDate;
    internal TimeControl txtApprovalStartTime;
    internal TimeControl txtApprovalEndTime;
    internal Label LabelCount;
    internal DataGrid DataGridMeter;
    internal DataGrid DataGridMeterData;
    internal Button ButtonOpen;
    internal ComboBox ComboBoxFwTypes;
    private bool _contentLoaded;

    private BackupWindow()
    {
      this.InitializeComponent();
      this.txtProductionEndTime.DateTimeValue = new DateTime?(new DateTime(2000, 1, 1, 23, 59, 0));
      this.txtApprovalEndTime.DateTimeValue = new DateTime?(new DateTime(2000, 1, 1, 23, 59, 0));
      this.listMeter = new ObservableCollection<BaseTables.MeterRow>();
      this.listMeterData = new ObservableCollection<BaseTables.MeterDataRow>();
      this.DataGridMeter.DataContext = (object) this.listMeter;
      this.DataGridMeterData.DataContext = (object) this.listMeterData;
      this.useDataFilter = true;
      this.useSecondDB = false;
    }

    private void BackupWindow_Loaded(object sender, RoutedEventArgs e)
    {
      this.ButtonStartSearch_Click(sender, e);
    }

    public static byte[] ShowDialog(
      Window owner,
      ICreateMeter handler,
      FirmwareType fwType,
      bool isV2,
      bool useSecondDB = false)
    {
      return BackupWindow.ShowDialog(owner, handler, new FirmwareType[1]
      {
        fwType
      }, (isV2 ? 1 : 0) != 0, (useSecondDB ? 1 : 0) != 0);
    }

    public static byte[] ShowDialog(
      Window owner,
      ICreateMeter handler,
      FirmwareType[] fwType,
      bool isV2,
      bool useSecondDB = false)
    {
      return BackupWindow.ShowDialog(owner, handler, (string[]) null, fwType, isV2, useSecondDB);
    }

    public static byte[] ShowDialog(
      Window owner,
      ICreateMeter handler,
      string hardwareName,
      bool isV2)
    {
      return BackupWindow.ShowDialog(owner, handler, new string[1]
      {
        hardwareName
      }, (isV2 ? 1 : 0) != 0);
    }

    public static byte[] ShowDialog(
      Window owner,
      ICreateMeter handler,
      string[] hardwareName,
      bool isV2)
    {
      return BackupWindow.ShowDialog(owner, handler, hardwareName, (FirmwareType[]) null, isV2);
    }

    public static byte[] ShowDialog(Window owner, uint? meterID)
    {
      BackupWindow.window = new BackupWindow();
      BackupWindow.window.Owner = owner;
      BackupWindow.window.handler = (ICreateMeter) null;
      BackupWindow.window.hardwareName = new string[1]
      {
        string.Empty
      };
      BackupWindow.window.fwType = new FirmwareType[1];
      BackupWindow.window.isV2 = false;
      BackupWindow.window.useDataFilter = false;
      Device.MeterFound += new EventHandler<BaseTables.MeterRow>(BackupWindow.Device_MeterFound);
      Device.SearchDone += new EventHandler(BackupWindow.Device_SearchDone);
      BackupWindow.window.txtMeterID.Text = meterID.HasValue ? meterID.ToString() : throw new ArgumentException("Invalid call!");
      BackupWindow.window.ComboBoxFwTypes.SelectedIndex = 0;
      BackupWindow.window.ButtonOpen.IsEnabled = true;
      BackupWindow.window.txtMeterID.IsEnabled = false;
      BackupWindow.window.txtOrderNumber.IsEnabled = false;
      BackupWindow.window.txtProductionEndTime.IsEnabled = false;
      BackupWindow.window.txtProductionStartTime.IsEnabled = false;
      BackupWindow.window.txtSerialnumber.IsEnabled = false;
      BackupWindow.window.DatePickerApprovalEndDate.IsEnabled = false;
      BackupWindow.window.DatePickerApprovalStartDate.IsEnabled = false;
      BackupWindow.window.DatePickerProductionEndDate.IsEnabled = false;
      BackupWindow.window.DatePickerProductionStartDate.IsEnabled = false;
      BackupWindow.window.txtInfo.Visibility = Visibility.Hidden;
      BackupWindow.window.Loaded += new RoutedEventHandler(BackupWindow.window.BackupWindow_Loaded);
      try
      {
        return BackupWindow.window.ShowDialog().Value && BackupWindow.window.DataGridMeterData != null && BackupWindow.window.DataGridMeterData.SelectedCells.Any<DataGridCellInfo>() && BackupWindow.window.DataGridMeterData.SelectedCells[0].Item is BaseTables.MeterDataRow meterDataRow && !meterDataRow.IsPValueBinaryNull() ? meterDataRow.PValueBinary : (byte[]) null;
      }
      finally
      {
        Device.MeterFound -= new EventHandler<BaseTables.MeterRow>(BackupWindow.Device_MeterFound);
        Device.SearchDone -= new EventHandler(BackupWindow.Device_SearchDone);
        BackupWindow.window.Loaded -= new RoutedEventHandler(BackupWindow.window.BackupWindow_Loaded);
      }
    }

    private static byte[] ShowDialog(
      Window owner,
      ICreateMeter handler,
      string[] hardwareName,
      FirmwareType[] fwType,
      bool isV2,
      bool useSecondDB = false)
    {
      if (handler == null)
        throw new ArgumentNullException(nameof (handler));
      if (useSecondDB && DbBasis.SecondaryDB == null)
        throw new Exception("Secondary data base not defined");
      BackupWindow.window = new BackupWindow();
      BackupWindow.window.Owner = owner;
      BackupWindow.window.handler = handler;
      BackupWindow.window.hardwareName = hardwareName;
      BackupWindow.window.fwType = fwType;
      BackupWindow.window.isV2 = isV2;
      BackupWindow.window.useSecondDB = useSecondDB;
      Device.MeterFound += new EventHandler<BaseTables.MeterRow>(BackupWindow.Device_MeterFound);
      Device.SearchDone += new EventHandler(BackupWindow.Device_SearchDone);
      if (fwType != null)
        BackupWindow.window.ComboBoxFwTypes.ItemsSource = (IEnumerable) fwType;
      else
        BackupWindow.window.ComboBoxFwTypes.ItemsSource = hardwareName != null ? (IEnumerable) hardwareName : throw new ArgumentException("Invalid call!");
      BackupWindow.window.ComboBoxFwTypes.SelectedIndex = 0;
      try
      {
        return BackupWindow.window.ShowDialog().Value && BackupWindow.window.DataGridMeterData != null && BackupWindow.window.DataGridMeterData.SelectedCells.Any<DataGridCellInfo>() && BackupWindow.window.DataGridMeterData.SelectedCells[0].Item is BaseTables.MeterDataRow meterDataRow && !meterDataRow.IsPValueBinaryNull() ? meterDataRow.PValueBinary : (byte[]) null;
      }
      finally
      {
        Device.MeterFound -= new EventHandler<BaseTables.MeterRow>(BackupWindow.Device_MeterFound);
        Device.SearchDone -= new EventHandler(BackupWindow.Device_SearchDone);
      }
    }

    private static void Device_SearchDone(object sender, EventArgs e)
    {
      if (!BackupWindow.window.CheckAccess())
      {
        BackupWindow.window.Dispatcher.Invoke((Action) (() => BackupWindow.Device_SearchDone(sender, e)));
      }
      else
      {
        BackupWindow.window.ButtonStop.IsEnabled = false;
        BackupWindow.window.ButtonStartSearch.IsEnabled = true;
        if (BackupWindow.window.listMeter.Count > 0)
        {
          DataGrid dataGridMeter = BackupWindow.window.DataGridMeter;
          dataGridMeter.CurrentCell = new DataGridCellInfo(dataGridMeter.Items[0], dataGridMeter.Columns[0]);
          dataGridMeter.SelectedCells.Add(dataGridMeter.CurrentCell);
        }
        else
        {
          BackupWindow.window.LabelCount.Content = (object) 0;
          int num = (int) MessageBox.Show((Window) BackupWindow.window, "No results!");
        }
      }
    }

    private static void Device_MeterFound(object sender, BaseTables.MeterRow e)
    {
      if (!BackupWindow.window.CheckAccess())
      {
        BackupWindow.window.Dispatcher.Invoke((Action) (() => BackupWindow.Device_MeterFound(sender, e)));
      }
      else
      {
        BackupWindow.window.listMeter.Add(e);
        BackupWindow.window.LabelCount.Content = (object) BackupWindow.window.listMeter.Count;
      }
    }

    private void ButtonStartSearch_Click(object sender, RoutedEventArgs e)
    {
      this.listMeter.Clear();
      this.txtInfo.Text = string.Empty;
      BackupWindow.window.ButtonStartSearch.IsEnabled = false;
      BackupWindow.window.ButtonStop.IsEnabled = true;
      string str1 = this.txtSerialnumber.Text;
      if (!string.IsNullOrEmpty(str1) && str1.IndexOf(" ") > -1)
        str1 = str1.Replace(" ", "").Trim();
      string str2 = this.txtMeterID.Text;
      if (!string.IsNullOrEmpty(str2) && str2.IndexOf(" ") > -1)
        str2 = str2.Replace(" ", "").Trim();
      DateTime? selectedDate1 = this.DatePickerProductionStartDate.SelectedDate;
      DateTime? selectedDate2 = this.DatePickerProductionEndDate.SelectedDate;
      DateTime? dateTimeValue1 = this.txtProductionStartTime.DateTimeValue;
      DateTime? dateTimeValue2 = this.txtProductionEndTime.DateTimeValue;
      DateTime? selectedDate3 = this.DatePickerApprovalStartDate.SelectedDate;
      DateTime? selectedDate4 = this.DatePickerApprovalEndDate.SelectedDate;
      DateTime? dateTimeValue3 = this.txtApprovalStartTime.DateTimeValue;
      DateTime? dateTimeValue4 = this.txtApprovalEndTime.DateTimeValue;
      string str3 = str1;
      string str4 = str2;
      string text = this.txtOrderNumber.Text;
      DateTime? nullable1 = BackupWindow.ConcatDateTime(selectedDate1, dateTimeValue1);
      DateTime? nullable2 = BackupWindow.ConcatDateTime(selectedDate2, dateTimeValue2);
      DateTime? nullable3 = BackupWindow.ConcatDateTime(selectedDate3, dateTimeValue3);
      DateTime? nullable4 = BackupWindow.ConcatDateTime(selectedDate4, dateTimeValue4);
      string empty = string.Empty;
      FirmwareType firmwareType = FirmwareType.None;
      if (BackupWindow.window.ComboBoxFwTypes.SelectedItem != null)
      {
        if (BackupWindow.window.ComboBoxFwTypes.SelectedItem is FirmwareType)
          firmwareType = (FirmwareType) BackupWindow.window.ComboBoxFwTypes.SelectedItem;
        else
          empty = BackupWindow.window.ComboBoxFwTypes.SelectedItem.ToString();
      }
      else
        empty = string.Empty;
      BaseDbConnection db = !this.useSecondDB ? DbBasis.PrimaryDB.BaseDbConnection : DbBasis.SecondaryDB.BaseDbConnection;
      DeviceSearchFilter filter = new DeviceSearchFilter();
      filter.ProductionStartDate = nullable1;
      filter.ProductionEndDate = nullable2;
      filter.ApprovalStartDate = nullable3;
      filter.ApprovalEndDate = nullable4;
      filter.Serialnumber = str3;
      filter.MeterID = str4;
      filter.OrderNumber = text;
      filter.HardwareName = empty;
      filter.FwType = firmwareType;
      filter.IsOldVersion = !this.isV2;
      int num = this.useDataFilter ? 1 : 0;
      Device.StartSearch(db, filter, num != 0);
    }

    private void ButtonStop_Click(object sender, RoutedEventArgs e)
    {
      Device.CancelSearch();
      BackupWindow.window.ButtonStop.IsEnabled = false;
      BackupWindow.window.ButtonStartSearch.IsEnabled = true;
    }

    private void ButtonOpen_Click(object sender, RoutedEventArgs e)
    {
      if (this.DataGridMeterData == null || !this.DataGridMeterData.SelectedCells.Any<DataGridCellInfo>() || !(this.DataGridMeterData.SelectedCells[0].Item is BaseTables.MeterDataRow))
        return;
      this.DialogResult = new bool?(true);
      this.Close();
    }

    private static DateTime? ConcatDateTime(DateTime? date, DateTime? time)
    {
      if (!date.HasValue || !time.HasValue)
        return new DateTime?();
      DateTime dateTime = date.Value;
      int year = dateTime.Year;
      dateTime = date.Value;
      int month = dateTime.Month;
      dateTime = date.Value;
      int day = dateTime.Day;
      dateTime = time.Value;
      int hour = dateTime.Hour;
      dateTime = time.Value;
      int minute = dateTime.Minute;
      return new DateTime?(new DateTime(year, month, day, hour, minute, 0));
    }

    private void DataGridMeter_SelectedCellsChanged(object sender, SelectedCellsChangedEventArgs e)
    {
      this.listMeterData.Clear();
      if (this.DataGridMeter == null || !this.DataGridMeter.SelectedCells.Any<DataGridCellInfo>())
        return;
      BaseTables.MeterRow meterRow = this.DataGridMeter.SelectedCells[0].Item as BaseTables.MeterRow;
      List<BaseTables.MeterDataRow> source = MeterData.LoadMeterData(!this.useSecondDB ? DbBasis.PrimaryDB.BaseDbConnection : DbBasis.SecondaryDB.BaseDbConnection, meterRow.MeterID);
      if (source == null)
        return;
      foreach (BaseTables.MeterDataRow meterDataRow in source.OrderByDescending<BaseTables.MeterDataRow, DateTime>((Func<BaseTables.MeterDataRow, DateTime>) (o => o.TimePoint)).ToList<BaseTables.MeterDataRow>())
        this.listMeterData.Add(meterDataRow);
      DataGrid dataGridMeterData = this.DataGridMeterData;
      dataGridMeterData.CurrentCell = new DataGridCellInfo(dataGridMeterData.Items[0], dataGridMeterData.Columns[0]);
      dataGridMeterData.SelectedCells.Add(dataGridMeterData.CurrentCell);
    }

    private void DataGridMeterData_SelectedCellsChanged(
      object sender,
      SelectedCellsChangedEventArgs e)
    {
      this.txtInfo.Text = string.Empty;
      if (this.DataGridMeterData == null || !this.DataGridMeterData.SelectedCells.Any<DataGridCellInfo>())
        return;
      BaseTables.MeterDataRow meterData = this.DataGridMeterData.SelectedCells[0].Item as BaseTables.MeterDataRow;
      if (meterData.IsPValueBinaryNull())
        return;
      try
      {
        if (Enum.IsDefined(typeof (MeterData.Special), (object) meterData.PValueID))
        {
          this.txtInfo.Text = (this.handler as IMeterDataSpecial).Create(meterData).ToString();
        }
        else
        {
          if (this.handler == null)
            return;
          IMeter meter = this.handler.CreateMeter(meterData.PValueBinary);
          if (meter == null)
            return;
          this.txtInfo.Text = meter.GetInfo();
        }
      }
      catch (Exception ex)
      {
        this.txtInfo.Text = ex.Message;
      }
    }

    private void DatePickerProductionStartDate_SelectedDateChanged(
      object sender,
      SelectionChangedEventArgs e)
    {
      if (!this.DatePickerProductionStartDate.SelectedDate.HasValue || this.DatePickerProductionEndDate.SelectedDate.HasValue)
        return;
      this.DatePickerProductionEndDate.SelectedDate = this.DatePickerProductionStartDate.SelectedDate;
    }

    private void DatePickerApprovalStartDate_SelectedDateChanged(
      object sender,
      SelectionChangedEventArgs e)
    {
      if (!this.DatePickerApprovalStartDate.SelectedDate.HasValue || this.DatePickerApprovalEndDate.SelectedDate.HasValue)
        return;
      this.DatePickerApprovalEndDate.SelectedDate = this.DatePickerApprovalStartDate.SelectedDate;
    }

    private void Input_KeyDown(object sender, KeyEventArgs e)
    {
      if (e.Key != Key.Return)
        return;
      this.ButtonStartSearch_Click((object) this, (RoutedEventArgs) null);
    }

    private void Row_DoubleClick(object sender, MouseButtonEventArgs e)
    {
      this.ButtonOpen_Click(sender, (RoutedEventArgs) null);
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/backupwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    internal Delegate _CreateDelegate(Type delegateType, string handler)
    {
      return Delegate.CreateDelegate(delegateType, (object) this, handler);
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.txtInfo = (TextBox) target;
          break;
        case 2:
          this.DatePickerProductionStartDate = (DatePicker) target;
          this.DatePickerProductionStartDate.SelectedDateChanged += new EventHandler<SelectionChangedEventArgs>(this.DatePickerProductionStartDate_SelectedDateChanged);
          break;
        case 3:
          this.DatePickerProductionEndDate = (DatePicker) target;
          break;
        case 4:
          this.txtProductionStartTime = (TimeControl) target;
          break;
        case 5:
          this.txtProductionEndTime = (TimeControl) target;
          break;
        case 6:
          this.ButtonStartSearch = (Button) target;
          this.ButtonStartSearch.Click += new RoutedEventHandler(this.ButtonStartSearch_Click);
          break;
        case 7:
          this.ButtonStop = (Button) target;
          this.ButtonStop.Click += new RoutedEventHandler(this.ButtonStop_Click);
          break;
        case 8:
          this.txtSerialnumber = (TextBox) target;
          this.txtSerialnumber.KeyDown += new KeyEventHandler(this.Input_KeyDown);
          break;
        case 9:
          this.txtMeterID = (TextBox) target;
          this.txtMeterID.KeyDown += new KeyEventHandler(this.Input_KeyDown);
          break;
        case 10:
          this.txtOrderNumber = (TextBox) target;
          this.txtOrderNumber.KeyDown += new KeyEventHandler(this.Input_KeyDown);
          break;
        case 11:
          this.DatePickerApprovalStartDate = (DatePicker) target;
          this.DatePickerApprovalStartDate.SelectedDateChanged += new EventHandler<SelectionChangedEventArgs>(this.DatePickerApprovalStartDate_SelectedDateChanged);
          break;
        case 12:
          this.DatePickerApprovalEndDate = (DatePicker) target;
          break;
        case 13:
          this.txtApprovalStartTime = (TimeControl) target;
          break;
        case 14:
          this.txtApprovalEndTime = (TimeControl) target;
          break;
        case 15:
          this.LabelCount = (Label) target;
          break;
        case 16:
          this.DataGridMeter = (DataGrid) target;
          this.DataGridMeter.SelectedCellsChanged += new SelectedCellsChangedEventHandler(this.DataGridMeter_SelectedCellsChanged);
          break;
        case 17:
          this.DataGridMeterData = (DataGrid) target;
          this.DataGridMeterData.SelectedCellsChanged += new SelectedCellsChangedEventHandler(this.DataGridMeterData_SelectedCellsChanged);
          break;
        case 19:
          this.ButtonOpen = (Button) target;
          this.ButtonOpen.Click += new RoutedEventHandler(this.ButtonOpen_Click);
          break;
        case 20:
          this.ComboBoxFwTypes = (ComboBox) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IStyleConnector.Connect(int connectionId, object target)
    {
      if (connectionId != 18)
        return;
      ((Style) target).Setters.Add((SetterBase) new EventSetter()
      {
        Event = Control.MouseDoubleClickEvent,
        Handler = (Delegate) new MouseButtonEventHandler(this.Row_DoubleClick)
      });
    }
  }
}


--- BaseMemoryAccess.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.BaseMemoryAccess
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class BaseMemoryAccess
  {
    public virtual async Task ReadMemoryAsync(
      AddressRange addressRange,
      DeviceMemory deviceMemory,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      throw new NotImplementedException(nameof (ReadMemoryAsync));
    }

    public virtual async Task WriteMemoryAsync(
      AddressRange addressRange,
      DeviceMemory deviceMemory,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      throw new NotImplementedException(nameof (WriteMemoryAsync));
    }

    public virtual async Task<DeviceIdentification> ReadVersionAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      throw new NotImplementedException(nameof (ReadVersionAsync));
    }

    public virtual async Task InterruptConnection(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
    }
  }
}


--- BatteryEnergyManagement.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.BatteryEnergyManagement
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using NLog;
using System;

#nullable disable
namespace HandlerLib
{
  public class BatteryEnergyManagement
  {
    public const uint SecondsPerYear = 31536000;
    public const uint SecondsPerHalfYear = 15768000;
    public const uint SecondsPerMonth = 2592000;
    public const uint SecondsPerDay = 86400;
    protected static Logger SetBatteryEnergyLogger = LogManager.GetLogger("SetBatteryEnergy");
    protected static Logger GetBatteryEnergyLogger = LogManager.GetLogger("GetBatteryEnergy");
    protected double BatteryUsableFactor = 0.7;
    protected double VolumeCycleEnergy_mAh_per_cycle = 0.0;
    protected double TemperatureMeasurement_mAh_per_cycle = 0.0;
    protected double EnergyCalculationEnergy_mAh_per_cycle = 0.0;
    protected double RadioTransmitEnergy_mAh_per_telegram = 0.0;
    protected int NumberOfRadioInputs = 0;
    protected double RadioTransmitEnergy_mAh_per_inputTelegram = 0.0;
    protected double RadioEnergy_mAh_per_cycle;
    protected double StandbyEnergy_mAh_per_year = 0.0;
    protected double VolumeCycleEnergy_mAh_per_year = 0.0;
    protected double TemperatureMeasurement_mAh_per_year = 0.0;
    protected double EnergyCalculationEnergy_mAh_per_year = 0.0;
    protected double RadioEnergy_mAh_per_year = 0.0;
    protected double? PossibleHourDiagnosticYears;
    protected DateTime NewBatteryStartDate;
    protected bool SetConfig;
    protected Logger NlogLogger;

    public double BatteryCapacity_mAh { get; protected set; }

    public DateTime MinRequiredBatteryEndDate { get; protected set; }

    public double VolumeCycle_s { get; protected set; }

    public double EnergyCycle_s { get; protected set; }

    public double RadioCycle_s { get; protected set; }

    public uint UsableBatteryCapacity_mAh
    {
      get => (uint) (this.BatteryCapacity_mAh * this.BatteryUsableFactor);
    }

    public double BatteryEnergyPerYear_mAh
    {
      get
      {
        return this.StandbyEnergy_mAh_per_year + this.VolumeCycleEnergy_mAh_per_year + this.TemperatureMeasurement_mAh_per_year + this.EnergyCalculationEnergy_mAh_per_year + this.RadioEnergy_mAh_per_year;
      }
    }

    public double MaxBatteryYears
    {
      get => (double) this.UsableBatteryCapacity_mAh / this.BatteryEnergyPerYear_mAh;
    }

    public double RequiredBatteryYears
    {
      get
      {
        return (double) this.MinRequiredBatteryEndDate.Subtract(this.NewBatteryStartDate).Days / 365.0;
      }
    }

    public double MissingBatteryMonth => (this.RequiredBatteryYears - this.MaxBatteryYears) * 12.0;

    public double RemainingYears => this.MaxBatteryYears - this.RequiredBatteryYears;

    public double Remaining_mAh
    {
      get => (double) this.UsableBatteryCapacity_mAh / this.MaxBatteryYears * this.RemainingYears;
    }

    public DateTime MaxEndOfBatteryDate
    {
      get
      {
        return this.NewBatteryStartDate.Date.AddDays((double) ((int) (this.MaxBatteryYears * 365.3) + 1));
      }
    }

    public uint? LoRaDiagnosticCounts { get; protected set; }

    public BatteryEnergyManagement(double batteryNominalCapacity_mAh, DateTime deviceTime)
    {
      this.NewBatteryStartDate = deviceTime;
      this.BatteryCapacity_mAh = batteryNominalCapacity_mAh;
      this.VolumeCycle_s = 0.0;
      this.EnergyCycle_s = 0.0;
      this.RadioCycle_s = 0.0;
    }

    public double GetEnergyForLoRaBytes_mAh(int bytes)
    {
      if (bytes == 24)
        return BatteryEnergyManagement.GetEnergyForTime_mAh(29.0, 1.7);
      if (bytes == 30)
        return BatteryEnergyManagement.GetEnergyForTime_mAh(29.0, 1.9);
      throw new Exception("Illegal LoRa telegram bytes: " + bytes.ToString());
    }

    public static double GetEnergyForTime_mAh(double current_mA, double activeTime_s)
    {
      return activeTime_s == 0.0 ? 0.0 : current_mA * activeTime_s / 3600.0;
    }

    public static double GetEnergyPerYear_mAh(double energyPerCycle, double cycleTime_s)
    {
      return cycleTime_s == 0.0 ? 0.0 : energyPerCycle * 31536000.0 / cycleTime_s;
    }

    protected void StartNLogLogging(bool setConfig)
    {
      this.SetConfig = setConfig;
      if (this.SetConfig)
      {
        this.NlogLogger = BatteryEnergyManagement.SetBatteryEnergyLogger;
        this.NlogLogger.Trace("*** SetBatteryEnergy ***");
      }
      else
      {
        this.NlogLogger = BatteryEnergyManagement.GetBatteryEnergyLogger;
        this.NlogLogger.Trace("*** GetBatteryEnergy ***");
      }
    }

    protected void LogResultsAndExceptionOnSet()
    {
      if (this.NlogLogger.IsTraceEnabled)
      {
        this.NlogLogger.Trace("BatteryNominalCapacity_mAh = " + this.BatteryCapacity_mAh.ToString("0.0") + "; BatteryUsableFactor = " + this.BatteryUsableFactor.ToString("0.00") + "; UsableBatteryCapacity_mAh = " + this.UsableBatteryCapacity_mAh.ToString());
        this.NlogLogger.Trace("VolumeCycle_s = " + this.VolumeCycle_s.ToString() + "; EnergyCycle_s = " + this.EnergyCycle_s.ToString() + "; RadioCycle_s = " + this.RadioCycle_s.ToString());
        this.NlogLogger.Trace("StandbyEnergy_mAh_per_year = " + this.StandbyEnergy_mAh_per_year.ToString());
        if (this.VolumeCycle_s > 0.0)
          this.NlogLogger.Trace("VolumeCycleEnergy_mAh_per_year = " + this.VolumeCycleEnergy_mAh_per_year.ToString());
        if (this.EnergyCycle_s > 0.0)
          this.NlogLogger.Trace("TemperatureMeasurement_mAh_per_year = " + this.TemperatureMeasurement_mAh_per_year.ToString() + "; EnergyCalculationEnergy_mAh_per_year = " + this.EnergyCalculationEnergy_mAh_per_year.ToString());
        if (this.RadioCycle_s > 0.0)
          this.NlogLogger.Trace("RadioEnergy_mAh_per_year = " + this.RadioEnergy_mAh_per_year.ToString("0.0"));
        Logger nlogLogger1 = this.NlogLogger;
        double num = this.BatteryEnergyPerYear_mAh;
        string message1 = "-> BatteryEnergyPerYear_mAh = " + num.ToString();
        nlogLogger1.Trace(message1);
        this.NlogLogger.Trace("NewBatteryStartDate = " + this.NewBatteryStartDate.ToShortDateString() + "; RequiredBatteryEndDate = " + this.MinRequiredBatteryEndDate.ToShortDateString() + "; MaxBatteryEndDate = " + this.MaxEndOfBatteryDate.ToShortDateString());
        Logger nlogLogger2 = this.NlogLogger;
        num = this.RequiredBatteryYears;
        string str1 = num.ToString("0.00");
        num = this.MaxBatteryYears;
        string str2 = num.ToString("0.00");
        string message2 = "RequiredBatteryYears = " + str1 + "; MaxBatteryYears = " + str2;
        nlogLogger2.Trace(message2);
        if (this.MissingBatteryMonth > 0.0)
        {
          Logger nlogLogger3 = this.NlogLogger;
          num = this.MissingBatteryMonth;
          string message3 = "-> MissingBatteryMonth = " + num.ToString("0.00");
          nlogLogger3.Trace(message3);
        }
        else
        {
          Logger nlogLogger4 = this.NlogLogger;
          num = this.MissingBatteryMonth * -1.0;
          string message4 = "-> BatteryReserveMonth = " + num.ToString("0.00");
          nlogLogger4.Trace(message4);
        }
      }
      if (this.SetConfig && this.MaxEndOfBatteryDate < this.MinRequiredBatteryEndDate)
        throw new BatteryNotEnoughException(this);
    }
  }
}


--- BatteryNotEnoughException.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.BatteryNotEnoughException
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Runtime.Serialization;

#nullable disable
namespace HandlerLib
{
  public class BatteryNotEnoughException : Exception
  {
    public BatteryEnergyManagement BatteryManagement;

    public BatteryNotEnoughException(BatteryEnergyManagement batteryManagement)
    {
      double num = batteryManagement.RequiredBatteryYears;
      string str1 = num.ToString("0.00");
      num = batteryManagement.MissingBatteryMonth;
      string str2 = num.ToString("0.000");
      // ISSUE: explicit constructor call
      base.\u002Ector("Battery not enough! Required years:" + str1 + "; Missing month:" + str2);
      this.BatteryManagement = batteryManagement;
    }

    protected BatteryNotEnoughException(SerializationInfo info, StreamingContext context)
    {
    }
  }
}


--- BootLoader_FC.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.BootLoader_FC
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum BootLoader_FC : byte
  {
    GET_VERSION,
    READ_MEMORY,
    WRITE_MEMORY,
    ERASE_MEMORY,
    GO,
  }
}


--- BootLoaderFunctions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.BootLoaderFunctions
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.Functions;
using ReadoutConfiguration;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZENNER.CommonLibrary.Exceptions;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class BootLoaderFunctions
  {
    private CommunicationPortFunctions myPort = (CommunicationPortFunctions) null;
    private FirmwareUpdateToolDeviceCommands DeviceCMD = (FirmwareUpdateToolDeviceCommands) null;
    public byte[] response;
    public bool isIUW = false;
    private Stopwatch watch;

    public BootLoaderFunctions(
      CommunicationPortFunctions port,
      FirmwareUpdateToolDeviceCommands fwUpDevCMD = null)
    {
      this.myPort = port;
      this.myPort.OnResponse += new EventHandler<byte[]>(this.myPort_OnResponse);
      this.isIUW = false;
      ConfigList readoutConfiguration = this.myPort.GetReadoutConfiguration();
      bool flag = Enum.IsDefined(typeof (BTL_NON_NFC_Devices), (object) new ConnectionProfileIdentification(readoutConfiguration.ConnectionProfileID).DeviceModelID);
      if (readoutConfiguration.BusMode != null)
        this.isIUW = readoutConfiguration.BusMode.Contains("NFC") && !flag;
      this.DeviceCMD = fwUpDevCMD;
      this.watch = new Stopwatch();
    }

    private void myPort_OnResponse(object sender, byte[] e)
    {
      this.response = new byte[e.Length];
      if (e.Length == 0)
        return;
      Buffer.BlockCopy((Array) e, 0, (Array) this.response, 0, e.Length);
    }

    public async Task writeMemoryAsync(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      uint address,
      byte[] data)
    {
      if (this.isIUW)
      {
        if (address >= 134742016U)
          this.DeviceCMD.SetBlockMode(false, 64U);
        else
          this.DeviceCMD.SetBlockMode();
        await this.DeviceCMD.WriteMemoryAsync(progress, cancel.Token, address, data);
      }
      else
        await Task.Run((Action) (() => this.writeMemory(progress, cancel, address, data)));
    }

    private void writeMemory(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      uint address,
      byte[] data)
    {
      if (progress == null)
        throw new ArgumentNullException(nameof (progress));
      if (cancel == null)
        throw new ArgumentNullException("token");
      if (address == 0U)
        throw new ArgumentException(nameof (address));
      if (data == null)
        throw new ArgumentNullException("buffer");
      cancel.Token.ThrowIfCancellationRequested();
      byte[] numArray = new byte[3];
      Buffer.BlockCopy((Array) BitConverter.GetBytes(data.Length), 0, (Array) numArray, 0, 3);
      List<byte> byteList = new List<byte>();
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(address));
      byteList.AddRange((IEnumerable<byte>) numArray);
      byteList.AddRange((IEnumerable<byte>) data);
      this.TransmitAndCheckAck(BootLoader_FC.WRITE_MEMORY, byteList.ToArray(), progress, cancel.Token, BTL_MEM_ERROR.ERROR_ADR);
    }

    public async Task<byte[]> readMemoryAsync(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      uint address,
      uint count,
      bool overrideIUW = true)
    {
      if (overrideIUW && this.isIUW)
      {
        this.DeviceCMD.SetBlockMode();
        byte[] numArray = await this.DeviceCMD.ReadMemoryAsync(progress, cancel.Token, address, count);
        return numArray;
      }
      byte[] numArray1 = await Task.Run<byte[]>((Func<byte[]>) (() => this.readMemory(progress, cancel, address, count)));
      return numArray1;
    }

    internal byte[] readMemory(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      uint address,
      uint count)
    {
      if (progress == null)
        throw new ArgumentNullException(nameof (progress));
      if (cancel == null)
        throw new ArgumentNullException("token");
      if (count <= 0U)
        throw new ArgumentOutOfRangeException(nameof (count));
      cancel.Token.ThrowIfCancellationRequested();
      byte[] numArray = new byte[3];
      Buffer.BlockCopy((Array) BitConverter.GetBytes(count), 0, (Array) numArray, 0, 3);
      List<byte> byteList = new List<byte>();
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(address));
      byteList.AddRange((IEnumerable<byte>) numArray);
      byte[] data = this.TransmitAndGetData(BootLoader_FC.READ_MEMORY, byteList.ToArray(), false, progress, cancel.Token);
      byte[] dst = new byte[(int) count];
      Buffer.BlockCopy((Array) data, 7, (Array) dst, 0, (int) count);
      if ((long) dst.Length != (long) count)
        throw new Exception("Invalid response by read the memory! Expected: " + count.ToString() + " bytes but received: " + data.Length.ToString() + " byte(s)");
      return dst;
    }

    internal uint verifyMemory(uint startAddress, uint endAddress)
    {
      if (startAddress <= 0U)
        throw new ArgumentOutOfRangeException(nameof (startAddress));
      if (endAddress <= 0U)
        throw new ArgumentOutOfRangeException(nameof (endAddress));
      if (!this.isIUW)
        return 0;
      this.DeviceCMD.SetBlockMode();
      return (uint) this.DeviceCMD.VerifyMemory(startAddress, endAddress);
    }

    internal async Task<uint> verifyMemoryAsync(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      uint startAddress,
      uint endAddress)
    {
      if (progress == null)
        throw new ArgumentNullException(nameof (progress));
      if (cancel == null)
        throw new ArgumentNullException("token");
      if (startAddress <= 0U)
        throw new ArgumentOutOfRangeException(nameof (startAddress));
      if (endAddress <= 0U)
        throw new ArgumentOutOfRangeException(nameof (endAddress));
      cancel.Token.ThrowIfCancellationRequested();
      if (!this.isIUW)
        return 0;
      this.DeviceCMD.SetBlockMode();
      ushort num = await this.DeviceCMD.VerifyMemoryAsync(progress, cancel.Token, startAddress, endAddress);
      return (uint) num;
    }

    public async Task eraseMemoryAsync(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      uint address,
      uint count)
    {
      if (this.isIUW)
        ;
      else
        await Task.Run((Action) (() => this.eraseMemory(progress, cancel, address, count)));
    }

    private void eraseMemory(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      uint address,
      uint count)
    {
      if (progress == null)
        throw new ArgumentNullException(nameof (progress));
      if (cancel == null)
        throw new ArgumentNullException("token");
      if (count <= 0U)
        throw new ArgumentOutOfRangeException(nameof (count));
      cancel.Token.ThrowIfCancellationRequested();
      byte[] numArray = new byte[3];
      Buffer.BlockCopy((Array) BitConverter.GetBytes(count), 0, (Array) numArray, 0, 3);
      List<byte> byteList = new List<byte>();
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(address));
      byteList.AddRange((IEnumerable<byte>) numArray);
      this.TransmitAndCheckAck(BootLoader_FC.ERASE_MEMORY, byteList.ToArray(), progress, cancel.Token, BTL_MEM_ERROR.ERROR_ADR);
    }

    public async Task<byte[]> getVersionAsync(
      ProgressHandler progress,
      CancellationTokenSource cancel)
    {
      if (this.isIUW)
      {
        byte[] versionAsync = await this.DeviceCMD.getVersionAsync(progress, cancel.Token);
        return versionAsync;
      }
      byte[] versionAsync1 = await Task.Run<byte[]>((Func<byte[]>) (() => this.getVersion(progress, cancel)));
      return versionAsync1;
    }

    private byte[] getVersion(ProgressHandler progress, CancellationTokenSource cancel)
    {
      int num = 3;
      if (progress == null)
        throw new ArgumentNullException(nameof (progress));
      if (cancel == null)
        throw new ArgumentNullException("token");
      cancel.Token.ThrowIfCancellationRequested();
      progress.Split(num + 1);
      for (int index = 0; index < num; ++index)
      {
        progress.Report("Try to connect ... " + (index + 1).ToString());
        byte[] data = this.TransmitAndGetData(BootLoader_FC.GET_VERSION, (byte[]) null, false, progress, cancel.Token);
        if (data.Length != 0)
          return data;
        Thread.Sleep(500);
      }
      throw new Exception("No answer after " + num.ToString() + " attempts, please check connection to BOOTLOADER ...");
    }

    public async Task GO_Async(ProgressHandler progress, CancellationTokenSource cancel)
    {
      if (this.isIUW)
        await this.DeviceCMD.ResetDeviceAsync(progress, cancel.Token);
      else
        await Task.Run((Action) (() => this.GO(progress, cancel)));
    }

    private void GO(ProgressHandler progress, CancellationTokenSource cancel)
    {
      if (progress == null)
        throw new ArgumentNullException(nameof (progress));
      if (cancel == null)
        throw new ArgumentNullException("token");
      cancel.Token.ThrowIfCancellationRequested();
      this.TransmitAndCheckAck(BootLoader_FC.GO, (byte[]) null, progress, cancel.Token);
    }

    public async Task TransmitAndCheckAckAsync(
      BootLoader_FC FC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken,
      BTL_MEM_ERROR typ = BTL_MEM_ERROR.ERROR_NO)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, data, progress, cancelToken, typ)));
    }

    private void TransmitAndCheckAck(
      BootLoader_FC FC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken,
      BTL_MEM_ERROR typ = BTL_MEM_ERROR.ERROR_NO)
    {
      byte[] data1 = this.TransmitAndGetData(FC, data, true, progress, cancelToken);
      if (data1 == null || data1.Length > 1)
        throw new Exception("Illegal ACK data received.");
      if (data1.Length > 2)
        throw new Exception("Too much ACK data.");
      if (data1[0] != (byte) 229 && (BTL_MEM_ERROR) data1[0] != typ)
      {
        foreach (byte num in Enum.GetValues(typeof (BTL_MEM_ERROR)))
        {
          if ((int) data1[0] == (int) num)
            throw new Exception("Error received from device. Type: " + Enum.GetName(typeof (BTL_MEM_ERROR), (object) num));
        }
        throw new Exception("Error while incorrect return error typ from device.");
      }
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      BootLoader_FC FC,
      byte[] parameter,
      bool ACK_allowed,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, parameter, false, progress, cancelToken)));
      return dataAsync;
    }

    private byte[] TransmitAndGetData(
      BootLoader_FC FC,
      byte[] parameterBytes,
      bool ACK_allowed,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int num1 = 0;
      if (parameterBytes != null)
        num1 = parameterBytes.Length;
      int dstOffset = 0;
      int num2 = 0;
      int length = num1 + 4;
      byte[] numArray1 = new byte[length];
      byte[] numArray2 = new byte[4]
      {
        (byte) 104,
        BitConverter.GetBytes(length)[0],
        BitConverter.GetBytes(length)[1],
        (byte) 104
      };
      byte[] numArray3 = new byte[length + numArray2.Length];
      Buffer.BlockCopy((Array) numArray2, 0, (Array) numArray3, dstOffset, numArray2.Length);
      int num3 = dstOffset + numArray2.Length;
      byte[] numArray4 = numArray1;
      int index1 = num2;
      int num4 = index1 + 1;
      int num5 = (int) FC;
      numArray4[index1] = (byte) num5;
      if (parameterBytes != null)
      {
        for (int index2 = 0; index2 < num1; ++index2)
          numArray1[num4++] = parameterBytes[index2];
      }
      byte[] numArray5 = new byte[length - 3];
      Buffer.BlockCopy((Array) numArray1, 0, (Array) numArray5, 0, numArray5.Length);
      byte[] bytes = BitConverter.GetBytes(CRC.CRC_CCITT(numArray5));
      byte[] numArray6 = numArray1;
      int index3 = num4;
      int num6 = index3 + 1;
      int num7 = (int) bytes[0];
      numArray6[index3] = (byte) num7;
      byte[] numArray7 = numArray1;
      int index4 = num6;
      int num8 = index4 + 1;
      int num9 = (int) bytes[1];
      numArray7[index4] = (byte) num9;
      byte[] numArray8 = numArray1;
      int index5 = num8;
      int num10 = index5 + 1;
      numArray8[index5] = (byte) 22;
      if (numArray1 != null)
      {
        for (int index6 = 0; index6 < numArray1.Length; ++index6)
          numArray3[num3++] = numArray1[index6];
      }
      this.response = new byte[0];
      if (!this.myPort.IsOpen)
        this.myPort.Open();
      this.myPort.Write(numArray3);
      this.response = this.myPort.ReadHeader(1);
      if (ACK_allowed && this.response[0] != (byte) 104)
        return this.response;
      if (this.response[0] == (byte) 26)
        throw new NACK_Exception("(NACK)Not acknowledged command or data received, please check ...");
      List<byte> source = new List<byte>();
      source.AddRange((IEnumerable<byte>) this.response);
      source.AddRange((IEnumerable<byte>) this.myPort.ReadEnd(3));
      this.response = source.ToArray<byte>();
      ushort uint16 = BitConverter.ToUInt16(this.response, 1);
      if (uint16 > (ushort) 0)
      {
        this.response = this.myPort.ReadEnd((int) uint16);
        if (this.response.Length != 0)
        {
          if (ACK_allowed && (BootLoader_FC) (this.response[0] ^= (byte) 128) != FC)
            throw new NACK_Exception("COMMAND error ...\nPlease check command.");
          byte[] dst = new byte[(int) uint16 - 4];
          Buffer.BlockCopy((Array) this.response, 1, (Array) dst, 0, dst.Length);
          return dst;
        }
      }
      progress.Report("Error writing bytes to device ...");
      throw new Exception("Error while writing bytes to device.\nNO or wrong answer from device.\nHead: " + Util.ByteArrayToString(numArray2) + "\nPayLoad: " + Util.ByteArrayToString(numArray1) + "\nResponse:" + Util.ByteArrayToString(this.response));
    }
  }
}


--- BTL_MEM_ERROR.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.BTL_MEM_ERROR
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum BTL_MEM_ERROR : byte
  {
    ERROR_ERR = 26, // 0x1A
    ERROR_CRC = 27, // 0x1B
    ERROR_ADR = 28, // 0x1C
    ERROR_ERASE = 29, // 0x1D
    ERROR_WRITE = 30, // 0x1E
    ERROR_NO = 229, // 0xE5
  }
}


--- BTL_NON_NFC_Devices.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.BTL_NON_NFC_Devices
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum BTL_NON_NFC_Devices
  {
    DEVICE_MODELL_ID = 80, // 0x00000050
  }
}


--- BusModuleCommand.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.BusModuleCommand
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum BusModuleCommand : byte
  {
    BUS_ASYNC_NO_COMMAND,
    BUS_ASYNC_MODULE_INITIALISATION,
    BUS_ASYNC_CHANGE_STATE,
    BUS_ASYNC_SAVE_SETUP_TO_MASTER,
    BUS_ASYNC_LOAD_SETUP_FROM_MASTER,
    BUS_ASYNC_TRANSPARENT_TO_MODULE,
    BUS_ASYNC_TRANSPARENT_FROM_MODULE,
    BUS_ASYNC_WAIT_FOR_NEXT_CYCLE,
    BUS_ASYNC_GET_LAST_CYCLE_ANSWER,
    BUS_ASYNC_GET_MEMORY_RANGES,
    BUS_ASYNC_READ_MEMORY,
    BUS_ASYNC_WRITE_MEMORY,
  }
}


--- BusModuleInfo.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.BusModuleInfo
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;
using System.Text;

#nullable disable
namespace HandlerLib
{
  public class BusModuleInfo : IComparable<BusModuleInfo>
  {
    private const int MinBufferSize = 17;
    public BusModuleTypes BusModuleType;
    public uint BusModuleSerialNumber;
    public uint FirmwareVersion;
    public uint FirmwareRevision;
    public ushort HardwareVersion;
    public byte Status;

    public static List<BusModuleInfo> GetBusModuleInfoList(byte[] readBuffer, int offset)
    {
      List<BusModuleInfo> busModuleInfoList = new List<BusModuleInfo>();
      while (readBuffer.Length - offset >= 17)
      {
        BusModuleInfo busModuleInfo = new BusModuleInfo(readBuffer, ref offset);
        busModuleInfoList.Add(busModuleInfo);
      }
      busModuleInfoList.Sort();
      return busModuleInfoList;
    }

    public BusModuleInfo()
    {
      this.BusModuleType = BusModuleTypes.OUT2_VMCP;
      this.BusModuleSerialNumber = 4711U;
    }

    public BusModuleInfo(byte[] readBuffer, ref int offset)
    {
      this.BusModuleType = (BusModuleTypes) BitConverter.ToUInt16(readBuffer, offset);
      offset += 2;
      this.BusModuleSerialNumber = BitConverter.ToUInt32(readBuffer, offset);
      offset += 4;
      this.FirmwareVersion = BitConverter.ToUInt32(readBuffer, offset);
      offset += 4;
      this.FirmwareRevision = BitConverter.ToUInt32(readBuffer, offset);
      offset += 4;
      this.HardwareVersion = BitConverter.ToUInt16(readBuffer, offset);
      offset += 2;
      this.Status = readBuffer[offset];
      ++offset;
    }

    public int CompareTo(BusModuleInfo obj)
    {
      int num1 = this.BusModuleType.CompareTo((object) obj.BusModuleType);
      if (num1 != 0)
        return num1;
      int num2 = this.BusModuleSerialNumber.CompareTo(obj.BusModuleSerialNumber);
      if (num2 != 0)
        return num2;
      int num3 = this.FirmwareVersion.CompareTo(obj.FirmwareVersion);
      if (num3 != 0)
        return num3;
      int num4 = this.FirmwareRevision.CompareTo(obj.FirmwareRevision);
      if (num4 != 0)
        return num4;
      int num5 = this.HardwareVersion.CompareTo(obj.HardwareVersion);
      return num5 != 0 ? num5 : this.Status.CompareTo(obj.Status);
    }

    public string GetModuleInfoText()
    {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.AppendLine("Type: " + this.BusModuleType.ToString() + "; SerialNumber: " + this.BusModuleSerialNumber.ToString());
      stringBuilder.AppendLine("FirmwareVersion: 0x" + this.FirmwareVersion.ToString("x08") + "; Revision: " + this.FirmwareRevision.ToString());
      stringBuilder.AppendLine("HardwareVersion: 0x" + this.HardwareVersion.ToString("x04") + "; Status: " + this.Status.ToString());
      return stringBuilder.ToString();
    }

    public override string ToString()
    {
      return this.BusModuleType.ToString() + "_" + this.BusModuleSerialNumber.ToString();
    }
  }
}


--- BusModuleTypes.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.BusModuleTypes
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum BusModuleTypes : ushort
  {
    UNDEFINED,
    OUT2_VMCP,
    NB_RADIO,
  }
}


--- ByteArrayScanner.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ByteArrayScanner
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Text;

#nullable disable
namespace HandlerLib
{
  public class ByteArrayScanner
  {
    public static string ScanString(byte[] byteArray, ref int offset)
    {
      if (byteArray == null)
        throw new ArgumentException("byteArray == null");
      if (offset < 0)
        throw new ArgumentException("offset < 0");
      int index = offset;
      while (true)
      {
        if (byteArray.Length > offset)
        {
          if (byteArray[offset] != (byte) 0)
            ++offset;
          else
            goto label_7;
        }
        else
          break;
      }
      throw new Exception("End of ASCII string not found");
label_7:
      string str = Encoding.ASCII.GetString(byteArray, index, offset - index);
      ++offset;
      return str;
    }

    public static DateTime ScanDate(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 3);
      try
      {
        DateTime dateTime = new DateTime((int) byteArray[offset] + 2000, (int) byteArray[offset + 1], (int) byteArray[offset + 2], 0, 0, 0, 0, DateTimeKind.Local);
        offset += 3;
        return dateTime;
      }
      catch (Exception ex)
      {
        throw new Exception("Illegal Date stamp", ex);
      }
    }

    public static DateTime ScanDateTime(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 6);
      try
      {
        DateTime dateTime = new DateTime((int) byteArray[offset] + 2000, (int) byteArray[offset + 1], (int) byteArray[offset + 2], (int) byteArray[offset + 3], (int) byteArray[offset + 4], (int) byteArray[offset + 5]);
        offset += 6;
        return dateTime;
      }
      catch (Exception ex)
      {
        throw new Exception("Illegal DateTime stamp", ex);
      }
    }

    public static DateTimeOffset ScanDateTimeOffset(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 7);
      try
      {
        TimeSpan offset1 = new TimeSpan(0, (int) (sbyte) byteArray[offset + 6] * 15, 0);
        DateTimeOffset dateTimeOffset = new DateTimeOffset((int) byteArray[offset] + 2000, (int) byteArray[offset + 1], (int) byteArray[offset + 2], (int) byteArray[offset + 3], (int) byteArray[offset + 4], (int) byteArray[offset + 5], offset1);
        offset += 6;
        return dateTimeOffset;
      }
      catch (Exception ex)
      {
        throw new Exception("Illegal DateTime stamp", ex);
      }
    }

    public static byte ScanByte(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 1);
      byte num = byteArray[offset];
      ++offset;
      return num;
    }

    public static sbyte ScanSByte(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 1);
      sbyte num = (sbyte) byteArray[offset];
      ++offset;
      return num;
    }

    public static ushort ScanUInt16(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 2);
      ushort uint16 = BitConverter.ToUInt16(byteArray, offset);
      offset += 2;
      return uint16;
    }

    public static short ScanInt16(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 2);
      short int16 = BitConverter.ToInt16(byteArray, offset);
      offset += 2;
      return int16;
    }

    public static uint ScanUInt32(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 4);
      uint uint32 = BitConverter.ToUInt32(byteArray, offset);
      offset += 4;
      return uint32;
    }

    public static int ScanInt32(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 4);
      int int32 = BitConverter.ToInt32(byteArray, offset);
      offset += 4;
      return int32;
    }

    public static ulong ScanUInt64(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 8);
      ulong uint64 = BitConverter.ToUInt64(byteArray, offset);
      offset += 8;
      return uint64;
    }

    public static long ScanInt64(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 8);
      long int64 = BitConverter.ToInt64(byteArray, offset);
      offset += 8;
      return int64;
    }

    public static float ScanFloat(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 4);
      float single = BitConverter.ToSingle(byteArray, offset);
      offset += 4;
      return single;
    }

    public static double ScanDouble(byte[] byteArray, ref int offset)
    {
      ByteArrayScanner.CheckArray(byteArray, offset, 8);
      double num = BitConverter.ToDouble(byteArray, offset);
      offset += 8;
      return num;
    }

    private static void CheckArray(byte[] byteArray, int offset, int minByteSize)
    {
      if (byteArray == null)
        throw new ArgumentException("byteArray == null");
      if (offset < 0)
        throw new ArgumentException("offset < 0");
      if (offset > byteArray.Length - minByteSize)
        throw new ArgumentException("out of array size");
    }

    public static void ScanInString(byte[] byteArray, string theString, ref int offset)
    {
      byte[] bytes = Encoding.ASCII.GetBytes(theString);
      if (byteArray.Length < offset + bytes.Length + 1)
        throw new Exception("Size of byteArray to small");
      Array.Copy((Array) bytes, 0, (Array) byteArray, offset, bytes.Length);
      offset += bytes.Length;
      byteArray[offset++] = (byte) 0;
    }

    public static void ScanInByte(byte[] byteArray, byte theByte, ref int offset)
    {
      if (byteArray.Length < offset + 1)
        throw new Exception("Size of byteArray to small");
      byteArray[offset++] = theByte;
    }

    public static void ScanInSByte(byte[] byteArray, sbyte theByte, ref int offset)
    {
      if (byteArray.Length < offset + 1)
        throw new Exception("Size of byteArray to small");
      byteArray[offset++] = (byte) theByte;
    }

    public static void ScanInUInt16(byte[] byteArray, ushort theValue, ref int offset)
    {
      if (byteArray.Length < offset + 2)
        throw new Exception("Size of byteArray to small");
      Array.Copy((Array) BitConverter.GetBytes(theValue), 0, (Array) byteArray, offset, 2);
      offset += 2;
    }

    public static void ScanInInt16(byte[] byteArray, short theValue, ref int offset)
    {
      if (byteArray.Length < offset + 2)
        throw new Exception("Size of byteArray to small");
      Array.Copy((Array) BitConverter.GetBytes(theValue), 0, (Array) byteArray, offset, 2);
      offset += 2;
    }

    public static void ScanInUInt32(byte[] byteArray, uint theValue, ref int offset)
    {
      if (byteArray.Length < offset + 4)
        throw new Exception("Size of byteArray to small");
      Array.Copy((Array) BitConverter.GetBytes(theValue), 0, (Array) byteArray, offset, 4);
      offset += 4;
    }

    public static void ScanInInt32(byte[] byteArray, int theValue, ref int offset)
    {
      if (byteArray.Length < offset + 4)
        throw new Exception("Size of byteArray to small");
      Array.Copy((Array) BitConverter.GetBytes(theValue), 0, (Array) byteArray, offset, 4);
      offset += 4;
    }

    public static void ScanInUInt64(byte[] byteArray, ulong theValue, ref int offset)
    {
      if (byteArray.Length < offset + 8)
        throw new Exception("Size of byteArray to small");
      Array.Copy((Array) BitConverter.GetBytes(theValue), 0, (Array) byteArray, offset, 8);
      offset += 8;
    }

    public static void ScanInInt64(byte[] byteArray, long theValue, ref int offset)
    {
      if (byteArray.Length < offset + 8)
        throw new Exception("Size of byteArray to small");
      Array.Copy((Array) BitConverter.GetBytes(theValue), 0, (Array) byteArray, offset, 8);
      offset += 8;
    }

    public static void ScanInFloat(byte[] byteArray, float theValue, ref int offset)
    {
      if (byteArray.Length < offset + 4)
        throw new Exception("Size of byteArray to small");
      Array.Copy((Array) BitConverter.GetBytes(theValue), 0, (Array) byteArray, offset, 4);
      offset += 4;
    }

    public static void ScanInDouble(byte[] byteArray, double theValue, ref int offset)
    {
      if (byteArray.Length < offset + 8)
        throw new Exception("Size of byteArray to small");
      Array.Copy((Array) BitConverter.GetBytes(theValue), 0, (Array) byteArray, offset, 8);
      offset += 8;
    }

    public static void ScanInDate(byte[] byteArray, DateTime theValue, ref int offset)
    {
      if (byteArray.Length < offset + 3)
        throw new Exception("Size of byteArray to small");
      byte num = (byte) (theValue.Year - 2000);
      byte month = (byte) theValue.Month;
      byte day = (byte) theValue.Day;
      byteArray[offset++] = num;
      byteArray[offset++] = month;
      byteArray[offset++] = day;
    }

    public static void ScanInDateTime(byte[] byteArray, DateTime theValue, ref int offset)
    {
      if (byteArray.Length < offset + 6)
        throw new Exception("Size of byteArray to small");
      ByteArrayScanner.ScanInDate(byteArray, theValue, ref offset);
      byte hour = (byte) theValue.Hour;
      byte minute = (byte) theValue.Minute;
      byte second = (byte) theValue.Second;
      byteArray[offset++] = hour;
      byteArray[offset++] = minute;
      byteArray[offset++] = second;
    }

    public static void ScanInDateTime2000(byte[] byteArray, DateTime theValue, ref int offset)
    {
      if (byteArray.Length < offset + 4)
        throw new Exception("Size of byteArray to small");
      uint meterTime = CalendarBase2000.Cal_GetMeterTime(theValue);
      ByteArrayScanner.ScanInUInt32(byteArray, meterTime, ref offset);
    }

    public static void ScanInDateTimeOffset(
      byte[] byteArray,
      DateTimeOffset theValue,
      ref int offset)
    {
      if (byteArray.Length < offset + 6)
        throw new Exception("Size of byteArray to small");
      ByteArrayScanner.ScanInDateTime(byteArray, theValue.DateTime, ref offset);
      sbyte num = (sbyte) (theValue.Offset.TotalMinutes / 15.0);
      byteArray[offset++] = (byte) num;
    }
  }
}


--- C5_Commands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.C5_Commands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum C5_Commands
  {
    EEPROM_READ_0x00,
    FLASH_WRITE_0x01,
    CPU_READ_0x02,
    CPU_WRITE_0x03,
    RESET_0x04,
    VOLUME_MONITOR_0x05,
    VERSION_0x06,
    MANAGE_WRITE_PROTECTION_0x07,
    RUN_BACKUP_0x08,
    WRITE_BITS_0x09,
    SET_EMERGENCY_MODE_0x0a,
    TEMP_TEST_AND_VOL_SIM_0x0b,
    IO_ACCESS_0x0c,
    SET_IR_OFF_TIME_0x0d,
    ERASE_FLASH_0x0e,
    CLEAR_TESTMODES_0x0f,
    SET_ENERGY_TEST_MODE_0x10,
    SET_VOLUME_TEST_MODE_0x11,
    VOLUME_TEST_START_0x12,
    VOLUME_TEST_STOP_0x13,
    READ_TEST_VOLUME_0x14,
    IO_HARDWARE_TEST_0x15,
    RADIO_2_CENTER_TEST_0x16,
    RADIO_2_PN9_TEST_0x17,
    RADIO_3_CENTER_TEST_0x18,
    RADIO_3_PN9_TEST_0x19,
    WMBUS_S_CENTER_TEST_0x1a,
    WMBUS_S_PN9_TEST_0x1b,
    WMBUS_T_CENTER_TEST_0x1c,
    WMBUS_T_PN9_TEST_0x1d,
    F_868_3_CW_TEST_0x1e,
    F_868_9_CW_TEST_0x1f,
    RADIO_3_PACKET_TEST_0x20,
    SET_DUE_DATE_0x21,
    SET_RADIO_POWER_0x22,
    SET_ACLK_TO_OUTPUT_0x23,
    SET_RTCCLK_TO_OUTPUT_0x24,
    GET_PARAMETERLIST_INFO_0x25,
    SET_CAPACITY_TEST_0x26,
    RADIO_3_RUS_CENTER_TEST_0x27,
    RADIO_3_RUS_PN9_TEST_0x28,
    GET_VOLUME_COUNTER_0x29,
    SET_RADIO_PARAMS_0x2a,
  }
}


--- CalendarBase2000.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CalendarBase2000
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class CalendarBase2000
  {
    public const uint Cal_SecoundsPerDay = 86400;
    public const uint Cal_SecoundsPerMonth = 2629800;
    public const uint Cal_SecoundsPerYear = 31557600;
    private static uint[] MonthBeginTabel = new uint[26]
    {
      0U,
      31U,
      59U,
      90U,
      120U,
      151U,
      181U,
      212U,
      243U,
      273U,
      304U,
      334U,
      365U,
      0U,
      31U,
      60U,
      91U,
      121U,
      152U,
      182U,
      213U,
      244U,
      274U,
      305U,
      335U,
      366U
    };

    public static uint Cal_GetNow() => CalendarBase2000.Cal_GetMeterTime(DateTime.Now);

    public static uint Cal_GetMeterTime(DateTime TheTime)
    {
      DateTime dateTime = new DateTime(2000, 1, 1);
      return (uint) (TheTime - dateTime).TotalSeconds;
    }

    public static DateTime Cal_GetDateTime(uint TheTime)
    {
      return new DateTime(2000, 1, 1, 0, 0, 0, DateTimeKind.Unspecified).Add(new TimeSpan(0, 0, (int) TheTime));
    }

    public static CalStruct Cal_Sec2000ToStruct(uint Sec2000)
    {
      CalTime time = CalendarBase2000.Cal_Sec2000ToTime(Sec2000);
      CalDate date = CalendarBase2000.Cal_Sec2000ToDate(Sec2000);
      return new CalStruct()
      {
        Secound = time.Secound,
        Minute = time.Minute,
        Hour = time.Hour,
        Day = date.Day,
        Month = date.Month,
        Year = date.Year
      };
    }

    public static uint Cal_StructToSec2000(CalStruct DateTime)
    {
      CalTime Time = new CalTime();
      CalDate Date = new CalDate();
      Time.Secound = DateTime.Secound;
      Time.Minute = DateTime.Minute;
      Time.Hour = DateTime.Hour;
      Date.Day = DateTime.Day;
      Date.Month = DateTime.Month;
      Date.Year = DateTime.Year;
      return CalendarBase2000.Cal_TimeToSec2000(Time) + CalendarBase2000.Cal_DateToSec2000(Date);
    }

    public static CalTime Cal_Sec2000ToTime(uint Sec2000)
    {
      return new CalTime()
      {
        Secound = Sec2000 % 60U,
        Minute = Sec2000 % 3600U / 60U,
        Hour = Sec2000 % 86400U / 3600U
      };
    }

    public static uint Cal_TimeToSec2000(CalTime Time)
    {
      if (Time.Secound > 59U)
        Time.Secound = 59U;
      if (Time.Minute > 59U)
        Time.Minute = 59U;
      if (Time.Hour > 23U)
        Time.Hour = 23U;
      return Time.Secound + Time.Minute * 60U + Time.Hour * 3600U;
    }

    public static CalDate Cal_Sec2000ToDate(uint Sec2000)
    {
      CalDate date = new CalDate();
      uint num1 = Sec2000 / 86400U;
      uint num2 = (num1 << 2) / 1461U;
      date.Year = 2000U + num2;
      uint num3 = num1 - (num2 * 365U + (num2 + 3U >> 2));
      uint index = num2 % 4U <= 0U ? 13U : 0U;
      while (num3 >= CalendarBase2000.MonthBeginTabel[(int) index + 1])
        ++index;
      date.Month = index <= 12U ? index + 1U : index - 12U;
      date.Day = (uint) ((int) num3 - (int) CalendarBase2000.MonthBeginTabel[(int) index] + 1);
      return date;
    }

    public static uint Cal_DateToSec2000(CalDate Date)
    {
      while (Date.Year < 2000U)
        Date.Year += 100U;
      while (Date.Year > 2099U)
        Date.Year -= 100U;
      if (Date.Month < 1U)
      {
        Date.Month = 12U;
        --Date.Year;
      }
      if (Date.Month > 12U)
        Date.Month = 12U;
      if (Date.Day < 1U)
        Date.Day = 1U;
      uint num1 = Date.Year - 2000U;
      uint num2 = num1 % 4U <= 0U ? 13U : 0U;
      uint num3 = CalendarBase2000.MonthBeginTabel[(int) num2 + (int) Date.Month] - CalendarBase2000.MonthBeginTabel[(int) num2 + (int) Date.Month - 1];
      if (Date.Day > num3)
        Date.Day = num3;
      uint index = (uint) ((int) num2 + (int) Date.Month - 1);
      return ((uint) ((int) CalendarBase2000.MonthBeginTabel[(int) index] + (int) Date.Day - 1) + (num1 * 365U + (num1 + 3U >> 2))) * 86400U;
    }

    public static byte Cal_GetWeekdayBit(uint TimePoint)
    {
      return (byte) (1U << (int) ((TimePoint / 86400U + 5U) % 7U));
    }

    public static uint Cal_SetTimeToNextYear(uint Sec2000)
    {
      bool flag = true;
      CalDate date = CalendarBase2000.Cal_Sec2000ToDate(Sec2000);
      while (true)
      {
        if (flag)
        {
          if (Sec2000 > CalendarBase2000.Cal_GetNow())
          {
            --date.Year;
          }
          else
          {
            flag = false;
            continue;
          }
        }
        else if (Sec2000 < CalendarBase2000.Cal_GetNow())
          ++date.Year;
        else
          break;
        Sec2000 = CalendarBase2000.Cal_DateToSec2000(date) + Sec2000;
      }
      return Sec2000;
    }

    public static DateTime Cal_GetWintertime(DateTime AktTime, int WinterUTCVerschiebungInMinuten)
    {
      TimeSpan utcOffset = TimeZone.CurrentTimeZone.GetUtcOffset(AktTime);
      double num1 = (double) (utcOffset.Hours * 60 + utcOffset.Minutes);
      double num2 = (double) WinterUTCVerschiebungInMinuten - num1;
      return AktTime.AddMinutes(num2);
    }

    public static int Cal_UTCVerschiebungInMinuten(int Stunden, ushort Minuten)
    {
      return Stunden >= 0 ? Stunden * 60 + (int) Minuten : Stunden * 60 - (int) Minuten;
    }

    public static string Cal_GetIntervalInfo(uint Sec2000)
    {
      switch (Sec2000)
      {
        case 3600:
          return "one hour";
        case 86400:
          return "one day";
        case 2629800:
          return "one month";
        case 31557600:
          return "one year";
        default:
          return Sec2000.ToString() + " sec";
      }
    }
  }
}


--- ChangeIdentWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ChangeIdentWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommonWPF;
using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using System.Windows.Media;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class ChangeIdentWindow : Window, IComponentConnector
  {
    private DeviceIdentification theIdent;
    private Brush defaultBackground;
    internal StartupLib.GmmCorporateControl gmmCorporateControl1;
    internal TextBox TextBoxFirmwareVersion;
    internal TextBox TextBoxUnique_ID;
    internal TextBox TextBoxSvnRevision;
    internal TextBox TextBoxBuildTime;
    internal TextBox TextBoxSignature;
    internal TextBox TextBoxHardwareID;
    internal Button ButtonHardwareID;
    internal TextBox TextBoxFullSerialNumber;
    internal Button ButtonFullSerialNumber;
    internal TextBox TextBoxIdentIficationPrefix;
    internal Button ButtonIdentificationPrefix;
    internal TextBox TextBoxFabricationNumber;
    internal Button ButtonFabricationNumber;
    internal TextBox TextBoxID_BCD;
    internal Button ButtonID_BCD;
    internal TextBox TextBoxManufacturer;
    internal TextBox TextBoxManufacturerName;
    internal Button ButtonManufacturer;
    internal TextBox TextBoxGeneration;
    internal Button ButtonGeneration;
    internal TextBox TextBoxMedium;
    internal TextBox TextBoxMediumText;
    internal Button ButtonMedium;
    internal TextBox TextBoxAesKey;
    internal Button ButtonAesKey;
    internal TextBox TextBoxDevEUI;
    internal Button ButtonDevEUI;
    internal TextBox TextBoxJoinEUI;
    internal Button ButtonAppEUI;
    internal TextBox TextBoxAppKey;
    internal Button ButtonAppKey;
    internal TextBox TextBoxMeterID;
    internal Button ButtonMeterID;
    internal TextBox TextBoxHardwareTypeID;
    internal Button ButtonHardwareTypeID;
    internal TextBox TextBoxMeterInfoID;
    internal Button ButtonMeterInfoID;
    internal TextBox TextBoxMeterTypeID;
    internal Button ButtonMeterTypeID;
    internal TextBox TextBoxBaseTypeID;
    internal Button ButtonBaseTypeID;
    internal TextBox TextBoxSubPartNumber;
    internal Button ButtonSubPartNumber;
    internal TextBox TextBoxSAP_MaterialNumber;
    internal Button ButtonSAP_MaterialNumber;
    internal TextBox TextBoxSAP_ProductionOrderNumber;
    internal Button ButtonSAP_ProductionOrderNumber;
    internal TextBox TextBoxPrintedSerialNumber;
    internal Button ButtonPrintedSerialNumber;
    internal TextBox TextBoxApprovalRevision;
    internal Button ButtonApprovalRevision;
    internal TextBox TextBox_FD_ID_BCD;
    internal TextBox TextBox_FD_Manufacturer;
    internal TextBox TextBox_FD_ManufacturerName;
    internal TextBox TextBox_FD_Generation;
    internal TextBox TextBox_FD_Medium;
    internal TextBox TextBox_FD_MediumText;
    internal TextBox TextBox_FD_AES_Key;
    internal TextBox TextBox_FD_DevEUI;
    internal TextBox TextBox_FD_JoinEUI;
    internal TextBox TextBox_FD_AppKey;
    internal Button ButtonDevEUI_FromFullSerialNumber;
    internal Button ButtonSetFactoryDefaultValues;
    private bool _contentLoaded;

    public ChangeIdentWindow(DeviceIdentification currentIdentification)
    {
      this.theIdent = currentIdentification;
      this.InitializeComponent();
      this.defaultBackground = this.TextBoxMeterID.Background;
      this.UpdateData();
    }

    private void UpdateData()
    {
      try
      {
        this.TextBoxFirmwareVersion.Text = this.theIdent.GetFirmwareVersionString();
        this.TextBoxUnique_ID.Text = this.theIdent.GetUnique_ID_String();
        this.TextBoxSvnRevision.Text = this.theIdent.GetSvnRevisionString();
        this.TextBoxBuildTime.Text = this.theIdent.GetBuildTimeString();
        this.TextBoxSignature.Text = this.theIdent.GetSignaturString();
        this.TextBoxHardwareID.Text = this.theIdent.GetHardwareIDString();
        this.TextBoxID_BCD.Text = this.theIdent.ID_BCD_AsString;
        this.TextBoxManufacturer.Text = this.theIdent.ManufacturerAsString;
        this.TextBoxManufacturerName.Text = this.theIdent.ManufacturerName;
        this.TextBoxGeneration.Text = this.theIdent.GenerationAsString;
        this.TextBoxMedium.Text = this.theIdent.MediumAsString;
        this.TextBoxMediumText.Text = this.theIdent.GetMediumAsText();
        this.TextBoxAesKey.Text = this.theIdent.AES_Key_AsString;
        this.TextBoxPrintedSerialNumber.Text = this.theIdent.PrintedSerialNumberAsString;
        this.TextBoxApprovalRevision.Text = this.theIdent.ApprovalRevisionAsString;
        this.TextBoxFullSerialNumber.Text = this.theIdent.FullSerialNumber;
        this.TextBoxIdentIficationPrefix.Text = this.theIdent.IdentificationPrefix;
        this.TextBoxFabricationNumber.Text = this.theIdent.FabricationNumberAsString;
        this.TextBoxDevEUI.Text = this.theIdent.LoRa_DevEUI_AsString;
        this.TextBoxJoinEUI.Text = this.theIdent.LoRa_JoinEUI_AsString;
        this.TextBoxAppKey.Text = this.theIdent.LoRa_AppKey_AsString;
        this.TextBoxMeterID.Text = this.theIdent.GetMeterID_String();
        this.TextBoxHardwareTypeID.Text = this.theIdent.GetHardwareTypeID_String();
        this.TextBoxMeterInfoID.Text = this.theIdent.MeterInfoID_AsString;
        this.TextBoxMeterTypeID.Text = this.theIdent.GetMeterTypeID_String();
        this.TextBoxBaseTypeID.Text = this.theIdent.GetBaseTypeID_String();
        this.TextBoxSubPartNumber.Text = this.theIdent.GetSubPartNumber_String();
        this.TextBoxSAP_MaterialNumber.Text = this.theIdent.GetSAP_MaterialNumberString();
        this.TextBoxSAP_ProductionOrderNumber.Text = this.theIdent.SAP_ProductionOrderNumber;
        this.TextBox_FD_ID_BCD.Text = this.theIdent.FD_ID_BCD_AsString;
        this.TextBox_FD_Manufacturer.Text = this.theIdent.FD_ManufacturerAsString;
        this.TextBox_FD_ManufacturerName.Text = this.theIdent.FD_ManufacturerName;
        this.TextBox_FD_Generation.Text = this.theIdent.FD_GenerationAsString;
        this.TextBox_FD_Medium.Text = this.theIdent.FD_MediumAsString;
        this.TextBox_FD_MediumText.Text = this.theIdent.GetFD_MediumAsText();
        this.TextBox_FD_AES_Key.Text = this.theIdent.FD_AES_Key_AsString;
        this.TextBox_FD_DevEUI.Text = this.theIdent.FD_LoRa_DevEUI_AsString;
        this.TextBox_FD_JoinEUI.Text = this.theIdent.FD_LoRa_JoinEUI_AsString;
        this.TextBox_FD_AppKey.Text = this.theIdent.FD_LoRa_AppKey_AsString;
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex, "Update data exception");
      }
      this.ShowChangedColors();
    }

    private void ShowChangedColors()
    {
      try
      {
        this.SetTextBoxColor((object) this.TextBoxHardwareID, this.theIdent.GetHardwareIDString());
        this.SetTextBoxColor((object) this.TextBoxID_BCD, this.theIdent.ID_BCD_AsString);
        this.SetTextBoxColor((object) this.TextBoxManufacturer, this.theIdent.ManufacturerAsString);
        this.SetTextBoxColor((object) this.TextBoxManufacturerName, this.theIdent.ManufacturerName);
        this.SetTextBoxColor((object) this.TextBoxGeneration, this.theIdent.GenerationAsString);
        this.SetTextBoxColor((object) this.TextBoxMedium, this.theIdent.MediumAsString);
        this.SetTextBoxColor((object) this.TextBoxAesKey, this.theIdent.AES_Key_AsString);
        this.SetTextBoxColor((object) this.TextBoxPrintedSerialNumber, this.theIdent.PrintedSerialNumberAsString);
        this.SetTextBoxColor((object) this.TextBoxApprovalRevision, this.theIdent.ApprovalRevisionAsString);
        this.SetTextBoxColor((object) this.TextBoxFullSerialNumber, this.theIdent.FullSerialNumber);
        this.SetTextBoxColor((object) this.TextBoxIdentIficationPrefix, this.theIdent.IdentificationPrefix);
        this.SetTextBoxColor((object) this.TextBoxFabricationNumber, this.theIdent.FabricationNumberAsString);
        this.SetTextBoxColor((object) this.TextBoxDevEUI, this.theIdent.LoRa_DevEUI_AsString);
        this.SetTextBoxColor((object) this.TextBoxJoinEUI, this.theIdent.LoRa_JoinEUI_AsString);
        this.SetTextBoxColor((object) this.TextBoxAppKey, this.theIdent.LoRa_AppKey_AsString);
        this.SetTextBoxColor((object) this.TextBoxMeterID, this.theIdent.GetMeterID_String());
        this.SetTextBoxColor((object) this.TextBoxHardwareTypeID, this.theIdent.GetHardwareTypeID_String());
        this.SetTextBoxColor((object) this.TextBoxMeterInfoID, this.theIdent.MeterInfoID_AsString);
        this.SetTextBoxColor((object) this.TextBoxMeterTypeID, this.theIdent.GetMeterTypeID_String());
        this.SetTextBoxColor((object) this.TextBoxBaseTypeID, this.theIdent.GetBaseTypeID_String());
        this.SetTextBoxColor((object) this.TextBoxSubPartNumber, this.theIdent.GetSubPartNumber_String());
        this.SetTextBoxColor((object) this.TextBoxSAP_MaterialNumber, this.theIdent.GetSAP_MaterialNumberString());
        this.SetTextBoxColor((object) this.TextBoxSAP_ProductionOrderNumber, this.theIdent.SAP_ProductionOrderNumber);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex, "ShowChangedColors exception");
      }
    }

    private void SetTextBox(object sender, string theValue)
    {
      try
      {
        ((TextBox) sender).Text = theValue;
        this.SetTextBoxColor(sender, theValue);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex, "SetTextBox exception");
      }
    }

    private void SetTextBoxColor(object sender, string theValue)
    {
      if (((TextBox) sender).Text.Length == 0)
      {
        if (string.IsNullOrEmpty(theValue))
          ((Control) sender).Background = this.defaultBackground.Clone();
        else
          ((Control) sender).Background = (Brush) Brushes.LightYellow;
      }
      else if (string.IsNullOrEmpty(theValue))
        ((Control) sender).Background = (Brush) Brushes.LightYellow;
      else if (((TextBox) sender).Text == theValue)
        ((Control) sender).Background = this.defaultBackground.Clone();
      else
        ((Control) sender).Background = (Brush) Brushes.LightYellow;
    }

    private void TextBoxHardwareID_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.GetHardwareIDString());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonHardwareID_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        uint result;
        if (uint.TryParse(this.TextBoxHardwareID.Text, out result))
          this.theIdent.HardwareID = new uint?(result);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.TextBoxHardwareID.Text = this.theIdent.GetHardwareIDString();
    }

    private void TextBox_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.ID_BCD_AsString);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonID_BCD_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        uint result;
        if (uint.TryParse(this.TextBoxID_BCD.Text, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          this.theIdent.ID_BCD = new uint?(result);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxManufacturer_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.ManufacturerAsString);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void TextBoxManufacturerText_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.ManufacturerName);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonManufacturer_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        if (this.TextBoxManufacturerName.Background == Brushes.LightYellow)
          this.theIdent.ManufacturerName = this.TextBoxManufacturerName.Text;
        else
          this.theIdent.ManufacturerAsString = this.TextBoxManufacturer.Text;
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxGeneration_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.GenerationAsString);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonGeneration_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        byte result;
        if (byte.TryParse(this.TextBoxGeneration.Text, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          this.theIdent.Generation = new byte?(result);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxMedium_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.MediumAsString);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonMedium_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        byte result;
        if (byte.TryParse(this.TextBoxMedium.Text.Substring(0, 2), NumberStyles.HexNumber, (IFormatProvider) null, out result))
          this.theIdent.Medium = new byte?(result);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxPrintedSerialNumber_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.PrintedSerialNumberAsString);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonPrintedSerialNumber_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.theIdent.PrintedSerialNumberAsString = this.TextBoxPrintedSerialNumber.Text;
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxApprovalRevision_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        ushort? approvalRevision = this.theIdent.ApprovalRevision;
        if (!approvalRevision.HasValue)
        {
          this.SetTextBoxColor(sender, (string) null);
        }
        else
        {
          object sender1 = sender;
          approvalRevision = this.theIdent.ApprovalRevision;
          string theValue = approvalRevision.ToString();
          this.SetTextBoxColor(sender1, theValue);
        }
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonApprovalRevision_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.theIdent.ApprovalRevision = new ushort?(ushort.Parse(this.TextBoxApprovalRevision.Text));
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxFullSerialNumber_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.FullSerialNumber);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonFullSerialNumber_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.theIdent.FullSerialNumber = this.TextBoxFullSerialNumber.Text.Trim();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxIdentIficationPrefix_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.IdentificationPrefix);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonIdentificationPrefix_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.theIdent.IdentificationPrefix = this.TextBoxIdentIficationPrefix.Text;
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxFabricationNumber_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.FabricationNumberAsString);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonFabricationNumber_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.theIdent.FabricationNumberAsString = this.TextBoxFabricationNumber.Text;
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxDevEUI_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.LoRa_DevEUI_AsString);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonDevEUI_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        ulong result;
        if (ulong.TryParse(this.TextBoxDevEUI.Text, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          this.theIdent.LoRa_DevEUI = new ulong?(result);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxAppEUI_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.LoRa_JoinEUI_AsString);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonAppEUI_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        ulong result;
        if (ulong.TryParse(this.TextBoxJoinEUI.Text, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          this.theIdent.LoRa_JoinEUI = new ulong?(result);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxAppKey_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.LoRa_AppKey_AsString);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonAppKey_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.theIdent.LoRa_AppKey = Utility.HexStringToByteArray(this.TextBoxAppKey.Text);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxMeterID_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.GetMeterID_String());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonMeterID_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        uint result;
        if (uint.TryParse(this.TextBoxMeterID.Text, out result))
          this.theIdent.MeterID = new uint?(result);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxHardwareTypeID_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.GetHardwareTypeID_String());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonHardwareTypeID_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        uint result;
        if (uint.TryParse(this.TextBoxHardwareTypeID.Text, out result))
          this.theIdent.HardwareTypeID = new uint?(result);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxMeterInfoID_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.MeterInfoID_AsString);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonMeterInfoID_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.theIdent.MeterInfoID_AsString = this.TextBoxMeterInfoID.Text.Trim();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxMeterTypeID_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.GetMeterTypeID_String());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonMeterTypeID_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        uint result;
        if (uint.TryParse(this.TextBoxMeterTypeID.Text, out result))
          this.theIdent.MeterTypeID = new uint?(result);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxBaseTypeID_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.GetBaseTypeID_String());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonBaseTypeID_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        uint result;
        if (uint.TryParse(this.TextBoxBaseTypeID.Text, out result))
          this.theIdent.BaseTypeID = new uint?(result);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxSubPartNumber_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.GetSubPartNumber_String());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonSubPartNumber_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        uint result;
        if (uint.TryParse(this.TextBoxSubPartNumber.Text, out result))
          this.theIdent.SubPartNumber = new uint?(result);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxSAP_MaterialNumber_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.GetSAP_MaterialNumberString());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonSAP_MaterialNumber_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        uint result;
        if (uint.TryParse(this.TextBoxSAP_MaterialNumber.Text, out result))
          this.theIdent.SAP_MaterialNumber = new uint?(result);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void TextBoxSAP_ProductionOrderNumber_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.SAP_ProductionOrderNumber);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonSAP_ProductionOrderNumber_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        string str = this.TextBoxSAP_ProductionOrderNumber.Text.Trim();
        this.theIdent.SAP_ProductionOrderNumber = string.IsNullOrEmpty(str) ? (string) null : str;
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    private void ButtonSetFactoryDefaultValues_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.theIdent.Set_FD_Values();
        this.UpdateData();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex, "Error on set FD_Values");
      }
    }

    private void ButtonDevEUI_FromFullSerialNumber_Click(object sender, RoutedEventArgs e)
    {
      if (this.theIdent.FullSerialNumber == null)
        return;
      try
      {
        this.theIdent.LoRa_DevEUI = new ulong?(new IdentificationMapping(this.theIdent.FullSerialNumber).GetAsDevEUI_Value());
        this.UpdateData();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex, "Can not create DevEUI");
      }
    }

    private void TextBoxAesKey_TextChanged(object sender, TextChangedEventArgs e)
    {
      try
      {
        this.SetTextBoxColor(sender, this.theIdent.AES_Key_AsString);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonAesKey_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.theIdent.AES_Key = Utility.HexStringToByteArray(this.TextBoxAesKey.Text);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
      this.UpdateData();
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/changeidentwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.gmmCorporateControl1 = (StartupLib.GmmCorporateControl) target;
          break;
        case 2:
          this.TextBoxFirmwareVersion = (TextBox) target;
          break;
        case 3:
          this.TextBoxUnique_ID = (TextBox) target;
          break;
        case 4:
          this.TextBoxSvnRevision = (TextBox) target;
          break;
        case 5:
          this.TextBoxBuildTime = (TextBox) target;
          break;
        case 6:
          this.TextBoxSignature = (TextBox) target;
          break;
        case 7:
          this.TextBoxHardwareID = (TextBox) target;
          this.TextBoxHardwareID.TextChanged += new TextChangedEventHandler(this.TextBoxHardwareID_TextChanged);
          break;
        case 8:
          this.ButtonHardwareID = (Button) target;
          this.ButtonHardwareID.Click += new RoutedEventHandler(this.ButtonHardwareID_Click);
          break;
        case 9:
          this.TextBoxFullSerialNumber = (TextBox) target;
          this.TextBoxFullSerialNumber.TextChanged += new TextChangedEventHandler(this.TextBoxFullSerialNumber_TextChanged);
          break;
        case 10:
          this.ButtonFullSerialNumber = (Button) target;
          this.ButtonFullSerialNumber.Click += new RoutedEventHandler(this.ButtonFullSerialNumber_Click);
          break;
        case 11:
          this.TextBoxIdentIficationPrefix = (TextBox) target;
          this.TextBoxIdentIficationPrefix.TextChanged += new TextChangedEventHandler(this.TextBoxIdentIficationPrefix_TextChanged);
          break;
        case 12:
          this.ButtonIdentificationPrefix = (Button) target;
          this.ButtonIdentificationPrefix.Click += new RoutedEventHandler(this.ButtonIdentificationPrefix_Click);
          break;
        case 13:
          this.TextBoxFabricationNumber = (TextBox) target;
          this.TextBoxFabricationNumber.TextChanged += new TextChangedEventHandler(this.TextBoxFabricationNumber_TextChanged);
          break;
        case 14:
          this.ButtonFabricationNumber = (Button) target;
          this.ButtonFabricationNumber.Click += new RoutedEventHandler(this.ButtonFabricationNumber_Click);
          break;
        case 15:
          this.TextBoxID_BCD = (TextBox) target;
          this.TextBoxID_BCD.TextChanged += new TextChangedEventHandler(this.TextBox_TextChanged);
          break;
        case 16:
          this.ButtonID_BCD = (Button) target;
          this.ButtonID_BCD.Click += new RoutedEventHandler(this.ButtonID_BCD_Click);
          break;
        case 17:
          this.TextBoxManufacturer = (TextBox) target;
          this.TextBoxManufacturer.TextChanged += new TextChangedEventHandler(this.TextBoxManufacturer_TextChanged);
          break;
        case 18:
          this.TextBoxManufacturerName = (TextBox) target;
          this.TextBoxManufacturerName.TextChanged += new TextChangedEventHandler(this.TextBoxManufacturerText_TextChanged);
          break;
        case 19:
          this.ButtonManufacturer = (Button) target;
          this.ButtonManufacturer.Click += new RoutedEventHandler(this.ButtonManufacturer_Click);
          break;
        case 20:
          this.TextBoxGeneration = (TextBox) target;
          this.TextBoxGeneration.TextChanged += new TextChangedEventHandler(this.TextBoxGeneration_TextChanged);
          break;
        case 21:
          this.ButtonGeneration = (Button) target;
          this.ButtonGeneration.Click += new RoutedEventHandler(this.ButtonGeneration_Click);
          break;
        case 22:
          this.TextBoxMedium = (TextBox) target;
          this.TextBoxMedium.TextChanged += new TextChangedEventHandler(this.TextBoxMedium_TextChanged);
          break;
        case 23:
          this.TextBoxMediumText = (TextBox) target;
          break;
        case 24:
          this.ButtonMedium = (Button) target;
          this.ButtonMedium.Click += new RoutedEventHandler(this.ButtonMedium_Click);
          break;
        case 25:
          this.TextBoxAesKey = (TextBox) target;
          this.TextBoxAesKey.TextChanged += new TextChangedEventHandler(this.TextBoxAesKey_TextChanged);
          break;
        case 26:
          this.ButtonAesKey = (Button) target;
          this.ButtonAesKey.Click += new RoutedEventHandler(this.ButtonAesKey_Click);
          break;
        case 27:
          this.TextBoxDevEUI = (TextBox) target;
          this.TextBoxDevEUI.TextChanged += new TextChangedEventHandler(this.TextBoxDevEUI_TextChanged);
          break;
        case 28:
          this.ButtonDevEUI = (Button) target;
          this.ButtonDevEUI.Click += new RoutedEventHandler(this.ButtonDevEUI_Click);
          break;
        case 29:
          this.TextBoxJoinEUI = (TextBox) target;
          this.TextBoxJoinEUI.TextChanged += new TextChangedEventHandler(this.TextBoxAppEUI_TextChanged);
          break;
        case 30:
          this.ButtonAppEUI = (Button) target;
          this.ButtonAppEUI.Click += new RoutedEventHandler(this.ButtonAppEUI_Click);
          break;
        case 31:
          this.TextBoxAppKey = (TextBox) target;
          this.TextBoxAppKey.TextChanged += new TextChangedEventHandler(this.TextBoxAppKey_TextChanged);
          break;
        case 32:
          this.ButtonAppKey = (Button) target;
          this.ButtonAppKey.Click += new RoutedEventHandler(this.ButtonAppKey_Click);
          break;
        case 33:
          this.TextBoxMeterID = (TextBox) target;
          this.TextBoxMeterID.TextChanged += new TextChangedEventHandler(this.TextBoxMeterID_TextChanged);
          break;
        case 34:
          this.ButtonMeterID = (Button) target;
          this.ButtonMeterID.Click += new RoutedEventHandler(this.ButtonMeterID_Click);
          break;
        case 35:
          this.TextBoxHardwareTypeID = (TextBox) target;
          this.TextBoxHardwareTypeID.TextChanged += new TextChangedEventHandler(this.TextBoxHardwareTypeID_TextChanged);
          break;
        case 36:
          this.ButtonHardwareTypeID = (Button) target;
          this.ButtonHardwareTypeID.Click += new RoutedEventHandler(this.ButtonHardwareTypeID_Click);
          break;
        case 37:
          this.TextBoxMeterInfoID = (TextBox) target;
          this.TextBoxMeterInfoID.TextChanged += new TextChangedEventHandler(this.TextBoxMeterInfoID_TextChanged);
          break;
        case 38:
          this.ButtonMeterInfoID = (Button) target;
          this.ButtonMeterInfoID.Click += new RoutedEventHandler(this.ButtonMeterInfoID_Click);
          break;
        case 39:
          this.TextBoxMeterTypeID = (TextBox) target;
          this.TextBoxMeterTypeID.TextChanged += new TextChangedEventHandler(this.TextBoxMeterTypeID_TextChanged);
          break;
        case 40:
          this.ButtonMeterTypeID = (Button) target;
          this.ButtonMeterTypeID.Click += new RoutedEventHandler(this.ButtonMeterTypeID_Click);
          break;
        case 41:
          this.TextBoxBaseTypeID = (TextBox) target;
          this.TextBoxBaseTypeID.TextChanged += new TextChangedEventHandler(this.TextBoxBaseTypeID_TextChanged);
          break;
        case 42:
          this.ButtonBaseTypeID = (Button) target;
          this.ButtonBaseTypeID.Click += new RoutedEventHandler(this.ButtonBaseTypeID_Click);
          break;
        case 43:
          this.TextBoxSubPartNumber = (TextBox) target;
          this.TextBoxSubPartNumber.TextChanged += new TextChangedEventHandler(this.TextBoxSubPartNumber_TextChanged);
          break;
        case 44:
          this.ButtonSubPartNumber = (Button) target;
          this.ButtonSubPartNumber.Click += new RoutedEventHandler(this.ButtonSubPartNumber_Click);
          break;
        case 45:
          this.TextBoxSAP_MaterialNumber = (TextBox) target;
          this.TextBoxSAP_MaterialNumber.TextChanged += new TextChangedEventHandler(this.TextBoxSAP_MaterialNumber_TextChanged);
          break;
        case 46:
          this.ButtonSAP_MaterialNumber = (Button) target;
          this.ButtonSAP_MaterialNumber.Click += new RoutedEventHandler(this.ButtonSAP_MaterialNumber_Click);
          break;
        case 47:
          this.TextBoxSAP_ProductionOrderNumber = (TextBox) target;
          this.TextBoxSAP_ProductionOrderNumber.TextChanged += new TextChangedEventHandler(this.TextBoxSAP_ProductionOrderNumber_TextChanged);
          break;
        case 48:
          this.ButtonSAP_ProductionOrderNumber = (Button) target;
          this.ButtonSAP_ProductionOrderNumber.Click += new RoutedEventHandler(this.ButtonSAP_ProductionOrderNumber_Click);
          break;
        case 49:
          this.TextBoxPrintedSerialNumber = (TextBox) target;
          this.TextBoxPrintedSerialNumber.TextChanged += new TextChangedEventHandler(this.TextBoxPrintedSerialNumber_TextChanged);
          break;
        case 50:
          this.ButtonPrintedSerialNumber = (Button) target;
          this.ButtonPrintedSerialNumber.Click += new RoutedEventHandler(this.ButtonPrintedSerialNumber_Click);
          break;
        case 51:
          this.TextBoxApprovalRevision = (TextBox) target;
          this.TextBoxApprovalRevision.TextChanged += new TextChangedEventHandler(this.TextBoxApprovalRevision_TextChanged);
          break;
        case 52:
          this.ButtonApprovalRevision = (Button) target;
          this.ButtonApprovalRevision.Click += new RoutedEventHandler(this.ButtonApprovalRevision_Click);
          break;
        case 53:
          this.TextBox_FD_ID_BCD = (TextBox) target;
          break;
        case 54:
          this.TextBox_FD_Manufacturer = (TextBox) target;
          break;
        case 55:
          this.TextBox_FD_ManufacturerName = (TextBox) target;
          break;
        case 56:
          this.TextBox_FD_Generation = (TextBox) target;
          break;
        case 57:
          this.TextBox_FD_Medium = (TextBox) target;
          break;
        case 58:
          this.TextBox_FD_MediumText = (TextBox) target;
          break;
        case 59:
          this.TextBox_FD_AES_Key = (TextBox) target;
          break;
        case 60:
          this.TextBox_FD_DevEUI = (TextBox) target;
          break;
        case 61:
          this.TextBox_FD_JoinEUI = (TextBox) target;
          break;
        case 62:
          this.TextBox_FD_AppKey = (TextBox) target;
          break;
        case 63:
          this.ButtonDevEUI_FromFullSerialNumber = (Button) target;
          this.ButtonDevEUI_FromFullSerialNumber.Click += new RoutedEventHandler(this.ButtonDevEUI_FromFullSerialNumber_Click);
          break;
        case 64:
          this.ButtonSetFactoryDefaultValues = (Button) target;
          this.ButtonSetFactoryDefaultValues.Click += new RoutedEventHandler(this.ButtonSetFactoryDefaultValues_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- CheckBoxForEnumWithFlagAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CheckBoxForEnumWithFlagAttribute
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using Microsoft.CSharp.RuntimeBinder;
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Controls;

#nullable disable
namespace HandlerLib
{
  public class CheckBoxForEnumWithFlagAttribute : CheckBox
  {
    public static DependencyProperty EnumValueProperty = DependencyProperty.Register(nameof (EnumValue), typeof (object), typeof (CheckBoxForEnumWithFlagAttribute), new PropertyMetadata(new PropertyChangedCallback(CheckBoxForEnumWithFlagAttribute.EnumValueChangedCallback)));
    public static DependencyProperty EnumFlagProperty = DependencyProperty.Register(nameof (EnumFlag), typeof (object), typeof (CheckBoxForEnumWithFlagAttribute), new PropertyMetadata(new PropertyChangedCallback(CheckBoxForEnumWithFlagAttribute.EnumFlagChangedCallback)));

    public CheckBoxForEnumWithFlagAttribute()
    {
      this.Checked += new RoutedEventHandler(this.CheckBoxForEnumWithFlag_Checked);
      this.Unchecked += new RoutedEventHandler(this.CheckBoxForEnumWithFlag_Unchecked);
    }

    private static void EnumValueChangedCallback(
      DependencyObject dependencyObject,
      DependencyPropertyChangedEventArgs dependencyPropertyChangedEventArgs)
    {
      if (!(dependencyObject is CheckBoxForEnumWithFlagAttribute withFlagAttribute))
        return;
      withFlagAttribute.RefreshCheckBoxState();
    }

    private static void EnumFlagChangedCallback(
      DependencyObject dependencyObject,
      DependencyPropertyChangedEventArgs dependencyPropertyChangedEventArgs)
    {
      if (!(dependencyObject is CheckBoxForEnumWithFlagAttribute withFlagAttribute))
        return;
      withFlagAttribute.RefreshCheckBoxState();
    }

    public object EnumValue
    {
      get => this.GetValue(CheckBoxForEnumWithFlagAttribute.EnumValueProperty);
      set => this.SetValue(CheckBoxForEnumWithFlagAttribute.EnumValueProperty, value);
    }

    public object EnumFlag
    {
      get => this.GetValue(CheckBoxForEnumWithFlagAttribute.EnumFlagProperty);
      set => this.SetValue(CheckBoxForEnumWithFlagAttribute.EnumFlagProperty, value);
    }

    private void RefreshCheckBoxState()
    {
      if (this.EnumValue == null || !(this.EnumValue is Enum))
        return;
      Type underlyingType = Enum.GetUnderlyingType(this.EnumValue.GetType());
      object obj1 = Convert.ChangeType(this.EnumValue, underlyingType);
      object obj2 = Convert.ChangeType(this.EnumFlag, underlyingType);
      // ISSUE: reference to a compiler-generated field
      if (CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__11.\u003C\u003Ep__2 == null)
      {
        // ISSUE: reference to a compiler-generated field
        CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__11.\u003C\u003Ep__2 = CallSite<Func<CallSite, object, bool?>>.Create(Binder.Convert(CSharpBinderFlags.None, typeof (bool?), typeof (CheckBoxForEnumWithFlagAttribute)));
      }
      // ISSUE: reference to a compiler-generated field
      Func<CallSite, object, bool?> target1 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__11.\u003C\u003Ep__2.Target;
      // ISSUE: reference to a compiler-generated field
      CallSite<Func<CallSite, object, bool?>> p2 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__11.\u003C\u003Ep__2;
      // ISSUE: reference to a compiler-generated field
      if (CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__11.\u003C\u003Ep__1 == null)
      {
        // ISSUE: reference to a compiler-generated field
        CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__11.\u003C\u003Ep__1 = CallSite<Func<CallSite, object, int, object>>.Create(Binder.BinaryOperation(CSharpBinderFlags.None, ExpressionType.GreaterThan, typeof (CheckBoxForEnumWithFlagAttribute), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[2]
        {
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null),
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.Constant, (string) null)
        }));
      }
      // ISSUE: reference to a compiler-generated field
      Func<CallSite, object, int, object> target2 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__11.\u003C\u003Ep__1.Target;
      // ISSUE: reference to a compiler-generated field
      CallSite<Func<CallSite, object, int, object>> p1 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__11.\u003C\u003Ep__1;
      // ISSUE: reference to a compiler-generated field
      if (CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__11.\u003C\u003Ep__0 == null)
      {
        // ISSUE: reference to a compiler-generated field
        CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__11.\u003C\u003Ep__0 = CallSite<Func<CallSite, object, object, object>>.Create(Binder.BinaryOperation(CSharpBinderFlags.None, ExpressionType.And, typeof (CheckBoxForEnumWithFlagAttribute), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[2]
        {
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null),
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null)
        }));
      }
      // ISSUE: reference to a compiler-generated field
      // ISSUE: reference to a compiler-generated field
      object obj3 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__11.\u003C\u003Ep__0.Target((CallSite) CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__11.\u003C\u003Ep__0, obj1, obj2);
      object obj4 = target2((CallSite) p1, obj3, 0);
      this.IsChecked = target1((CallSite) p2, obj4);
    }

    private void CheckBoxForEnumWithFlag_Checked(object sender, RoutedEventArgs e)
    {
      this.RefreshEnumValue();
    }

    private void CheckBoxForEnumWithFlag_Unchecked(object sender, RoutedEventArgs e)
    {
      this.RefreshEnumValue();
    }

    private void RefreshEnumValue()
    {
      if (this.EnumValue == null || !(this.EnumValue is Enum))
        return;
      Type underlyingType = Enum.GetUnderlyingType(this.EnumValue.GetType());
      object obj1 = Convert.ChangeType(this.EnumValue, underlyingType);
      object obj2 = Convert.ChangeType(this.EnumFlag, underlyingType);
      bool? isChecked = this.IsChecked;
      bool flag = true;
      object obj3;
      if (isChecked.GetValueOrDefault() == flag & isChecked.HasValue)
      {
        // ISSUE: reference to a compiler-generated field
        if (CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__0 == null)
        {
          // ISSUE: reference to a compiler-generated field
          CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__0 = CallSite<Func<CallSite, object, object, object>>.Create(Binder.BinaryOperation(CSharpBinderFlags.None, ExpressionType.Or, typeof (CheckBoxForEnumWithFlagAttribute), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[2]
          {
            CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null),
            CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null)
          }));
        }
        // ISSUE: reference to a compiler-generated field
        // ISSUE: reference to a compiler-generated field
        obj3 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__0.Target((CallSite) CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__0, obj1, obj2);
      }
      else
      {
        // ISSUE: reference to a compiler-generated field
        if (CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__2 == null)
        {
          // ISSUE: reference to a compiler-generated field
          CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__2 = CallSite<Func<CallSite, object, object, object>>.Create(Binder.BinaryOperation(CSharpBinderFlags.None, ExpressionType.And, typeof (CheckBoxForEnumWithFlagAttribute), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[2]
          {
            CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null),
            CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null)
          }));
        }
        // ISSUE: reference to a compiler-generated field
        Func<CallSite, object, object, object> target = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__2.Target;
        // ISSUE: reference to a compiler-generated field
        CallSite<Func<CallSite, object, object, object>> p2 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__2;
        object obj4 = obj1;
        // ISSUE: reference to a compiler-generated field
        if (CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__1 == null)
        {
          // ISSUE: reference to a compiler-generated field
          CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__1 = CallSite<Func<CallSite, object, object>>.Create(Binder.UnaryOperation(CSharpBinderFlags.None, ExpressionType.OnesComplement, typeof (CheckBoxForEnumWithFlagAttribute), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[1]
          {
            CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null)
          }));
        }
        // ISSUE: reference to a compiler-generated field
        // ISSUE: reference to a compiler-generated field
        object obj5 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__1.Target((CallSite) CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__1, obj2);
        obj3 = target((CallSite) p2, obj4, obj5);
      }
      // ISSUE: reference to a compiler-generated field
      if (CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__4 == null)
      {
        // ISSUE: reference to a compiler-generated field
        CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__4 = CallSite<Func<CallSite, object, bool>>.Create(Binder.UnaryOperation(CSharpBinderFlags.None, ExpressionType.IsTrue, typeof (CheckBoxForEnumWithFlagAttribute), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[1]
        {
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null)
        }));
      }
      // ISSUE: reference to a compiler-generated field
      Func<CallSite, object, bool> target1 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__4.Target;
      // ISSUE: reference to a compiler-generated field
      CallSite<Func<CallSite, object, bool>> p4 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__4;
      // ISSUE: reference to a compiler-generated field
      if (CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__3 == null)
      {
        // ISSUE: reference to a compiler-generated field
        CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__3 = CallSite<Func<CallSite, object, object, object>>.Create(Binder.BinaryOperation(CSharpBinderFlags.None, ExpressionType.NotEqual, typeof (CheckBoxForEnumWithFlagAttribute), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[2]
        {
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null),
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null)
        }));
      }
      // ISSUE: reference to a compiler-generated field
      // ISSUE: reference to a compiler-generated field
      object obj6 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__3.Target((CallSite) CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__3, obj3, obj1);
      if (target1((CallSite) p4, obj6))
      {
        // ISSUE: reference to a compiler-generated field
        if (CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__5 == null)
        {
          // ISSUE: reference to a compiler-generated field
          CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__5 = CallSite<Func<CallSite, Type, Type, object, object>>.Create(Binder.InvokeMember(CSharpBinderFlags.None, "ToObject", (IEnumerable<Type>) null, typeof (CheckBoxForEnumWithFlagAttribute), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[3]
          {
            CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null),
            CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType, (string) null),
            CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null)
          }));
        }
        // ISSUE: reference to a compiler-generated field
        // ISSUE: reference to a compiler-generated field
        this.EnumValue = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__5.Target((CallSite) CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__14.\u003C\u003Ep__5, typeof (Enum), this.EnumValue.GetType(), obj3);
      }
    }

    public void SetChecked(Enum value, Enum flag)
    {
      this.EnumFlag = (object) flag;
      Type underlyingType = Enum.GetUnderlyingType(value.GetType());
      object obj1 = Convert.ChangeType((object) value, underlyingType);
      object obj2 = Convert.ChangeType((object) flag, underlyingType);
      // ISSUE: reference to a compiler-generated field
      if (CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__15.\u003C\u003Ep__1 == null)
      {
        // ISSUE: reference to a compiler-generated field
        CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__15.\u003C\u003Ep__1 = CallSite<Func<CallSite, Type, Type, object, object>>.Create(Binder.InvokeMember(CSharpBinderFlags.None, "ToObject", (IEnumerable<Type>) null, typeof (CheckBoxForEnumWithFlagAttribute), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[3]
        {
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null),
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType, (string) null),
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null)
        }));
      }
      // ISSUE: reference to a compiler-generated field
      Func<CallSite, Type, Type, object, object> target = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__15.\u003C\u003Ep__1.Target;
      // ISSUE: reference to a compiler-generated field
      CallSite<Func<CallSite, Type, Type, object, object>> p1 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__15.\u003C\u003Ep__1;
      Type type1 = typeof (Enum);
      Type type2 = value.GetType();
      // ISSUE: reference to a compiler-generated field
      if (CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__15.\u003C\u003Ep__0 == null)
      {
        // ISSUE: reference to a compiler-generated field
        CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__15.\u003C\u003Ep__0 = CallSite<Func<CallSite, object, object, object>>.Create(Binder.BinaryOperation(CSharpBinderFlags.None, ExpressionType.And, typeof (CheckBoxForEnumWithFlagAttribute), (IEnumerable<CSharpArgumentInfo>) new CSharpArgumentInfo[2]
        {
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null),
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null)
        }));
      }
      // ISSUE: reference to a compiler-generated field
      // ISSUE: reference to a compiler-generated field
      object obj3 = CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__15.\u003C\u003Ep__0.Target((CallSite) CheckBoxForEnumWithFlagAttribute.\u003C\u003Eo__15.\u003C\u003Ep__0, obj1, obj2);
      this.EnumValue = target((CallSite) p1, type1, type2, obj3);
    }
  }
}


--- cImpulseInputCounters.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.cImpulseInputCounters
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public class cImpulseInputCounters
  {
    public string ImputState;
    public short VolumePulseCounter;
    public ushort HardwareCounter;
    public ushort Input0Counter;
    public ushort Input1Counter;
    public ushort Input2Counter;
  }
}


--- CommandWindowCommon.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CommandWindowCommon
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Threading;
using ZENNER.CommonLibrary;
using ZENNER.CommonLibrary.Exceptions;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class CommandWindowCommon : Window, IComponentConnector
  {
    private Common32BitCommands myCommonCommands;
    private List<string> Argument1_last_values;
    private List<string> Argument2_last_values;
    private List<string> Argument3_last_values;
    private List<string> Argument4_last_values;
    private ContextMenu Argument1ValuesMenu;
    private ContextMenu Argument2ValuesMenu;
    private ContextMenu Argument3ValuesMenu;
    private ContextMenu Argument4ValuesMenu;
    private string result = string.Empty;
    private Cursor defaultCursor;
    private CancellationTokenSource cancelTokenSource;
    private byte LCDStateActualTestByte;
    private byte LCDStateStartByte;
    private ProgressHandler progress;
    private static readonly string CMD_GetVersion = "GetVersion";
    private static readonly string CMD_Resetdevice = "Reset device (0x80)";
    private static readonly string CMD_SetWriteProtection = "Set Write Protection (0x81)";
    private static readonly string CMD_OpenWriteProtectionTemporaly = "Open Write Protection Temporarily(0x82)";
    private static readonly string CMD_SetMode = "Set Mode (0x83)";
    private static readonly string CMD_GetMode = "Get Mode (0x83)";
    private static readonly string CMD_RunBackup = "Run Backup (0x86)";
    private static readonly string CMD_SetSystemTime = "Set System Time (0x87)";
    private static readonly string CMD_GetSystemTime = "Get System Time (0x87)";
    private static readonly string CMD_SetKeyDate = "Set KeyDate (0x88)";
    private static readonly string CMD_GetKeyDate = "Get KeyDate (0x88)";
    private static readonly string CMD_SetRadioOperation = "Set RadioOperation (0x89)";
    private static readonly string CMD_GetRadioOperation = "Get RadioOperation (0x89)";
    private static readonly string CMD_ClearResetCounter = "Clear ResetCounter (0x8a)";
    private static readonly string CMD_GetResetCounter = "Get ResetCounter (0x8a)";
    private static readonly string CMD_SetLcdTestState = "Set LCD Test State (0x8b)";
    private static readonly string CMD_SwitchLoRaLED = "Switch LoRa LED (0x8c)";
    private static readonly string CMD_ActivateDeactivateDisplay = "Activate/Deactivate Display (0x8d)";
    private static readonly string CMD_TimeShift = "TimeShift (0x8e)";
    private static readonly string CMD_ExecuteEvent = "Execute Event (0x8f)";
    private static readonly string CMD_SetRTCCalibration = "SetRTCCalibration (0x90)";
    private static readonly string CMD_GetCommunicationScenario = "GetCommunicationScenario (0x91)";
    private static readonly string CMD_SetCommunicationScenario = "SetCommunicationScenario (0x92)";
    private static readonly string CMD_GetPrintedSerialNumber = "GetPrintedSerialNumber (0x93)";
    private static readonly string CMD_GetLocalInterfaceEncryption = "GetLocalInterfaceEncryption (0x94)";
    private static readonly string CMD_SetLocalInterfaceEncryption = "SetLocalInterfaceEncryption (0x94)";
    private static readonly string CMD_ReadMemory = "ReadMemory";
    internal TextBlock TextBlockStatus;
    internal TextBox TextBoxUniversalCommandResult;
    internal StackPanel StackPanalButtons;
    internal Label FunctionCode_Label;
    internal ComboBox ComboCommand;
    internal CheckBox CheckBoxEncryption;
    internal Label EncryptionKey_Label;
    internal TextBox TextBoxEncryptionKey;
    internal Label ComboAddCommand_Label;
    internal ComboBox ComboAddCommand;
    internal Label TextArgument_1_Label;
    internal TextBox TextCommandArgument_1;
    internal Label TextArgument_2_Label;
    internal TextBox TextCommandArgument_2;
    internal Label TextArgument_3_Label;
    internal TextBox TextCommandArgument_3;
    internal Label TextArgument_4_Label;
    internal TextBox TextCommandArgument_4;
    internal StackPanel StackPanalButtons2;
    internal Button ButtonRunCommand;
    internal Button ButtonRunCommandPreview;
    internal Button ButtonBreak;
    internal ProgressBar ProgressBar1;
    private bool _contentLoaded;

    public CommandWindowCommon(Common32BitCommands myWindowFunctions)
    {
      this.myCommonCommands = myWindowFunctions;
      this.InitializeComponent();
      this.setCommonCommands();
      this.SetArgumentFields((Dictionary<int, string>) null);
      this.Argument1_last_values = new List<string>();
      this.Argument2_last_values = new List<string>();
      this.Argument3_last_values = new List<string>();
      this.Argument4_last_values = new List<string>();
      this.Argument1ValuesMenu = new ContextMenu();
      this.Argument2ValuesMenu = new ContextMenu();
      this.Argument3ValuesMenu = new ContextMenu();
      this.Argument4ValuesMenu = new ContextMenu();
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
      this.setCryptState();
    }

    private void setCryptState()
    {
      this.CheckBoxEncryption.IsChecked = new bool?(this.myCommonCommands.enDeCrypt);
      if (!this.myCommonCommands.enDeCrypt)
        this.CheckBoxEncryption_UnChecked((object) null, (RoutedEventArgs) null);
      this.TextBoxEncryptionKey.Text = this.myCommonCommands.AES_Key;
    }

    private void SetRunState()
    {
      this.cancelTokenSource = new CancellationTokenSource();
      this.progress.Reset();
      this.progress.Split(new double[2]{ 2.0, 98.0 });
      this.progress.Report("Run");
      this.ComboCommand.IsEnabled = false;
      this.TextBoxUniversalCommandResult.IsEnabled = false;
      this.ButtonRunCommand.IsEnabled = false;
      this.ButtonRunCommandPreview.IsEnabled = false;
      this.ButtonBreak.IsEnabled = true;
      this.TextBoxEncryptionKey.IsEnabled = false;
      this.CheckBoxEncryption.IsEnabled = false;
      this.defaultCursor = this.Cursor;
      this.Cursor = Cursors.Wait;
    }

    private void SetStopState()
    {
      this.ComboCommand.IsEnabled = true;
      this.TextBoxUniversalCommandResult.IsEnabled = true;
      this.ButtonRunCommand.IsEnabled = true;
      this.ButtonRunCommandPreview.IsEnabled = true;
      this.ButtonBreak.IsEnabled = false;
      this.Cursor = this.defaultCursor;
      this.TextBoxEncryptionKey.IsEnabled = true;
      this.CheckBoxEncryption.IsEnabled = true;
      this.Cursor = this.defaultCursor;
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.ProgressBar1.Value = obj.ProgressPercentage;
        this.TextBlockStatus.Text = obj.Message;
      }
    }

    private void ButtonBreak_Click(object sender, RoutedEventArgs e)
    {
      this.cancelTokenSource.Cancel();
    }

    private async Task<byte[]> RunDeviceCommend(CommandWindowCommon.DeviceCommand theCommand)
    {
      byte[] result = (byte[]) null;
      this.SetRunState();
      try
      {
        result = await theCommand(this.progress, this.cancelTokenSource.Token);
      }
      catch (OperationCanceledException ex)
      {
      }
      catch (TimeoutException ex)
      {
        int num = (int) MessageBox.Show("Timeout");
      }
      catch (Exception ex)
      {
        bool isTimeout = false;
        if (ex is AggregateException)
        {
          AggregateException aex = ex as AggregateException;
          for (int i = 0; i < aex.InnerExceptions.Count; ++i)
          {
            Exception theException = aex.InnerExceptions[i];
            if (theException is TimeoutException)
            {
              if (i == aex.InnerExceptions.Count - 1)
              {
                isTimeout = true;
                int num = (int) MessageBox.Show("**** Multiple timouts ****" + Environment.NewLine + "Timeout count: " + aex.InnerExceptions.Count.ToString());
              }
              theException = (Exception) null;
            }
            else
              break;
          }
          aex = (AggregateException) null;
        }
        if (!isTimeout)
        {
          int num1 = (int) MessageBox.Show(ex.ToString());
        }
      }
      this.SetStopState();
      byte[] numArray = result;
      result = (byte[]) null;
      return numArray;
    }

    private async Task RunCommandFrame()
    {
      this.SetRunState();
      try
      {
        await this.RunCommand();
      }
      catch (OperationCanceledException ex)
      {
      }
      catch (TimeoutException ex)
      {
        this.TextBoxUniversalCommandResult.Text = "Timeout";
      }
      catch (NACK_Exception ex)
      {
        this.TextBoxUniversalCommandResult.Text = "Device response is NACK: " + ex.Message;
      }
      catch (Exception ex)
      {
        bool isTimeout = false;
        if (ex is AggregateException)
        {
          AggregateException aex = ex as AggregateException;
          int num1;
          for (int i = 0; i < aex.InnerExceptions.Count; num1 = i++)
          {
            Exception theException = aex.InnerExceptions[i];
            if (theException is TimeoutException)
            {
              if (i == aex.InnerExceptions.Count - 1)
              {
                isTimeout = true;
                string newLine = Environment.NewLine;
                num1 = aex.InnerExceptions.Count;
                string str = num1.ToString();
                int num2 = (int) MessageBox.Show("**** Multiple timeouts ****" + newLine + "Timeout count: " + str);
              }
              theException = (Exception) null;
            }
            else
              break;
          }
          aex = (AggregateException) null;
        }
        if (!isTimeout)
        {
          int num = (int) MessageBox.Show(ex.ToString());
        }
      }
      this.SetStopState();
    }

    private void ButtonAddNewMap_Click(object sender, RoutedEventArgs e)
    {
      throw new NotImplementedException();
    }

    private void ComboCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboCommand.SelectedIndex >= 0)
      {
        this.ComboAddCommand.Items.Clear();
        Dictionary<int, string> template = new Dictionary<int, string>();
        object selectedItem = this.ComboCommand.SelectedItem;
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_ReadMemory))
        {
          template.Add(1, "Adress(HEX):");
          template.Add(2, "Lenght(max.255): ");
        }
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_SetSystemTime))
        {
          template.Add(1, "Day.Month.Year:");
          template.Add(2, "Hour:Min:Sec:");
          template.Add(3, "Timezone:");
        }
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_SetWriteProtection))
          template.Add(1, "ProtectionKey:");
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_OpenWriteProtectionTemporaly))
          template.Add(1, "ProtectionKey:");
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_SetMode))
          template.Add(0, "Set Mode:");
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_SetKeyDate))
        {
          template.Add(1, "Month:");
          template.Add(2, "DayofMonth:");
          template.Add(3, "FirstYear:");
        }
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_SetRadioOperation))
          template.Add(1, "Set RadioOperation(0x00/0x01):");
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_SetLcdTestState))
        {
          template.Add(1, "LCD Test State:");
          template.Add(2, "LCD Ram Data:");
        }
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_SwitchLoRaLED))
          template.Add(1, "Switch LoRa LED (0x00/0x01):");
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_ActivateDeactivateDisplay))
          template.Add(1, "Switch Display (0x00/0x01):");
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_TimeShift))
          template.Add(1, "Data (HEX):");
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_ExecuteEvent))
          template.Add(1, "Set Event (HexByte):");
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_SetRTCCalibration))
          template.Add(1, "Set Calibration Value:");
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_SetCommunicationScenario))
          template.Add(1, "Set Communication Scenario:");
        if (selectedItem.ToString().Contains(CommandWindowCommon.CMD_SetLocalInterfaceEncryption))
        {
          template.Add(1, "Set encryption cmd:");
          template.Add(2, "Set additional data:");
        }
        this.SetArgumentFields(template);
        this.ButtonRunCommand.IsEnabled = true;
      }
      else
        this.ButtonRunCommand.IsEnabled = false;
    }

    private void ComboAddCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboAddCommand.SelectedIndex < 0)
        return;
      object selectedItem = this.ComboAddCommand.SelectedItem;
      if (this.ComboAddCommand.SelectedIndex == 7 || this.ComboAddCommand.SelectedIndex == 8)
      {
        this.SetArgumentFields(new Dictionary<int, string>()
        {
          {
            1,
            "Mode:"
          }
        });
      }
      else
      {
        this.TextCommandArgument_1.Visibility = Visibility.Collapsed;
        this.TextArgument_1_Label.Visibility = Visibility.Collapsed;
      }
    }

    private void SetArgumentFieldsValues(Dictionary<int, string> values)
    {
      if (values == null)
        return;
      foreach (KeyValuePair<int, string> keyValuePair in values)
      {
        if (keyValuePair.Key == 0)
          this.ComboAddCommand.SelectedItem = (object) keyValuePair.Value;
        if (keyValuePair.Key == 1)
          this.TextCommandArgument_1.Text = keyValuePair.Value;
        if (keyValuePair.Key == 2)
          this.TextCommandArgument_2.Text = keyValuePair.Value;
        if (keyValuePair.Key == 3)
          this.TextCommandArgument_3.Text = keyValuePair.Value;
        if (keyValuePair.Key == 4)
          this.TextCommandArgument_4.Text = keyValuePair.Value;
      }
    }

    private void SetArgumentFields(Dictionary<int, string> template)
    {
      this.TextCommandArgument_1.Text = string.Empty;
      this.TextCommandArgument_2.Text = string.Empty;
      this.TextCommandArgument_3.Text = string.Empty;
      this.TextCommandArgument_4.Text = string.Empty;
      this.ComboAddCommand_Label.Visibility = Visibility.Collapsed;
      this.ComboAddCommand.Visibility = Visibility.Collapsed;
      this.TextCommandArgument_1.Visibility = Visibility.Collapsed;
      this.TextCommandArgument_2.Visibility = Visibility.Collapsed;
      this.TextCommandArgument_3.Visibility = Visibility.Collapsed;
      this.TextCommandArgument_4.Visibility = Visibility.Collapsed;
      this.TextArgument_1_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_2_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_3_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_4_Label.Visibility = Visibility.Collapsed;
      if (template == null)
        return;
      foreach (KeyValuePair<int, string> keyValuePair in template)
      {
        if (keyValuePair.Key == 0)
        {
          this.ComboAddCommand.Visibility = Visibility.Visible;
          if (this.ComboCommand.SelectedItem.ToString().Contains(CommandWindowCommon.CMD_SetMode))
          {
            this.ComboAddCommand.Items.Add((object) "Operation Mode(0x00)");
            this.ComboAddCommand.Items.Add((object) "Delivery Mode(0x01)");
            this.ComboAddCommand.Items.Add((object) "Clock calibration mode(0x02)");
            this.ComboAddCommand.Items.Add((object) "Temperature calibration mode(0x03)");
            this.ComboAddCommand.Items.Add((object) "Volume calibration mode(0x04)");
            this.ComboAddCommand.Items.Add((object) "Bootloader prepare mode(0x05)");
            this.ComboAddCommand.Items.Add((object) "Bootloader mode(0x06)");
            this.ComboAddCommand.Items.Add((object) "Reserved for future common definitions(0x07~0x7F)");
            this.ComboAddCommand.Items.Add((object) "Special device modes(0x80~0xFF)");
          }
          this.ComboAddCommand_Label.Visibility = Visibility.Visible;
          this.ComboAddCommand_Label.Content = (object) keyValuePair.Value;
        }
        if (keyValuePair.Key == 1)
        {
          this.TextCommandArgument_1.Visibility = Visibility.Visible;
          this.TextArgument_1_Label.Visibility = Visibility.Visible;
          this.TextArgument_1_Label.Content = (object) keyValuePair.Value;
          this.TextCommandArgument_1.ContextMenu = this.Argument1ValuesMenu;
          this.TextCommandArgument_1.TextChanged += new TextChangedEventHandler(this.TextCommandArgument_1_TextChanged);
          if (this.ComboCommand.SelectedItem.ToString().Contains(CommandWindowCommon.CMD_SetSystemTime))
            this.TextCommandArgument_1.Text = DateTime.Now.ToShortDateString().ToString();
          if (this.ComboCommand.SelectedItem.ToString().Contains(CommandWindowCommon.CMD_SetMode))
          {
            this.ComboAddCommand.Visibility = Visibility.Visible;
            this.ComboAddCommand_Label.Visibility = Visibility.Visible;
            this.ComboAddCommand_Label.Content = (object) keyValuePair.Value;
            string str = this.ComboAddCommand.SelectedItem.ToString();
            this.TextArgument_1_Label.Content = (object) (str.Split('(')[1].Substring(2, 3) + str.Split('(')[1].Substring(7, 2));
          }
        }
        if (keyValuePair.Key == 2)
        {
          this.TextCommandArgument_2.Visibility = Visibility.Visible;
          this.TextArgument_2_Label.Visibility = Visibility.Visible;
          this.TextArgument_2_Label.Content = (object) keyValuePair.Value;
          this.TextCommandArgument_2.ContextMenu = this.Argument2ValuesMenu;
          if (this.ComboCommand.SelectedItem.ToString().Contains(CommandWindowCommon.CMD_SetSystemTime))
            this.TextCommandArgument_2.Text = string.Format("{0:T}", (object) DateTime.Now);
          if (this.ComboCommand.SelectedItem.ToString().Contains(CommandWindowCommon.CMD_SetLcdTestState))
          {
            this.TextCommandArgument_2.Visibility = Visibility.Hidden;
            this.TextArgument_2_Label.Visibility = Visibility.Hidden;
          }
        }
        if (keyValuePair.Key == 3)
        {
          this.TextCommandArgument_3.Visibility = Visibility.Visible;
          this.TextArgument_3_Label.Visibility = Visibility.Visible;
          this.TextArgument_3_Label.Content = (object) keyValuePair.Value;
          this.TextCommandArgument_3.ContextMenu = this.Argument3ValuesMenu;
          if (this.ComboCommand.SelectedItem.ToString().Contains(CommandWindowCommon.CMD_SetSystemTime))
            this.TextCommandArgument_3.Text = "00";
        }
        if (keyValuePair.Key == 4)
        {
          this.TextCommandArgument_4.Visibility = Visibility.Visible;
          this.TextArgument_4_Label.Visibility = Visibility.Visible;
          this.TextArgument_4_Label.Content = (object) keyValuePair.Value;
          this.TextCommandArgument_4.ContextMenu = this.Argument3ValuesMenu;
        }
      }
    }

    private void TextCommandArgument_1_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (!this.ComboCommand.SelectedItem.ToString().Contains(CommandWindowCommon.CMD_SetLcdTestState))
        return;
      if (this.TextCommandArgument_1.Text.Equals("0xff") || this.TextCommandArgument_1.Text.Equals("255"))
      {
        this.TextArgument_2_Label.Content = (object) "DataRam:";
        this.TextArgument_2_Label.Visibility = Visibility.Visible;
        this.TextCommandArgument_2.Visibility = Visibility.Visible;
      }
      else
      {
        this.TextArgument_2_Label.Content = (object) "";
        this.TextArgument_2_Label.Visibility = Visibility.Hidden;
        this.TextCommandArgument_2.Visibility = Visibility.Hidden;
      }
    }

    private void setCommonCommands()
    {
      this.ComboCommand.Items.Clear();
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_GetVersion);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_Resetdevice);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_SetWriteProtection);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_OpenWriteProtectionTemporaly);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_RunBackup);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_SetSystemTime);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_GetSystemTime);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_SetMode);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_GetMode);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_SetKeyDate);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_GetKeyDate);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_SetRadioOperation);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_GetRadioOperation);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_ClearResetCounter);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_GetResetCounter);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_SetLcdTestState);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_SwitchLoRaLED);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_ActivateDeactivateDisplay);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_TimeShift);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_ExecuteEvent);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_SetRTCCalibration);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_GetCommunicationScenario);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_SetCommunicationScenario);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_GetPrintedSerialNumber);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_SetLocalInterfaceEncryption);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_GetLocalInterfaceEncryption);
      this.ComboCommand.Items.Add((object) CommandWindowCommon.CMD_ReadMemory);
      this.ComboCommand.SelectedIndex = 0;
    }

    private void mi_Click(object sender, RoutedEventArgs e)
    {
      ((TextBox) ((FrameworkElement) sender).Tag).Text = ((HeaderedItemsControl) sender).Header.ToString();
    }

    private async Task RunCommand()
    {
      string FC = this.ComboCommand.SelectedItem.ToString();
      object addFC = this.ComboAddCommand.SelectedItem;
      string arg1 = string.IsNullOrEmpty(this.TextCommandArgument_1.Text) ? (string) null : this.TextCommandArgument_1.Text.Trim();
      string arg2 = string.IsNullOrEmpty(this.TextCommandArgument_2.Text) ? (string) null : this.TextCommandArgument_2.Text.Trim();
      string arg3 = string.IsNullOrEmpty(this.TextCommandArgument_3.Text) ? (string) null : this.TextCommandArgument_3.Text.Trim();
      this.myCommonCommands.enDeCrypt = this.CheckBoxEncryption.IsChecked.Value;
      this.myCommonCommands.AES_Key = this.TextBoxEncryptionKey.Text.Trim();
      try
      {
        if (FC.Contains(CommandWindowCommon.CMD_GetVersion))
        {
          try
          {
            byte[] retVal = await this.myCommonCommands.TransmitAndReceiveVersionData((byte) 6, (byte) 0, this.progress, this.cancelTokenSource.Token);
            this.result = this.result + "\nreturn byte array: " + Utility.ByteArrayToHexString(retVal);
            ushort uFV = retVal.Length >= 5 ? (ushort) retVal[0] : throw new Exception("FirmwareVersion has to be at least 4 Bytes long!");
            switch (uFV)
            {
              case 6:
                uint uFV1 = BitConverter.ToUInt32(retVal, 1);
                FirmwareVersion localFV = new FirmwareVersion(uFV1);
                this.result = this.result + "\nVersion: " + localFV.ToString();
                retVal = (byte[]) null;
                localFV = new FirmwareVersion();
                break;
              case (ushort) byte.MaxValue:
                throw new Exception("NACK received!\nCommand not known by this firmware!");
              default:
                throw new Exception("wrong answer received... 0x06 expected!");
            }
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nRead Version ERROR: \n -->" + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_ReadMemory))
        {
          try
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              uint address = Convert.ToUInt32(arg1, 16);
              uint len = 10;
              if (!uint.TryParse(arg2, out len))
                len = 10U;
              len = len > (uint) byte.MaxValue ? (uint) byte.MaxValue : len;
              byte[] retVal = await this.myCommonCommands.ReadMemoryAsync(this.progress, this.cancelTokenSource.Token, address, (byte) len);
              this.result = this.result + "\nData at address(" + arg1 + ")";
              this.result = this.result + "\n" + Utility.ByteArrayToHexString(retVal);
              retVal = (byte[]) null;
            }
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nRead Memory \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_Resetdevice))
        {
          try
          {
            await this.myCommonCommands.ResetDeviceAsync(this.progress, this.cancelTokenSource.Token);
            this.result += "\nReset Device OK";
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (Reset device) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_RunBackup))
        {
          try
          {
            await this.myCommonCommands.BackupDeviceAsync(this.progress, this.cancelTokenSource.Token);
            this.result += "\nBackup Device OK";
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (Run Backup) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_SetWriteProtection))
        {
          try
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              uint uiKey = 0;
              uiKey = arg1.IndexOf("0x") < 0 ? Convert.ToUInt32(arg1, 10) : Convert.ToUInt32(arg1, 16);
              byte[] baKey = BitConverter.GetBytes(uiKey);
              await this.myCommonCommands.SetWriteProtectionAsync(baKey, this.progress, this.cancelTokenSource.Token);
              this.result = this.result + "\n" + CommandWindowCommon.CMD_SetWriteProtection.ToString() + " was send ...";
              baKey = (byte[]) null;
            }
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (" + CommandWindowCommon.CMD_SetWriteProtection.ToString() + ") \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_OpenWriteProtectionTemporaly))
        {
          try
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              uint uiKey = 0;
              uiKey = arg1.IndexOf("0x") < 0 ? Convert.ToUInt32(arg1, 10) : Convert.ToUInt32(arg1, 16);
              byte[] baKey = BitConverter.GetBytes(uiKey);
              await this.myCommonCommands.OpenWriteProtectionTemporarilyAsync(baKey, this.progress, this.cancelTokenSource.Token);
              this.result = this.result + "\n" + CommandWindowCommon.CMD_OpenWriteProtectionTemporaly.ToString() + " was send ...";
              baKey = (byte[]) null;
            }
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (" + CommandWindowCommon.CMD_OpenWriteProtectionTemporaly.ToString() + ") \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_SetSystemTime))
        {
          try
          {
            if (!string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2) && !string.IsNullOrEmpty(arg3))
            {
              string myTime = arg1 + " " + arg2;
              DateTime setTime = DateTime.Now;
              if (!DateTime.TryParse(myTime, out setTime))
                throw new FormatException("Date has no the correct format.");
              Common32BitCommands.SystemTime sysTime = Convert.ToInt32(arg3) <= 56 && Convert.ToInt32(arg3) >= -48 ? new Common32BitCommands.SystemTime(setTime, sbyte.Parse(arg3)) : throw new ArgumentOutOfRangeException("Invalid value of 'Timezone'! Max. UTC+14:00 (14*4=56), Min. UTC-12:00 (-12*4=-48), Actual value is: " + arg3);
              await this.myCommonCommands.SetSystemTimeAsync(sysTime, this.progress, this.cancelTokenSource.Token);
              this.result += "\nSet System Time OK";
              this.updateContextMenu1(arg1);
              this.updateContextMenu2(arg2);
              this.updateContextMenu3(arg3);
              myTime = (string) null;
              sysTime = (Common32BitCommands.SystemTime) null;
            }
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (Set System Time) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_GetSystemTime))
        {
          try
          {
            Common32BitCommands.SystemTime sysTime = await this.myCommonCommands.GetSystemTimeAsync(this.progress, this.cancelTokenSource.Token);
            this.result = this.result + "\nSystemTime " + sysTime.ToString();
            sysTime = (Common32BitCommands.SystemTime) null;
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (Get System Time) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_SetMode))
        {
          if (addFC != null)
          {
            try
            {
              if (addFC.ToString().Contains("Reserved for future common definitions") || addFC.ToString().Contains("Special device modes"))
              {
                if (!string.IsNullOrEmpty(arg1))
                {
                  this.updateContextMenu1(arg1);
                  arg1 = arg1.Replace("0x", "");
                  byte mode = Utility.HexStringToByteArray(arg1)[0];
                  await this.myCommonCommands.SetModeAsync(mode, this.progress, this.cancelTokenSource.Token);
                  this.result = this.result + "\nMode set to " + addFC?.ToString();
                }
                else
                {
                  int num = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
                }
              }
              else
              {
                string mode = ushort.Parse(addFC.ToString().Split('(')[1].Substring(2, 2)).ToString();
                if (!string.IsNullOrEmpty(mode))
                {
                  await this.myCommonCommands.SetModeAsync(byte.Parse(mode), this.progress, this.cancelTokenSource.Token);
                  this.result = this.result + "\nMode set to " + addFC?.ToString();
                }
                mode = (string) null;
              }
            }
            catch (Exception ex)
            {
              this.result = this.result + "\nFunction (Set Mode) \nERROR: " + ex.Message;
            }
          }
          else
          {
            int num1 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_GetMode))
        {
          try
          {
            string DeviceMode = string.Empty;
            byte retVal = await this.myCommonCommands.GetModeAsync(this.progress, this.cancelTokenSource.Token);
            if (retVal >= (byte) 0 && retVal <= (byte) 127)
            {
              byte num = retVal;
              switch (num)
              {
                case 0:
                  DeviceMode = "Operation Mode";
                  break;
                case 1:
                  DeviceMode = "Delivery Mode";
                  break;
                case 2:
                  DeviceMode = "Clock calibration mode";
                  break;
                case 3:
                  DeviceMode = "Temperature calibration mode";
                  break;
                case 4:
                  DeviceMode = "Volume calibration mode";
                  break;
                case 5:
                  DeviceMode = "Bootloader prepare mode";
                  break;
                case 6:
                  DeviceMode = "Bootloader mode";
                  break;
                default:
                  DeviceMode = "Reserved for future common definitions";
                  break;
              }
            }
            else
              DeviceMode = "Special device modes";
            this.result = this.result + "\nGet Mode: " + DeviceMode + "(" + retVal.ToString("X2") + ")";
            DeviceMode = (string) null;
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (Get Mode) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_SetKeyDate))
        {
          if (!string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2))
          {
            try
            {
              this.updateContextMenu1(arg1);
              this.updateContextMenu2(arg2);
              Common32BitCommands.KeyDate keydate = new Common32BitCommands.KeyDate();
              keydate.Month = byte.Parse(arg1);
              keydate.DayOfMonth = byte.Parse(arg2);
              keydate.FirstYear = byte.Parse("255");
              if (!string.IsNullOrEmpty(arg3))
                keydate.FirstYear = byte.Parse(arg3);
              await this.myCommonCommands.SetKeyDateAsync(keydate, this.progress, this.cancelTokenSource.Token);
              this.result += "\nSet KeyDate OK";
              keydate = (Common32BitCommands.KeyDate) null;
            }
            catch (Exception ex)
            {
              this.result = this.result + "\nFunction (Set KeyDate) \nERROR: " + ex.Message;
            }
          }
          else
          {
            int num2 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_GetKeyDate))
        {
          try
          {
            Common32BitCommands.KeyDate keydate = await this.myCommonCommands.GetKeyDateAsync(this.progress, this.cancelTokenSource.Token);
            this.result += string.Format("\nGet KeyDate: Month {0} DayofMonth {1}  FirstYear {2} ", (object) keydate.Month, (object) keydate.DayOfMonth, (object) keydate.FirstYear);
            keydate = (Common32BitCommands.KeyDate) null;
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (Get KeyDate) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_SetRadioOperation))
        {
          if (!string.IsNullOrEmpty(arg1))
          {
            try
            {
              this.updateContextMenu1(arg1);
              arg1 = arg1.Contains("0x") ? uint.Parse(arg1.Substring(2), NumberStyles.HexNumber).ToString() : arg1;
              byte state = byte.Parse(arg1);
              await this.myCommonCommands.SetRadioOperationAsync(state, this.progress, this.cancelTokenSource.Token);
              this.result += "\nSet RadioOperation OK";
            }
            catch (Exception ex)
            {
              this.result = this.result + "\nFunction (Set RadioOperation) \nERROR: " + ex.Message;
            }
          }
          else
          {
            int num3 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_GetRadioOperation))
        {
          try
          {
            byte retVal = await this.myCommonCommands.GetRadioOperationAsync(this.progress, this.cancelTokenSource.Token);
            this.result = retVal != (byte) 0 ? (retVal != (byte) 1 ? this.result + "Unknown" : this.result + "\nGet RadioOperation: RadioOn(1)") : this.result + "\nGet RadioOperation: RadioOff(0)";
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (Get RadioOperation) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_ClearResetCounter))
        {
          try
          {
            await this.myCommonCommands.ClearResetCounterAsync(this.progress, this.cancelTokenSource.Token);
            this.result += "\nClear ResetCounter OK";
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (Clear ResetCounter) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_GetResetCounter))
        {
          try
          {
            byte retVal = await this.myCommonCommands.GetResetCounterAsync(this.progress, this.cancelTokenSource.Token);
            this.result = this.result + "\nGet ResetCounter: " + retVal.ToString();
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (Get ResetCounter) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_SetLcdTestState))
        {
          try
          {
            if (string.IsNullOrEmpty(arg1))
            {
              this.result += "\n Please input one byte from 0x00 to 0xff, only!";
              FC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              return;
            }
            arg1 = arg1.Replace("0x", "");
            if (!string.IsNullOrEmpty(arg1))
            {
              this.TextBoxUniversalCommandResult.Text = string.Empty;
              this.result = string.Empty;
              uint myCMDByte;
              this.LCDStateStartByte = !uint.TryParse(arg1, out myCMDByte) ? (byte) Convert.ToUInt16(arg1, 16) : (byte) myCMDByte;
              if (myCMDByte > (uint) byte.MaxValue)
              {
                this.progress.Report("LCD Test start ...");
                this.result += "\nValue for LCD Test State is not allowed!";
                this.result += "\nPlease use a value from 0x00 up to 0xff.";
              }
              else if (this.LCDStateStartByte != byte.MaxValue && this.LCDStateStartByte != (byte) 254)
              {
                this.LCDStateActualTestByte = this.LCDStateStartByte;
                this.progress.Report("LCD Test start ...");
                await this.myCommonCommands.SetLcdTestStateAsync(this.LCDStateActualTestByte, (byte[]) null, this.progress, this.cancelTokenSource.Token);
                this.result = this.result + "\nSet LCD to State: " + this.LCDStateActualTestByte.ToString("x2");
                this.progress.Report("LCD Test done.");
              }
              else if ((this.LCDStateStartByte == byte.MaxValue || this.LCDStateStartByte == (byte) 254) && string.IsNullOrEmpty(arg2))
                this.result += "\n\nRam data NOT set correctly, please set Ram data.";
              else if (this.LCDStateStartByte == byte.MaxValue && !string.IsNullOrEmpty(arg2))
              {
                byte[] dataRam = new byte[1];
                arg2 = arg2.Replace("0x", "");
                dataRam = Util.HexStringToByteArray(arg2);
                await this.myCommonCommands.SetLcdTestStateAsync(this.LCDStateStartByte, dataRam, this.progress, this.cancelTokenSource.Token);
                this.result += "\nSet LCD Special with DataRam: OK.";
                dataRam = (byte[]) null;
              }
            }
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (SetLcdTestState) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_SwitchLoRaLED))
        {
          try
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              arg1 = arg1.Replace("0x", "");
              byte state = Utility.HexStringToByteArray(arg1)[0];
              await this.myCommonCommands.SwitchLoRaLEDAsync(state, this.progress, this.cancelTokenSource.Token);
              this.result = this.result + "\nSwitched LoRa LED -> " + (state == (byte) 0 ? "OFF" : (state == (byte) 1 ? "ON" : "UNKNOWN"));
            }
            else
              this.result += "\nThe argument was not set correctly.";
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (SwitchLoRaLEDAsync) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_ActivateDeactivateDisplay))
        {
          try
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              arg1 = arg1.Replace("0x", "");
              byte state = Utility.HexStringToByteArray(arg1)[0];
              await this.myCommonCommands.ActivateDeactivateDisplayAsync(state, this.progress, this.cancelTokenSource.Token);
              this.result = this.result + "\nDisplay should be -> " + (state == (byte) 0 ? "DEACTIVATED" : (state == (byte) 1 ? "ACTIVATED" : "UNKNOWN"));
            }
            else
              this.result += "\nThe argument was not set correctly.";
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (ActivateDeactivateDisplayAsync) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_TimeShift))
        {
          try
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              arg1 = arg1.Replace("0x", "");
              byte[] data = Utility.HexStringToByteArray(arg1);
              await this.myCommonCommands.TimeShiftAsync(data, this.progress, this.cancelTokenSource.Token);
              this.result += "\nTimeShift was send ...";
              data = (byte[]) null;
            }
            else
              this.result += "\nThe argument was not set correctly.";
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (TimeShift) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_ExecuteEvent))
        {
          try
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              arg1 = arg1.Replace("0x", "");
              byte[] data = Utility.HexStringToByteArray(arg1);
              await this.myCommonCommands.ExecuteEventAsync(data[0], this.progress, this.cancelTokenSource.Token);
              this.result += "\nExecuteEvent was send ...";
              data = (byte[]) null;
            }
            else
              this.result += "\nThe argument was not set correctly.";
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (ExecuteEvent) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_SetRTCCalibration))
        {
          try
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              short iData = 0;
              iData = arg1.IndexOf("0x") < 0 ? Convert.ToInt16(arg1, 10) : Convert.ToInt16(arg1, 16);
              await this.myCommonCommands.SetRTC_Calibration(iData, this.progress, this.cancelTokenSource.Token);
              this.result += "\nSetRTCCalibration was send ...";
            }
            else
              this.result += "\nThe argument was not set correctly.";
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (SetRTCCalibration) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_GetCommunicationScenario))
        {
          try
          {
            Common32BitCommands.Scenarios retVal = await this.myCommonCommands.GetCommunicationScenarioAsync(this.progress, this.cancelTokenSource.Token);
            this.result = this.result + "\nGet CommunicationScenario: " + Utility.ByteArrayToHexString(retVal.basedata);
            string result1 = this.result;
            ushort? nullable = retVal.ScenarioOne;
            string str1;
            if (nullable.HasValue)
            {
              nullable = retVal.ScenarioOne;
              str1 = nullable.ToString();
            }
            else
              str1 = "n.a.";
            this.result = result1 + "\nScenario 1: " + str1;
            string result2 = this.result;
            nullable = retVal.ScenarioTwo;
            string str2;
            if (nullable.HasValue)
            {
              nullable = retVal.ScenarioTwo;
              str2 = nullable.ToString();
            }
            else
              str2 = "n.a.";
            this.result = result2 + "\nScenario 2: " + str2;
            retVal = (Common32BitCommands.Scenarios) null;
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (GetCommunicationScenario) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_SetCommunicationScenario))
        {
          try
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              ushort iData = 0;
              iData = arg1.IndexOf("0x") < 0 ? Convert.ToUInt16(arg1, 10) : Convert.ToUInt16(arg1, 16);
              byte[] data = BitConverter.GetBytes(iData);
              await this.myCommonCommands.SetCommunicationScenarioAsync(data, this.progress, this.cancelTokenSource.Token);
              this.result += "\nSetCommunicationScenario was send ... OK.";
              this.result += "\nDone.";
              data = (byte[]) null;
            }
            else
              this.result += "\nThe argument was not set correctly.";
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (SetCommunicationScenario) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_GetPrintedSerialNumber))
        {
          try
          {
            string retVal = await this.myCommonCommands.GetPrintedSerialNumberAsync(this.progress, this.cancelTokenSource.Token);
            this.result = this.result + "\nGet PrintedSerialNumber: '" + retVal + "'";
            retVal = (string) null;
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (Get PrintedSerialNumber) \nERROR: " + ex.Message;
          }
        }
        if (FC.Contains(CommandWindowCommon.CMD_SetLocalInterfaceEncryption))
        {
          string cmdName = "SetLocalInterfaceEncryption";
          try
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              ushort iData = 0;
              ushort iDataAdd = 0;
              iData = arg1.IndexOf("0x") < 0 ? (ushort) Convert.ToByte(arg1, 10) : (ushort) Convert.ToByte(arg1, 16);
              if (!string.IsNullOrEmpty(arg2))
                iDataAdd = arg2.IndexOf("0x") < 0 ? Convert.ToUInt16(arg2, 10) : Convert.ToUInt16(arg2, 16);
              byte[] tmpData = BitConverter.GetBytes(iData);
              byte[] tmpDataAdd = BitConverter.GetBytes(iDataAdd);
              byte[] data = new byte[3];
              Buffer.BlockCopy((Array) tmpData, 0, (Array) data, 0, 1);
              Buffer.BlockCopy((Array) tmpDataAdd, 0, (Array) data, 1, 2);
              await this.myCommonCommands.SetLocalInterfaceEncryptionAsync(data, this.progress, this.cancelTokenSource.Token);
              this.result = this.result + "\n" + cmdName + " was send ... OK.";
              this.result += "\nDone.";
              tmpData = (byte[]) null;
              tmpDataAdd = (byte[]) null;
              data = (byte[]) null;
            }
            else
              this.result += "\nThe argument was not set correctly.";
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (" + cmdName + ") \nERROR: " + ex.Message;
          }
          cmdName = (string) null;
        }
        if (FC.Contains(CommandWindowCommon.CMD_GetLocalInterfaceEncryption))
        {
          try
          {
            byte[] retVal = await this.myCommonCommands.GetLocalInterfaceEncryptionAsync(this.progress, this.cancelTokenSource.Token);
            this.result = this.result + "\nGet GetLocalInterfaceEncryption: '" + Utility.ByteArrayToHexString(retVal) + "'";
            retVal = (byte[]) null;
          }
          catch (Exception ex)
          {
            this.result = this.result + "\nFunction (Get GetLocalInterfaceEncryption) \nERROR: " + ex.Message;
          }
        }
        if (string.IsNullOrEmpty(this.result))
        {
          FC = (string) null;
          addFC = (object) null;
          arg1 = (string) null;
          arg2 = (string) null;
          arg3 = (string) null;
        }
        else
        {
          this.TextBoxUniversalCommandResult.Text = this.result;
          this.TextBoxUniversalCommandResult.UpdateLayout();
          CommandWindowCommon.ForceUIToUpdate();
          FC = (string) null;
          addFC = (object) null;
          arg1 = (string) null;
          arg2 = (string) null;
          arg3 = (string) null;
        }
      }
      catch (Exception ex)
      {
        this.result = "Error occoured ...\n\n" + ex.Message;
        this.TextBoxUniversalCommandResult.Text = this.result;
        FC = (string) null;
        addFC = (object) null;
        arg1 = (string) null;
        arg2 = (string) null;
        arg3 = (string) null;
      }
    }

    public static void ForceUIToUpdate()
    {
      DispatcherFrame frame = new DispatcherFrame();
      Dispatcher.CurrentDispatcher.Invoke(DispatcherPriority.Render, (Delegate) (parameter =>
      {
        frame.Continue = false;
        return (object) null;
      }), (object) null);
      Dispatcher.PushFrame(frame);
    }

    private async void ButtonRunCommand_Click(object sender, RoutedEventArgs e)
    {
      if (this.ButtonRunCommand.Content.ToString().Contains("STOP"))
      {
        this.ButtonBreak.IsEnabled = false;
        this.ButtonRunCommand.IsEnabled = true;
        this.ButtonRunCommand.Content = (object) "Run command";
      }
      else
        await this.RunCommandFrame();
    }

    private async void ButtonRunCommandPreview_Click(object sender, RoutedEventArgs e)
    {
      this.result = "Actual data of connected device:\n-------------------------------------------";
      Dictionary<int, string> args = new Dictionary<int, string>();
      this.ComboCommand.SelectedItem = (object) CommandWindowCommon.CMD_GetSystemTime;
      await this.RunCommandFrame();
      this.ComboCommand.SelectedItem = (object) CommandWindowCommon.CMD_GetMode;
      await this.RunCommandFrame();
      this.ComboCommand.SelectedItem = (object) CommandWindowCommon.CMD_GetKeyDate;
      await this.RunCommandFrame();
      this.ComboCommand.SelectedItem = (object) CommandWindowCommon.CMD_GetRadioOperation;
      await this.RunCommandFrame();
      this.ComboCommand.SelectedItem = (object) CommandWindowCommon.CMD_GetResetCounter;
      await this.RunCommandFrame();
      args = (Dictionary<int, string>) null;
    }

    private async void ButtonGetversion_Click(object sender, RoutedEventArgs e)
    {
      await Task.Delay(1);
      throw new NotImplementedException();
    }

    private void updateContextMenu1(string packet)
    {
      if (!this.Argument1_last_values.Contains(packet))
        this.Argument1_last_values.Add(packet);
      this.Argument1ValuesMenu.Items.Clear();
      if (this.Argument1_last_values.Count > 20)
        this.Argument1_last_values.RemoveRange(0, this.Argument1_last_values.Count - 20);
      foreach (string argument1LastValue in this.Argument1_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument1LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextCommandArgument_1;
        this.Argument1ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu2(string packet)
    {
      if (!this.Argument2_last_values.Contains(packet))
        this.Argument2_last_values.Add(packet);
      this.Argument2ValuesMenu.Items.Clear();
      if (this.Argument2_last_values.Count > 20)
        this.Argument2_last_values.RemoveRange(0, this.Argument2_last_values.Count - 20);
      foreach (string argument2LastValue in this.Argument2_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument2LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextCommandArgument_2;
        this.Argument2ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu3(string packet)
    {
      if (!this.Argument3_last_values.Contains(packet))
        this.Argument3_last_values.Add(packet);
      this.Argument3ValuesMenu.Items.Clear();
      if (this.Argument3_last_values.Count > 20)
        this.Argument3_last_values.RemoveRange(0, this.Argument3_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextCommandArgument_3;
        this.Argument3ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void CheckBoxEncryption_Checked(object sender, RoutedEventArgs e)
    {
      this.myCommonCommands.enDeCrypt = true;
      this.TextBoxEncryptionKey.Visibility = Visibility.Visible;
      this.EncryptionKey_Label.Visibility = Visibility.Visible;
    }

    private void CheckBoxEncryption_UnChecked(object sender, RoutedEventArgs e)
    {
      this.myCommonCommands.enDeCrypt = false;
      this.TextBoxEncryptionKey.Visibility = Visibility.Collapsed;
      this.EncryptionKey_Label.Visibility = Visibility.Collapsed;
    }

    private void TextBoxEncryptionKey_TextChanged(object sender, TextChangedEventArgs e)
    {
      this.myCommonCommands.AES_Key = this.TextBoxEncryptionKey.Text;
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/commandwindowcommon.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.TextBlockStatus = (TextBlock) target;
          break;
        case 2:
          this.TextBoxUniversalCommandResult = (TextBox) target;
          break;
        case 3:
          this.StackPanalButtons = (StackPanel) target;
          break;
        case 4:
          this.FunctionCode_Label = (Label) target;
          break;
        case 5:
          this.ComboCommand = (ComboBox) target;
          this.ComboCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboCommand_SelectionChanged);
          break;
        case 6:
          this.CheckBoxEncryption = (CheckBox) target;
          this.CheckBoxEncryption.Checked += new RoutedEventHandler(this.CheckBoxEncryption_Checked);
          this.CheckBoxEncryption.Unchecked += new RoutedEventHandler(this.CheckBoxEncryption_UnChecked);
          break;
        case 7:
          this.EncryptionKey_Label = (Label) target;
          break;
        case 8:
          this.TextBoxEncryptionKey = (TextBox) target;
          this.TextBoxEncryptionKey.TextChanged += new TextChangedEventHandler(this.TextBoxEncryptionKey_TextChanged);
          break;
        case 9:
          this.ComboAddCommand_Label = (Label) target;
          break;
        case 10:
          this.ComboAddCommand = (ComboBox) target;
          this.ComboAddCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboAddCommand_SelectionChanged);
          break;
        case 11:
          this.TextArgument_1_Label = (Label) target;
          break;
        case 12:
          this.TextCommandArgument_1 = (TextBox) target;
          break;
        case 13:
          this.TextArgument_2_Label = (Label) target;
          break;
        case 14:
          this.TextCommandArgument_2 = (TextBox) target;
          break;
        case 15:
          this.TextArgument_3_Label = (Label) target;
          break;
        case 16:
          this.TextCommandArgument_3 = (TextBox) target;
          break;
        case 17:
          this.TextArgument_4_Label = (Label) target;
          break;
        case 18:
          this.TextCommandArgument_4 = (TextBox) target;
          break;
        case 19:
          this.StackPanalButtons2 = (StackPanel) target;
          break;
        case 20:
          this.ButtonRunCommand = (Button) target;
          this.ButtonRunCommand.Click += new RoutedEventHandler(this.ButtonRunCommand_Click);
          break;
        case 21:
          this.ButtonRunCommandPreview = (Button) target;
          this.ButtonRunCommandPreview.Click += new RoutedEventHandler(this.ButtonRunCommandPreview_Click);
          break;
        case 22:
          this.ButtonBreak = (Button) target;
          this.ButtonBreak.Click += new RoutedEventHandler(this.ButtonBreak_Click);
          break;
        case 23:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }

    private delegate Task<byte[]> DeviceCommand(
      ProgressHandler progress,
      CancellationToken cancelToken);
  }
}


--- Common16BitCommands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.Common16BitCommands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using HandlerLib.Interfaces;
using MBusLib;
using NLog;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public sealed class Common16BitCommands : IHandlerMemoryAccess
  {
    private static Logger Common16BitLogger = LogManager.GetLogger("S3_CommandsConnectionPort");
    private DeviceCommandsMBus deviceCMD;

    public Common16BitCommands(DeviceCommandsMBus deviceCMD) => this.deviceCMD = deviceCMD;

    public async Task ReadMemoryAsync(
      AddressRange addressRange,
      DeviceMemory deviceMemory,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] readData = await this.ReadMemoryAsync(progress, cancelToken, addressRange, (byte) 90);
      deviceMemory.SetData(addressRange.StartAddress, readData);
      readData = (byte[]) null;
    }

    public async Task WriteMemoryAsync(
      AddressRange addressRange,
      DeviceMemory deviceMemory,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] writeData = deviceMemory.GetData(addressRange);
      uint num = addressRange.ByteSize;
      byte cmd = byte.Parse(num.ToString());
      num = addressRange.StartAddress;
      ushort address = ushort.Parse(num.ToString());
      byte maxBytes = byte.Parse("192");
      await Task.Run((Action) (() => this.WriteMemory(progress, cancelToken, cmd, address, writeData, maxBytes)));
    }

    public async Task<byte[]> ReadMemoryAsync(
      ProgressHandler progress,
      CancellationToken token,
      ushort address,
      byte count)
    {
      byte[] numArray = await Task.Run<byte[]>((Func<byte[]>) (() => this.ReadMemory(progress, token, address, count)), token);
      return numArray;
    }

    public async Task<byte[]> ReadMemoryAsync(
      ProgressHandler progress,
      CancellationToken token,
      AddressRange addressRange,
      byte maxBytesPerPacket)
    {
      if (addressRange == null)
        throw new NullReferenceException(nameof (addressRange));
      if (addressRange.StartAddress > (uint) ushort.MaxValue)
        throw new ArgumentOutOfRangeException("AddressRange.StartAddress can not be greater as " + ushort.MaxValue.ToString());
      byte[] numArray = await Task.Run<byte[]>((Func<byte[]>) (() => this.ReadMemory(progress, token, (ushort) addressRange.StartAddress, addressRange.ByteSize, maxBytesPerPacket)), token);
      return numArray;
    }

    public async Task<byte[]> ReadMemoryAsync(
      ProgressHandler progress,
      CancellationToken token,
      ushort address,
      uint count,
      byte maxBytesPerPacket)
    {
      byte[] numArray = await Task.Run<byte[]>((Func<byte[]>) (() => this.ReadMemory(progress, token, address, count, maxBytesPerPacket)), token);
      return numArray;
    }

    public byte[] ReadMemory(
      ProgressHandler progress,
      CancellationToken token,
      ushort address,
      byte count)
    {
      if (progress == null)
        throw new ArgumentNullException(nameof (progress));
      if (count <= (byte) 0)
        throw new ArgumentOutOfRangeException(nameof (count));
      token.ThrowIfCancellationRequested();
      List<byte> byteList = new List<byte>();
      byteList.Add((byte) 15);
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(address));
      byteList.Add(count);
      byteList.Add((byte) 2);
      Common16BitCommands.Common16BitLogger.Debug("Read memory. Address: 0x" + address.ToString("X4") + " 0x" + count.ToString("x4") + " byte(s)");
      VariableDataStructure variableDataStructure = VariableDataStructure.Parse(this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(byteList.ToArray()), progress, token));
      if (variableDataStructure.MfgData.Length != (int) count)
        throw new Exception("Invalid response by read the memory! Expected: " + count.ToString() + " bytes but receive: " + variableDataStructure.MfgData.Length.ToString() + " byte(s)");
      return variableDataStructure.MfgData;
    }

    public byte[] ReadMemory(
      ProgressHandler progress,
      CancellationToken token,
      ushort address,
      uint count,
      byte maxBytesPerPacket)
    {
      if (count < 0U)
        throw new ArgumentOutOfRangeException(nameof (count));
      int num1 = maxBytesPerPacket >= (byte) 0 ? Convert.ToInt32(count / (uint) maxBytesPerPacket) : throw new ArgumentOutOfRangeException(nameof (maxBytesPerPacket));
      if (num1 <= 1 && count <= (uint) maxBytesPerPacket)
        return this.ReadMemory(progress, token, address, (byte) count);
      byte num2 = (byte) (count % (uint) maxBytesPerPacket);
      if (num2 > (byte) 0)
        ++num1;
      List<byte> byteList = new List<byte>((int) count);
      ushort address1 = address;
      byte count1 = maxBytesPerPacket;
      progress.Split(num1 + 1);
      progress.Report("Read: 0x" + address.ToString("X4"));
      for (int index = 1; index <= num1; ++index)
      {
        if (index > 1)
          address1 += (ushort) count1;
        count1 = (long) (index * (int) maxBytesPerPacket) >= (long) count ? (num2 > (byte) 0 ? num2 : maxBytesPerPacket) : maxBytesPerPacket;
        byte[] collection = this.ReadMemory(progress, token, address1, count1);
        byteList.AddRange((IEnumerable<byte>) collection);
      }
      return byteList.ToArray();
    }

    public async Task WriteRAMAsync(
      ProgressHandler progress,
      CancellationToken token,
      ushort address,
      byte[] buffer)
    {
      await Task.Run((Action) (() => this.WriteRAM(progress, token, address, buffer)), token);
    }

    public async Task WriteRAMAsync(
      ProgressHandler progress,
      CancellationToken token,
      AddressRange addressRange,
      byte[] buffer,
      byte maxBytesPerPacket)
    {
      if (addressRange == null)
        throw new NullReferenceException(nameof (addressRange));
      if (addressRange.StartAddress > (uint) ushort.MaxValue)
        throw new ArgumentOutOfRangeException("AddressRange.StartAddress can not be greater as " + ushort.MaxValue.ToString());
      await Task.Run((Action) (() => this.WriteRAM(progress, token, (ushort) addressRange.StartAddress, buffer, maxBytesPerPacket)), token);
    }

    public async Task WriteRAMAsync(
      ProgressHandler progress,
      CancellationToken token,
      ushort address,
      byte[] buffer,
      byte maxBytesPerPacket)
    {
      await Task.Run((Action) (() => this.WriteRAM(progress, token, address, buffer, maxBytesPerPacket)), token);
    }

    public void WriteRAM(
      ProgressHandler progress,
      CancellationToken token,
      ushort address,
      byte[] buffer)
    {
      this.WriteMemory(progress, token, (byte) 3, address, buffer);
    }

    public void WriteRAM(
      ProgressHandler progress,
      CancellationToken token,
      ushort address,
      byte[] buffer,
      byte maxBytesPerPacket)
    {
      this.WriteMemory(progress, token, (byte) 3, address, buffer, maxBytesPerPacket);
    }

    public async Task WriteFLASHAsync(
      ProgressHandler progress,
      CancellationToken token,
      ushort address,
      byte[] buffer)
    {
      await Task.Run((Action) (() => this.WriteFLASH(progress, token, address, buffer)), token);
    }

    public async Task WriteFLASHAsync(
      ProgressHandler progress,
      CancellationToken token,
      ushort address,
      byte[] buffer,
      byte maxBytesPerPacket)
    {
      await Task.Run((Action) (() => this.WriteFLASH(progress, token, address, buffer, maxBytesPerPacket)), token);
    }

    public void WriteFLASH(
      ProgressHandler progress,
      CancellationToken token,
      ushort address,
      byte[] buffer)
    {
      this.WriteMemory(progress, token, (byte) 1, address, buffer);
    }

    public void WriteFLASH(
      ProgressHandler progress,
      CancellationToken token,
      ushort address,
      byte[] buffer,
      byte maxBytesPerPacket)
    {
      this.WriteMemory(progress, token, (byte) 1, address, buffer, maxBytesPerPacket);
    }

    public async Task EraseFLASHAsync(
      ProgressHandler progress,
      CancellationToken token,
      ushort address)
    {
      await Task.Run((Action) (() => this.EraseFLASH(progress, token, address)), token);
    }

    public void EraseFLASH(ProgressHandler progress, CancellationToken token, ushort address)
    {
      if (progress == null)
        throw new ArgumentNullException(nameof (progress));
      if (address <= (ushort) 0)
        throw new ArgumentException(nameof (address));
      token.ThrowIfCancellationRequested();
      List<byte> byteList = new List<byte>();
      byteList.Add((byte) 15);
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(address));
      byteList.Add((byte) 0);
      byteList.Add((byte) 14);
      progress.Split(new double[2]{ 10.0, 90.0 });
      progress.Report("Erase FLASH");
      Common16BitCommands.Common16BitLogger.Debug("EraseFLASH: " + address.ToString("x4"));
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(byteList.ToArray()), progress, token);
      if (resultFrame.Type != 0)
        throw new Exception("Invalid response by erase the memory! Expected: ACK, but receive: " + resultFrame.Type.ToString());
    }

    public void EraseFLASH(
      ProgressHandler progress,
      CancellationToken token,
      ushort StartAddress,
      int NumberOfBytes)
    {
      int num = NumberOfBytes / 128;
      if (((uint) StartAddress & 63U) > 0U)
      {
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.IllegalData, "Illegal erase flash start address");
        throw new Exception("Illegal erase flash start address");
      }
      if ((NumberOfBytes & 63) != 0 || num > (int) byte.MaxValue)
      {
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.IllegalData, "Illegal number of bytes by erase flash");
        throw new Exception("Illegal number of bytes by erase flash");
      }
      List<byte> byteList = new List<byte>();
      byteList.Add((byte) 15);
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(StartAddress));
      byteList.Add((byte) num);
      byteList.Add((byte) 14);
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(byteList.ToArray()), progress, token);
      Common16BitCommands.Common16BitLogger.Debug("EraseFlash. Address: 0x" + StartAddress.ToString("X4") + " " + NumberOfBytes.ToString("x4") + " byte(s)");
      if (resultFrame.Type != 0)
        throw new Exception("Invalid response by erase the memory! Expected: ACK, but receive: " + resultFrame.Type.ToString());
    }

    public async Task SetEmergencyModeAsync(ProgressHandler progress, CancellationToken token)
    {
      int num = await Task.Run<bool>((Func<bool>) (() => this.SetEmergencyMode(progress, token)), token) ? 1 : 0;
    }

    public bool SetEmergencyMode(ProgressHandler progress, CancellationToken token)
    {
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(new List<byte>()
      {
        (byte) 15,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 10
      }.ToArray()), progress, token);
      Common16BitCommands.Common16BitLogger.Debug("calling SetEmergencyMode ... done. ");
      if (resultFrame.Type != 0)
        throw new Exception("Invalid response while setting emergency mode! Expected: ACK, but receive: " + resultFrame.Type.ToString());
      return true;
    }

    public async Task BackupDeviceAsync(ProgressHandler progress, CancellationToken token)
    {
      await Task.Run((Action) (() => this.BackupDevice(progress, token)), token);
    }

    public void BackupDevice(ProgressHandler progress, CancellationToken token)
    {
      if (progress == null)
        throw new ArgumentNullException(nameof (progress));
      token.ThrowIfCancellationRequested();
      List<byte> byteList = new List<byte>();
      byteList.Add((byte) 15);
      byteList.Add((byte) 0);
      byteList.Add((byte) 0);
      byteList.Add((byte) 0);
      byteList.Add((byte) 8);
      progress.Split(new double[2]{ 10.0, 90.0 });
      progress.Report("Backup device");
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(byteList.ToArray()), progress, token);
      if (resultFrame.Type != 0)
        throw new Exception("Invalid response by backup device! Expected: ACK, but receive: " + resultFrame.Type.ToString());
    }

    public async Task ResetDeviceAsync(ProgressHandler progress, CancellationToken token)
    {
      await Task.Run((Action) (() => this.ResetDevice(progress, token)), token);
    }

    public void ResetDevice(ProgressHandler progress, CancellationToken token)
    {
      if (progress == null)
        throw new ArgumentNullException(nameof (progress));
      token.ThrowIfCancellationRequested();
      List<byte> byteList = new List<byte>();
      byteList.Add((byte) 15);
      byteList.Add((byte) 0);
      byteList.Add((byte) 0);
      byteList.Add((byte) 0);
      byteList.Add((byte) 4);
      progress.Split(new double[2]{ 10.0, 90.0 });
      progress.Report("Reset device");
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(byteList.ToArray()), progress, token);
      if (resultFrame.Type != 0)
        throw new Exception("Invalid response by reset device! Expected: ACK, but receive: " + resultFrame.Type.ToString());
      this.deviceCMD.MBus.Repeater.Port.ForceWakeup();
    }

    private void WriteMemory(
      ProgressHandler progress,
      CancellationToken token,
      byte cmd,
      ushort address,
      byte[] buffer)
    {
      if (progress == null)
        throw new ArgumentNullException(nameof (progress));
      if (address == (ushort) 0)
        throw new ArgumentException(nameof (address));
      if (buffer == null)
        throw new ArgumentNullException(nameof (buffer));
      token.ThrowIfCancellationRequested();
      List<byte> byteList = new List<byte>();
      byteList.Add((byte) 15);
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(address));
      byteList.Add((byte) buffer.Length);
      byteList.Add(cmd);
      byteList.AddRange((IEnumerable<byte>) buffer);
      progress.Split(new double[2]{ 10.0, 90.0 });
      progress.Report("Write: 0x" + address.ToString("X4") + " " + buffer.Length.ToString() + " byte(s)");
      MBusFrame frame = new MBusFrame(byteList.ToArray());
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(frame, progress, token);
      if (resultFrame.Type != 0)
      {
        Common16BitCommands.Common16BitLogger.Debug("--> Write memory error!!!");
        throw new Exception("Invalid response by write the memory! Expected: ACK, but receive: " + resultFrame.Type.ToString());
      }
      Common16BitCommands.Common16BitLogger.Debug("Write memory block. Address: 0x" + address.ToString("X4") + " " + buffer.Length.ToString("x4") + " byte(s)");
      Common16BitCommands.Common16BitLogger.Debug("--> " + BitConverter.ToString(frame.ToByteArray()));
      Common16BitCommands.Common16BitLogger.Debug("--> Write memory done");
    }

    public void WriteMemory(
      ProgressHandler progress,
      CancellationToken token,
      byte cmd,
      ushort address,
      byte[] buffer,
      byte maxBytesPerPacket)
    {
      if (buffer == null || buffer.Length == 0)
        throw new ArgumentException(nameof (buffer));
      if (maxBytesPerPacket < (byte) 0)
        throw new ArgumentOutOfRangeException(nameof (maxBytesPerPacket));
      int int32 = Convert.ToInt32(buffer.Length / (int) maxBytesPerPacket);
      if (int32 <= 1 && buffer.Length <= (int) maxBytesPerPacket)
      {
        this.WriteMemory(progress, token, cmd, address, buffer);
      }
      else
      {
        byte num = (byte) ((uint) buffer.Length % (uint) maxBytesPerPacket);
        if (num > (byte) 0)
          ++int32;
        ushort address1 = address;
        byte length = maxBytesPerPacket;
        int srcOffset = 0;
        progress.Split(int32 * 2 + 1);
        for (int index = 1; index <= int32; ++index)
        {
          progress.Report("Write: 0x" + address1.ToString("X4") + " " + length.ToString() + " byte(s)");
          if (index > 1)
            address1 += (ushort) length;
          length = index * (int) maxBytesPerPacket >= buffer.Length ? (num > (byte) 0 ? num : maxBytesPerPacket) : maxBytesPerPacket;
          byte[] numArray = new byte[(int) length];
          Buffer.BlockCopy((Array) buffer, srcOffset, (Array) numArray, 0, numArray.Length);
          this.WriteMemory(progress, token, cmd, address1, numArray);
          srcOffset += numArray.Length;
        }
        if (srcOffset != buffer.Length)
          throw new Exception("Write memory failed! Written number of bytes is incorrect. Expected: " + buffer.Length.ToString() + ", Actual: " + srcOffset.ToString());
        progress.Report("Write: 0x" + address.ToString("X4") + " " + srcOffset.ToString() + " byte(s)");
      }
    }

    public async Task DeviceProtectionGetAsync(ProgressHandler progress, CancellationToken token)
    {
      int num = await Task.Run<bool>((Func<bool>) (() => this.DeviceProtectionGet(progress, token)), token) ? 1 : 0;
    }

    public bool DeviceProtectionGet(ProgressHandler progress, CancellationToken token)
    {
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(new List<byte>()
      {
        (byte) 15,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 7
      }.ToArray()), progress, token);
      if (resultFrame.Type != 0)
        throw new Exception("Invalid response while getting device protection! Expected: ACK, but receive: " + resultFrame.Type.ToString());
      return true;
    }

    public async Task DeviceProtectionSetAsync(ProgressHandler progress, CancellationToken token)
    {
      int num = await Task.Run<bool>((Func<bool>) (() => this.DeviceProtectionSet(progress, token)), token) ? 1 : 0;
    }

    public bool DeviceProtectionSet(ProgressHandler progress, CancellationToken token)
    {
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(new List<byte>()
      {
        (byte) 15,
        (byte) 1,
        (byte) 0,
        (byte) 0,
        (byte) 7
      }.ToArray()), progress, token);
      if (resultFrame.Type != 0)
        throw new Exception("Invalid response while setting device protection! Expected: ACK, but receive: " + resultFrame.Type.ToString());
      return true;
    }

    public async Task DeviceProtectionResetAsync(
      ProgressHandler progress,
      CancellationToken token,
      uint meterKey)
    {
      int num = await Task.Run<bool>((Func<bool>) (() => this.DeviceProtectionReset(progress, token, meterKey)), token) ? 1 : 0;
    }

    public bool DeviceProtectionReset(
      ProgressHandler progress,
      CancellationToken token,
      uint meterKey)
    {
      List<byte> byteList = new List<byte>();
      byteList.Add((byte) 15);
      byteList.Add((byte) 2);
      byteList.Add((byte) 0);
      byteList.Add((byte) 4);
      byteList.Add((byte) 7);
      for (int index = 0; index < 4; ++index)
      {
        byteList.Add((byte) meterKey);
        meterKey >>= 8;
      }
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(byteList.ToArray()), progress, token);
      if (resultFrame.Type != 0)
        throw new Exception("Invalid response while device protection reset! Expected: ACK, but receive: " + resultFrame.Type.ToString());
      return true;
    }

    public async Task DeviceProtectionSetKeyAsync(
      ProgressHandler progress,
      CancellationToken token,
      uint meterKey)
    {
      int num = await Task.Run<bool>((Func<bool>) (() => this.DeviceProtectionSetKey(progress, token, meterKey)), token) ? 1 : 0;
    }

    public bool DeviceProtectionSetKey(
      ProgressHandler progress,
      CancellationToken token,
      uint meterKey)
    {
      List<byte> byteList = new List<byte>();
      byteList.Add((byte) 15);
      byteList.Add((byte) 3);
      byteList.Add((byte) 0);
      byteList.Add((byte) 4);
      byteList.Add((byte) 7);
      for (int index = 0; index < 4; ++index)
      {
        byteList.Add((byte) meterKey);
        meterKey >>= 8;
      }
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(byteList.ToArray()), progress, token);
      if (resultFrame.Type != 0)
        throw new Exception("Invalid response while setting device protection key! Expected: ACK, but receive: " + resultFrame.Type.ToString());
      return true;
    }

    public async Task SetOptoTimeoutSecondsAsync(
      ProgressHandler progress,
      CancellationToken token,
      int seconds)
    {
      int num = await Task.Run<bool>((Func<bool>) (() => this.SetOptoTimeoutSeconds(progress, token, seconds)), token) ? 1 : 0;
    }

    public bool SetOptoTimeoutSeconds(
      ProgressHandler progress,
      CancellationToken token,
      int Seconds)
    {
      uint OptionByte = (uint) (Seconds / 16 + 3);
      if (OptionByte < 4U)
        OptionByte = 0U;
      if (OptionByte > (uint) byte.MaxValue)
        OptionByte = (uint) byte.MaxValue;
      bool flag = this.S3Command(progress, token, (byte) 13, (byte) OptionByte, "Send opto timeout seconds");
      if (flag && OptionByte < 4U)
        this.deviceCMD.MBus.Repeater.Port.ForceWakeup();
      return flag;
    }

    public async Task FlyingTestActivateAsync(ProgressHandler progress, CancellationToken token)
    {
      int num = await Task.Run<bool>((Func<bool>) (() => this.FlyingTestActivate(progress, token)), token) ? 1 : 0;
    }

    public bool FlyingTestActivate(ProgressHandler progress, CancellationToken token)
    {
      return this.S3Command(progress, token, (byte) 17, "Send Flying test activate");
    }

    public async Task AdcTestActivateAsync(ProgressHandler progress, CancellationToken token)
    {
      int num = await Task.Run<bool>((Func<bool>) (() => this.AdcTestActivate(progress, token)), token) ? 1 : 0;
    }

    public bool AdcTestActivate(ProgressHandler progress, CancellationToken token)
    {
      return this.S3Command(progress, token, (byte) 16, "Send ADC test activate");
    }

    public async Task FlyingTestStartAsync(ProgressHandler progress, CancellationToken token)
    {
      await Task.Run((Action) (() => this.FlyingTestStart(progress, token)), token);
    }

    public void FlyingTestStart(ProgressHandler progress, CancellationToken token)
    {
      this.S3CommandNoAnswer((byte) 18, "Send Flying test start");
    }

    public async Task FlyingTestStopAsync(ProgressHandler progress, CancellationToken token)
    {
      await Task.Run((Action) (() => this.FlyingTestStop(progress, token)), token);
    }

    public void FlyingTestStop(ProgressHandler progress, CancellationToken token)
    {
      this.S3CommandNoAnswer((byte) 19, "Send Flying test stop");
    }

    public async Task CapacityOfTestActivateAsync(ProgressHandler progress, CancellationToken token)
    {
      int num = await Task.Run<bool>((Func<bool>) (() => this.CapacityOfTestActivate(progress, token)), token) ? 1 : 0;
    }

    public bool CapacityOfTestActivate(ProgressHandler progress, CancellationToken token)
    {
      return this.S3Command(progress, token, (byte) 38, "Send capacity off test activate");
    }

    public async Task Start512HzRtcCalibrationAsync(
      ProgressHandler progress,
      CancellationToken token)
    {
      int num = await Task.Run<bool>((Func<bool>) (() => this.Start512HzRtcCalibration(progress, token)), token) ? 1 : 0;
    }

    public bool Start512HzRtcCalibration(ProgressHandler progress, CancellationToken token)
    {
      return this.S3Command(progress, token, (byte) 36, "STart RTC 512Hz calibration mode");
    }

    public bool TestDone(ProgressHandler progress, CancellationToken token, long dispValueId)
    {
      switch (dispValueId)
      {
        case -1:
          return this.S3Command(progress, token, (byte) 15, (byte) 3, "Send test done. LCD: Sleep");
        case 272769346:
          return this.S3Command(progress, token, (byte) 15, (byte) 0, "Send test done. LCD: HeadEnergy");
        case 272769355:
          return this.S3Command(progress, token, (byte) 15, (byte) 1, "Send test done. LCD: CoolingEnergy");
        default:
          return this.S3Command(progress, token, (byte) 15, (byte) 2, "Send test done. LCD: SegmentTest");
      }
    }

    internal bool S3Command(
      ProgressHandler progress,
      CancellationToken token,
      byte CommandByte,
      string NlogString)
    {
      return this.S3Command(progress, token, CommandByte, (byte) 0, NlogString);
    }

    internal bool S3Command(
      ProgressHandler progress,
      CancellationToken token,
      byte CommandByte,
      byte OptionByte,
      string NlogString)
    {
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(new List<byte>()
      {
        (byte) 15,
        (byte) 0,
        (byte) 0,
        OptionByte,
        CommandByte
      }.ToArray()), progress, token);
      if (resultFrame.Type != 0)
        throw new Exception("Invalid response while " + NlogString + "! Expected: ACK, but receive: " + resultFrame.Type.ToString());
      return true;
    }

    internal byte[] S3CommandData(
      ProgressHandler progress,
      CancellationToken token,
      byte CommandByte,
      string NlogString)
    {
      return this.S3CommandData(progress, token, CommandByte, (byte) 0, NlogString);
    }

    internal byte[] S3CommandData(
      ProgressHandler progress,
      CancellationToken token,
      byte CommandByte,
      byte OptionByte,
      string NlogString)
    {
      return this.deviceCMD.MBus.Repeater.GetResultData(new MBusFrame(new List<byte>()
      {
        (byte) 15,
        (byte) 0,
        (byte) 0,
        OptionByte,
        CommandByte
      }.ToArray()), 504, progress, token);
    }

    internal void S3CommandNoAnswer(byte CommandByte, string NlogString)
    {
      this.deviceCMD.MBus.Repeater.TransmitMBusFrame(new MBusFrame(new List<byte>()
      {
        (byte) 15,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        CommandByte
      }.ToArray()));
    }

    public void FlyingTestReadVolume(
      ProgressHandler progress,
      CancellationToken token,
      out float volume,
      out byte state)
    {
      volume = 0.0f;
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(new List<byte>()
      {
        (byte) 15,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 20
      }.ToArray()), progress, token);
      FixedDataHeader fixedDataHeader = resultFrame.Type == FrameType.LongFrame ? FixedDataHeader.Parse(resultFrame.UserData) : throw new Exception("Invalid response by FlyingTestReadVolume! Expected: ACK, but receive: " + resultFrame.Type.ToString());
      state = fixedDataHeader.Status;
      volume = BitConverter.ToSingle(resultFrame.UserData, 12);
    }

    public bool AdcTestCycleWithSimulatedVolume(
      ProgressHandler progress,
      CancellationToken token,
      float simulationVolume)
    {
      byte[] bytes = BitConverter.GetBytes(simulationVolume);
      List<byte> byteList = new List<byte>();
      byteList.Add((byte) 15);
      byteList.Add((byte) 0);
      byteList.Add((byte) 0);
      byteList.Add((byte) 4);
      byteList.Add((byte) 11);
      for (int index = 0; index < bytes.Length; ++index)
        byteList.Add(bytes[index]);
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(byteList.ToArray()), progress, token);
      if (resultFrame.Type != 0)
        throw new Exception("Invalid response by AdcTestCycleWithSimulatedVolume! Expected: ACK, but receive: " + resultFrame.Type.ToString());
      return true;
    }

    public ParameterListInfo GetTransmitListInfo(ProgressHandler progress, CancellationToken token)
    {
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(new List<byte>()
      {
        (byte) 15,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 37
      }.ToArray()), progress, token);
      return resultFrame.IsVariableDataStructure ? ParameterListInfo.Parse(VariableDataStructure.Parse(resultFrame).MfgData) : throw new ArgumentException("response does not include variable data structure");
    }

    public async Task SetRadioParametersAsync(
      ProgressHandler progress,
      CancellationToken token,
      byte listNumber,
      RADIO_MODE radioMode,
      AES_ENCRYPTION_MODE AES_Encryption,
      ushort intervallSeconds)
    {
      byte radioAndEncMode = (byte) (((int) radioMode << 4) + AES_Encryption);
      List<byte> TransmitBuffer = new List<byte>();
      TransmitBuffer.Add((byte) 15);
      TransmitBuffer.Add((byte) 0);
      TransmitBuffer.Add((byte) 0);
      TransmitBuffer.Add((byte) 4);
      TransmitBuffer.Add((byte) 42);
      TransmitBuffer.Add(listNumber);
      TransmitBuffer.Add(radioAndEncMode);
      TransmitBuffer.AddRange((IEnumerable<byte>) BitConverter.GetBytes(intervallSeconds));
      MBusFrame request = new MBusFrame(TransmitBuffer.ToArray());
      MBusFrame response = await this.deviceCMD.MBus.Repeater.GetResultFrameAsync(request, progress, token);
      if (response.Type != 0)
        throw new Exception("Invalid response while setting device protection! Expected: ACK, but receive: " + response.Type.ToString());
      TransmitBuffer = (List<byte>) null;
      request = (MBusFrame) null;
      response = (MBusFrame) null;
    }

    public byte[] SetTransmitList(
      ProgressHandler progress,
      CancellationToken token,
      ushort list,
      bool isRadio,
      ushort enc_mode,
      ushort intervallseconds)
    {
      List<byte> byteList = new List<byte>();
      byteList.AddRange((IEnumerable<byte>) ParameterListInfo.GetCommandPayload(list, isRadio, enc_mode));
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(intervallseconds));
      return this.deviceCMD.MBus.Repeater.GetResultData(new MBusFrame(byteList.ToArray()), 1, progress, token);
    }

    public byte[] SetTransmitList(
      ProgressHandler progress,
      CancellationToken token,
      ushort list,
      bool isRadio,
      ushort enc_mode)
    {
      List<byte> byteList = new List<byte>();
      byteList.AddRange((IEnumerable<byte>) ParameterListInfo.GetCommandPayload(list, isRadio, enc_mode));
      return this.deviceCMD.MBus.Repeater.GetResultData(new MBusFrame(byteList.ToArray()), 1, progress, token);
    }

    public byte[] GetMeterMonitorData(ProgressHandler progress, CancellationToken token)
    {
      return this.deviceCMD.MBus.Repeater.GetResultData(new MBusFrame(new List<byte>()
      {
        (byte) 15,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 5
      }.ToArray()), 504, progress, token);
    }

    public cImpulseInputCounters ReadInputCounters(
      ProgressHandler progress,
      CancellationToken token)
    {
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(new List<byte>()
      {
        (byte) 15,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 41
      }.ToArray()), progress, token);
      if (resultFrame.Type != FrameType.LongFrame)
        throw new Exception("Invalid response by ReadInputCounters! Expected: ACK, but receive: " + resultFrame.Type.ToString());
      int length = 12;
      int count = 12;
      byte[] numArray = new byte[count];
      byte[] dst = new byte[length];
      Buffer.BlockCopy((Array) resultFrame.UserData, 0, (Array) dst, 0, length);
      Buffer.BlockCopy((Array) resultFrame.UserData, length, (Array) numArray, 0, count);
      ByteField byteField = new ByteField(numArray);
      if (byteField.Count != count)
        throw new Exception("Illegal number of bytes by ReadInputCounters");
      return new cImpulseInputCounters()
      {
        ImputState = ((eWR4_VOL_INPUT_STATE) byteField.Data[1]).ToString(),
        HardwareCounter = BitConverter.ToUInt16(byteField.Data, 2),
        VolumePulseCounter = BitConverter.ToInt16(byteField.Data, 4),
        Input0Counter = BitConverter.ToUInt16(byteField.Data, 6),
        Input1Counter = BitConverter.ToUInt16(byteField.Data, 8),
        Input2Counter = BitConverter.ToUInt16(byteField.Data, 10)
      };
    }

    public byte[] RunIoTest(
      ProgressHandler progress,
      CancellationToken token,
      eIoTestFunctions theFunction)
    {
      List<byte> byteList = new List<byte>();
      byteList.Add((byte) 15);
      byteList.Add((byte) 0);
      byteList.Add((byte) 0);
      byteList.Add((byte) theFunction);
      byteList.Add((byte) 21);
      byte[] numArray1 = new byte[1];
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(byteList.ToArray()), progress, token);
      if (resultFrame.Type != FrameType.ACK && resultFrame.Type != FrameType.LongFrame)
        throw new Exception("Invalid response by RunIoTest! Expected: ACK, but receive: " + resultFrame.Type.ToString());
      if (theFunction != eIoTestFunctions.IoTest_Run)
        return numArray1;
      int length = 4;
      int num = resultFrame.UserData.Length - length;
      byte[] numArray2 = new byte[length];
      for (int index = 0; index < length; ++index)
        numArray2[index] = resultFrame.UserData[index + num];
      return numArray2;
    }

    public void DigitalInputsAndOutputs(
      ProgressHandler progress,
      CancellationToken token,
      uint NewOutputMask,
      uint NewOutputState,
      ref uint OldOutputState,
      ref uint OldInputState)
    {
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(new List<byte>()
      {
        (byte) 15,
        (byte) NewOutputMask,
        (byte) NewOutputState,
        (byte) 0,
        (byte) 12
      }.ToArray()), progress, token);
      OldOutputState = (uint) resultFrame.UserData[13];
      OldInputState = (uint) resultFrame.UserData[14];
    }

    public void RadioTest(ProgressHandler progress, CancellationToken token, byte testMode)
    {
      MBusFrame resultFrame = this.deviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(new List<byte>()
      {
        (byte) 15,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        testMode
      }.ToArray()), progress, token);
      if (resultFrame.Type != FrameType.ACK && resultFrame.Type != FrameType.LongFrame)
        throw new Exception("Invalid response by RadioTest! Expected: ACK, but receive: " + resultFrame.Type.ToString());
    }

    public bool TransmitBlock(ProgressHandler progress, CancellationToken token, ref byte[] buffer)
    {
      try
      {
        Common16BitCommands.Common16BitLogger.Debug("TransmitBlock: " + Util.ByteArrayToHexString(buffer));
        this.deviceCMD.MBus.Repeater.Port.Write(buffer);
        return true;
      }
      catch (Exception ex)
      {
        throw new Exception("Invalid response by TransmitBlock! " + ex.Message);
      }
    }

    public bool SendBlock(ProgressHandler progress, CancellationToken token, ref byte[] buffer)
    {
      try
      {
        Common16BitCommands.Common16BitLogger.Debug("SendBlock: " + Util.ByteArrayToHexString(buffer));
        this.deviceCMD.MBus.Repeater.Port.Write(buffer);
        return true;
      }
      catch (Exception ex)
      {
        throw new Exception("Invalid response by SendBlock! " + ex.Message);
      }
    }

    public byte[] ReceiveBlock(
      ProgressHandler progress,
      CancellationToken token,
      int MinByteNb,
      bool first)
    {
      byte[] numArray = new byte[0];
      byte[] buffer = !first ? this.deviceCMD.MBus.Repeater.Port.ReadEnd(MinByteNb) : this.deviceCMD.MBus.Repeater.Port.ReadHeader(MinByteNb);
      Common16BitCommands.Common16BitLogger.Debug("ReceiveBlock: " + Util.ByteArrayToHexString(buffer));
      return buffer;
    }

    private enum DeviceProtectionCommands
    {
      IsProtected,
      SetProtection,
      ResetProtection,
      SetKey,
    }
  }
}


--- Common32BitCommands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.Common32BitCommands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using MBusLib;
using MBusLib.Exceptions;
using MBusLib.Utility;
using NLog;
using StartupLib;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZENNER.CommonLibrary.Exceptions;

#nullable disable
namespace HandlerLib
{
  public class Common32BitCommands : BaseMemoryAccess, IZRCommand
  {
    internal static Logger Common32BitCommands_Logger = LogManager.GetLogger(nameof (Common32BitCommands));
    private bool crypt = false;
    private string AESKey = (string) null;
    private AES_ENCRYPTION_MODE cryptMode;

    public bool enDeCrypt
    {
      get => this.crypt;
      set => this.crypt = value;
    }

    public string AES_Key
    {
      get => this.AESKey;
      set => this.AESKey = value;
    }

    public AES_ENCRYPTION_MODE enDeCryptMode
    {
      get => this.cryptMode;
      set => this.cryptMode = value;
    }

    public DeviceCommandsMBus DeviceCMD { get; set; }

    public Common32BitCommands(
      DeviceCommandsMBus deviceCMD,
      bool crypt = false,
      string AESkey = null,
      AES_ENCRYPTION_MODE ENC_MODE = AES_ENCRYPTION_MODE.MODE_7)
    {
      this.DeviceCMD = deviceCMD;
      this.AES_Key = AESkey;
      this.enDeCrypt = crypt;
      this.cryptMode = ENC_MODE;
    }

    public override async Task ReadMemoryAsync(
      AddressRange addressRange,
      DeviceMemory deviceMemory,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      Common32BitCommands.Common32BitCommands_Logger.Trace("ReadMemoryAsync: " + addressRange.ToString());
      byte[] readData = await this.ReadMemoryAsync(progress, cancelToken, addressRange, (byte) 90);
      deviceMemory.SetData(addressRange.StartAddress, readData);
      Common32BitCommands.Common32BitCommands_Logger.Trace("ReadMemoryAsync: done");
      readData = (byte[]) null;
    }

    public override async Task WriteMemoryAsync(
      AddressRange addressRange,
      DeviceMemory deviceMemory,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      Common32BitCommands.Common32BitCommands_Logger.Trace("WriteMemoryAsync: " + addressRange.ToString());
      byte[] writeData = deviceMemory.GetData(addressRange);
      await this.WriteMemoryAsync(progress, cancelToken, addressRange, writeData, (byte) 192);
      Common32BitCommands.Common32BitCommands_Logger.Trace("WriteMemoryAsync: done");
      writeData = (byte[]) null;
    }

    public virtual async Task<byte[]> TransmitAndReceiveVersionData(
      byte FC,
      byte EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      List<byte> myCommand = new List<byte>();
      myCommand.Add((byte) 15);
      myCommand.AddRange((IEnumerable<byte>) new byte[3]);
      myCommand.Add(FC);
      myCommand.Add(EFC);
      byte[] resultData = (byte[]) null;
      MBusFrame request = new MBusFrame(myCommand.ToArray());
      MBusFrame response = await this.DeviceCMD.MBus.Repeater.GetResultFrameAsync(request, progress, cancelToken);
      resultData = DeviceCommandsMBus.Get_FC_EFC_AndData(response);
      request = (MBusFrame) null;
      response = (MBusFrame) null;
      byte[] versionData = resultData;
      myCommand = (List<byte>) null;
      resultData = (byte[]) null;
      return versionData;
    }

    public async Task<byte> GetMBusStatusByte(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      List<byte> myCommand = new List<byte>();
      myCommand.Add((byte) 15);
      myCommand.AddRange((IEnumerable<byte>) new byte[3]);
      myCommand.Add((byte) 6);
      MBusFrame request = new MBusFrame(myCommand.ToArray());
      MBusFrame response = await this.DeviceCMD.MBus.Repeater.GetResultFrameAsync(request, progress, cancelToken);
      VariableDataStructure vds = VariableDataStructure.Parse(response);
      byte status = vds.Header.Status;
      myCommand = (List<byte>) null;
      request = (MBusFrame) null;
      response = (MBusFrame) null;
      vds = (VariableDataStructure) null;
      return status;
    }

    public async Task TransmitAndCheckAckAsync(
      Manufacturer_FC FC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, new byte?(), (byte[]) null, progress, cancelToken)));
    }

    public async Task TransmitAndCheckAckAsync(
      Manufacturer_FC FC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, new byte?(), data, progress, cancelToken)));
    }

    public async Task TransmitAndCheckAckAsync(
      Manufacturer_FC FC,
      CommonRadioCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, new byte?((byte) EFC), (byte[]) null, progress, cancelToken)));
    }

    public async Task TransmitAndCheckAckAsync(
      Manufacturer_FC FC,
      CommonRadioCommands_EFC EFC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, new byte?((byte) EFC), data, progress, cancelToken)));
    }

    public async Task TransmitAndCheckAckAsync(
      Manufacturer_FC FC,
      CommonMBusCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, new byte?((byte) EFC), (byte[]) null, progress, cancelToken)));
    }

    public async Task TransmitAndCheckAckAsync(
      Manufacturer_FC FC,
      CommonMBusCommands_EFC EFC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, new byte?((byte) EFC), data, progress, cancelToken)));
    }

    public async Task TransmitAndCheckAckAsync(
      Manufacturer_FC FC,
      CommonLoRaCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, new byte?((byte) EFC), (byte[]) null, progress, cancelToken)));
    }

    public async Task TransmitAndCheckAckAsync(
      Manufacturer_FC FC,
      CommonNBIoTCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, new byte?((byte) EFC), (byte[]) null, progress, cancelToken)));
    }

    public async Task TransmitAndCheckAckAsync(
      Manufacturer_FC FC,
      CommonLoRaCommands_EFC EFC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, new byte?((byte) EFC), data, progress, cancelToken)));
    }

    public async Task TransmitAndCheckAckAsync(
      Manufacturer_FC FC,
      CommonNBIoTCommands_EFC EFC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, new byte?((byte) EFC), data, progress, cancelToken)));
    }

    public async Task TransmitAndCheckAckAsync(
      Manufacturer_FC FC,
      SpecialCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, new byte?((byte) EFC), (byte[]) null, progress, cancelToken)));
    }

    public async Task TransmitAndCheckAckAsync(
      Manufacturer_FC FC,
      SpecialCommands_EFC EFC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Run((Action) (() => this.TransmitAndCheckAck(FC, new byte?((byte) EFC), data, progress, cancelToken)));
    }

    private void TransmitAndCheckAck(
      Manufacturer_FC FC,
      byte? EFC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] data1 = this.TransmitAndGetData(FC, EFC, data, true, progress, cancelToken);
      if (this.enDeCrypt)
        return;
      if (data1 == null || data1.Length < 2)
        throw new Exception("Illegal ACK data received.");
      if (data1[0] != (byte) 254)
        throw new Exception("Illegal ACK code received");
      if ((Manufacturer_FC) data1[1] != FC)
        throw new Exception("Illegal FC inside ACK data received.");
      if (EFC.HasValue)
      {
        int num = data1.Length >= 3 ? (int) data1[2] : throw new Exception("Illegal ACK data length for EFC code using");
        byte? nullable1 = EFC;
        int? nullable2 = nullable1.HasValue ? new int?((int) nullable1.GetValueOrDefault()) : new int?();
        int valueOrDefault = nullable2.GetValueOrDefault();
        if (!(num == valueOrDefault & nullable2.HasValue))
          throw new Exception("Illegal EFC inside ACK data received.");
        if (data1.Length > 3)
        {
          if (data1.Length > 4)
            throw new Exception("Too much ACK data.");
          if (data1.Length == 4)
            throw new Exception("\nNACK: " + this.checkForNACKValue((int) data1[3]));
        }
      }
      else if (data1.Length > 2)
      {
        if (data1.Length > 3)
          throw new Exception("Too much ACK data.");
        if (data1.Length == 3)
          throw new Exception("\nNACK: " + this.checkForNACKValue((int) data1[2]));
      }
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      Manufacturer_FC FC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, new byte?(), (byte[]) null, false, progress, cancelToken)));
      return dataAsync;
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      Manufacturer_FC FC,
      CommonRadioCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, new byte?((byte) EFC), (byte[]) null, false, progress, cancelToken)));
      return dataAsync;
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      Manufacturer_FC FC,
      CommonRadioCommands_EFC EFC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, new byte?((byte) EFC), data, false, progress, cancelToken)));
      return dataAsync;
    }

    public byte[] TransmitAndGetData(
      Manufacturer_FC FC,
      CommonRadioCommands_EFC EFC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      return this.TransmitAndGetData(FC, new byte?((byte) EFC), data, false, progress, cancelToken);
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      Manufacturer_FC FC,
      CommonMBusCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, new byte?((byte) EFC), (byte[]) null, false, progress, cancelToken)));
      return dataAsync;
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      Manufacturer_FC FC,
      CommonMBusCommands_EFC EFC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, new byte?((byte) EFC), data, false, progress, cancelToken)));
      return dataAsync;
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      Manufacturer_FC FC,
      CommonMBusCommands_EFC EFC,
      byte[] data,
      bool ack_allowed,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, new byte?((byte) EFC), data, ack_allowed, progress, cancelToken)));
      return dataAsync;
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      Manufacturer_FC FC,
      CommonLoRaCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, new byte?((byte) EFC), (byte[]) null, false, progress, cancelToken)));
      return dataAsync;
    }

    public byte[] TransmitAndGetData(
      Manufacturer_FC FC,
      CommonLoRaCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      return this.TransmitAndGetData(FC, new byte?((byte) EFC), (byte[]) null, false, progress, cancelToken);
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      Manufacturer_FC FC,
      CommonNBIoTCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, new byte?((byte) EFC), (byte[]) null, false, progress, cancelToken)));
      return dataAsync;
    }

    public byte[] TransmitAndGetData(
      Manufacturer_FC FC,
      CommonNBIoTCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      return this.TransmitAndGetData(FC, new byte?((byte) EFC), (byte[]) null, false, progress, cancelToken);
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      Manufacturer_FC FC,
      CommonNBIoTCommands_EFC EFC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, new byte?((byte) EFC), data, false, progress, cancelToken)));
      return dataAsync;
    }

    public byte[] TransmitAndGetData(
      Manufacturer_FC FC,
      CommonMBusCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      return this.TransmitAndGetData(FC, new byte?((byte) EFC), (byte[]) null, false, progress, cancelToken);
    }

    public byte[] TransmitAndGetData(
      Manufacturer_FC FC,
      CommonMBusCommands_EFC EFC,
      byte[] bytes,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      return this.TransmitAndGetData(FC, new byte?((byte) EFC), bytes, false, progress, cancelToken);
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      Manufacturer_FC FC,
      CommonLoRaCommands_EFC EFC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, new byte?((byte) EFC), data, false, progress, cancelToken)));
      return dataAsync;
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      Manufacturer_FC FC,
      SpecialCommands_EFC EFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, new byte?((byte) EFC), (byte[]) null, false, progress, cancelToken)));
      return dataAsync;
    }

    public async Task<byte[]> TransmitAndGetDataAsync(
      Manufacturer_FC FC,
      SpecialCommands_EFC EFC,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] dataAsync = await Task.Run<byte[]>((Func<byte[]>) (() => this.TransmitAndGetData(FC, new byte?((byte) EFC), data, false, progress, cancelToken)));
      return dataAsync;
    }

    public virtual byte[] TransmitAndGetData(
      Manufacturer_FC FC,
      byte? EFC,
      byte[] parameterBytes,
      bool ACK_allowed,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      this.CheckLicence_ReadOnly(FC, EFC, parameterBytes);
      if (this.DeviceCMD.ConnectedReducedID == null)
        throw new Exception("Please read version first! 'DeviceCMD.ConnectedReducedID == null'");
      int num1 = 0;
      if (parameterBytes != null)
        num1 = parameterBytes.Length;
      byte[] numArray1;
      int length1;
      if (!EFC.HasValue)
      {
        numArray1 = new byte[5 + num1];
        length1 = 15;
      }
      else
      {
        numArray1 = new byte[6 + num1];
        length1 = 16;
      }
      int num2 = 0;
      byte[] numArray2 = numArray1;
      int index1 = num2;
      int num3 = index1 + 1;
      numArray2[index1] = (byte) 15;
      for (int index2 = 0; index2 < 3; ++index2)
        numArray1[num3++] = this.DeviceCMD.ConnectedReducedID[index2];
      byte[] numArray3 = numArray1;
      int index3 = num3;
      int num4 = index3 + 1;
      int num5 = (int) FC;
      numArray3[index3] = (byte) num5;
      if (EFC.HasValue)
        numArray1[num4++] = EFC.Value;
      if (parameterBytes != null)
      {
        for (int index4 = 0; index4 < parameterBytes.Length; ++index4)
          numArray1[num4++] = parameterBytes[index4];
      }
      if (this.enDeCrypt && !string.IsNullOrEmpty(this.AES_Key))
      {
        this.DeviceCMD.MBus.Repeater.AES_Key = this.AES_Key;
        byte[] byteArray = ZENNER.CommonLibrary.Utility.HexStringToByteArray(this.AES_Key);
        MBusFrameCrypt previousFrame = MBusFrameCrypt.Parse(Direction.GatewayToDevice, new DateTime?(DateTime.Now), new MBusFrameCrypt(numArray1).ToByteArray());
        byte[] numArray4 = new byte[15];
        byte[] numArray5 = new byte[4];
        Buffer.BlockCopy((Array) numArray1, 0, (Array) numArray5, 0, 4);
        int length2 = numArray5.Length;
        Buffer.BlockCopy((Array) numArray5, 0, (Array) numArray4, 0, numArray5.Length);
        byte[] numArray6 = numArray4;
        int index5 = length2;
        int length3 = index5 + 1;
        int num6 = (int) FC;
        numArray6[index5] = (byte) num6;
        if (EFC.HasValue)
          numArray4[length3++] = EFC.Value;
        if (parameterBytes != null)
        {
          for (int index6 = 0; index6 < parameterBytes.Length; ++index6)
            numArray4[length3++] = parameterBytes[index6];
        }
        byte[] numArray7 = new byte[length3];
        Buffer.BlockCopy((Array) numArray4, 0, (Array) numArray7, 0, numArray7.Length);
        MBusFrameCrypt resultFrame = this.DeviceCMD.MBus.Repeater.GetResultFrame(new MBusFrameCrypt(Direction.DeviceToGateway, numArray7, new int?(7), byteArray, previousFrame), progress, cancelToken);
        if (resultFrame == null)
          throw new ArgumentNullException("response");
        resultFrame.EncryptionKey = byteArray;
        if (resultFrame.Type != FrameType.LongFrame)
          throw new InvalidFrameException(string.Format("Expected: LongFrame, Actual: {0}", (object) resultFrame.Type), resultFrame.ToByteArray());
        VariableDataStructure variableDataStructure = resultFrame.IsVariableDataStructure ? VariableDataStructure.Parse(resultFrame) : throw new InvalidFrameException("Expected: VariableDataStructure", resultFrame.ToByteArray());
        int? nullable1 = resultFrame.EncryptionMode;
        int num7 = 7;
        if (nullable1.GetValueOrDefault() == num7 & nullable1.HasValue && variableDataStructure.MfgData != null && (variableDataStructure.MDH == (byte) 15 || variableDataStructure.MDH == byte.MaxValue))
        {
          int length4 = variableDataStructure.MfgData.Length;
          for (int index7 = variableDataStructure.MfgData.Length - 1; index7 >= 0; --index7)
          {
            if (variableDataStructure.MfgData[index7] == (byte) 47)
              --length4;
            if (variableDataStructure.MfgData[index7] == (byte) 22)
            {
              length4 -= 2;
              break;
            }
          }
          variableDataStructure.MfgData = variableDataStructure.MfgData.SubArray<byte>(0, length4);
        }
        if (variableDataStructure.MDH != (byte) 15)
          throw new InvalidFrameException("Missed manufacturer specific data header (0x0F)", resultFrame.ToByteArray());
        if (variableDataStructure.MfgData.Length >= 2 && variableDataStructure.MfgData[0] == (byte) 254 && (Manufacturer_FC) variableDataStructure.MfgData[1] == FC)
        {
          if (EFC.HasValue)
          {
            int num8;
            if (variableDataStructure.MfgData.Length >= 2)
            {
              int num9 = (int) variableDataStructure.MfgData[2];
              byte? nullable2 = EFC;
              nullable1 = nullable2.HasValue ? new int?((int) nullable2.GetValueOrDefault()) : new int?();
              int valueOrDefault = nullable1.GetValueOrDefault();
              num8 = !(num9 == valueOrDefault & nullable1.HasValue) ? 1 : 0;
            }
            else
              num8 = 1;
            if (num8 != 0)
              throw new InvalidFrameException("Wrong EFC", resultFrame.ToByteArray());
          }
          return (byte[]) null;
        }
        if (variableDataStructure.MfgData[0] == byte.MaxValue)
        {
          if ((Manufacturer_FC) variableDataStructure.MfgData[1] != FC)
            throw new InvalidFrameException(string.Format("Invalid FC. Expected: {0:X2}h, Actual: {1}h", (object) (int) FC, (object) variableDataStructure.MfgData[0]), resultFrame.ToByteArray());
          Nack nack = EFC.HasValue ? (Nack) variableDataStructure.MfgData[3] : (Nack) variableDataStructure.MfgData[2];
          if (nack == Nack.UnknownFunction)
            throw new InvalidFrameException("Unknown command !!!", resultFrame.ToByteArray());
          throw new NackException(FC.ToString(), nack, variableDataStructure.MfgData);
        }
        try
        {
          if (variableDataStructure.MfgData.Length < 5)
            throw new InvalidFrameException("Invalid ZR1 frame!", resultFrame.ToByteArray());
          if ((Manufacturer_FC) variableDataStructure.MfgData[3] != FC)
            throw new InvalidFrameException(string.Format("Invalid FC. Expected: {0:X2}h, Actual: {1}h", (object) (int) FC, (object) variableDataStructure.MfgData[3]), resultFrame.ToByteArray());
          int num10;
          if (EFC.HasValue && ((int) variableDataStructure.MfgData[4] & 128) != 128)
          {
            int num11 = (int) variableDataStructure.MfgData[4] & (int) sbyte.MaxValue;
            byte? nullable3 = EFC;
            nullable1 = nullable3.HasValue ? new int?((int) nullable3.GetValueOrDefault()) : new int?();
            int valueOrDefault = nullable1.GetValueOrDefault();
            num10 = !(num11 == valueOrDefault & nullable1.HasValue) ? 1 : 0;
          }
          else
            num10 = 0;
          if (num10 != 0)
            throw new InvalidFrameException(string.Format("Invalid EFC. Expected: {0:X2}h, Actual: {1}h", (object) EFC.Value, (object) variableDataStructure.MfgData[1]), resultFrame.ToByteArray());
          int index8 = EFC.HasValue ? 5 : 4;
          return variableDataStructure.MfgData.SubArray<byte>(index8, variableDataStructure.MfgData.Length - index8);
        }
        catch
        {
          if ((Manufacturer_FC) variableDataStructure.MfgData[0] != FC)
            throw new InvalidFrameException(string.Format("Invalid FC. Expected: {0:X2}h, Actual: {1}h", (object) (int) FC, (object) variableDataStructure.MfgData[0]), resultFrame.ToByteArray());
          if (EFC.HasValue && (int) variableDataStructure.MfgData[1] != (int) EFC.Value)
            throw new InvalidFrameException(string.Format("Invalid EFC. Expected: {0:X2}h, Actual: {1}h", (object) EFC.Value, (object) variableDataStructure.MfgData[1]), resultFrame.ToByteArray());
          int index9 = EFC.HasValue ? 2 : 1;
          return variableDataStructure.MfgData.SubArray<byte>(index9, variableDataStructure.MfgData.Length - index9);
        }
      }
      else
      {
        MBusFrame resultFrame = this.DeviceCMD.MBus.Repeater.GetResultFrame(new MBusFrame(numArray1), progress, cancelToken);
        byte[] userData = resultFrame.UserData;
        DeviceCommandsMBus.CheckManufacturerResponse(resultFrame, this.DeviceCMD.ConnectedDeviceVersion.LongID);
        if (resultFrame.UserData[13] == byte.MaxValue)
        {
          if (resultFrame.UserData.Length < length1 + 1)
            throw new NACK_Exception("Illegal manufacturer NACK frame. No error code available.");
          string str1 = (string) null;
          if (resultFrame.UserData.Length > length1 + 1)
            str1 = ZENNER.CommonLibrary.Utility.ByteArrayToHexString(resultFrame.UserData, 0, length1);
          string str2 = this.checkForNACKValue((int) resultFrame.UserData[length1]);
          if (str1 != null)
            throw new NACK_Exception(str2 + "; Additional infos: " + str1);
          throw new NACK_Exception(str2 + " CMD: " + FC.ToString());
        }
        int srcOffset;
        if (resultFrame.UserData[13] == (byte) 254)
        {
          if (!ACK_allowed)
            throw new Exception("ACK received, data expected.");
          srcOffset = 13;
        }
        else
        {
          if ((Manufacturer_FC) resultFrame.UserData[13] != FC)
            throw new Exception("Illegal FC received");
          if (EFC.HasValue)
          {
            srcOffset = 15;
            if ((int) resultFrame.UserData[14] != (int) EFC.Value)
              throw new Exception("Illegal EFC received");
          }
          else
            srcOffset = 14;
        }
        byte[] dst;
        if (srcOffset < 0)
        {
          dst = (byte[]) null;
        }
        else
        {
          int count = resultFrame.UserData.Length - srcOffset;
          dst = new byte[count];
          Buffer.BlockCopy((Array) resultFrame.UserData, srcOffset, (Array) dst, 0, count);
        }
        return dst;
      }
    }

    private void CheckLicence_ReadOnly(Manufacturer_FC FC, byte? EFC, byte[] parameterBytes)
    {
      if (parameterBytes == null)
        return;
      byte? nullable1;
      int num1;
      if (FC != Manufacturer_FC.ReadMemory_0x84)
      {
        int? nullable2;
        if (FC == Manufacturer_FC.CommonRadioCommands_0x2f)
        {
          nullable1 = EFC;
          nullable2 = nullable1.HasValue ? new int?((int) nullable1.GetValueOrDefault()) : new int?();
          int num2 = 36;
          if (nullable2.GetValueOrDefault() == num2 & nullable2.HasValue)
            goto label_26;
        }
        if (FC == Manufacturer_FC.CommonMBusCommands_0x34)
        {
          nullable1 = EFC;
          nullable2 = nullable1.HasValue ? new int?((int) nullable1.GetValueOrDefault()) : new int?();
          int num3 = 1;
          if (nullable2.GetValueOrDefault() == num3 & nullable2.HasValue && parameterBytes.Length == 1)
            goto label_26;
        }
        if (FC == Manufacturer_FC.CommonMBusCommands_0x34)
        {
          nullable1 = EFC;
          nullable2 = nullable1.HasValue ? new int?((int) nullable1.GetValueOrDefault()) : new int?();
          int num4 = 2;
          if (nullable2.GetValueOrDefault() == num4 & nullable2.HasValue && parameterBytes.Length == 1)
            goto label_26;
        }
        if (FC == Manufacturer_FC.CommonMBusCommands_0x34)
        {
          nullable1 = EFC;
          nullable2 = nullable1.HasValue ? new int?((int) nullable1.GetValueOrDefault()) : new int?();
          int num5 = 3;
          if (nullable2.GetValueOrDefault() == num5 & nullable2.HasValue && parameterBytes.Length == 1)
            goto label_26;
        }
        if (FC == Manufacturer_FC.CommonMBusCommands_0x34)
        {
          nullable1 = EFC;
          nullable2 = nullable1.HasValue ? new int?((int) nullable1.GetValueOrDefault()) : new int?();
          int num6 = 4;
          if (nullable2.GetValueOrDefault() == num6 & nullable2.HasValue && parameterBytes.Length == 1)
            goto label_26;
        }
        if (FC == Manufacturer_FC.CommonMBusCommands_0x34)
        {
          nullable1 = EFC;
          nullable2 = nullable1.HasValue ? new int?((int) nullable1.GetValueOrDefault()) : new int?();
          int num7 = 5;
          if (nullable2.GetValueOrDefault() == num7 & nullable2.HasValue && parameterBytes.Length == 1)
            goto label_26;
        }
        if (FC == Manufacturer_FC.CommonMBusCommands_0x34)
        {
          nullable1 = EFC;
          nullable2 = nullable1.HasValue ? new int?((int) nullable1.GetValueOrDefault()) : new int?();
          int num8 = 16;
          if (nullable2.GetValueOrDefault() == num8 & nullable2.HasValue && parameterBytes.Length == 4)
            goto label_26;
        }
        if (FC == Manufacturer_FC.CommonMBusCommands_0x34)
        {
          nullable1 = EFC;
          nullable2 = nullable1.HasValue ? new int?((int) nullable1.GetValueOrDefault()) : new int?();
          int num9 = 17;
          if (nullable2.GetValueOrDefault() == num9 & nullable2.HasValue && parameterBytes.Length == 1)
            goto label_26;
        }
        if (FC == Manufacturer_FC.CommonMBusCommands_0x34)
        {
          nullable1 = EFC;
          nullable2 = nullable1.HasValue ? new int?((int) nullable1.GetValueOrDefault()) : new int?();
          int num10 = 19;
          if (nullable2.GetValueOrDefault() == num10 & nullable2.HasValue && parameterBytes.Length == 1)
            goto label_26;
        }
        if (FC == Manufacturer_FC.CommonMBusCommands_0x34)
        {
          nullable1 = EFC;
          nullable2 = nullable1.HasValue ? new int?((int) nullable1.GetValueOrDefault()) : new int?();
          int num11 = 21;
          if (nullable2.GetValueOrDefault() == num11 & nullable2.HasValue && parameterBytes.Length == 3)
            goto label_26;
        }
        if (FC == Manufacturer_FC.SpecialCommands_0x36)
        {
          nullable1 = EFC;
          nullable2 = nullable1.HasValue ? new int?((int) nullable1.GetValueOrDefault()) : new int?();
          int num12 = 10;
          if (nullable2.GetValueOrDefault() == num12 & nullable2.HasValue)
          {
            num1 = parameterBytes.Length == 1 ? 1 : 0;
            goto label_27;
          }
        }
        num1 = 0;
        goto label_27;
      }
label_26:
      num1 = 1;
label_27:
      if (num1 == 0 && UserManager.CheckPermission(UserManager.Right_ReadOnly))
      {
        string[] strArray = new string[5]
        {
          "Access denied! Command (FC): ",
          FC.ToString(),
          ", EFC: ",
          null,
          null
        };
        nullable1 = EFC;
        strArray[3] = nullable1.ToString();
        strArray[4] = " is not allowed on 'ReadOnly'.";
        throw new AccessDeniedException("Right\\ReadOnly", string.Concat(strArray));
      }
    }

    private string checkForNACKValue(int iCaseValue)
    {
      string str;
      switch (iCaseValue)
      {
        case 0:
          str = NACK_Messages.Unknown_function.ToString();
          break;
        case 1:
          str = NACK_Messages.Illegal_reduced_device_information.ToString();
          break;
        case 2:
          str = NACK_Messages.Illegal_request_frame_lenght.ToString();
          break;
        case 3:
          str = NACK_Messages.Parameter_error.ToString();
          break;
        case 4:
          str = NACK_Messages.Not_classified_error.ToString();
          break;
        case 5:
          str = NACK_Messages.Access_denied.ToString();
          break;
        case 6:
          str = NACK_Messages.Wrong_activation_code.ToString();
          break;
        case 7:
          str = NACK_Messages.Invalid_encryption_key.ToString();
          break;
        default:
          str = NACK_Messages.Illegal_NACK_code.ToString();
          break;
      }
      return str;
    }

    public async Task SetWriteProtectionAsync(
      byte[] key,
      ProgressHandler progress,
      CancellationToken token)
    {
      if (key.Length != 4)
        throw new ArgumentException("Wrong Keylenght was set.");
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.SetWriteProtection_0x81, key, progress, token);
    }

    public async Task OpenWriteProtectionTemporarilyAsync(
      byte[] key,
      ProgressHandler progress,
      CancellationToken token)
    {
      if (key.Length != 4 && key.Length != 8)
        throw new ArgumentException("Wrong Keylenght was set.");
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.OpenWriteProtectionTemp_0x82, key, progress, token);
    }

    public async Task SetModeAsync(byte mode, ProgressHandler progress, CancellationToken token)
    {
      byte[] data = new byte[1]{ mode };
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.GetSetMode_0x83, data, progress, token);
      data = (byte[]) null;
    }

    public async Task<byte> GetModeAsync(ProgressHandler progress, CancellationToken token)
    {
      byte[] result = await this.TransmitAndGetDataAsync(Manufacturer_FC.GetSetMode_0x83, progress, token);
      byte modeAsync = result[0];
      result = (byte[]) null;
      return modeAsync;
    }

    public async Task<byte[]> ReadMemoryAsync(
      ProgressHandler progress,
      CancellationToken token,
      uint address,
      byte count)
    {
      byte[] numArray = await Task.Run<byte[]>((Func<byte[]>) (() => this.ReadMemory(progress, token, address, count)), token);
      return numArray;
    }

    public async Task<byte[]> ReadMemoryAsync(
      ProgressHandler progress,
      CancellationToken token,
      AddressRange addressRange,
      byte maxBytesPerPacket)
    {
      if (addressRange == null)
        throw new NullReferenceException(nameof (addressRange));
      byte[] numArray = await Task.Run<byte[]>((Func<byte[]>) (() => this.ReadMemory(progress, token, addressRange.StartAddress, addressRange.ByteSize, maxBytesPerPacket)), token);
      return numArray;
    }

    public async Task<byte[]> ReadMemoryAsync(
      ProgressHandler progress,
      CancellationToken token,
      uint address,
      uint count,
      byte maxBytesPerPacket)
    {
      byte[] numArray = await Task.Run<byte[]>((Func<byte[]>) (() => this.ReadMemory(progress, token, address, count, maxBytesPerPacket)), token);
      return numArray;
    }

    public byte[] ReadMemory(
      ProgressHandler progress,
      CancellationToken token,
      uint address,
      uint count,
      byte maxBytesPerPacket)
    {
      if (count < 0U)
        throw new ArgumentOutOfRangeException(nameof (count));
      int subParts = maxBytesPerPacket >= (byte) 0 ? Convert.ToInt32(count / (uint) maxBytesPerPacket) : throw new ArgumentOutOfRangeException(nameof (maxBytesPerPacket));
      if (subParts <= 1 && count <= (uint) maxBytesPerPacket)
        return this.ReadMemory(progress, token, address, (byte) count);
      byte num = (byte) (count % (uint) maxBytesPerPacket);
      if (num > (byte) 0)
        ++subParts;
      List<byte> byteList = new List<byte>((int) count);
      uint address1 = address;
      byte count1 = maxBytesPerPacket;
      if (progress != null)
      {
        progress.Split(new double[2]{ 10.0, 90.0 });
        progress.Split(subParts);
        progress.Report("Read: 0x" + address.ToString("X4") + " " + byteList.Count.ToString() + " byte(s)");
      }
      for (int index = 1; index <= subParts; ++index)
      {
        if (index > 1)
          address1 += (uint) count1;
        count1 = (long) (index * (int) maxBytesPerPacket) >= (long) count ? (num > (byte) 0 ? num : maxBytesPerPacket) : maxBytesPerPacket;
        byte[] collection = this.ReadMemory(progress, token, address1, count1);
        byteList.AddRange((IEnumerable<byte>) collection);
      }
      return byteList.ToArray();
    }

    internal byte[] ReadMemory(
      ProgressHandler progress,
      CancellationToken token,
      uint address,
      byte count)
    {
      if (count <= (byte) 0)
        throw new ArgumentOutOfRangeException(nameof (count));
      token.ThrowIfCancellationRequested();
      List<byte> byteList = new List<byte>();
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(address));
      byteList.Add(count);
      byte[] data = this.TransmitAndGetData(Manufacturer_FC.ReadMemory_0x84, new byte?(), byteList.ToArray(), false, progress, token);
      if (data.Length != (int) count)
        throw new Exception("Invalid response by read the memory! Expected: " + count.ToString() + " bytes but receive: " + data.Length.ToString() + " byte(s)");
      return data;
    }

    public async Task WriteMemoryAsync(
      ProgressHandler progress,
      CancellationToken token,
      uint address,
      byte[] buffer)
    {
      await Task.Run((Action) (() => this.WriteMemory(progress, token, address, buffer)), token);
    }

    public async Task WriteMemoryAsync(
      ProgressHandler progress,
      CancellationToken token,
      AddressRange addressRange,
      byte[] buffer,
      byte maxBytesPerPacket)
    {
      if (addressRange == null)
        throw new NullReferenceException(nameof (addressRange));
      await Task.Run((Action) (() => this.WriteMemory(progress, token, addressRange.StartAddress, buffer, maxBytesPerPacket)), token);
    }

    public async Task WriteMemoryAsync(
      ProgressHandler progress,
      CancellationToken token,
      uint address,
      byte[] buffer,
      byte maxBytesPerPacket)
    {
      await Task.Run((Action) (() => this.WriteMemory(progress, token, address, buffer, maxBytesPerPacket)), token);
    }

    private void WriteMemory(
      ProgressHandler progress,
      CancellationToken token,
      uint address,
      byte[] buffer,
      byte maxBytesPerPacket)
    {
      if (buffer == null || buffer.Length == 0)
        throw new ArgumentException(nameof (buffer));
      if (maxBytesPerPacket < (byte) 0)
        throw new ArgumentOutOfRangeException(nameof (maxBytesPerPacket));
      int int32 = Convert.ToInt32(buffer.Length / (int) maxBytesPerPacket);
      if (int32 <= 1 && buffer.Length <= (int) maxBytesPerPacket)
      {
        this.WriteMemory(progress, token, address, buffer);
      }
      else
      {
        byte num = (byte) ((uint) buffer.Length % (uint) maxBytesPerPacket);
        if (num > (byte) 0)
          ++int32;
        uint address1 = address;
        byte length = maxBytesPerPacket;
        int srcOffset = 0;
        progress.Split(int32 * 2 + 1);
        for (int index = 1; index <= int32; ++index)
        {
          if (index > 1)
            address1 += (uint) length;
          length = index * (int) maxBytesPerPacket >= buffer.Length ? (num > (byte) 0 ? num : maxBytesPerPacket) : maxBytesPerPacket;
          byte[] numArray = new byte[(int) length];
          Buffer.BlockCopy((Array) buffer, srcOffset, (Array) numArray, 0, numArray.Length);
          this.WriteMemory(progress, token, address1, numArray);
          srcOffset += numArray.Length;
        }
        if (srcOffset != buffer.Length)
          throw new Exception("Write memory failed! Written number of bytes is incorrect. Expected: " + buffer.Length.ToString() + ", Actual: " + srcOffset.ToString());
      }
    }

    public void WriteMemory(
      ProgressHandler progress,
      CancellationToken token,
      uint address,
      byte[] buffer)
    {
      if (address == 0U)
        throw new ArgumentException(nameof (address));
      if (buffer == null)
        throw new ArgumentNullException(nameof (buffer));
      token.ThrowIfCancellationRequested();
      progress?.Split(new double[2]{ 10.0, 90.0 });
      List<byte> byteList = new List<byte>();
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(address));
      byteList.AddRange((IEnumerable<byte>) buffer);
      this.TransmitAndCheckAck(Manufacturer_FC.WriteMemory_0x85, new byte?(), byteList.ToArray(), progress, token);
    }

    public async Task BackupDeviceAsync(ProgressHandler progress, CancellationToken token)
    {
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.RunBackup_0x86, progress, token);
    }

    public async Task ResetDeviceAsync(ProgressHandler progress, CancellationToken token)
    {
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.ResetDevice_0x80, progress, token);
      ConfigList cfg = this.DeviceCMD.MBus.Repeater.Port.GetReadoutConfiguration();
      if (cfg.Baudrate != 9600)
      {
        cfg = (ConfigList) null;
      }
      else
      {
        await Task.Delay(2500, token);
        this.DeviceCMD.MBus.Repeater.Port.DiscardInBuffer();
        this.DeviceCMD.MBus.Repeater.Port.ForceWakeup();
        cfg = (ConfigList) null;
      }
    }

    public void ResetDevice(ProgressHandler progress, CancellationToken token)
    {
      this.TransmitAndCheckAck(Manufacturer_FC.ResetDevice_0x80, new byte?(), (byte[]) null, progress, token);
      Thread.Sleep(2500);
      if (this.DeviceCMD.MBus.Repeater.Port.GetReadoutConfiguration().Baudrate != 9600)
        return;
      this.DeviceCMD.MBus.Repeater.Port.DiscardInBuffer();
      this.DeviceCMD.MBus.Repeater.Port.ForceWakeup();
    }

    public async Task SetSystemTimeAsync(
      byte year,
      byte month,
      byte day,
      byte hour,
      byte min,
      byte sec,
      sbyte tz,
      ProgressHandler progress,
      CancellationToken token)
    {
      Common32BitCommands.SystemTime sysTime = new Common32BitCommands.SystemTime();
      sysTime.Year = year;
      sysTime.Month = month;
      sysTime.Day = day;
      sysTime.Hour = hour;
      sysTime.Min = min;
      sysTime.Sec = sec;
      sysTime.TimeZone = tz;
      await this.SetSystemTimeAsync(sysTime, progress, token);
      sysTime = (Common32BitCommands.SystemTime) null;
    }

    public async Task SetSystemTimeAsync(
      Common32BitCommands.SystemTime sysTime,
      ProgressHandler progress,
      CancellationToken token)
    {
      List<byte> myCommand = new List<byte>();
      myCommand.Add(sysTime.Year);
      myCommand.Add(sysTime.Month);
      myCommand.Add(sysTime.Day);
      myCommand.Add(sysTime.Hour);
      myCommand.Add(sysTime.Min);
      myCommand.Add(sysTime.Sec);
      myCommand.Add((byte) ((uint) sysTime.TimeZone * 4U));
      byte[] data = myCommand.ToArray();
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.GetSetSystemTime_0x87, data, progress, token);
      myCommand = (List<byte>) null;
      data = (byte[]) null;
    }

    public async Task<Common32BitCommands.SystemTime> GetSystemTimeAsync(
      ProgressHandler progress,
      CancellationToken token)
    {
      byte[] result = await this.TransmitAndGetDataAsync(Manufacturer_FC.GetSetSystemTime_0x87, progress, token);
      Common32BitCommands.SystemTime sysTime = new Common32BitCommands.SystemTime();
      sysTime.Year = result[0];
      sysTime.Month = result[1];
      sysTime.Day = result[2];
      sysTime.Hour = result[3];
      sysTime.Min = result[4];
      sysTime.Sec = result[5];
      sysTime.TimeZone = (sbyte) ((int) result[6] / 4);
      sysTime.basedata = result;
      Common32BitCommands.SystemTime systemTimeAsync = sysTime;
      result = (byte[]) null;
      sysTime = (Common32BitCommands.SystemTime) null;
      return systemTimeAsync;
    }

    public async Task SetKeyDateAsync(
      byte month,
      byte dayOfMonth,
      ProgressHandler progress,
      CancellationToken token)
    {
      Common32BitCommands.KeyDate kDate = new Common32BitCommands.KeyDate();
      kDate.Month = month;
      kDate.DayOfMonth = dayOfMonth;
      kDate.FirstYear = byte.MaxValue;
      await this.SetKeyDateAsync(kDate, progress, token);
      kDate = (Common32BitCommands.KeyDate) null;
    }

    public async Task SetKeyDateAsync(
      Common32BitCommands.KeyDate kDate,
      ProgressHandler progress,
      CancellationToken token)
    {
      List<byte> myCommand = new List<byte>();
      myCommand.Add(kDate.Month);
      myCommand.Add(kDate.DayOfMonth);
      myCommand.Add(kDate.FirstYear);
      byte[] data = myCommand.ToArray();
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.GetSetKeyDate_0x88, data, progress, token);
      myCommand = (List<byte>) null;
      data = (byte[]) null;
    }

    public async Task<Common32BitCommands.KeyDate> GetKeyDateAsync(
      ProgressHandler progress,
      CancellationToken token)
    {
      byte[] result = await this.TransmitAndGetDataAsync(Manufacturer_FC.GetSetKeyDate_0x88, progress, token);
      Common32BitCommands.KeyDate kDate = new Common32BitCommands.KeyDate();
      if (result.Length == 3 || result.Length == 2)
      {
        kDate.Month = result[0];
        kDate.DayOfMonth = result[1];
        if (result.Length == 3)
          kDate.FirstYear = result[2];
        kDate.basedata = result;
      }
      else
      {
        kDate.Month = (byte) 0;
        kDate.DayOfMonth = (byte) 0;
        kDate.FirstYear = (byte) 0;
      }
      Common32BitCommands.KeyDate keyDateAsync = kDate;
      result = (byte[]) null;
      kDate = (Common32BitCommands.KeyDate) null;
      return keyDateAsync;
    }

    public async Task SetRadioOperationAsync(
      byte state,
      ProgressHandler progress,
      CancellationToken token)
    {
      byte[] data = new byte[1]{ state };
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.GetSetRadioOperation_0x89, data, progress, token);
      data = (byte[]) null;
    }

    public async Task<byte> GetRadioOperationAsync(
      ProgressHandler progress,
      CancellationToken token)
    {
      byte[] result = await this.TransmitAndGetDataAsync(Manufacturer_FC.GetSetRadioOperation_0x89, progress, token);
      byte radioOperationAsync = result[0];
      result = (byte[]) null;
      return radioOperationAsync;
    }

    public bool GetRadioOperation(ProgressHandler progress, CancellationToken token)
    {
      return BitConverter.ToBoolean(this.TransmitAndGetData(Manufacturer_FC.GetSetRadioOperation_0x89, new byte?(), (byte[]) null, false, progress, token), 0);
    }

    public async Task ClearResetCounterAsync(ProgressHandler progress, CancellationToken token)
    {
      byte[] data = new byte[1];
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.ClearGetResetCounter_0x8a, data, progress, token);
      data = (byte[]) null;
    }

    public async Task<byte> GetResetCounterAsync(ProgressHandler progress, CancellationToken token)
    {
      byte[] result = await this.TransmitAndGetDataAsync(Manufacturer_FC.ClearGetResetCounter_0x8a, progress, token);
      byte resetCounterAsync = result[0];
      result = (byte[]) null;
      return resetCounterAsync;
    }

    public async Task SetLcdTestStateAsync(
      byte testState,
      byte[] ramData,
      ProgressHandler progress,
      CancellationToken token)
    {
      int ramSize = ramData != null ? ramData.Length : 0;
      int size = ramSize + 1;
      byte[] data = new byte[size];
      data[0] = testState;
      if (testState == byte.MaxValue)
        Buffer.BlockCopy((Array) ramData, 0, (Array) data, 1, ramData.Length);
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.SetLcdTestState_0x8b, data, progress, token);
      data = (byte[]) null;
    }

    public async Task SwitchLoRaLEDAsync(
      byte state,
      ProgressHandler progress,
      CancellationToken token)
    {
      byte[] data = new byte[1]{ state };
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.SwitchLoRaLED_0x8c, data, progress, token);
      data = (byte[]) null;
    }

    public async Task ActivateDeactivateDisplayAsync(
      byte state,
      ProgressHandler progress,
      CancellationToken token)
    {
      byte[] data = new byte[1]{ state };
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.ActivateDeactivateDisplay_0x8d, data, progress, token);
      data = (byte[]) null;
    }

    public async Task TimeShiftAsync(
      byte[] data,
      ProgressHandler progress,
      CancellationToken token)
    {
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.TimeShift_0x8e, data, progress, token);
    }

    public async Task ExecuteEventAsync(
      byte eventNumber,
      ProgressHandler progress,
      CancellationToken token)
    {
      byte[] data = new byte[1]{ eventNumber };
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.ExecuteEvent_0x8f, data, progress, token);
      data = (byte[]) null;
    }

    public async Task SetRTC_Calibration(
      short calibrationClocks,
      ProgressHandler progress,
      CancellationToken token)
    {
      byte[] data = new byte[2];
      data = BitConverter.GetBytes(calibrationClocks);
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.SetRTCCalibration_0x90, data, progress, token);
      data = (byte[]) null;
    }

    public async Task<Common32BitCommands.Scenarios> GetCommunicationScenarioAsync(
      ProgressHandler progress,
      CancellationToken token)
    {
      Common32BitCommands.Common32BitCommands_Logger.Trace(nameof (GetCommunicationScenarioAsync));
      byte[] result = await this.TransmitAndGetDataAsync(Manufacturer_FC.GetCommunicationScenario_0x91, progress, token);
      Common32BitCommands.Scenarios scenarios = new Common32BitCommands.Scenarios();
      byte[] dataONE = new byte[2]{ result[1], result[0] };
      if (result.Length == 2)
      {
        scenarios.ScenarioOne = new ushort?(Convert.ToUInt16(ZENNER.CommonLibrary.Utility.ByteArrayToHexString(dataONE), 16));
        scenarios.basedata = dataONE;
      }
      if (result.Length == 4)
      {
        dataONE = new byte[2]{ result[1], result[0] };
        scenarios.ScenarioOne = new ushort?(Convert.ToUInt16(ZENNER.CommonLibrary.Utility.ByteArrayToHexString(dataONE), 16));
        byte[] dataTWO = new byte[2]{ result[3], result[2] };
        scenarios.ScenarioTwo = new ushort?(Convert.ToUInt16(ZENNER.CommonLibrary.Utility.ByteArrayToHexString(dataTWO), 16));
        scenarios.basedata = new byte[4]
        {
          result[1],
          result[0],
          result[3],
          result[2]
        };
        dataTWO = (byte[]) null;
      }
      Common32BitCommands.Scenarios communicationScenarioAsync = scenarios;
      result = (byte[]) null;
      scenarios = (Common32BitCommands.Scenarios) null;
      dataONE = (byte[]) null;
      return communicationScenarioAsync;
    }

    public Common32BitCommands.Scenarios GetCommunicationScenario(
      ProgressHandler progress,
      CancellationToken token)
    {
      Common32BitCommands.Common32BitCommands_Logger.Trace(nameof (GetCommunicationScenario));
      byte[] data = this.TransmitAndGetData(Manufacturer_FC.GetCommunicationScenario_0x91, new byte?(), (byte[]) null, false, progress, token);
      Common32BitCommands.Scenarios communicationScenario = new Common32BitCommands.Scenarios();
      communicationScenario.basedata = data;
      communicationScenario.ScenarioOne = new ushort?(BitConverter.ToUInt16(data, 0));
      if (data.Length == 4)
        communicationScenario.ScenarioTwo = new ushort?(BitConverter.ToUInt16(data, 2));
      return communicationScenario;
    }

    public async Task SetCommunicationScenarioAsync(
      byte[] scenario,
      ProgressHandler progress,
      CancellationToken token)
    {
      Common32BitCommands.Common32BitCommands_Logger.Trace(nameof (SetCommunicationScenarioAsync));
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.SetCommunicationScenario_0x92, scenario, progress, token);
    }

    public async Task<string> GetPrintedSerialNumberAsync(
      ProgressHandler progress,
      CancellationToken token)
    {
      Common32BitCommands.Common32BitCommands_Logger.Trace(nameof (GetPrintedSerialNumberAsync));
      byte[] result = await this.TransmitAndGetDataAsync(Manufacturer_FC.GetPrintedSerialNumber_0x93, progress, token);
      if (result.Length < 1 || result[result.Length - 1] > (byte) 0)
        throw new Exception("Illegal GetPrintedSerialNumber result");
      if (result.Length == 1)
        return string.Empty;
      return ZENNER.CommonLibrary.Utility.ZeroTerminatedAsciiStringToString(result) ?? throw new Exception("Illegal PrintedSerialNumber found");
    }

    public async Task SetLocalInterfaceEncryptionAsync(
      byte[] data,
      ProgressHandler progress,
      CancellationToken token)
    {
      Common32BitCommands.Common32BitCommands_Logger.Trace(nameof (SetLocalInterfaceEncryptionAsync));
      await this.TransmitAndCheckAckAsync(Manufacturer_FC.GetLocalInterfaceEncryption_0x94, data, progress, token);
    }

    public async Task<byte[]> GetLocalInterfaceEncryptionAsync(
      ProgressHandler progress,
      CancellationToken token)
    {
      Common32BitCommands.Common32BitCommands_Logger.Trace(nameof (GetLocalInterfaceEncryptionAsync));
      byte[] result = await this.TransmitAndGetDataAsync(Manufacturer_FC.GetLocalInterfaceEncryption_0x94, progress, token);
      byte[] interfaceEncryptionAsync = result.Length >= 1 && result.Length <= 3 ? result : throw new Exception("Illegal GetLocalInterfaceEncryption result");
      result = (byte[]) null;
      return interfaceEncryptionAsync;
    }

    public class SystemTime : ReturnValue
    {
      public byte Year { get; set; }

      public byte Month { get; set; }

      public byte Day { get; set; }

      public byte Hour { get; set; }

      public byte Min { get; set; }

      public byte Sec { get; set; }

      public sbyte TimeZone { get; set; }

      public override string ToString()
      {
        return Convert.ToString((int) Convert.ToInt16(this.Year) + 2000) + "-" + Convert.ToInt16(this.Month).ToString("D2") + "-" + Convert.ToInt16(this.Day).ToString("D2") + " " + Convert.ToInt16(this.Hour).ToString("D2") + ":" + Convert.ToInt16(this.Min).ToString("D2") + ":" + Convert.ToInt16(this.Sec).ToString("D2") + " " + Convert.ToInt16(this.TimeZone).ToString("D2");
      }

      public SystemTime(DateTime dateTime, sbyte timezone)
      {
        this.Year = (byte) (dateTime.Year - 2000);
        this.Month = (byte) dateTime.Month;
        this.Day = (byte) dateTime.Day;
        this.Hour = (byte) dateTime.Hour;
        this.Min = (byte) dateTime.Minute;
        this.Sec = (byte) dateTime.Second;
        this.TimeZone = timezone;
      }

      public SystemTime()
      {
      }

      public DateTime GetAsDateTime()
      {
        return new DateTime((int) this.Year, (int) this.Month, (int) this.Day, (int) this.Hour, (int) this.Min, (int) this.Sec);
      }
    }

    public class KeyDate : ReturnValue
    {
      public byte Month { get; set; }

      public byte DayOfMonth { get; set; }

      public byte FirstYear { get; set; }
    }

    public class Scenarios : ReturnValue
    {
      public ushort? ScenarioOne { get; set; }

      public ushort? ScenarioTwo { get; set; }

      public Scenarios()
      {
        this.ScenarioOne = new ushort?();
        this.ScenarioTwo = new ushort?();
      }
    }
  }
}


--- CommonLoRaCommands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CommonLoRaCommands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using MBusLib;
using NLog;
using System;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class CommonLoRaCommands : IZRCommand
  {
    internal static Logger CommonLoRaCommands_Logger = LogManager.GetLogger(nameof (CommonLoRaCommands));
    private Common32BitCommands commonCMD;
    private bool crypt = false;
    private string AESKey = (string) null;

    public bool enDeCrypt
    {
      get => this.crypt;
      set
      {
        this.crypt = value;
        if (this.commonCMD == null)
          return;
        this.commonCMD.enDeCrypt = value;
      }
    }

    public string AES_Key
    {
      get => this.AESKey;
      set
      {
        this.AESKey = value;
        if (this.commonCMD == null)
          return;
        this.commonCMD.AES_Key = value;
      }
    }

    public CommonLoRaCommands(Common32BitCommands commonCMD)
    {
      this.commonCMD = commonCMD;
      this.setCryptValuesFromBaseClass();
    }

    public void setCryptValuesFromBaseClass()
    {
      this.enDeCrypt = this.commonCMD.enDeCrypt;
      this.AES_Key = this.commonCMD.AES_Key;
    }

    public async Task<LoRaFcVersion> GetLoRaFC_VersionAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte FC = 53;
      byte EFC = 0;
      byte[] resultData = await this.commonCMD.TransmitAndReceiveVersionData(FC, EFC, progress, cancelToken);
      if (resultData.Length != 4)
        throw new Exception("Illegal result length by GetLoRaVersionAsync");
      if ((int) resultData[0] != (int) FC || (int) resultData[1] != (int) EFC)
        throw new Exception("Illegal FC,EFC by GetLoRaVersionAsync");
      LoRaFcVersion retVal = new LoRaFcVersion();
      retVal.Version = BitConverter.ToUInt16(resultData, 2);
      retVal.basedata = resultData;
      LoRaFcVersion raFcVersionAsync = retVal;
      resultData = (byte[]) null;
      retVal = (LoRaFcVersion) null;
      return raFcVersionAsync;
    }

    public LoRaFcVersion GetLoRaFC_Version(ProgressHandler progress, CancellationToken cancelToken)
    {
      byte[] data = this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetLoRaFC_Version_0x00, progress, cancelToken);
      if (data.Length != 2)
        throw new Exception("Illegal result length by GetLoRaVersion");
      LoRaFcVersion loRaFcVersion = new LoRaFcVersion();
      loRaFcVersion.Version = BitConverter.ToUInt16(data, 0);
      loRaFcVersion.basedata = data;
      return loRaFcVersion;
    }

    public async Task<LoRaWANVersion> GetLoRaWAN_VersionAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte FC = 53;
      byte EFC = 1;
      byte[] resultData = await this.commonCMD.TransmitAndReceiveVersionData(FC, EFC, progress, cancelToken);
      if (resultData.Length != 5)
        throw new Exception("Illegal result length by GetLoRaWANVersionAsync");
      if ((int) resultData[0] != (int) FC || (int) resultData[1] != (int) EFC)
        throw new Exception("Illegal FC,EFC by GetLoRaWANVersionAsync");
      LoRaWANVersion retVal = new LoRaWANVersion();
      retVal.MainVersion = resultData[2];
      retVal.MinorVersion = resultData[3];
      retVal.ReleaseNr = resultData[4];
      retVal.basedata = resultData;
      LoRaWANVersion raWanVersionAsync = retVal;
      resultData = (byte[]) null;
      retVal = (LoRaWANVersion) null;
      return raWanVersionAsync;
    }

    public LoRaWANVersion GetLoRaWAN_Version(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] data = this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetLoRaWAN_Version_0x01, progress, cancelToken);
      if (data.Length != 3)
        throw new Exception("Illegal result length by GetLoRaWANVersion");
      LoRaWANVersion loRaWanVersion = new LoRaWANVersion();
      loRaWanVersion.MainVersion = data[0];
      loRaWanVersion.MinorVersion = data[1];
      loRaWanVersion.ReleaseNr = data[2];
      loRaWanVersion.basedata = data;
      return loRaWanVersion;
    }

    public async Task SendJoinRequestAsync(ProgressHandler progress, CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.SendJoinRequest_0x06, progress, cancelToken);
    }

    public async Task<LoRaCheckJoinAccept> CheckJoinAcceptAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.CheckJoinAccept_0x07, progress, cancelToken);
      LoRaCheckJoinAccept retVal = new LoRaCheckJoinAccept();
      DateTime? localDateTime = new DateTime?();
      localDateTime = MBusUtil.ConvertToDateTime_MBus_CP32_TypeF(theData);
      retVal.Timestamp = localDateTime.HasValue ? localDateTime.Value : DateTime.MinValue;
      Buffer.BlockCopy((Array) theData, 4, (Array) (retVal.NetID = new byte[3]), 0, 3);
      retVal.DeviceAddress = BitConverter.ToUInt32(theData, 7);
      retVal.basedata = theData;
      LoRaCheckJoinAccept raCheckJoinAccept = retVal;
      theData = (byte[]) null;
      retVal = (LoRaCheckJoinAccept) null;
      return raCheckJoinAccept;
    }

    public async Task SendUnconfirmedDataAsync(
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int maxBytes = 50;
      int dataBytes = data.Length > maxBytes ? maxBytes : data.Length;
      byte[] ba = new byte[dataBytes];
      Buffer.BlockCopy((Array) data, 0, (Array) ba, 0, dataBytes);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.SendUnconfirmedData_0x08, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task SendConfirmedDataAsync(
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int maxBytes = 50;
      int dataBytes = data.Length > maxBytes ? maxBytes : data.Length;
      byte[] ba = new byte[dataBytes];
      Buffer.BlockCopy((Array) data, 0, (Array) ba, 0, dataBytes);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.SendConfirmedData_0x09, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task SetNetIDAsync(
      byte[] id,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetNetID_0x20, id, progress, cancelToken);
    }

    public async Task<byte[]> GetNetIDAsync(ProgressHandler progress, CancellationToken cancelToken)
    {
      CommonLoRaCommands.CommonLoRaCommands_Logger.Trace(nameof (GetNetIDAsync));
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetNetID_0x20, progress, cancelToken);
      byte[] netIdAsync = theData;
      theData = (byte[]) null;
      return netIdAsync;
    }

    public async Task SetAppEUIAsync(
      byte[] appEUI,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int maxBytes = 8;
      byte[] ba = new byte[maxBytes];
      Buffer.BlockCopy((Array) appEUI, 0, (Array) ba, 0, appEUI.Length > maxBytes ? maxBytes : appEUI.Length);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetAppEUI_0x21, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task<byte[]> GetAppEUIAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      CommonLoRaCommands.CommonLoRaCommands_Logger.Trace(nameof (GetAppEUIAsync));
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetAppEUI_0x21, progress, cancelToken);
      byte[] appEuiAsync = theData;
      theData = (byte[]) null;
      return appEuiAsync;
    }

    public byte[] GetAppEUI(ProgressHandler progress, CancellationToken cancelToken)
    {
      return this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetAppEUI_0x21, progress, cancelToken);
    }

    public async Task SetNwkSKeyAsync(
      byte[] nwkSKey,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int maxBytes = 16;
      byte[] ba = new byte[maxBytes];
      Buffer.BlockCopy((Array) nwkSKey, 0, (Array) ba, 0, nwkSKey.Length > maxBytes ? maxBytes : nwkSKey.Length);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetNwkSKey_0x22, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task<byte[]> GetNwkSKeyAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      CommonLoRaCommands.CommonLoRaCommands_Logger.Trace(nameof (GetNwkSKeyAsync));
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetNwkSKey_0x22, progress, cancelToken);
      byte[] nwkSkeyAsync = theData;
      theData = (byte[]) null;
      return nwkSkeyAsync;
    }

    public byte[] GetNwkSKey(ProgressHandler progress, CancellationToken cancelToken)
    {
      return this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetNwkSKey_0x22, progress, cancelToken);
    }

    public async Task SetAppSKeyAsync(
      byte[] appSKey,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int maxBytes = 16;
      byte[] ba = new byte[maxBytes];
      Buffer.BlockCopy((Array) appSKey, 0, (Array) ba, 0, appSKey.Length > maxBytes ? maxBytes : appSKey.Length);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetAppSKey_0x23, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task<byte[]> GetAppSKeyAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      CommonLoRaCommands.CommonLoRaCommands_Logger.Trace(nameof (GetAppSKeyAsync));
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetAppSKey_0x23, progress, cancelToken);
      byte[] appSkeyAsync = theData;
      theData = (byte[]) null;
      return appSkeyAsync;
    }

    public byte[] GetAppSKey(ProgressHandler progress, CancellationToken cancelToken)
    {
      return this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetAppSKey_0x23, progress, cancelToken);
    }

    public async Task SetOTAA_ABPAsync(
      OTAA_ABP flag,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[1]{ (byte) flag };
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetOTAA_ABP_0x24, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task<OTAA_ABP> GetOTAA_ABPAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetOTAA_ABP_0x24, progress, cancelToken);
      OTAA_ABP otaaAbpAsync = (OTAA_ABP) theData[0];
      theData = (byte[]) null;
      return otaaAbpAsync;
    }

    public OTAA_ABP GetOTAA_ABP(ProgressHandler progress, CancellationToken cancelToken)
    {
      return (OTAA_ABP) this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetOTAA_ABP_0x24, progress, cancelToken)[0];
    }

    public async Task SetDevEUIAsync(
      byte[] devEUI,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (devEUI == null || devEUI.Length != 8)
        throw new Exception("SetDevEUIAsync: illegal devEUI");
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetDevEUI_0x25, devEUI, progress, cancelToken);
    }

    public async Task<byte[]> GetDevEUIAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      CommonLoRaCommands.CommonLoRaCommands_Logger.Trace(nameof (GetDevEUIAsync));
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetDevEUI_0x25, progress, cancelToken);
      byte[] devEuiAsync = theData;
      theData = (byte[]) null;
      return devEuiAsync;
    }

    public byte[] GetDevEUI(ProgressHandler progress, CancellationToken cancelToken)
    {
      return this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetDevEUI_0x25, progress, cancelToken);
    }

    public async Task SetDevAddrAsync(
      byte[] devAddr,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (devAddr == null || devAddr.Length != 4)
        throw new Exception("SetDevAddrAsync: illegal device address");
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetDevAddr_0x27, devAddr, progress, cancelToken);
    }

    public async Task<byte[]> GetDevAddrAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      CommonLoRaCommands.CommonLoRaCommands_Logger.Trace(nameof (GetDevAddrAsync));
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetDevAddr_0x27, progress, cancelToken);
      byte[] devAddrAsync = theData;
      theData = (byte[]) null;
      return devAddrAsync;
    }

    public async Task SetAppKeyAsync(
      byte[] appKey,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (appKey == null || appKey.Length != 16)
        throw new Exception("SetAppKeyAsync: illegal appKey");
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetAppKey_0x26, appKey, progress, cancelToken);
    }

    public async Task<byte[]> GetAppKeyAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      CommonLoRaCommands.CommonLoRaCommands_Logger.Trace(nameof (GetAppKeyAsync));
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetAppKey_0x26, progress, cancelToken);
      byte[] appKeyAsync = theData;
      theData = (byte[]) null;
      return appKeyAsync;
    }

    public byte[] GetAppKey(ProgressHandler progress, CancellationToken cancelToken)
    {
      return this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetAppKey_0x26, progress, cancelToken);
    }

    public async Task SetTransmissionScenarioAsync(
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (data == null || data.Length > 1)
        throw new Exception("SetTransmissionScenarioAsync: illegal data lenght");
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetTransmissionScenario_0x28, data, progress, cancelToken);
    }

    public async Task<byte> GetTransmissionScenarioAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetTransmissionScenario_0x28, progress, cancelToken);
      byte transmissionScenarioAsync = theData[0];
      theData = (byte[]) null;
      return transmissionScenarioAsync;
    }

    public byte GetTransmissionScenario(ProgressHandler progress, CancellationToken cancelToken)
    {
      return this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetTransmissionScenario_0x28, progress, cancelToken)[0];
    }

    public async Task<byte> GetAdrAsync(ProgressHandler progress, CancellationToken cancelToken)
    {
      CommonLoRaCommands.CommonLoRaCommands_Logger.Trace(nameof (GetAdrAsync));
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetADR_0x2A, progress, cancelToken);
      byte adrAsync = theData[0];
      theData = (byte[]) null;
      return adrAsync;
    }

    public async Task SetAdrAsync(
      byte ADR,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] data = new byte[1]{ ADR };
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetADR_0x2A, data, progress, cancelToken);
      data = (byte[]) null;
    }

    public byte GetAdr(ProgressHandler progress, CancellationToken cancelToken)
    {
      return this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.GetSetADR_0x2A, progress, cancelToken)[0];
    }

    public async Task SendConfigurationPaketAsync(
      byte[] PacketType,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.SendConfigurationPacket_0x29, PacketType, progress, cancelToken);
    }

    public async Task TriggerSystemDiagnosticAsync(
      LoRaSystemDiagnostic lsd,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int maxBytes = 3;
      byte[] ba = new byte[maxBytes];
      ba[0] = lsd.DiagnosticConfig;
      ba[1] = lsd.DailyStartTime;
      ba[2] = lsd.DailyEndTime;
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.TriggerSystemDiagnostic_0x2B, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task<LoRaSystemDiagnostic> SystemDiagnosticStateAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      bool test = false)
    {
      if (test)
        return new LoRaSystemDiagnostic()
        {
          DiagnosticConfig = 83,
          DailyStartTime = 40,
          DailyEndTime = 133,
          RemainigActivity = 33,
          RemainigDiagnostic = 8704
        };
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonLoRaCommands_0x35, CommonLoRaCommands_EFC.TriggerSystemDiagnostic_0x2B, progress, cancelToken);
      LoRaSystemDiagnostic lsd = new LoRaSystemDiagnostic();
      lsd.basedata = theData;
      if (theData.Length == 9)
      {
        lsd.DiagnosticConfig = theData[0];
        lsd.DailyStartTime = theData[1];
        lsd.DailyEndTime = theData[2];
        lsd.RemainigActivity = BitConverter.ToUInt16(theData, 3);
        lsd.RemainigDiagnostic = BitConverter.ToUInt32(theData, 5);
      }
      else
      {
        lsd.DiagnosticConfig = (byte) 0;
        lsd.DailyStartTime = (byte) 0;
        lsd.DailyEndTime = (byte) 0;
        lsd.RemainigActivity = (ushort) 0;
        lsd.RemainigDiagnostic = 0U;
      }
      return lsd;
    }
  }
}


--- CommonLoRaCommands_EFC.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CommonLoRaCommands_EFC
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum CommonLoRaCommands_EFC : byte
  {
    GetLoRaFC_Version_0x00 = 0,
    GetLoRaWAN_Version_0x01 = 1,
    SendJoinRequest_0x06 = 6,
    CheckJoinAccept_0x07 = 7,
    SendUnconfirmedData_0x08 = 8,
    SendConfirmedData_0x09 = 9,
    GetSetNetID_0x20 = 32, // 0x20
    GetSetAppEUI_0x21 = 33, // 0x21
    GetSetNwkSKey_0x22 = 34, // 0x22
    GetSetAppSKey_0x23 = 35, // 0x23
    GetSetOTAA_ABP_0x24 = 36, // 0x24
    GetSetDevEUI_0x25 = 37, // 0x25
    GetSetAppKey_0x26 = 38, // 0x26
    GetSetDevAddr_0x27 = 39, // 0x27
    GetSetTransmissionScenario_0x28 = 40, // 0x28
    SendConfigurationPacket_0x29 = 41, // 0x29
    GetSetADR_0x2A = 42, // 0x2A
    SystemDiagnosticState_0x2B = 43, // 0x2B
    TriggerSystemDiagnostic_0x2B = 43, // 0x2B
  }
}


--- CommonMBusCommands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CommonMBusCommands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using MBusLib;
using System;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public sealed class CommonMBusCommands : IZRCommand
  {
    private Common32BitCommands commonCMD;
    private bool crypt = false;
    private string AESKey = (string) null;

    public bool enDeCrypt
    {
      get => this.crypt;
      set
      {
        this.crypt = value;
        if (this.commonCMD == null)
          return;
        this.commonCMD.enDeCrypt = value;
      }
    }

    public string AES_Key
    {
      get => this.AESKey;
      set
      {
        this.AESKey = value;
        if (this.commonCMD == null)
          return;
        this.commonCMD.AES_Key = value;
      }
    }

    public CommonMBusCommands(Common32BitCommands commonCMD)
    {
      this.commonCMD = commonCMD;
      this.setCryptValuesFromBaseClass();
    }

    public void setCryptValuesFromBaseClass()
    {
      this.enDeCrypt = this.commonCMD.enDeCrypt;
      this.AES_Key = this.commonCMD.AES_Key;
    }

    public async Task<MBusChannelAddress> GetMBusChannelAddressAsync(
      byte channel,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetMBusChannelAddress_0x01, new byte[1]
      {
        channel
      }, progress, cancelToken);
      MBusChannelAddress retVal = new MBusChannelAddress();
      retVal.Channel = theData[0];
      retVal.Address = theData[1];
      MBusChannelAddress channelAddressAsync = retVal;
      theData = (byte[]) null;
      retVal = (MBusChannelAddress) null;
      return channelAddressAsync;
    }

    public async Task SetMBusChannelAddressAsync(
      byte channel,
      byte address,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[2]{ channel, address };
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetMBusChannelAddress_0x01, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task<MBusChannelIdentification> GetChannelIdentificationAsync(
      byte channel,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[1]{ channel };
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetChannelIdentification_0x02, ba, progress, cancelToken);
      MBusChannelIdentification retVal = new MBusChannelIdentification();
      retVal.Channel = theData[0];
      byte[] baTemp = new byte[4];
      Buffer.BlockCopy((Array) theData, 1, (Array) baTemp, 0, 4);
      retVal.SerialNumber = (long) Util.ConvertBcdUInt32ToUInt32(BitConverter.ToUInt32(baTemp, 0));
      baTemp = new byte[2];
      Buffer.BlockCopy((Array) theData, 5, (Array) baTemp, 0, 2);
      retVal.Manufacturer = MBusUtil.GetManufacturer(BitConverter.ToUInt16(baTemp, 0));
      retVal.Generation = theData[7];
      retVal.Medium = MBusUtil.GetMedium(theData[8]);
      MBusChannelIdentification identificationAsync = retVal;
      ba = (byte[]) null;
      theData = (byte[]) null;
      retVal = (MBusChannelIdentification) null;
      baTemp = (byte[]) null;
      return identificationAsync;
    }

    public MBusChannelIdentification GetChannelIdentification(
      byte channel,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] data = this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetChannelIdentification_0x02, new byte[1]
      {
        channel
      }, progress, cancelToken);
      MBusChannelIdentification channelIdentification = new MBusChannelIdentification();
      channelIdentification.Channel = data[0];
      byte[] dst1 = new byte[4];
      Buffer.BlockCopy((Array) data, 1, (Array) dst1, 0, 4);
      channelIdentification.SerialNumber = (long) Util.ConvertBcdUInt32ToUInt32(BitConverter.ToUInt32(dst1, 0));
      byte[] dst2 = new byte[2];
      Buffer.BlockCopy((Array) data, 5, (Array) dst2, 0, 2);
      channelIdentification.Manufacturer = MBusUtil.GetManufacturer(BitConverter.ToUInt16(dst2, 0));
      channelIdentification.Generation = data[7];
      channelIdentification.Medium = MBusUtil.GetMedium(data[8]);
      return channelIdentification;
    }

    public async Task SetChannelIdentificationAsync(
      MBusChannelIdentification mbChannelIdent,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[9];
      ba[0] = mbChannelIdent.Channel;
      uint serial = (uint) mbChannelIdent.SerialNumber;
      Buffer.BlockCopy((Array) BitConverter.GetBytes(serial), 0, (Array) ba, 1, 4);
      ushort manu = MBusUtil.GetManufacturerCode(mbChannelIdent.Manufacturer);
      Buffer.BlockCopy((Array) BitConverter.GetBytes(manu), 0, (Array) ba, 5, 2);
      ba[7] = mbChannelIdent.Generation;
      ba[8] = byte.Parse(Enum.Format(typeof (Medium), Enum.Parse(typeof (Medium), mbChannelIdent.Medium), "d"));
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetChannelIdentification_0x02, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task<MBusChannelOBIS> GetChannelOBISCodeAsync(
      byte channel,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[1]{ channel };
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetChannelOBIS_Code_0x03, ba, progress, cancelToken);
      MBusChannelOBIS retVal = new MBusChannelOBIS();
      retVal.Channel = theData[0];
      retVal.OBIS_code = theData[1];
      MBusChannelOBIS channelObisCodeAsync = retVal;
      ba = (byte[]) null;
      theData = (byte[]) null;
      retVal = (MBusChannelOBIS) null;
      return channelObisCodeAsync;
    }

    public async Task SetChannelOBISCodeAsync(
      byte channel,
      byte code,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[2]{ channel, code };
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetChannelOBIS_Code_0x03, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task SetChannelConfigurationAsync(
      MBusChannelConfiguration mbChannelConfig,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[5]
      {
        mbChannelConfig.Channel,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 0
      };
      Buffer.BlockCopy((Array) mbChannelConfig.Mantissa, 0, (Array) ba, 1, 2);
      ba[3] = (byte) mbChannelConfig.Exponent;
      ba[4] = mbChannelConfig.VIF;
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetChannelConfiguration_0x04, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task<MBusChannelConfiguration> GetChannelConfigurationAsync(
      byte channel,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[1]{ channel };
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetChannelConfiguration_0x04, ba, progress, cancelToken);
      MBusChannelConfiguration retVal = new MBusChannelConfiguration();
      retVal.Channel = theData[0];
      Buffer.BlockCopy((Array) theData, 1, (Array) (retVal.Mantissa = new byte[2]), 0, 2);
      retVal.Exponent = (sbyte) theData[3];
      retVal.VIF = theData[4];
      MBusChannelConfiguration configurationAsync = retVal;
      ba = (byte[]) null;
      theData = (byte[]) null;
      retVal = (MBusChannelConfiguration) null;
      return configurationAsync;
    }

    public async Task SetChannelValueAsync(
      byte channel,
      uint value,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[5]
      {
        channel,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 0
      };
      Buffer.BlockCopy((Array) BitConverter.GetBytes(value), 0, (Array) ba, 1, 4);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetChannelValue_0x05, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task<uint> GetChannelValueAsync(
      byte channel,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] parameter = new byte[1]{ channel };
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetChannelValue_0x05, parameter, progress, cancelToken);
      uint uint32 = BitConverter.ToUInt32(theData, 1);
      parameter = (byte[]) null;
      theData = (byte[]) null;
      return uint32;
    }

    public async Task<MBusChannelLog> ReadChannelLogValueAsync(
      byte channel,
      byte logSelect,
      byte startIndex,
      byte endIndex,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[4]
      {
        channel,
        logSelect,
        startIndex,
        endIndex
      };
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.ReadChannelLogValue_0x10, ba, progress, cancelToken);
      if (theData == null || theData.Length == 0)
        return (MBusChannelLog) null;
      MBusChannelLog retVal = new MBusChannelLog();
      retVal.Channel = theData[0];
      retVal.LogSelected = theData[1];
      retVal.StartIndex = theData[2];
      retVal.EndIndex = theData[3];
      retVal.Lenght = theData[4];
      retVal.Year = theData[5];
      retVal.Month = theData[6];
      retVal.Day = theData[7];
      retVal.Hour = theData[8];
      retVal.Minute = theData[9];
      retVal.Second = theData[10];
      Buffer.BlockCopy((Array) theData, 11, (Array) (retVal.LogValues = new byte[theData.Length - 11]), 0, theData.Length - 11);
      return retVal;
    }

    public async Task<MBusEventLog> ReadEventLogAsync(
      byte flowControl,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[1]{ flowControl };
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.ReadEventLog_0x11, ba, progress, cancelToken);
      MBusEventLog retVal = new MBusEventLog();
      retVal.FlowControl = theData[0];
      retVal.EntryFormat = theData[1];
      retVal.SystemEventType = theData[2];
      Buffer.BlockCopy((Array) theData, 3, (Array) (retVal.EventTime = new byte[5]), 0, 5);
      Buffer.BlockCopy((Array) theData, 8, (Array) (retVal.Channel0Value = new byte[4]), 0, 4);
      Buffer.BlockCopy((Array) theData, 12, (Array) (retVal.Channel1Value = new byte[4]), 0, 4);
      MBusEventLog mbusEventLog = retVal;
      ba = (byte[]) null;
      theData = (byte[]) null;
      retVal = (MBusEventLog) null;
      return mbusEventLog;
    }

    public async Task ClearEventLogAsync(ProgressHandler progress, CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.ClearEventLog_0x12, progress, cancelToken);
    }

    public async Task<MBusSystemLog> ReadSystemLogAsync(
      byte flowControl,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[1]{ flowControl };
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.ReadSystemLog_0x13, ba, progress, cancelToken);
      MBusSystemLog retVal = new MBusSystemLog();
      retVal.FlowControl = theData[0];
      retVal.EntryFormat = theData[1];
      retVal.SystemEventType = theData[2];
      Buffer.BlockCopy((Array) theData, 3, (Array) (retVal.EventTime = new byte[5]), 0, 5);
      Buffer.BlockCopy((Array) theData, 8, (Array) (retVal.Channel0Value = new byte[4]), 0, 4);
      Buffer.BlockCopy((Array) theData, 12, (Array) (retVal.Channel1Value = new byte[4]), 0, 4);
      MBusSystemLog mbusSystemLog = retVal;
      ba = (byte[]) null;
      theData = (byte[]) null;
      retVal = (MBusSystemLog) null;
      return mbusSystemLog;
    }

    public async Task ClearSystemLogAsync(ProgressHandler progress, CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.ClearSystemLog_0x14, progress, cancelToken);
    }

    public async Task<MBusChannelSingleLogValue> ReadChannelSingleLogValueAsync(
      byte channel,
      byte[] date,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      ushort pos = 0;
      byte[] ba = new byte[3];
      ba[(int) pos++] = channel;
      Buffer.BlockCopy((Array) date, 0, (Array) ba, (int) pos, 2);
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.ReadChannelSingleLogValue_0x15, ba, progress, cancelToken);
      MBusChannelSingleLogValue retVal = new MBusChannelSingleLogValue();
      retVal.basedata = theData;
      retVal.Channel = theData[0];
      retVal.Date = new byte[2];
      Buffer.BlockCopy((Array) theData, 1, (Array) retVal.Date, 0, 2);
      retVal.DateAndTime = Util.ConvertToDate_MBus_CP16_TypeG(retVal.Date, 0).Value;
      byte[] localValue = new byte[4];
      Buffer.BlockCopy((Array) theData, 3, (Array) localValue, 0, 4);
      retVal.Value = BitConverter.ToUInt32(localValue, 0);
      MBusChannelSingleLogValue channelSingleLogValue = retVal;
      ba = (byte[]) null;
      theData = (byte[]) null;
      retVal = (MBusChannelSingleLogValue) null;
      localValue = (byte[]) null;
      return channelSingleLogValue;
    }

    public async Task SetRadioListAsync(
      byte radiolist,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ba = new byte[1]{ radiolist };
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetRadioList_0x16, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task<byte[]> GetRadioListAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] retVal = new byte[1];
      retVal = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetRadioList_0x16, progress, cancelToken);
      byte[] radioListAsync = retVal;
      retVal = (byte[]) null;
      return radioListAsync;
    }

    public async Task SetTXTimingsAsync(
      MBusTXTimings values,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.SetTXTimingsAsync(values.Interval, values.NightTimeStart, values.NightTimeEnd, values.RadioSuppressionDays, values.Reserved, progress, cancelToken);
    }

    public async Task SetTXTimingsAsync(
      ushort interval,
      byte beginHour,
      byte endHour,
      byte radioSuppressionDays,
      uint reserved,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      ushort pos = 0;
      byte[] ba = new byte[9];
      Buffer.BlockCopy((Array) BitConverter.GetBytes(interval), 0, (Array) ba, (int) pos, 2);
      pos += (ushort) 2;
      ba[(int) pos++] = beginHour;
      ba[(int) pos++] = endHour;
      ba[(int) pos++] = radioSuppressionDays;
      Buffer.BlockCopy((Array) BitConverter.GetBytes(reserved), 0, (Array) ba, (int) pos, 4);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetTXTimings_0x17, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task<MBusTXTimings> GetTXTimingsAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetTXTimings_0x17, progress, cancelToken);
      MBusTXTimings retVal = new MBusTXTimings();
      retVal.basedata = theData;
      retVal.Interval = BitConverter.ToUInt16(theData, 0);
      retVal.NightTimeStart = theData[2];
      retVal.NightTimeEnd = theData[3];
      retVal.RadioSuppressionDays = theData[4];
      retVal.Reserved = BitConverter.ToUInt32(theData, 5);
      MBusTXTimings txTimingsAsync = retVal;
      theData = (byte[]) null;
      retVal = (MBusTXTimings) null;
      return txTimingsAsync;
    }

    public async Task<byte[]> GetMBusKeyAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetMBusKey_0x18, progress, cancelToken);
      byte[] mbusKeyAsync = theData;
      theData = (byte[]) null;
      return mbusKeyAsync;
    }

    public byte[] GetMBusKey(ProgressHandler progress, CancellationToken cancelToken)
    {
      return this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetMBusKey_0x18, progress, cancelToken);
    }

    public async Task SetMBusKeyAsync(
      byte[] mbusKey,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (mbusKey == null)
        throw new ArgumentNullException(nameof (mbusKey));
      if (mbusKey.Length != 16)
        throw new ArgumentOutOfRangeException("The length of 'mbusKey' must be 16 bytes");
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonMBusCommands_0x34, CommonMBusCommands_EFC.GetSetMBusKey_0x18, mbusKey, progress, cancelToken);
    }
  }
}


--- CommonMBusCommands_EFC.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CommonMBusCommands_EFC
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum CommonMBusCommands_EFC : byte
  {
    GetSetMBusChannelAddress_0x01 = 1,
    GetSetChannelIdentification_0x02 = 2,
    GetSetChannelOBIS_Code_0x03 = 3,
    GetSetChannelConfiguration_0x04 = 4,
    GetSetChannelValue_0x05 = 5,
    ReadChannelLogValue_0x10 = 16, // 0x10
    ReadEventLog_0x11 = 17, // 0x11
    ClearEventLog_0x12 = 18, // 0x12
    ReadSystemLog_0x13 = 19, // 0x13
    ClearSystemLog_0x14 = 20, // 0x14
    ReadChannelSingleLogValue_0x15 = 21, // 0x15
    GetSetRadioList_0x16 = 22, // 0x16
    GetSetTXTimings_0x17 = 23, // 0x17
    GetSetMBusKey_0x18 = 24, // 0x18
  }
}


--- CommonNBIoTCommands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CommonNBIoTCommands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public sealed class CommonNBIoTCommands : IZRCommand
  {
    private Common32BitCommands commonCMD;
    private bool crypt = false;
    private string AESKey = (string) null;

    public bool enDeCrypt
    {
      get => this.crypt;
      set
      {
        this.crypt = value;
        if (this.commonCMD == null)
          return;
        this.commonCMD.enDeCrypt = value;
      }
    }

    public string AES_Key
    {
      get => this.AESKey;
      set
      {
        this.AESKey = value;
        if (this.commonCMD == null)
          return;
        this.commonCMD.AES_Key = value;
      }
    }

    public CommonNBIoTCommands(Common32BitCommands commonCMD)
    {
      this.commonCMD = commonCMD;
      this.setCryptValuesFromBaseClass();
    }

    public void setCryptValuesFromBaseClass()
    {
      this.enDeCrypt = this.commonCMD.enDeCrypt;
      this.AES_Key = this.commonCMD.AES_Key;
    }

    public async Task<byte[]> GetNBIoT_ModulePartNumberAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetNBIoTModulePartNumber_0x00, progress, cancelToken);
      byte[] modulePartNumberAsync = theData;
      theData = (byte[]) null;
      return modulePartNumberAsync;
    }

    public async Task<byte[]> GetNBIoT_FirmwareVersionAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetNBIoTFirmwareVersion_0x01, progress, cancelToken);
      byte[] firmwareVersionAsync = theData;
      theData = (byte[]) null;
      return firmwareVersionAsync;
    }

    public async Task<byte[]> GetNBIoT_IMEI_IMSI_NBVER_RAMAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetIMEI_IMSI_RAM_0x22, progress, cancelToken);
      byte[] imsiNbverRamAsync = theData;
      theData = (byte[]) null;
      return imsiNbverRamAsync;
    }

    public async Task<byte[]> GetNBIoT_ICCID_IMSI_RAMAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetICCID_IMSI_RAM_0x23, progress, cancelToken);
      byte[] iccidImsiRamAsync = theData;
      theData = (byte[]) null;
      return iccidImsiRamAsync;
    }

    public async Task SetNBIoT_IMEI_IMSI_NBVER_RAMAsync(
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetIMEI_IMSI_RAM_0x22, data, progress, cancelToken);
    }

    public async Task<byte[]> GetNBIoT_IMEI_NBAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetNBIoTIMEI_NB_0x02, progress, cancelToken);
      byte[] nbIoTImeiNbAsync = theData;
      theData = (byte[]) null;
      return nbIoTImeiNbAsync;
    }

    public async Task<byte[]> Get_SIM_IMSI_NBAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int oldTimeout = 0;
      int oldMaxRequestRepeat = 0;
      IPort port = this.commonCMD.DeviceCMD.MBus.Repeater.Port;
      ConfigList cfgList = port.GetReadoutConfiguration();
      byte[] simImsiNbAsync;
      try
      {
        oldTimeout = cfgList.RecTime_BeforFirstByte;
        oldMaxRequestRepeat = cfgList.MaxRequestRepeat;
        cfgList.RecTime_BeforFirstByte = 20300;
        cfgList.MaxRequestRepeat = 1;
        byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSIM_IMSI_NB_0x03, progress, cancelToken);
        simImsiNbAsync = theData;
      }
      finally
      {
        cfgList.RecTime_BeforFirstByte = oldTimeout;
        cfgList.MaxRequestRepeat = oldMaxRequestRepeat;
      }
      port = (IPort) null;
      cfgList = (ConfigList) null;
      return simImsiNbAsync;
    }

    public async Task<byte[]> GetNBIoT_Protocol(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetProtocol_0x04, progress, cancelToken);
      byte[] nbIoTProtocol = theData;
      theData = (byte[]) null;
      return nbIoTProtocol;
    }

    public async Task SetNBIoT_Protocol(
      byte[] id,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetProtocol_0x04, id, progress, cancelToken);
    }

    public async Task<byte[]> GetNBIoT_Band(ProgressHandler progress, CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetBand_0x05, progress, cancelToken);
      byte[] nbIoTBand = theData;
      theData = (byte[]) null;
      return nbIoTBand;
    }

    public async Task SetNBIoT_Band(
      byte[] id,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetBand_0x05, id, progress, cancelToken);
    }

    public async Task<byte[]> GetNBIoT_SecondaryBand(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetSecondaryBand_0x0E, progress, cancelToken);
      byte[] ioTSecondaryBand = theData;
      theData = (byte[]) null;
      return ioTSecondaryBand;
    }

    public async Task SetNBIoT_SecondaryBand(
      byte[] id,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetSecondaryBand_0x0E, id, progress, cancelToken);
    }

    public async Task<byte[]> GetNBIoT_RemoteIP(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetRemoteIP_0x06, progress, cancelToken);
      byte[] nbIoTRemoteIp = theData;
      theData = (byte[]) null;
      return nbIoTRemoteIp;
    }

    public async Task SetNBIoT_RemoteIP(
      byte[] id,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetRemoteIP_0x06, id, progress, cancelToken);
    }

    public async Task<byte[]> GetNBIoT_RemotePort(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetRemotePort_0x07, progress, cancelToken);
      byte[] nbIoTRemotePort = theData;
      theData = (byte[]) null;
      return nbIoTRemotePort;
    }

    public async Task SetNBIoT_RemotePort(
      byte[] id,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetRemotePort_0x07, id, progress, cancelToken);
    }

    public async Task<byte[]> GetNBIoT_Operator(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetOperator_0x08, progress, cancelToken);
      byte[] nbIoTOperator = theData;
      theData = (byte[]) null;
      return nbIoTOperator;
    }

    public async Task SetNBIoT_Operator(
      byte[] id,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetOperator_0x08, id, progress, cancelToken);
    }

    public async Task SetNBIoT_PowerON(ProgressHandler progress, CancellationToken cancelToken)
    {
      byte[] data = new byte[1]{ (byte) 1 };
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SetNBIoTPowerOn_Off_0x20, data, progress, cancelToken);
      data = (byte[]) null;
    }

    public async Task SetNBIoT_PowerOFF(ProgressHandler progress, CancellationToken cancelToken)
    {
      byte[] data = new byte[1];
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SetNBIoTPowerOn_Off_0x20, data, progress, cancelToken);
      data = (byte[]) null;
    }

    public async Task<byte[]> NBIoT_CommonCommand(
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int oldTimeout = 0;
      int oldMaxRequestRepeat = 0;
      IPort port = this.commonCMD.DeviceCMD.MBus.Repeater.Port;
      ConfigList cfgList = port.GetReadoutConfiguration();
      byte[] numArray;
      try
      {
        oldTimeout = cfgList.RecTime_BeforFirstByte;
        oldMaxRequestRepeat = cfgList.MaxRequestRepeat;
        cfgList.RecTime_BeforFirstByte = 20300;
        cfgList.MaxRequestRepeat = 1;
        byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.NBIoTCommonCommand_0x21, data, progress, cancelToken);
        numArray = theData;
      }
      finally
      {
        cfgList.RecTime_BeforFirstByte = oldTimeout;
        cfgList.MaxRequestRepeat = oldMaxRequestRepeat;
      }
      port = (IPort) null;
      cfgList = (ConfigList) null;
      return numArray;
    }

    public async Task<byte[]> NBIoT_SendTestData(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int oldTimeout = 0;
      int oldMaxRequestRepeat = 0;
      IPort port = this.commonCMD.DeviceCMD.MBus.Repeater.Port;
      ConfigList cfgList = port.GetReadoutConfiguration();
      byte[] numArray;
      try
      {
        oldTimeout = cfgList.RecTime_BeforFirstByte;
        oldMaxRequestRepeat = cfgList.MaxRequestRepeat;
        cfgList.RecTime_BeforFirstByte = 60300;
        cfgList.MaxRequestRepeat = 1;
        byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SendTestData_0x0B, progress, cancelToken);
        numArray = theData;
      }
      finally
      {
        cfgList.RecTime_BeforFirstByte = oldTimeout;
        cfgList.MaxRequestRepeat = oldMaxRequestRepeat;
      }
      port = (IPort) null;
      cfgList = (ConfigList) null;
      return numArray;
    }

    public async Task<byte[]> SetNBIoT_RadioFullFunctionOn(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int oldTimeout = 0;
      int oldMaxRequestRepeat = 0;
      IPort port = this.commonCMD.DeviceCMD.MBus.Repeater.Port;
      ConfigList cfgList = port.GetReadoutConfiguration();
      byte[] numArray;
      try
      {
        oldTimeout = cfgList.RecTime_BeforFirstByte;
        oldMaxRequestRepeat = cfgList.MaxRequestRepeat;
        cfgList.RecTime_BeforFirstByte = 20300;
        cfgList.MaxRequestRepeat = 1;
        byte[] data = new byte[1]{ (byte) 1 };
        byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SendRadioFullFunctionOn_Off_0x0C, data, progress, cancelToken);
        numArray = theData;
      }
      finally
      {
        cfgList.RecTime_BeforFirstByte = oldTimeout;
        cfgList.MaxRequestRepeat = oldMaxRequestRepeat;
      }
      port = (IPort) null;
      cfgList = (ConfigList) null;
      return numArray;
    }

    public async Task<byte[]> SetNBIoT_RadioFullFunctionOff(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int oldTimeout = 0;
      int oldMaxRequestRepeat = 0;
      IPort port = this.commonCMD.DeviceCMD.MBus.Repeater.Port;
      ConfigList cfgList = port.GetReadoutConfiguration();
      byte[] numArray;
      try
      {
        oldTimeout = cfgList.RecTime_BeforFirstByte;
        oldMaxRequestRepeat = cfgList.MaxRequestRepeat;
        cfgList.RecTime_BeforFirstByte = 2300;
        cfgList.MaxRequestRepeat = 1;
        byte[] data = new byte[1];
        byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SendRadioFullFunctionOn_Off_0x0C, data, progress, cancelToken);
        numArray = theData;
      }
      finally
      {
        cfgList.RecTime_BeforFirstByte = oldTimeout;
        cfgList.MaxRequestRepeat = oldMaxRequestRepeat;
      }
      port = (IPort) null;
      cfgList = (ConfigList) null;
      return numArray;
    }

    public async Task<byte[]> ResetNBModem(
      ProgressHandler progress,
      CancellationToken cancelToken,
      byte data = 0)
    {
      int oldTimeout = 0;
      int oldMaxRequestRepeat = 0;
      IPort port = this.commonCMD.DeviceCMD.MBus.Repeater.Port;
      ConfigList cfgList = port.GetReadoutConfiguration();
      byte[] numArray;
      try
      {
        oldTimeout = cfgList.RecTime_BeforFirstByte;
        oldMaxRequestRepeat = cfgList.MaxRequestRepeat;
        cfgList.RecTime_BeforFirstByte = 2300;
        cfgList.MaxRequestRepeat = 1;
        byte[] Data = new byte[1]{ data };
        byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.ResetNBModem_0x11, Data, progress, cancelToken);
        numArray = theData;
      }
      finally
      {
        cfgList.RecTime_BeforFirstByte = oldTimeout;
        cfgList.MaxRequestRepeat = oldMaxRequestRepeat;
      }
      port = (IPort) null;
      cfgList = (ConfigList) null;
      return numArray;
    }

    public async Task<byte[]> SetNBModemManualOrAutoConnect(
      byte data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int oldTimeout = 0;
      int oldMaxRequestRepeat = 0;
      IPort port = this.commonCMD.DeviceCMD.MBus.Repeater.Port;
      ConfigList cfgList = port.GetReadoutConfiguration();
      byte[] numArray;
      try
      {
        oldTimeout = cfgList.RecTime_BeforFirstByte;
        oldMaxRequestRepeat = cfgList.MaxRequestRepeat;
        cfgList.RecTime_BeforFirstByte = 2300;
        cfgList.MaxRequestRepeat = 1;
        byte[] Data = new byte[1]{ data };
        byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SetNBModemAutoOrManualConnect_0x12, Data, progress, cancelToken);
        numArray = theData;
      }
      finally
      {
        cfgList.RecTime_BeforFirstByte = oldTimeout;
        cfgList.MaxRequestRepeat = oldMaxRequestRepeat;
      }
      port = (IPort) null;
      cfgList = (ConfigList) null;
      return numArray;
    }

    public async Task SendUnconfirmedDataAsync(
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int maxBytes = 50;
      byte[] ba = new byte[maxBytes];
      Buffer.BlockCopy((Array) data, 0, (Array) ba, 0, data.Length > maxBytes ? maxBytes : data.Length);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SendUnconfirmedData_0x0A, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task SendConfirmedDataAsync(
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int maxBytes = 50;
      byte[] ba = new byte[maxBytes];
      Buffer.BlockCopy((Array) data, 0, (Array) ba, 0, data.Length > maxBytes ? maxBytes : data.Length);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SendConfirmedData_0x09, ba, progress, cancelToken);
      ba = (byte[]) null;
    }

    public async Task SetTransmissionScenarioAsync(
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (data == null || data.Length > 1)
        throw new Exception("SetTransmissionScenarioAsync: illegal data lenght");
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetTransmissionScenario_0x28, data, progress, cancelToken);
    }

    public async Task<byte> GetTransmissionScenarioAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetTransmissionScenario_0x28, progress, cancelToken);
      byte transmissionScenarioAsync = theData[0];
      theData = (byte[]) null;
      return transmissionScenarioAsync;
    }

    public async Task NBIoT_SendActivePacket(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SendActivePacket_0x31, progress, cancelToken);
    }

    public async Task SetDevEUIAsync(
      byte[] devEUI,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (devEUI == null || devEUI.Length != 8)
        throw new Exception("SetDevEUIAsync: illegal devEUI");
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetDevEUI_0x25, devEUI, progress, cancelToken);
    }

    public async Task<byte[]> GetDevEUIAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetDevEUI_0x25, progress, cancelToken);
      byte[] devEuiAsync = theData;
      theData = (byte[]) null;
      return devEuiAsync;
    }

    public async Task<byte[]> GetSIM_ICCID_NBAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      int oldTimeout = 0;
      int oldMaxRequestRepeat = 0;
      IPort port = this.commonCMD.DeviceCMD.MBus.Repeater.Port;
      ConfigList cfgList = port.GetReadoutConfiguration();
      byte[] simIccidNbAsync;
      try
      {
        oldTimeout = cfgList.RecTime_BeforFirstByte;
        oldMaxRequestRepeat = cfgList.MaxRequestRepeat;
        cfgList.RecTime_BeforFirstByte = 20300;
        cfgList.MaxRequestRepeat = 1;
        byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSIM_ICCID_NB_0x0D, progress, cancelToken);
        simIccidNbAsync = theData;
      }
      finally
      {
        cfgList.RecTime_BeforFirstByte = oldTimeout;
        cfgList.MaxRequestRepeat = oldMaxRequestRepeat;
      }
      port = (IPort) null;
      cfgList = (ConfigList) null;
      return simIccidNbAsync;
    }

    public async Task<byte[]> GetDNSNameAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetDNSName_0x0F, progress, cancelToken);
      byte[] dnsNameAsync = theData;
      theData = (byte[]) null;
      return dnsNameAsync;
    }

    public async Task SetDNSNameAsync(
      byte[] dnsName,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (dnsName == null || dnsName.Length < 1)
        throw new Exception("SetDNSNameAsync: illegal DNSName");
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetSetDNSName_0x0F, dnsName, progress, cancelToken);
    }

    public async Task<byte[]> GetRadioSendingState(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.GetRadioSendingState_0x10, progress, cancelToken);
      byte[] radioSendingState = theData;
      theData = (byte[]) null;
      return radioSendingState;
    }

    public async Task<byte[]> GetNBModemAPN(ProgressHandler progress, CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SetGetNBModemAPN_0x13, progress, cancelToken);
      byte[] nbModemApn = theData;
      theData = (byte[]) null;
      return nbModemApn;
    }

    public async Task SetNBModemAPN(
      byte[] APN,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (APN == null || APN.Length < 1)
        throw new Exception("SetNBModemAPN: illegal APN");
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SetGetNBModemAPN_0x13, APN, progress, cancelToken);
    }

    public async Task SetDNSServerIP(
      byte[] ServerIP,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (ServerIP == null || ServerIP.Length < 8)
        throw new Exception("SetDNSServerIP: illegal ServerIP");
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SetGetDNSServerIP_0x14, ServerIP, progress, cancelToken);
    }

    public async Task<byte[]> GetDNSServerIP(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ReturnData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SetGetDNSServerIP_0x14, progress, cancelToken);
      byte[] dnsServerIp = ReturnData;
      ReturnData = (byte[]) null;
      return dnsServerIp;
    }

    public async Task SetDNSEnableByte(
      byte EnableByte,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SetGetDNSEnableByte_0x29, new byte[1]
      {
        EnableByte
      }, progress, cancelToken);
    }

    public async Task<byte> GetDNSEnableByte(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ReturnData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SetGetDNSEnableByte_0x29, progress, cancelToken);
      byte dnsEnableByte = ReturnData != null && ReturnData.Length != 0 ? ReturnData[0] : throw new Exception("GetDNSEnableByte: Return data is null or empty");
      ReturnData = (byte[]) null;
      return dnsEnableByte;
    }

    public async Task SetAPNEanbleByte(
      byte EnableByte,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SetGetAPNEnableByte_0x30, new byte[1]
      {
        EnableByte
      }, progress, cancelToken);
    }

    public async Task<byte> GetAPNEnabledByte(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] EnableByte = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonNBIoTCommands_0x37, CommonNBIoTCommands_EFC.SetGetAPNEnableByte_0x30, progress, cancelToken);
      byte apnEnabledByte = EnableByte.Length != 0 ? EnableByte[0] : throw new Exception("GetAPNEnableByte: return data is empty");
      EnableByte = (byte[]) null;
      return apnEnabledByte;
    }

    private enum Switch : byte
    {
      OFF,
      ON,
    }
  }
}


--- CommonNBIoTCommands_EFC.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CommonNBIoTCommands_EFC
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum CommonNBIoTCommands_EFC : byte
  {
    GetNBIoTModulePartNumber_0x00 = 0,
    GetNBIoTFirmwareVersion_0x01 = 1,
    GetNBIoTIMEI_NB_0x02 = 2,
    GetSIM_IMSI_NB_0x03 = 3,
    GetSetProtocol_0x04 = 4,
    GetSetBand_0x05 = 5,
    GetSetRemoteIP_0x06 = 6,
    GetSetRemotePort_0x07 = 7,
    GetSetOperator_0x08 = 8,
    SendConfirmedData_0x09 = 9,
    SendUnconfirmedData_0x0A = 10, // 0x0A
    SendTestData_0x0B = 11, // 0x0B
    SendRadioFullFunctionOn_Off_0x0C = 12, // 0x0C
    GetSIM_ICCID_NB_0x0D = 13, // 0x0D
    GetSetSecondaryBand_0x0E = 14, // 0x0E
    GetSetDNSName_0x0F = 15, // 0x0F
    GetRadioSendingState_0x10 = 16, // 0x10
    ResetNBModem_0x11 = 17, // 0x11
    SetNBModemAutoOrManualConnect_0x12 = 18, // 0x12
    SetGetNBModemAPN_0x13 = 19, // 0x13
    SetGetDNSServerIP_0x14 = 20, // 0x14
    SetNBIoTPowerOn_Off_0x20 = 32, // 0x20
    NBIoTCommonCommand_0x21 = 33, // 0x21
    GetIMEI_IMSI_RAM_0x22 = 34, // 0x22
    GetICCID_IMSI_RAM_0x23 = 35, // 0x23
    GetSetDevEUI_0x25 = 37, // 0x25
    GetSetTransmissionScenario_0x28 = 40, // 0x28
    SetGetDNSEnableByte_0x29 = 41, // 0x29
    SetGetAPNEnableByte_0x30 = 48, // 0x30
    SendActivePacket_0x31 = 49, // 0x31
  }
}


--- CommonOverwriteGroups.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CommonOverwriteGroups
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum CommonOverwriteGroups
  {
    IdentData,
    TypeIdentification,
    UltrasonicCalibration,
    UltrasonicHydraulicTestSetup,
    UltrasonicLimits,
    UltrasonicTempSensorCurve,
    MenuDefinition,
    RamData,
    BasicConfiguration,
    TemperatureSettings,
    TemperatureLimits,
    DeviceProtection,
    RTC_Calibration,
    ConfigurationParameters,
    CarrierFrequencyCalibration,
    ZeroFlowCalibration,
  }
}


--- CommonRadioCommands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CommonRadioCommands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using MBusLib;
using NLog;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public sealed class CommonRadioCommands : IZRCommand
  {
    private static Logger logger = LogManager.GetLogger(nameof (CommonRadioCommands));
    public const ushort DefaultSyncWord = 37331;
    private Common32BitCommands commonCMD;
    private bool crypt = false;
    private string AESKey = (string) null;

    public static byte[] DefaultAbitraryData { get; private set; }

    public bool enDeCrypt
    {
      get => this.crypt;
      set
      {
        this.crypt = value;
        if (this.commonCMD == null)
          return;
        this.commonCMD.enDeCrypt = value;
      }
    }

    public string AES_Key
    {
      get => this.AESKey;
      set
      {
        this.AESKey = value;
        if (this.commonCMD == null)
          return;
        this.commonCMD.AES_Key = value;
      }
    }

    static CommonRadioCommands()
    {
      CommonRadioCommands.DefaultAbitraryData = new byte[28];
      for (int index = 0; index < CommonRadioCommands.DefaultAbitraryData.Length; ++index)
        CommonRadioCommands.DefaultAbitraryData[index] = (byte) 85;
    }

    public CommonRadioCommands(Common32BitCommands commonCMD)
    {
      this.commonCMD = commonCMD;
      this.setCryptValuesFromBaseClass();
    }

    public void setCryptValuesFromBaseClass()
    {
      this.enDeCrypt = this.commonCMD.enDeCrypt;
      this.AES_Key = this.commonCMD.AES_Key;
    }

    public async Task<ushort> GetRadioVersionAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte FC = 47;
      byte EFC = 0;
      byte[] resultData = await this.commonCMD.TransmitAndReceiveVersionData(FC, EFC, progress, cancelToken);
      if (resultData.Length != 4)
        throw new Exception("Illegal result length by GetRadioVersionAsync");
      if ((int) resultData[0] != (int) FC || (int) resultData[1] != (int) EFC)
        throw new Exception("Illegal FC,EFC by GetRadioVersionAsync");
      ushort uint16 = BitConverter.ToUInt16(resultData, 2);
      resultData = (byte[]) null;
      return uint16;
    }

    public async Task<ushort> GetTransmitPowerAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetTransmitPower_0x05, progress, cancelToken);
      ushort uint16 = BitConverter.ToUInt16(theData, 0);
      theData = (byte[]) null;
      return uint16;
    }

    public async Task SetTransmitPowerAsync(
      ushort transmitPower,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetTransmitPower_0x05, BitConverter.GetBytes(transmitPower), progress, cancelToken);
    }

    public async Task<uint> GetCenterFrequencyAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetCenterFrequency_0x06, progress, cancelToken);
      uint uint32 = BitConverter.ToUInt32(theData, 0);
      theData = (byte[]) null;
      return uint32;
    }

    public async Task SetCenterFrequencyAsync(
      uint frequency,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetCenterFrequency_0x06, BitConverter.GetBytes(frequency), progress, cancelToken);
    }

    public async Task<ushort> GetFrequencyDeviationAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetFrequencyDeviation_0x09, progress, cancelToken);
      ushort uint16 = BitConverter.ToUInt16(theData, 0);
      theData = (byte[]) null;
      return uint16;
    }

    public async Task SetFrequencyDeviationAsync(
      ushort frequencyDeviation,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetFrequencyDeviation_0x09, BitConverter.GetBytes(frequencyDeviation), progress, cancelToken);
    }

    public async Task<byte> GetCarrierModeAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetCarrierMode_0x08, progress, cancelToken);
      byte carrierModeAsync = theData[0];
      theData = (byte[]) null;
      return carrierModeAsync;
    }

    public async Task SetCarrierModeAsync(
      byte mode,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetCarrierMode_0x08, new byte[1]
      {
        mode
      }, progress, cancelToken);
    }

    public async Task<int> GetFrequencyIncrementAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetFrequencyIncrement_0x07, progress, cancelToken);
      int int32 = BitConverter.ToInt32(theData, 0);
      theData = (byte[]) null;
      return int32;
    }

    public async Task SetFrequencyIncrementAsync(
      int frequency_Hz,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetFrequencyIncrement_0x07, BitConverter.GetBytes(frequency_Hz), progress, cancelToken);
    }

    public async Task MonitorRadioAsync(
      ushort timeout,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.MonitorRadioToOutput_0x26, BitConverter.GetBytes(timeout), progress, cancelToken);
    }

    public async Task ReceiveAndStreamRadio3Scenario3TelegramsAsync(
      byte telegramSize,
      ushort timeout,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      List<byte> cmd = new List<byte>();
      cmd.Add(telegramSize);
      cmd.AddRange((IEnumerable<byte>) BitConverter.GetBytes(timeout));
      byte[] parameter = cmd.ToArray();
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.ReceiveAndStreamR3S3_Telegrams_0x25, parameter, progress, cancelToken);
      cmd = (List<byte>) null;
      parameter = (byte[]) null;
    }

    public async Task<double?> ReceiveTestPacketAsync(
      byte timeoutInSec,
      uint deviceID,
      ProgressHandler progress,
      CancellationToken token,
      string syncWord)
    {
      if (syncWord == null || syncWord.Length != 4)
        throw new Exception("Invalid SYNC WORD!");
      if (syncWord == "0000" || syncWord == "5555" || syncWord == "AAAA")
        throw new Exception("SYNC WORD " + syncWord + " is not allowed");
      DeviceVersionMBus deviceVersionMbus = await this.commonCMD.DeviceCMD.ReadVersionAsync(progress, token);
      byte SYNC1 = Convert.ToByte(syncWord.Substring(0, 2), 16);
      byte SYNC2 = Convert.ToByte(syncWord.Substring(2, 2), 16);
      DateTime start = DateTime.Now;
      DateTime end = start.AddSeconds((double) timeoutInSec);
      while (DateTime.Now <= end)
      {
        try
        {
          byte[] buffer = await this.ReceiveRadio3Scenario3TelegramViaRadioAsync((byte) 33, new byte[2]
          {
            SYNC1,
            SYNC2
          }, timeoutInSec, progress, token);
          if (buffer != null && buffer.Length != 0)
          {
            string data = Encoding.ASCII.GetString(buffer, 3, buffer.Length - 3);
            if (data.StartsWith("TEST_PACKET_") && data.EndsWith("_TEST_PACKET"))
            {
              string id = data.Substring(12, 8).TrimStart('0');
              if ((int) uint.Parse(id) == (int) deviceID)
              {
                CommonRadioCommands.logger.Trace(Utility.ByteArrayToHexString(buffer));
                byte RegRssiValue = buffer[0];
                double rssi = (double) -RegRssiValue / 2.0;
                return new double?(rssi);
              }
              data = (string) null;
              id = (string) null;
            }
            else
              continue;
          }
          buffer = (byte[]) null;
        }
        catch (Exception ex)
        {
          CommonRadioCommands.logger.Error(ex.Message);
        }
      }
      return new double?();
    }

    public double? ReceiveTestPacket(
      byte timeoutInSec,
      uint deviceID,
      ProgressHandler progress,
      CancellationToken token,
      string syncWord)
    {
      if (syncWord == null || syncWord.Length != 4)
        throw new Exception("Invalid SYNC WORD!");
      if (syncWord == "0000" || syncWord == "5555" || syncWord == "AAAA")
        throw new Exception("SYNC WORD " + syncWord + " is not allowed");
      this.commonCMD.DeviceCMD.ReadVersion(progress, token);
      byte num1 = Convert.ToByte(syncWord.Substring(0, 2), 16);
      byte num2 = Convert.ToByte(syncWord.Substring(2, 2), 16);
      DateTime dateTime = DateTime.Now.AddSeconds((double) timeoutInSec);
      while (DateTime.Now <= dateTime)
      {
        try
        {
          byte[] telegramViaRadio = this.ReceiveRadio3Scenario3TelegramViaRadio((byte) 33, new byte[2]
          {
            num1,
            num2
          }, timeoutInSec, progress, token);
          if (telegramViaRadio != null && telegramViaRadio.Length != 0)
          {
            string str = Encoding.ASCII.GetString(telegramViaRadio, 3, telegramViaRadio.Length - 3);
            if (str.StartsWith("TEST_PACKET_") && str.EndsWith("_TEST_PACKET"))
            {
              if ((int) uint.Parse(str.Substring(12, 8).TrimStart('0')) == (int) deviceID)
              {
                CommonRadioCommands.logger.Trace(Utility.ByteArrayToHexString(telegramViaRadio));
                return new double?((double) -telegramViaRadio[0] / 2.0);
              }
            }
          }
        }
        catch (Exception ex)
        {
          CommonRadioCommands.logger.Error(ex.Message);
        }
      }
      return new double?();
    }

    public byte[] ReceiveRadio3Scenario3TelegramViaRadio(
      byte telegramSize,
      byte[] syncWord,
      byte timeout,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      CommonRadioCommands.logger.Debug("ReceiveRadio3Scenario3TelegramViaRadioAsync: SyncWord: " + Utility.ByteArrayToHexString(syncWord) + ", Timeout: " + timeout.ToString());
      int num1 = 0;
      int num2 = 0;
      ConfigList readoutConfiguration = this.commonCMD.DeviceCMD.MBus.Repeater.Port.GetReadoutConfiguration();
      try
      {
        num1 = readoutConfiguration.RecTime_BeforFirstByte;
        num2 = readoutConfiguration.MaxRequestRepeat;
        readoutConfiguration.RecTime_BeforFirstByte = (int) timeout * 1000 + 300;
        readoutConfiguration.MaxRequestRepeat = 1;
        CommonRadioCommands.logger.Debug("Set new value for RecTime_BeforFirstByte: " + readoutConfiguration.RecTime_BeforFirstByte.ToString());
        List<byte> byteList = new List<byte>();
        byteList.Add(telegramSize);
        byteList.AddRange((IEnumerable<byte>) syncWord);
        byteList.Add(timeout);
        return this.commonCMD.TransmitAndGetData(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.ReceiveOneR3S3_Telegram_0x24, byteList.ToArray(), progress, cancelToken);
      }
      finally
      {
        CommonRadioCommands.logger.Debug("Set old value for RecTime_BeforFirstByte: " + num1.ToString());
        readoutConfiguration.RecTime_BeforFirstByte = num1;
        readoutConfiguration.MaxRequestRepeat = num2;
      }
    }

    public async Task<byte[]> ReceiveRadio3Scenario3TelegramViaRadioAsync(
      byte telegramSize,
      byte[] syncWord,
      byte timeout,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      CommonRadioCommands.logger.Debug("ReceiveRadio3Scenario3TelegramViaRadioAsync: SyncWord: " + Utility.ByteArrayToHexString(syncWord) + ", Timeout: " + timeout.ToString());
      int oldTimeout = 0;
      int oldMaxRequestRepeat = 0;
      IPort port = this.commonCMD.DeviceCMD.MBus.Repeater.Port;
      ConfigList cfgList = port.GetReadoutConfiguration();
      byte[] telegramViaRadioAsync;
      try
      {
        oldTimeout = cfgList.RecTime_BeforFirstByte;
        oldMaxRequestRepeat = cfgList.MaxRequestRepeat;
        cfgList.RecTime_BeforFirstByte = (int) timeout * 1000 + 300;
        cfgList.MaxRequestRepeat = 1;
        CommonRadioCommands.logger.Debug("Set new value for RecTime_BeforFirstByte: " + cfgList.RecTime_BeforFirstByte.ToString());
        List<byte> cmd = new List<byte>();
        cmd.Add(telegramSize);
        cmd.AddRange((IEnumerable<byte>) syncWord);
        cmd.Add(timeout);
        byte[] parameter = cmd.ToArray();
        byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.ReceiveOneR3S3_Telegram_0x24, parameter, progress, cancelToken);
        telegramViaRadioAsync = theData;
      }
      finally
      {
        CommonRadioCommands.logger.Debug("Set old value for RecTime_BeforFirstByte: " + oldTimeout.ToString());
        cfgList.RecTime_BeforFirstByte = oldTimeout;
        cfgList.MaxRequestRepeat = oldMaxRequestRepeat;
      }
      port = (IPort) null;
      cfgList = (ConfigList) null;
      return telegramViaRadioAsync;
    }

    public async Task EchoRadio3TelegramViaRadioAsync(
      byte telegramSize,
      byte[] syncWord,
      ushort timeout,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (syncWord == null)
        throw new ArgumentNullException("EchoRadio3TelegramViaRadioAsync::syncWord");
      if (syncWord.Length != 2)
        throw new ArgumentException("syncWord.Length != 2");
      List<byte> cmd = new List<byte>();
      cmd.Add(telegramSize);
      cmd.AddRange((IEnumerable<byte>) syncWord);
      cmd.AddRange((IEnumerable<byte>) BitConverter.GetBytes(timeout));
      byte[] parameter = cmd.ToArray();
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.EchoRadio3viaRadio_0x27, parameter, progress, cancelToken);
      cmd = (List<byte>) null;
      parameter = (byte[]) null;
    }

    public async Task SendTestPacketAsync(
      ushort interval,
      ushort timeout,
      uint deviceID,
      byte[] arbitraryData,
      ProgressHandler progress,
      CancellationToken token,
      string syncWordString)
    {
      ushort syncWord = syncWordString != null && syncWordString.Length == 4 ? ushort.Parse(syncWordString, NumberStyles.HexNumber) : throw new Exception("Invalid SYNC WORD!");
      byte[] packetBytes = CommonRadioCommands.GetSendTestPacketData(interval, timeout, deviceID, arbitraryData, syncWord);
      await this.SendTestPacketAsync(interval, timeout, packetBytes, progress, token);
      packetBytes = (byte[]) null;
    }

    public static byte[] GetSendTestPacketData(
      ushort interval,
      ushort timeout,
      uint deviceID,
      byte[] arbitraryData,
      ushort syncWord)
    {
      if (arbitraryData == null)
        throw new ArgumentNullException("myDeviceCommands");
      if (syncWord == (ushort) 0 || syncWord == (ushort) 21845 || syncWord == (ushort) 43690)
        throw new Exception("SYNC WORD " + syncWord.ToString("x04") + " is not allowed");
      DateTime now = DateTime.Now;
      byte hour = (byte) now.Hour;
      byte minute = (byte) now.Minute;
      ushort yyyymmmmyyyddddd = MBusUtil.ConvertDateTimeTo_YYYYMMMMYYYDDDDD(now);
      List<byte> byteList = new List<byte>();
      byteList.Add((byte) ((uint) syncWord >> 8));
      byteList.Add((byte) syncWord);
      byteList.Add((byte) 38);
      byteList.Add((byte) 1);
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(Util.ConvertUnt32ToBcdUInt32(deviceID)));
      byteList.Add((byte) 0);
      byteList.Add(hour);
      byteList.Add(minute);
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(yyyymmmmyyyddddd));
      byteList.AddRange((IEnumerable<byte>) arbitraryData);
      byte[] array = byteList.ToArray();
      if (CommonRadioCommands.logger.IsDebugEnabled)
        CommonRadioCommands.logger.Debug(string.Format("SendTestPacket => Interval:{0}, Timeout:{1} Data: {2}", (object) interval, (object) timeout, (object) Utility.ByteArrayToHexString(array)));
      return array;
    }

    public async Task SendTestPacketAsync(
      ushort interval,
      ushort timeout,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      List<byte> cmd = new List<byte>();
      cmd.AddRange((IEnumerable<byte>) BitConverter.GetBytes(interval));
      cmd.AddRange((IEnumerable<byte>) BitConverter.GetBytes(timeout));
      cmd.AddRange((IEnumerable<byte>) data);
      byte[] parameter = cmd.ToArray();
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.SendTestPacket_0x23, parameter, progress, cancelToken);
      cmd = (List<byte>) null;
      parameter = (byte[]) null;
    }

    public async Task TransmitModulatedCarrierAsync(
      ushort timeout,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.TransmitModulatedCarrier_0x22, BitConverter.GetBytes(timeout), progress, cancelToken);
    }

    public async Task TransmitUnmodulatedCarrierAsync(
      ushort timeout,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.TransmitUnmodulatedCarrier_0x21, BitConverter.GetBytes(timeout), progress, cancelToken);
    }

    public async Task StopRadioTests(ProgressHandler progress, CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.StopRadioTest_0x20, progress, cancelToken);
    }

    public async Task<uint> GetTxDataRateAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetTxDataRate_0x0b, progress, cancelToken);
      uint uint32 = BitConverter.ToUInt32(theData, 0);
      theData = (byte[]) null;
      return uint32;
    }

    public async Task SetTxDataRateAsync(
      uint dataRate,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetTxDataRate_0x0b, BitConverter.GetBytes(dataRate), progress, cancelToken);
    }

    public async Task<uint> GetRxDataRateAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetRxDataRate_0x0c, progress, cancelToken);
      uint uint32 = BitConverter.ToUInt32(theData, 0);
      theData = (byte[]) null;
      return uint32;
    }

    public async Task SetRxDataRateAsync(
      uint dataRate,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetRxDataRate_0x0c, BitConverter.GetBytes(dataRate), progress, cancelToken);
    }

    public async Task<CommonRadioCommands.RadioBandWidth> GetBandWidthAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetBandWidth_0x0a, progress, cancelToken);
      CommonRadioCommands.RadioBandWidth retVal = new CommonRadioCommands.RadioBandWidth();
      retVal.BandWidth = BitConverter.ToUInt32(theData, 0);
      retVal.AFC = BitConverter.ToUInt32(theData, 4);
      retVal.basedata = theData;
      CommonRadioCommands.RadioBandWidth bandWidthAsync = retVal;
      theData = (byte[]) null;
      retVal = (CommonRadioCommands.RadioBandWidth) null;
      return bandWidthAsync;
    }

    public async Task SetBandWidthAsync(
      uint bandWidth,
      uint AFC,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      List<byte> cmd = new List<byte>();
      cmd.AddRange((IEnumerable<byte>) BitConverter.GetBytes(bandWidth));
      cmd.AddRange((IEnumerable<byte>) BitConverter.GetBytes(AFC));
      byte[] parameter = cmd.ToArray();
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetBandWidth_0x0a, parameter, progress, cancelToken);
      cmd = (List<byte>) null;
      parameter = (byte[]) null;
    }

    public async Task<ushort> GetTxBandWidthAsync(ProgressHandler progress, CancellationToken token)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetTxBandWidth_0x28, progress, token);
      ushort uint16 = BitConverter.ToUInt16(theData, 0);
      theData = (byte[]) null;
      return uint16;
    }

    public async Task SetTxBandWidthAsync(
      ushort bandWidth,
      ProgressHandler progress,
      CancellationToken token)
    {
      List<byte> cmd = new List<byte>();
      cmd.AddRange((IEnumerable<byte>) BitConverter.GetBytes(bandWidth));
      byte[] parameter = cmd.ToArray();
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.GetSetTxBandWidth_0x28, parameter, progress, token);
      cmd = (List<byte>) null;
      parameter = (byte[]) null;
    }

    public async Task StartTransmissionCycleAsync(
      byte numberOfFirstChannel,
      byte totalChannels,
      byte lenghtOfPayload,
      byte cycles,
      byte spreadFactor,
      ushort bandwidth,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (numberOfFirstChannel > (byte) 71 || numberOfFirstChannel < (byte) 0)
        throw new Exception("Number of first channel has to be between 0 and 71.");
      if (totalChannels > (byte) 72 || totalChannels < (byte) 1)
        throw new Exception("Number of total channels has to be between 1 and 72.");
      if (lenghtOfPayload > (byte) 60 || lenghtOfPayload < (byte) 1)
        throw new Exception("Length of payload has to be between 1 and 60.");
      List<byte> cmd = new List<byte>();
      cmd.Add(numberOfFirstChannel);
      cmd.Add(totalChannels);
      cmd.Add(lenghtOfPayload);
      cmd.Add(cycles);
      cmd.Add(spreadFactor);
      cmd.AddRange((IEnumerable<byte>) BitConverter.GetBytes(bandwidth));
      byte[] parameter = cmd.ToArray();
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.StartTransmissionCylcle_0x29, parameter, progress, cancelToken);
      cmd = (List<byte>) null;
      parameter = (byte[]) null;
    }

    public async Task SetNFCFieldAsync(
      byte function,
      ushort timeout,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      List<byte> cmd = new List<byte>();
      cmd.Add(function);
      cmd.AddRange((IEnumerable<byte>) BitConverter.GetBytes(timeout));
      byte[] parameters = cmd.ToArray();
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.CommonRadioCommands_0x2f, CommonRadioCommands_EFC.SetNFCField_0x2a, parameters, progress, cancelToken);
      cmd = (List<byte>) null;
      parameters = (byte[]) null;
    }

    public class RadioBandWidth : ReturnValue
    {
      public uint BandWidth;
      public uint AFC;
    }
  }
}


--- CommonRadioCommands_EFC.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CommonRadioCommands_EFC
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum CommonRadioCommands_EFC : byte
  {
    GetRadioVersion_0x00 = 0,
    GetSetTransmitPower_0x05 = 5,
    GetSetCenterFrequency_0x06 = 6,
    GetSetFrequencyIncrement_0x07 = 7,
    GetSetCarrierMode_0x08 = 8,
    GetSetFrequencyDeviation_0x09 = 9,
    GetSetBandWidth_0x0a = 10, // 0x0A
    GetSetTxDataRate_0x0b = 11, // 0x0B
    GetSetRxDataRate_0x0c = 12, // 0x0C
    StopRadioTest_0x20 = 32, // 0x20
    TransmitUnmodulatedCarrier_0x21 = 33, // 0x21
    TransmitModulatedCarrier_0x22 = 34, // 0x22
    SendTestPacket_0x23 = 35, // 0x23
    ReceiveOneR3S3_Telegram_0x24 = 36, // 0x24
    ReceiveAndStreamR3S3_Telegrams_0x25 = 37, // 0x25
    MonitorRadioToOutput_0x26 = 38, // 0x26
    EchoRadio3viaRadio_0x27 = 39, // 0x27
    GetSetTxBandWidth_0x28 = 40, // 0x28
    StartTransmissionCylcle_0x29 = 41, // 0x29
    SetNFCField_0x2a = 42, // 0x2A
  }
}


--- CompatibilityInfo.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CompatibilityInfo
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;
using System.Text;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class CompatibilityInfo : IComparable<CompatibilityInfo>
  {
    public int MapID;
    public uint Firmware;
    public int CompatibleToMapID;
    public uint CompatibleToFirmware;
    public bool IsFullCompatible = false;
    public List<string> CompatibleGroupShortcuts;

    public int CompareTo(CompatibilityInfo compareInfo)
    {
      int num = new FirmwareVersion(this.Firmware).CompareTo((object) new FirmwareVersion(compareInfo.Firmware));
      return num != 0 ? num : new FirmwareVersion(this.CompatibleToFirmware).CompareTo((object) new FirmwareVersion(compareInfo.CompatibleToFirmware));
    }

    public override string ToString()
    {
      StringBuilder stringBuilder = new StringBuilder();
      if (this.Firmware > 0U)
        stringBuilder.Append("FirmwareVersion: " + new FirmwareVersion(this.Firmware).ToString() + " / ");
      stringBuilder.Append("MapID:" + this.MapID.ToString() + " compatible to -> ");
      if (this.CompatibleToFirmware > 0U)
        stringBuilder.Append("FirmwareVersion :" + new FirmwareVersion(this.CompatibleToFirmware).ToString() + " / ");
      stringBuilder.Append("MapID:" + this.CompatibleToMapID.ToString());
      if (this.IsFullCompatible)
        stringBuilder.Append(" # Full compatible ");
      else if (this.CompatibleGroupShortcuts != null && this.CompatibleGroupShortcuts.Count > 0)
      {
        stringBuilder.Append(" # Compatible groups: ");
        bool flag = true;
        foreach (string compatibleGroupShortcut in this.CompatibleGroupShortcuts)
        {
          if (flag)
            flag = false;
          else
            stringBuilder.Append(";");
          stringBuilder.Append(compatibleGroupShortcut);
        }
      }
      return stringBuilder.ToString();
    }
  }
}


--- CompatibleFirmwareSelectWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CompatibleFirmwareSelectWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System.Collections;
using System.Data;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

#nullable disable
namespace HandlerLib
{
  internal class CompatibleFirmwareSelectWindow : Window
  {
    private Window ParentWND = (Window) null;
    private Canvas canvas = new Canvas();
    private DataGrid myDataGrid = new DataGrid();

    public CompatibleFirmwareSelectWindow(Window parent, ref DataTable dependencyFW)
    {
      this.ParentWND = parent;
      this.AllowsTransparency = false;
      this.WindowStyle = WindowStyle.ThreeDBorderWindow;
      this.Background = (Brush) Brushes.CornflowerBlue;
      this.Topmost = true;
      this.Title = "Choose a compatible firmware ...";
      this.Width = this.ParentWND.Width - 200.0;
      this.Height = this.ParentWND.Height - 50.0;
      this.canvas.Width = this.Width;
      this.canvas.Height = this.Height;
      this.canvas.Background = this.ParentWND.Background;
      this.myDataGrid.Width = this.canvas.Width - 20.0;
      this.myDataGrid.Height = this.canvas.Height - 50.0;
      this.myDataGrid.Visibility = Visibility.Visible;
      this.myDataGrid.ItemsSource = (IEnumerable) dependencyFW.AsDataView();
      this.myDataGrid.AutoGenerateColumns = true;
      this.canvas.Children.Add((UIElement) this.myDataGrid);
      this.Content = (object) this.canvas;
    }
  }
}


--- CompatibleFirmwareWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CompatibleFirmwareWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommonWPF;
using GmmDbLib;
using GmmDbLib.DataSets;
using Microsoft.Win32;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class CompatibleFirmwareWindow : Window, IComponentConnector
  {
    private uint? PreDefinedFirmwareVersion = new uint?();
    private uint? FirmwareVersionFromHandler = new uint?();
    private DbConnection myDbConnection;
    private DbDataAdapter ProgFilesDataAdapter;
    private DbCommandBuilder myComandBuilder;
    private string firmwareVersionUnchanged;
    private bool ignoreEditChanges = false;
    private bool newRowCreated;
    private int CommonMapID;
    private string HardwareName;
    private SortedList<int, CompatibleFirmwareWindow.RowCompareState> CompareStates = new SortedList<int, CompatibleFirmwareWindow.RowCompareState>();
    internal StackPanel StackPanelButtons;
    internal Button ButtonPrepareTable;
    internal Button ButtonImportProgrammerFile;
    internal Button ButtonExportProgrammerFile;
    internal Button ButtonTableToExcel;
    internal Button ButtonShowProgrammerFile;
    internal Button ButtonDeleteSelectedFirmware;
    internal Button ButtonDeleteSelectedFirmwareFile;
    internal Button ButtonAddFirmware;
    internal Button ButtonSaveChanges;
    internal Button ButtonCompareSelected;
    internal Button ButtonCompareAll;
    internal Button ButtonCopySelected;
    internal Border BorderVersionFromHandler;
    internal TextBox TextBoxFirmwareFromHandler;
    internal Button ButtonUseFirmwareFromHandler;
    internal StackPanel StackPanelBottom;
    internal Label LabelStatus;
    internal StackPanel StackPanelEditBoxes;
    internal TextBox TextBoxFirmwareVersion;
    internal TextBox TextBoxReleasedName;
    internal Button ButtonClearReleased;
    internal Button ButtonSetReleased;
    internal TextBox TextBoxCompatibleOverwriteGroups;
    internal CheckBox CheckBoxNoCompression;
    internal TextBox TextBoxOptions;
    internal TextBox TextBoxSourceInfo;
    internal TextBox TextBoxReleaseComments;
    internal Button ButtonFirmwareDependencies;
    internal CheckBox CheckBoxFirmwareDependenciesCleanUp;
    internal TextBox TextBoxFirmwareDependencies;
    internal DataGrid DataGridOverview;
    private bool _contentLoaded;

    public ObservableCollection<KeyValuePair<string, string>> PreDefinedInfos { get; set; }

    public HardwareTypeTables.ProgFilesDataTable ProgFilesTable { get; set; }

    public CompatibleFirmwareWindow(
      HardwareTypeTables.HardwareTypeRow hardwareTypeRow,
      uint? firmwareVersionFromHandler)
    {
      if (!hardwareTypeRow.IsFirmwareVersionNull())
        this.PreDefinedFirmwareVersion = new uint?((uint) hardwareTypeRow.FirmwareVersion);
      if (!this.PreDefinedFirmwareVersion.HasValue)
        this.PreDefinedFirmwareVersion = firmwareVersionFromHandler;
      this.FirmwareVersionFromHandler = firmwareVersionFromHandler;
      if (!this.FirmwareVersionFromHandler.HasValue)
        this.FirmwareVersionFromHandler = this.PreDefinedFirmwareVersion;
      this.CommonMapID = hardwareTypeRow.MapID;
      this.HardwareName = hardwareTypeRow.HardwareName;
      this.InitializeComponent();
      try
      {
        this.PreDefinedInfos = new ObservableCollection<KeyValuePair<string, string>>();
        if (!hardwareTypeRow.IsMapIDNull())
          this.PreDefinedInfos.Add(new KeyValuePair<string, string>("MapID", hardwareTypeRow.MapID.ToString()));
        this.PreDefinedInfos.Add(new KeyValuePair<string, string>("HardwareTypeID", hardwareTypeRow.HardwareTypeID.ToString()));
        if (!hardwareTypeRow.IsHardwareNameNull())
        {
          this.HardwareName = hardwareTypeRow.HardwareName;
          this.PreDefinedInfos.Add(new KeyValuePair<string, string>(nameof (HardwareName), hardwareTypeRow.HardwareName));
        }
        int num;
        if (!hardwareTypeRow.IsFirmwareVersionNull())
        {
          ObservableCollection<KeyValuePair<string, string>> preDefinedInfos = this.PreDefinedInfos;
          string[] strArray = new string[5]
          {
            hardwareTypeRow.FirmwareVersion.ToString(),
            " == 0x",
            null,
            null,
            null
          };
          num = hardwareTypeRow.FirmwareVersion;
          strArray[2] = num.ToString("x08");
          strArray[3] = " == ";
          strArray[4] = new FirmwareVersion((uint) hardwareTypeRow.FirmwareVersion).ToString();
          KeyValuePair<string, string> keyValuePair = new KeyValuePair<string, string>("FirmwareVersion", string.Concat(strArray));
          preDefinedInfos.Add(keyValuePair);
        }
        if (!hardwareTypeRow.IsHardwareVersionNull())
        {
          ObservableCollection<KeyValuePair<string, string>> preDefinedInfos = this.PreDefinedInfos;
          num = hardwareTypeRow.HardwareVersion;
          string str1 = num.ToString();
          num = hardwareTypeRow.HardwareVersion;
          string str2 = num.ToString("x08");
          KeyValuePair<string, string> keyValuePair = new KeyValuePair<string, string>("HardwareVersion", str1 + " == 0x" + str2);
          preDefinedInfos.Add(keyValuePair);
        }
        if (!hardwareTypeRow.IsHardwareResourceNull())
          this.PreDefinedInfos.Add(new KeyValuePair<string, string>("HardwareResource", hardwareTypeRow.HardwareResource));
        if (!hardwareTypeRow.IsHardwareOptionsNull())
          this.PreDefinedInfos.Add(new KeyValuePair<string, string>("HardwareOptions", hardwareTypeRow.HardwareOptions));
        if (!hardwareTypeRow.IsTestinfoNull())
          this.PreDefinedInfos.Add(new KeyValuePair<string, string>("Testinfo", hardwareTypeRow.Testinfo));
        if (!hardwareTypeRow.IsDescriptionNull())
          this.PreDefinedInfos.Add(new KeyValuePair<string, string>("Description", hardwareTypeRow.Description));
      }
      catch (Exception ex)
      {
        throw new Exception("Error on load HardwareType data", ex);
      }
      this.BaseConstructorFunction();
    }

    public CompatibleFirmwareWindow(
      int commonMapID,
      string hardwareName,
      uint? preDefinedFirmwareVersion)
    {
      if (string.IsNullOrEmpty(hardwareName))
        throw new ArgumentException("HardwareName not defined");
      this.CommonMapID = commonMapID;
      this.HardwareName = hardwareName;
      this.PreDefinedFirmwareVersion = preDefinedFirmwareVersion;
      this.InitializeComponent();
      try
      {
        this.PreDefinedInfos = new ObservableCollection<KeyValuePair<string, string>>();
        this.PreDefinedInfos.Add(new KeyValuePair<string, string>("Common MapID", this.CommonMapID.ToString()));
        this.PreDefinedInfos.Add(new KeyValuePair<string, string>(nameof (HardwareName), this.HardwareName));
        if (this.PreDefinedFirmwareVersion.HasValue)
        {
          ObservableCollection<KeyValuePair<string, string>> preDefinedInfos = this.PreDefinedInfos;
          string[] strArray = new string[5];
          uint num = this.PreDefinedFirmwareVersion.Value;
          strArray[0] = num.ToString();
          strArray[1] = " == 0x";
          num = this.PreDefinedFirmwareVersion.Value;
          strArray[2] = num.ToString("x08");
          strArray[3] = " == ";
          strArray[4] = new FirmwareVersion(this.PreDefinedFirmwareVersion.Value).ToString();
          KeyValuePair<string, string> keyValuePair = new KeyValuePair<string, string>("Pre defined FirmwareVersion", string.Concat(strArray));
          preDefinedInfos.Add(keyValuePair);
        }
      }
      catch (Exception ex)
      {
        throw new Exception("Error on load HardwareType data", ex);
      }
      this.BaseConstructorFunction();
    }

    private void BaseConstructorFunction()
    {
      this.myDbConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection();
      this.LoadData();
      if (this.FirmwareVersionFromHandler.HasValue)
      {
        this.BorderVersionFromHandler.Visibility = Visibility.Visible;
        this.TextBoxFirmwareFromHandler.Text = this.FirmwareVersionFromHandler.Value.ToString("x08");
      }
      else
        this.BorderVersionFromHandler.Visibility = Visibility.Collapsed;
      if (this.PreDefinedFirmwareVersion.HasValue)
        this.SetSelectedRowFromVersion((int) this.PreDefinedFirmwareVersion.Value);
      else
        this.DataGridOverview.SelectedIndex = 0;
    }

    private void SetSelectedRowFromVersion(int firmwareVersion)
    {
      int num = -1;
      for (int index = 0; index < this.DataGridOverview.Items.Count; ++index)
      {
        HardwareTypeTables.ProgFilesRow row = (HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.Items[index]).Row;
        if (!row.IsFirmwareVersionNull() && row.FirmwareVersion == firmwareVersion)
        {
          num = index;
          break;
        }
      }
      if (num >= 0)
        this.DataGridOverview.SelectedIndex = num;
      else
        this.DataGridOverview.SelectedIndex = 0;
    }

    private void LoadData()
    {
      try
      {
        this.ClearEditBoxes();
        this.LabelStatus.Content = (object) "";
        this.DataGridOverview.SelectedIndex = -1;
        this.ButtonAddFirmware.IsEnabled = false;
        this.ButtonSaveChanges.IsEnabled = false;
        this.ButtonDeleteSelectedFirmware.IsEnabled = false;
        this.ButtonDeleteSelectedFirmwareFile.IsEnabled = false;
        this.ButtonImportProgrammerFile.IsEnabled = false;
        this.ButtonExportProgrammerFile.IsEnabled = false;
        this.ButtonShowProgrammerFile.IsEnabled = false;
        this.newRowCreated = false;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append("SELECT MapID, SourceInfo, FirmwareVersion, HardwareName, Options, ProgFileName, HardwareTypeMapID, CompatibleOverwriteGroups, ReleasedName, ReleaseComments, FirmwareDependencies");
        stringBuilder.Append(" FROM ProgFiles");
        stringBuilder.Append(" WHERE HardwareTypeMapID = " + this.CommonMapID.ToString());
        stringBuilder.Append(" OR MapID = " + this.CommonMapID.ToString());
        stringBuilder.Append(" ORDER BY MapID DESC");
        this.ProgFilesDataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), this.myDbConnection, out this.myComandBuilder);
        this.ProgFilesTable = new HardwareTypeTables.ProgFilesDataTable();
        this.ProgFilesDataAdapter.Fill((DataTable) this.ProgFilesTable);
        if (this.ProgFilesTable.Count == 0)
        {
          HardwareTypeTables.ProgFilesRow row = this.ProgFilesTable.NewProgFilesRow();
          row.MapID = this.CommonMapID;
          row.HardwareTypeMapID = this.CommonMapID;
          row.Options = ";Compression=ZIP;";
          if (this.PreDefinedFirmwareVersion.HasValue)
            row.FirmwareVersion = (int) this.PreDefinedFirmwareVersion.Value;
          if (this.HardwareName != null)
            row.HardwareName = this.HardwareName;
          this.ProgFilesTable.AddProgFilesRow(row);
          this.newRowCreated = true;
        }
        this.DataGridOverview.ItemsSource = (IEnumerable) this.ProgFilesTable;
      }
      catch (Exception ex)
      {
        throw new Exception("ProgFiles tabel error. Maybe old table format", ex);
      }
    }

    private void DataGridOverview_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      this.ignoreEditChanges = true;
      try
      {
        if (this.DataGridOverview.SelectedItem == null)
          return;
        this.ClearEditBoxes();
        HardwareTypeTables.ProgFilesRow row = (HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
        this.firmwareVersionUnchanged = row.IsFirmwareVersionNull() ? (!this.PreDefinedFirmwareVersion.HasValue ? "" : this.PreDefinedFirmwareVersion.Value.ToString("x08")) : row.FirmwareVersion.ToString("x08");
        if (this.TextBoxFirmwareVersion.Text != this.firmwareVersionUnchanged)
          this.TextBoxFirmwareVersion.Text = this.firmwareVersionUnchanged;
        if (!row.IsReleasedNameNull())
          this.TextBoxReleasedName.Text = row.ReleasedName;
        if (!row.IsCompatibleOverwriteGroupsNull())
          this.TextBoxCompatibleOverwriteGroups.Text = row.CompatibleOverwriteGroups;
        if (!row.IsOptionsNull())
        {
          List<KeyValuePair<string, string>> keyValuePairList = DbUtil.KeyValueStringListToKeyValuePairList(row.Options);
          this.CheckBoxNoCompression.IsChecked = new bool?(keyValuePairList.FindIndex((Predicate<KeyValuePair<string, string>>) (x => x.Key == "Compression")) < 0);
          this.TextBoxOptions.Text = DbUtil.KeyValuePairListToKeyValueStringList(keyValuePairList);
        }
        if (!row.IsSourceInfoNull())
          this.TextBoxSourceInfo.Text = row.SourceInfo;
        if (!row.IsReleaseCommentsNull())
          this.TextBoxReleaseComments.Text = row.ReleaseComments;
        this.TextBoxFirmwareDependencies.Text = this.GetDependenciesText(row);
        this.StackPanelEditBoxes.IsEnabled = true;
        this.TextBoxReleaseComments.IsEnabled = true;
      }
      finally
      {
        this.CheckDataChanged(true);
        this.ignoreEditChanges = false;
      }
    }

    private string GetDependenciesText(HardwareTypeTables.ProgFilesRow progFilesRow)
    {
      string dependenciesText = "";
      if (!progFilesRow.IsFirmwareDependenciesNull())
      {
        if (progFilesRow.HardwareName != "Bootloader")
        {
          dependenciesText = progFilesRow.FirmwareDependencies;
        }
        else
        {
          StringBuilder stringBuilder = new StringBuilder();
          string firmwareDependencies = progFilesRow.FirmwareDependencies;
          char[] separator = new char[1]{ ';' };
          foreach (string versionString in firmwareDependencies.Split(separator, StringSplitOptions.RemoveEmptyEntries))
          {
            FirmwareVersion firmwareVersion = new FirmwareVersion(versionString);
            stringBuilder.Append(";" + firmwareVersion.ToString());
          }
          if (stringBuilder.Length > 0)
          {
            stringBuilder.Append(";");
            dependenciesText = stringBuilder.ToString();
          }
        }
      }
      return dependenciesText;
    }

    private void ClearEditBoxes()
    {
      this.TextBoxReleasedName.Clear();
      this.TextBoxCompatibleOverwriteGroups.Clear();
      this.TextBoxOptions.Clear();
      this.TextBoxSourceInfo.Clear();
      this.TextBoxReleaseComments.Clear();
    }

    private void ButtonSaveChanges_Click(object sender, RoutedEventArgs e)
    {
      DbBasis.PrimaryDB.BaseDbConnection.ExceptionIfNoSvnDatabase();
      try
      {
        this.CompareStates.Clear();
        if (this.DataGridOverview.SelectedItem == null)
          return;
        HardwareTypeTables.ProgFilesRow row = (HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
        this.SetDataFromEditFields(row);
        this.ProgFilesDataAdapter.Update((DataTable) this.ProgFilesTable);
        this.LoadData();
        this.SetSelectedRowFromVersion(row.FirmwareVersion);
        int num = (int) MessageBox.Show("Data saved");
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonDeleteSelectedFirmware_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.CompareStates.Clear();
        if (this.DataGridOverview.SelectedItem == null)
          return;
        ((DataRowView) this.DataGridOverview.SelectedItem).Row.Delete();
        this.ProgFilesDataAdapter.Update((DataTable) this.ProgFilesTable);
        this.LoadData();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonDeleteSelectedFirmwareFile_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.CompareStates.Clear();
        if (this.DataGridOverview.SelectedItem == null)
          return;
        HardwareTypeTables.ProgFilesRow row = (HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
        row.SetProgFileNameNull();
        row.SetHexTextNull();
        this.ProgFilesDataAdapter.Update((DataTable) this.ProgFilesTable);
        this.LoadData();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonAddFirmware_Click(object sender, RoutedEventArgs e)
    {
      DbBasis.PrimaryDB.BaseDbConnection.ExceptionIfNoSvnDatabase();
      try
      {
        this.CompareStates.Clear();
        int newId = DbBasis.PrimaryDB.BaseDbConnection.GetNewId("ProgFiles");
        HardwareTypeTables.ProgFilesRow progFilesRow = this.ProgFilesTable.NewProgFilesRow();
        progFilesRow.MapID = newId;
        progFilesRow.HardwareTypeMapID = this.CommonMapID;
        progFilesRow.HardwareName = this.HardwareName;
        this.SetDataFromEditFields(progFilesRow);
        progFilesRow.SourceInfo = new FirmwareVersion((uint) progFilesRow.FirmwareVersion).ToString();
        this.ProgFilesTable.AddProgFilesRow(progFilesRow);
        this.ProgFilesDataAdapter.Update((DataTable) this.ProgFilesTable);
        this.LoadData();
        this.SetSelectedRowFromVersion(progFilesRow.FirmwareVersion);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void SetDataFromEditFields(HardwareTypeTables.ProgFilesRow theRow)
    {
      theRow.Options = string.IsNullOrEmpty(this.TextBoxOptions.Text) ? "" : this.GetOptionsString();
      theRow.FirmwareVersion = int.Parse(this.TextBoxFirmwareVersion.Text, NumberStyles.HexNumber);
      if (!string.IsNullOrEmpty(this.TextBoxReleasedName.Text))
        theRow.ReleasedName = this.TextBoxReleasedName.Text;
      else
        theRow.SetReleasedNameNull();
      if (!string.IsNullOrEmpty(this.TextBoxReleaseComments.Text))
        theRow.ReleaseComments = this.TextBoxReleaseComments.Text;
      else
        theRow.SetReleaseCommentsNull();
      if (!string.IsNullOrEmpty(this.TextBoxFirmwareDependencies.Text))
      {
        if (theRow.HardwareName == "Bootloader")
        {
          StringBuilder stringBuilder = new StringBuilder();
          string text = this.TextBoxFirmwareDependencies.Text;
          char[] separator = new char[1]{ ';' };
          foreach (string versionString in text.Split(separator, StringSplitOptions.RemoveEmptyEntries))
          {
            FirmwareVersion firmwareVersion = new FirmwareVersion(versionString);
            stringBuilder.Append(";" + firmwareVersion.Version.ToString("x08"));
          }
          if (stringBuilder.Length > 0)
            theRow.FirmwareDependencies = stringBuilder.ToString() + ";";
          else
            theRow.SetFirmwareDependenciesNull();
        }
        else
          theRow.FirmwareDependencies = this.TextBoxFirmwareDependencies.Text;
      }
      else
        theRow.SetFirmwareDependenciesNull();
      if (!string.IsNullOrEmpty(this.TextBoxCompatibleOverwriteGroups.Text))
        theRow.CompatibleOverwriteGroups = this.TextBoxCompatibleOverwriteGroups.Text;
      else
        theRow.SetCompatibleOverwriteGroupsNull();
    }

    private void ChangeSelectedIndex(int newIndex)
    {
      if (this.DataGridOverview.SelectedIndex == newIndex)
        return;
      this.ignoreEditChanges = true;
      this.DataGridOverview.SelectedIndex = newIndex;
      this.ignoreEditChanges = false;
    }

    private void CheckDataChanged(bool afterSelectionCheck = false)
    {
      string str = (string) null;
      bool flag = true;
      try
      {
        if (this.TextBoxFirmwareVersion.Text.Length != 8)
        {
          str = "Illegal firmware length. 8 digits required.";
          this.ChangeSelectedIndex(-1);
          goto label_40;
        }
        else
        {
          str = "Illegal firmware value";
          uint versionValue = uint.Parse(this.TextBoxFirmwareVersion.Text, NumberStyles.HexNumber);
          str = "Illegal new firmware struct";
          FirmwareVersion firmwareVersion1 = new FirmwareVersion(versionValue);
          str = "";
          flag = false;
          if (this.DataGridOverview.SelectedItem == null)
          {
            str = "New firmware";
            goto label_40;
          }
          else
          {
            str = "Illegal old firmware struct";
            FirmwareVersion firmwareVersion2 = new FirmwareVersion(uint.Parse(this.firmwareVersionUnchanged, NumberStyles.HexNumber));
            if (this.newRowCreated)
            {
              str = "Data created.";
              goto label_40;
            }
            else
            {
              int newIndex = -1;
              HardwareTypeTables.ProgFilesRow[] progFilesRowArray = (HardwareTypeTables.ProgFilesRow[]) this.ProgFilesTable.Select("FirmwareVersion = " + versionValue.ToString());
              if (progFilesRowArray.Length != 0)
              {
                for (int index = 0; index < progFilesRowArray.Length; ++index)
                {
                  if (((DataRowView) this.DataGridOverview.SelectedItem).Row == progFilesRowArray[index])
                  {
                    newIndex = this.DataGridOverview.SelectedIndex;
                    break;
                  }
                }
              }
              this.ChangeSelectedIndex(newIndex);
            }
          }
        }
      }
      catch (Exception ex)
      {
        str = str + "; " + ex.Message;
        goto label_40;
      }
      HardwareTypeTables.ProgFilesRow row1 = (HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
      if (row1.IsOptionsNull())
      {
        if (this.TextBoxOptions.Text != "")
          goto label_40;
      }
      else if (!afterSelectionCheck && row1.Options != this.TextBoxOptions.Text)
        goto label_40;
      int result;
      if (this.TextBoxFirmwareVersion.Text.Length == 8 && int.TryParse(this.TextBoxFirmwareVersion.Text, NumberStyles.HexNumber, (IFormatProvider) null, out result) && !row1.IsFirmwareVersionNull() && result == row1.FirmwareVersion)
      {
        if (row1.IsReleasedNameNull())
        {
          if (this.TextBoxReleasedName.Text != "")
            goto label_40;
        }
        else if (row1.ReleasedName != this.TextBoxReleasedName.Text)
          goto label_40;
        if (row1.IsReleaseCommentsNull())
        {
          if (this.TextBoxReleaseComments.Text != "")
            goto label_40;
        }
        else if (row1.ReleaseComments != this.TextBoxReleaseComments.Text)
          goto label_40;
        if (!(this.GetDependenciesText(row1) != this.TextBoxFirmwareDependencies.Text))
        {
          if (row1.IsCompatibleOverwriteGroupsNull())
          {
            if (this.TextBoxCompatibleOverwriteGroups.Text != "")
              goto label_40;
          }
          else if (row1.CompatibleOverwriteGroups != this.TextBoxCompatibleOverwriteGroups.Text)
            goto label_40;
          this.ButtonSaveChanges.IsEnabled = false;
          this.ButtonAddFirmware.IsEnabled = false;
          this.ButtonImportProgrammerFile.IsEnabled = true;
          if (!row1.IsProgFileNameNull() && row1.ProgFileName.Length > 0)
          {
            this.ButtonExportProgrammerFile.IsEnabled = true;
            this.ButtonShowProgrammerFile.IsEnabled = true;
          }
          else
          {
            this.ButtonExportProgrammerFile.IsEnabled = false;
            this.ButtonShowProgrammerFile.IsEnabled = false;
          }
          this.ButtonDeleteSelectedFirmwareFile.IsEnabled = true;
          if (row1.IsHardwareTypeMapIDNull() || row1.HardwareTypeMapID == row1.MapID)
            this.ButtonDeleteSelectedFirmware.IsEnabled = false;
          else
            this.ButtonDeleteSelectedFirmware.IsEnabled = true;
          this.ButtonCompareSelected.IsEnabled = true;
          this.ButtonCompareAll.IsEnabled = true;
          if (!this.CompareStates.ContainsKey(row1.MapID) || this.CompareStates[row1.MapID] == CompatibleFirmwareWindow.RowCompareState.equal)
            this.ButtonCopySelected.IsEnabled = false;
          else
            this.ButtonCopySelected.IsEnabled = true;
          this.LabelStatus.Content = (object) "No changes";
          return;
        }
      }
label_40:
      this.ButtonCompareSelected.IsEnabled = false;
      this.ButtonCompareAll.IsEnabled = false;
      this.ButtonCopySelected.IsEnabled = false;
      if (flag)
      {
        this.ButtonSaveChanges.IsEnabled = false;
        this.ButtonAddFirmware.IsEnabled = false;
      }
      else if (this.newRowCreated)
      {
        this.ButtonSaveChanges.IsEnabled = true;
        this.ButtonAddFirmware.IsEnabled = false;
      }
      else if (this.DataGridOverview.SelectedItem != null)
      {
        HardwareTypeTables.ProgFilesRow row2 = (HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
        if (row2.IsOptionsNull())
        {
          if (this.TextBoxOptions.Text.Trim().Length > 0)
            this.ButtonAddFirmware.IsEnabled = true;
          else
            this.ButtonAddFirmware.IsEnabled = false;
        }
        else if (row2.Options != this.TextBoxOptions.Text.Trim())
          this.ButtonAddFirmware.IsEnabled = true;
        else
          this.ButtonAddFirmware.IsEnabled = false;
        this.ButtonSaveChanges.IsEnabled = true;
      }
      else
      {
        this.ButtonSaveChanges.IsEnabled = false;
        this.ButtonAddFirmware.IsEnabled = true;
      }
      this.ButtonImportProgrammerFile.IsEnabled = false;
      this.ButtonExportProgrammerFile.IsEnabled = false;
      this.ButtonShowProgrammerFile.IsEnabled = false;
      this.ButtonDeleteSelectedFirmware.IsEnabled = false;
      this.ButtonDeleteSelectedFirmwareFile.IsEnabled = false;
      if (str != null)
        this.LabelStatus.Content = (object) str;
      else
        this.LabelStatus.Content = (object) "";
    }

    private string GetOptionsString()
    {
      List<KeyValuePair<string, string>> keyValuePairList = DbUtil.KeyValueStringListToKeyValuePairList(this.TextBoxOptions.Text);
      int index = keyValuePairList.FindIndex((Predicate<KeyValuePair<string, string>>) (x => x.Key == "Compression"));
      if (index >= 0)
        keyValuePairList.RemoveAt(index);
      if (!this.CheckBoxNoCompression.IsChecked.Value)
        keyValuePairList.Add(new KeyValuePair<string, string>("Compression", "ZIP"));
      return DbUtil.KeyValuePairListToKeyValueStringList(keyValuePairList);
    }

    private void ButtonImportProgrammerFile_Click(object sender, RoutedEventArgs e)
    {
      this.ChangeProgrammerFile();
      this.CompareStates.Clear();
    }

    private void ButtonExportProgrammerFile_Click(object sender, RoutedEventArgs e)
    {
      if (this.DataGridOverview.SelectedItem == null)
        return;
      try
      {
        FirmwareData firmwareData = HardwareTypeSupport.GetFirmwareData((uint) ((HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row).MapID);
        if (firmwareData == null || firmwareData.ProgrammerFileAsString == null)
        {
          int num = (int) MessageBox.Show("No data in database");
        }
        else
        {
          SaveFileDialog saveFileDialog = new SaveFileDialog();
          saveFileDialog.Filter = "All files (*.*)|*.*";
          saveFileDialog.FilterIndex = 1;
          saveFileDialog.RestoreDirectory = true;
          if (!string.IsNullOrEmpty(firmwareData.ProgFileName))
            saveFileDialog.FileName = firmwareData.ProgFileName;
          if (!saveFileDialog.ShowDialog().Value)
            return;
          firmwareData.WriteToFile(saveFileDialog.FileName);
        }
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show(ex.Message, "Change programmer file error");
      }
    }

    private void ButtonShowProgrammerFile_Click(object sender, RoutedEventArgs e)
    {
      if (this.DataGridOverview.SelectedItem == null)
        return;
      try
      {
        FirmwareData firmwareData = HardwareTypeSupport.GetFirmwareData((uint) ((HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row).MapID);
        if (firmwareData == null || firmwareData.ProgrammerFileAsString == null)
        {
          int num = (int) MessageBox.Show("No data in database");
        }
        else
          GmmMessage.Show_Ok(firmwareData.ProgrammerFileAsString);
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show(ex.Message, "Show programmer file error");
      }
    }

    private void ChangeProgrammerFile()
    {
      DbBasis.PrimaryDB.BaseDbConnection.ExceptionIfNoSvnDatabase();
      if (this.DataGridOverview.SelectedItem == null)
        return;
      HardwareTypeTables.ProgFilesRow row1 = (HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
      try
      {
        OpenFileDialog openFileDialog = new OpenFileDialog();
        openFileDialog.Filter = "All files (*.*)|*.*";
        openFileDialog.FilterIndex = 1;
        openFileDialog.RestoreDirectory = true;
        if (!openFileDialog.ShowDialog().Value)
          return;
        string end;
        using (StreamReader streamReader = new StreamReader(openFileDialog.FileName))
          end = streamReader.ReadToEnd();
        using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          List<KeyValuePair<string, string>> keyValuePairList = DbUtil.KeyValueStringListToKeyValuePairList(this.TextBoxOptions.Text);
          int index = keyValuePairList.FindIndex((Predicate<KeyValuePair<string, string>>) (x => x.Key == "Compression"));
          if (index >= 0)
            keyValuePairList.RemoveAt(index);
          bool? isChecked = this.CheckBoxNoCompression.IsChecked;
          if (!isChecked.Value)
            keyValuePairList.Add(new KeyValuePair<string, string>("Compression", "ZIP"));
          string keyValueStringList = DbUtil.KeyValuePairListToKeyValueStringList(keyValuePairList);
          string selectSql1 = "SELECT * FROM ProgFiles WHERE MapID = " + row1.MapID.ToString();
          DbCommandBuilder commandBuilder;
          DbDataAdapter dataAdapter1 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(selectSql1, newConnection, out commandBuilder);
          HardwareTypeTables.ProgFilesDataTable progFilesDataTable1 = new HardwareTypeTables.ProgFilesDataTable();
          dataAdapter1.Fill((DataTable) progFilesDataTable1);
          HardwareTypeTables.ProgFilesRow row2;
          if (progFilesDataTable1.Count > 0)
          {
            row2 = progFilesDataTable1[0];
            if (keyValueStringList != row2.Options)
            {
              if (MessageBox.Show("old Options:" + Environment.NewLine + row2.Options + Environment.NewLine + Environment.NewLine + "new Options:" + Environment.NewLine + keyValueStringList + Environment.NewLine + Environment.NewLine + "Change to new options?", "Change ProgFiles Options", MessageBoxButton.OKCancel) != MessageBoxResult.OK)
                return;
            }
            row2.Options = keyValueStringList;
          }
          else
          {
            row2 = progFilesDataTable1.NewProgFilesRow();
            row2.MapID = row1.MapID;
            row2.Options = keyValueStringList;
            progFilesDataTable1.AddProgFilesRow(row2);
          }
          isChecked = this.CheckBoxNoCompression.IsChecked;
          row2.HexText = isChecked.Value ? end : ZipUnzip.GetZipedStringFromString(end);
          string fileName = Path.GetFileName(openFileDialog.FileName);
          row2.ProgFileName = fileName;
          if (!row1.IsFirmwareVersionNull())
          {
            FirmwareVersion firmwareVersion = new FirmwareVersion((uint) row1.FirmwareVersion);
            row2.SourceInfo = firmwareVersion.ToString() + "; " + DateTime.Now.ToShortDateString() + " " + DateTime.Now.ToShortTimeString();
          }
          dataAdapter1.Update((DataTable) progFilesDataTable1);
          string selectSql2 = "SELECT * FROM ProgFiles WHERE MapID = " + row1.MapID.ToString();
          DbDataAdapter dataAdapter2 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(selectSql2, newConnection, out commandBuilder);
          HardwareTypeTables.ProgFilesDataTable progFilesDataTable2 = new HardwareTypeTables.ProgFilesDataTable();
          dataAdapter2.Fill((DataTable) progFilesDataTable2);
          isChecked = this.CheckBoxNoCompression.IsChecked;
          if (isChecked.Value)
          {
            if (progFilesDataTable2[0].HexText != end)
              throw new Exception("VERIFY creates an error");
          }
          else if (ZipUnzip.GetStringFromZipedString(progFilesDataTable2[0].HexText) != end)
            throw new Exception("Zip-Unzip VERIFY creates an error");
          int num = (int) MessageBox.Show("Programer file changed");
          this.LoadData();
        }
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex, "Change programmer file error");
      }
    }

    private void ButtonUseFirmwareFromHandler_Click(object sender, RoutedEventArgs e)
    {
      this.TextBoxFirmwareVersion.Text = this.TextBoxFirmwareFromHandler.Text;
    }

    private void CheckBoxNoCompression_Checked(object sender, RoutedEventArgs e)
    {
      this.TextBoxOptions.Text = this.GetOptionsString();
    }

    private void TextBox_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.ignoreEditChanges)
        return;
      this.CheckDataChanged();
    }

    private void ButtonPrepareTable_Click(object sender, RoutedEventArgs e) => this.PrepareTable();

    private void PrepareTable()
    {
      int num = 0;
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.Append("SELECT HardwareTypeID, MapID, FirmwareVersion, HardwareName, HardwareResource FROM HardwareType");
      DbDataAdapter dataAdapter1 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), this.myDbConnection);
      HardwareTypeTables.HardwareTypeDataTable hardwareTypeDataTable = new HardwareTypeTables.HardwareTypeDataTable();
      dataAdapter1.Fill((DataTable) hardwareTypeDataTable);
      stringBuilder.Clear();
      stringBuilder.Append("SELECT MapID, FirmwareVersion, HardwareName, Options, HardwareTypeMapID, CompatibleOverwriteGroups, ReleasedName, FirmwareDependencies");
      stringBuilder.Append(" FROM ProgFiles");
      DbDataAdapter dataAdapter2 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), this.myDbConnection, out DbCommandBuilder _);
      HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
      dataAdapter2.Fill((DataTable) progFilesDataTable);
      foreach (HardwareTypeTables.ProgFilesRow progFilesRow in (TypedTableBase<HardwareTypeTables.ProgFilesRow>) progFilesDataTable)
      {
        if (progFilesRow.IsFirmwareVersionNull() || progFilesRow.IsHardwareNameNull())
        {
          HardwareTypeTables.HardwareTypeRow[] hardwareTypeRowArray = (HardwareTypeTables.HardwareTypeRow[]) hardwareTypeDataTable.Select("MapID = " + progFilesRow.MapID.ToString());
          if (hardwareTypeRowArray.Length != 0)
          {
            if (!hardwareTypeRowArray[0].IsFirmwareVersionNull())
            {
              progFilesRow.FirmwareVersion = hardwareTypeRowArray[0].FirmwareVersion;
              ++num;
            }
            if (!hardwareTypeRowArray[0].IsHardwareNameNull())
            {
              progFilesRow.HardwareName = hardwareTypeRowArray[0].HardwareName;
              ++num;
            }
          }
        }
        if (progFilesRow.IsHardwareTypeMapIDNull())
        {
          progFilesRow.HardwareTypeMapID = progFilesRow.MapID;
          ++num;
        }
        if (!progFilesRow.IsOptionsNull() && progFilesRow.IsReleasedNameNull() && progFilesRow.IsCompatibleOverwriteGroupsNull())
        {
          List<KeyValuePair<string, string>> keyValuePairList = DbUtil.KeyValueStringListToKeyValuePairList(progFilesRow.Options);
          string valueForKey1 = DbUtil.GetValueForKey("Released", keyValuePairList);
          if (valueForKey1 != null)
          {
            string str = valueForKey1.Replace(";", "");
            if (str.ToUpper() != "NO" && str.ToUpper() != "OLD")
            {
              progFilesRow.ReleasedName = str;
              ++num;
            }
          }
          string valueForKey2 = DbUtil.GetValueForKey("CompatibleMapId", keyValuePairList);
          if (valueForKey2 != null)
          {
            progFilesRow.CompatibleOverwriteGroups = valueForKey2;
            ++num;
          }
        }
        if (!progFilesRow.IsHardwareNameNull() && progFilesRow.HardwareName == "Bootloader" && progFilesRow.IsFirmwareDependenciesNull())
        {
          HardwareTypeTables.HardwareTypeRow[] hardwareTypeRowArray = (HardwareTypeTables.HardwareTypeRow[]) hardwareTypeDataTable.Select("MapID = " + progFilesRow.MapID.ToString());
          if (hardwareTypeRowArray.Length == 1 && !hardwareTypeRowArray[0].IsHardwareResourceNull())
          {
            progFilesRow.FirmwareDependencies = hardwareTypeRowArray[0].HardwareResource;
            ++num;
          }
        }
      }
      dataAdapter2.Update((DataTable) progFilesDataTable);
      GmmMessage.Show_Ok("Table prepared. Values copied: " + num.ToString());
      this.LoadData();
    }

    private void ButtonCompareSelected_Click(object sender, RoutedEventArgs e)
    {
      StringBuilder message = new StringBuilder();
      try
      {
        if (this.DataGridOverview.SelectedItem == null)
          return;
        this.GuarantDatabasesAndGetInfo(message);
        message.AppendLine("*** Compare result ***");
        HardwareTypeTables.ProgFilesRow row = (HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
        using (DbConnection newConnection = DbBasis.SecondaryDB.BaseDbConnection.GetNewConnection())
          this.GetCompareData(row, newConnection, message);
        this.LoadData();
        this.SetSelectedRowFromVersion(row.FirmwareVersion);
        GmmMessage.Show_Ok(message.ToString());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonCompareAll_Click(object sender, RoutedEventArgs e)
    {
      StringBuilder message = new StringBuilder();
      try
      {
        this.GuarantDatabasesAndGetInfo(message);
        message.AppendLine("*** Compare result ***");
        HardwareTypeTables.ProgFilesRow row1 = (HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
        using (DbConnection newConnection = DbBasis.SecondaryDB.BaseDbConnection.GetNewConnection())
        {
          foreach (DataRowView dataRowView in (IEnumerable) this.DataGridOverview.Items)
          {
            HardwareTypeTables.ProgFilesRow row2 = (HardwareTypeTables.ProgFilesRow) dataRowView.Row;
            message.AppendLine("MapID: " + row2.MapID.ToString());
            this.GetCompareData(row2, newConnection, message);
            message.AppendLine();
          }
        }
        this.LoadData();
        this.SetSelectedRowFromVersion(row1.FirmwareVersion);
        GmmMessage.Show_Ok(message.ToString());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonCopySelected_Click(object sender, RoutedEventArgs e)
    {
      StringBuilder message = new StringBuilder();
      try
      {
        this.GuarantDatabasesAndGetInfo(message);
        HardwareTypeTables.ProgFilesRow row1 = (HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
        using (DbConnection newConnection = DbBasis.SecondaryDB.BaseDbConnection.GetNewConnection())
        {
          string selectSql = "SELECT * FROM ProgFiles WHERE MapID = " + row1.MapID.ToString();
          DbDataAdapter dataAdapter1 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(selectSql, this.myDbConnection);
          HardwareTypeTables.ProgFilesDataTable progFilesDataTable1 = new HardwareTypeTables.ProgFilesDataTable();
          dataAdapter1.Fill((DataTable) progFilesDataTable1);
          DbDataAdapter dataAdapter2 = DbBasis.SecondaryDB.BaseDbConnection.GetDataAdapter(selectSql, newConnection, out DbCommandBuilder _);
          HardwareTypeTables.ProgFilesDataTable progFilesDataTable2 = new HardwareTypeTables.ProgFilesDataTable();
          dataAdapter2.Fill((DataTable) progFilesDataTable2);
          HardwareTypeTables.ProgFilesRow progFilesRow = progFilesDataTable1.Count == 1 ? progFilesDataTable1[0] : throw new Exception("Could not load primary data");
          HardwareTypeTables.ProgFilesRow row2;
          if (progFilesDataTable2.Count == 1)
            row2 = progFilesDataTable2[0];
          else
            row2 = progFilesDataTable2.Count == 0 ? progFilesDataTable2.NewProgFilesRow() : throw new Exception("Illegal nubers of secondary rows");
          foreach (DataColumn column in (InternalDataCollectionBase) row1.Table.Columns)
            row2[column.ColumnName] = progFilesRow[column.ColumnName];
          if (progFilesDataTable2.Count == 0)
            progFilesDataTable2.AddProgFilesRow(row2);
          dataAdapter2.Update((DataTable) progFilesDataTable2);
          message.AppendLine("Copy done.");
        }
        this.CompareStates[row1.MapID] = CompatibleFirmwareWindow.RowCompareState.equal;
        this.LoadData();
        this.SetSelectedRowFromVersion(row1.FirmwareVersion);
        GmmMessage.Show_Ok(message.ToString());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void GetCompareData(
      HardwareTypeTables.ProgFilesRow progFilesRow,
      DbConnection secDbConnection,
      StringBuilder message)
    {
      if (!this.CompareStates.ContainsKey(progFilesRow.MapID))
        this.CompareStates.Add(progFilesRow.MapID, CompatibleFirmwareWindow.RowCompareState.equal);
      else
        this.CompareStates[progFilesRow.MapID] = CompatibleFirmwareWindow.RowCompareState.equal;
      string selectSql = "SELECT * FROM ProgFiles WHERE MapID = " + progFilesRow.MapID.ToString();
      DbDataAdapter dataAdapter1 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(selectSql, this.myDbConnection);
      HardwareTypeTables.ProgFilesDataTable progFilesDataTable1 = new HardwareTypeTables.ProgFilesDataTable();
      dataAdapter1.Fill((DataTable) progFilesDataTable1);
      DbDataAdapter dataAdapter2 = DbBasis.SecondaryDB.BaseDbConnection.GetDataAdapter(selectSql, secDbConnection);
      HardwareTypeTables.ProgFilesDataTable progFilesDataTable2 = new HardwareTypeTables.ProgFilesDataTable();
      dataAdapter2.Fill((DataTable) progFilesDataTable2);
      if (progFilesDataTable1.Count != 1)
        throw new Exception("Could not load primary data");
      if (progFilesDataTable2.Count != 1)
      {
        this.CompareStates[progFilesRow.MapID] = CompatibleFirmwareWindow.RowCompareState.notAvailable;
        message.AppendLine("Second data not available");
      }
      else
      {
        foreach (DataColumn column in (InternalDataCollectionBase) progFilesRow.Table.Columns)
        {
          if (progFilesDataTable1[0][column.ColumnName] == DBNull.Value)
          {
            if (progFilesDataTable2[0][column.ColumnName] != DBNull.Value)
            {
              this.CompareStates[progFilesRow.MapID] = CompatibleFirmwareWindow.RowCompareState.different;
              message.AppendLine("Column: " + column.ColumnName + " -> PrimaryDB data not available");
            }
          }
          else if (progFilesDataTable2[0][column.ColumnName] == DBNull.Value)
          {
            this.CompareStates[progFilesRow.MapID] = CompatibleFirmwareWindow.RowCompareState.different;
            message.AppendLine("Column: " + column.ColumnName + " -> SecondaryDB data not available");
          }
          else
          {
            string str1 = progFilesDataTable1[0][column.ColumnName].ToString();
            string str2 = progFilesDataTable2[0][column.ColumnName].ToString();
            if (str2 != str1)
            {
              this.CompareStates[progFilesRow.MapID] = CompatibleFirmwareWindow.RowCompareState.different;
              message.AppendLine("Column: " + column.ColumnName + " -> Data different.");
              if (str1.Length < 100 && str2.Length < 100)
              {
                message.AppendLine("   Primary: " + str1);
                message.AppendLine("   Secondary: " + str2);
              }
            }
          }
        }
      }
      if (this.CompareStates[progFilesRow.MapID] != CompatibleFirmwareWindow.RowCompareState.equal)
        return;
      message.AppendLine("Data are equal");
      this.CompareStates[progFilesRow.MapID] = CompatibleFirmwareWindow.RowCompareState.equal;
    }

    private void GuarantDatabasesAndGetInfo(StringBuilder message)
    {
      if (!PlugInLoader.InitSecundaryDatabase())
        throw new Exception("Error on loading secondary database");
      message.AppendLine("*** Primary database ***");
      message.AppendLine(DbBasis.PrimaryDB.BaseDbConnection.GetDatabaseInfo(">"));
      message.AppendLine("*** Secondary database ***");
      message.AppendLine(DbBasis.SecondaryDB.BaseDbConnection.GetDatabaseInfo(">"));
    }

    private void DataGridOverview_LoadingRow(object sender, DataGridRowEventArgs e)
    {
      HardwareTypeTables.ProgFilesRow row = (HardwareTypeTables.ProgFilesRow) ((DataRowView) e.Row.DataContext).Row;
      if (!this.CompareStates.ContainsKey(row.MapID))
        return;
      switch (this.CompareStates[row.MapID])
      {
        case CompatibleFirmwareWindow.RowCompareState.checkError:
          e.Row.Background = (Brush) Brushes.Red;
          break;
        case CompatibleFirmwareWindow.RowCompareState.equal:
          e.Row.Background = (Brush) Brushes.LightGreen;
          break;
        case CompatibleFirmwareWindow.RowCompareState.different:
          e.Row.Background = (Brush) Brushes.Yellow;
          break;
        case CompatibleFirmwareWindow.RowCompareState.notAvailable:
          e.Row.Background = (Brush) Brushes.Orange;
          break;
      }
    }

    private void ButtonClearReleased_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        if (this.DataGridOverview.SelectedItem == null)
          return;
        this.CompareStates.Clear();
        this.TextBoxReleasedName.Clear();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonSetReleased_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        if (this.DataGridOverview.SelectedItem == null)
          return;
        this.CompareStates.Clear();
        HardwareTypeTables.ProgFilesRow row = (HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
        this.TextBoxReleasedName.Text = "Released for production";
        foreach (HardwareTypeTables.ProgFilesRow progFilesRow in (TypedTableBase<HardwareTypeTables.ProgFilesRow>) this.ProgFilesTable)
        {
          if (progFilesRow != row && !progFilesRow.IsReleasedNameNull() && progFilesRow.ReleasedName == "Released for production")
            progFilesRow.SetReleasedNameNull();
        }
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void TextBoxFirmwareDependencies_MouseDoubleClick(object sender, MouseButtonEventArgs e)
    {
      this.doSelectFirmwareForBootloader();
    }

    private void ButtonFirmwareDependencies_Click(object sender, RoutedEventArgs e)
    {
      this.doSelectFirmwareForBootloader();
    }

    private void doSelectFirmwareForBootloader()
    {
      List<string> source = new List<string>();
      List<string> dependencysCleanUp = new List<string>();
      string str1 = string.Empty;
      bool flag = this.CheckBoxFirmwareDependenciesCleanUp.IsChecked.HasValue && this.CheckBoxFirmwareDependenciesCleanUp.IsChecked.Value;
      HardwareTypeTables.ProgFilesRow row1 = (HardwareTypeTables.ProgFilesRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
      if (!row1.IsNull("FirmwareDependencies") && !string.IsNullOrEmpty(row1.Field<string>("FirmwareDependencies")))
      {
        str1 = row1.Field<string>("FirmwareDependencies").ToUpper();
        source = ((IEnumerable<string>) str1.Split(';')).ToList<string>();
      }
      string selectSql = "SELECT HardwareName, FirmwareVersion, FirmwareDependencies FROM ProgFiles WHERE HardwareName not like '%bootloader%' ORDER BY HardwareName, FirmwareVersion";
      DataTable dataTable = new DataTable();
      dataTable.Clear();
      dataTable.Columns.Add("HardwareName", typeof (string));
      dataTable.Columns.Add("FirmwareVersion", typeof (int));
      dataTable.Columns.Add("FirmwareDependencies", typeof (string));
      DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(selectSql, this.myDbConnection).Fill(dataTable);
      DataTable dependencyFW = new DataTable();
      dependencyFW.Clear();
      dependencyFW.Columns.Add("selected", typeof (bool));
      dependencyFW.Columns.Add("version", typeof (uint));
      dependencyFW.Columns.Add("version_X8", typeof (string));
      dependencyFW.Columns.Add("name", typeof (string));
      foreach (DataRow row2 in (InternalDataCollectionBase) dataTable.Rows)
      {
        uint num = row2.IsNull("FirmwareVersion") ? 0U : (uint) row2.Field<int>("FirmwareVersion");
        if (num > 0U)
        {
          string str2 = num.ToString("X8");
          DataRow row3 = dependencyFW.NewRow();
          row3["selected"] = (object) str1.ToUpper().Contains(str2.ToUpper());
          row3["version"] = (object) num;
          row3["version_X8"] = (object) str2;
          row3["name"] = (object) row2.Field<string>("HardwareName");
          dependencyFW.Rows.Add(row3);
        }
      }
      new CompatibleFirmwareSelectWindow((Window) this, ref dependencyFW).ShowDialog();
      dependencysCleanUp.Clear();
      foreach (DataRow row4 in (InternalDataCollectionBase) dependencyFW.Rows)
      {
        string upper = row4.Field<string>("version_X8").ToUpper();
        if (source.Contains(upper) && !row4.Field<bool>("selected"))
          source.Remove(upper);
        if (!source.Contains(upper) && row4.Field<bool>("selected"))
          source.Add(upper);
        dependencysCleanUp.Add(upper);
      }
      if (flag)
        source = source.Where<string>((System.Func<string, bool>) (x => dependencysCleanUp.Contains(x))).ToList<string>();
      string str3 = string.Empty;
      string str4 = string.Empty;
      foreach (string versionString in source)
      {
        if (!string.IsNullOrEmpty(versionString))
        {
          str3 = str3 + versionString + ";";
          FirmwareVersion firmwareVersion = new FirmwareVersion(versionString);
          str4 = str4 + firmwareVersion.ToString() + ";";
        }
      }
      row1["FirmwareDependencies"] = (object) str3;
      row1.AcceptChanges();
      this.TextBoxFirmwareDependencies.Text = str4;
      this.UpdateLayout();
    }

    private void ButtonTableToExcel_Click(object sender, RoutedEventArgs e)
    {
      ExcelConnect excelConnect = new ExcelConnect();
      excelConnect.AddTable((DataTable) this.ProgFilesTable, "IUW firmware versions", false, false);
      excelConnect.ShowWorkbook();
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/hardwaremanagement/compatiblefirmwarewindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.StackPanelButtons = (StackPanel) target;
          break;
        case 2:
          this.ButtonPrepareTable = (Button) target;
          this.ButtonPrepareTable.Click += new RoutedEventHandler(this.ButtonPrepareTable_Click);
          break;
        case 3:
          this.ButtonImportProgrammerFile = (Button) target;
          this.ButtonImportProgrammerFile.Click += new RoutedEventHandler(this.ButtonImportProgrammerFile_Click);
          break;
        case 4:
          this.ButtonExportProgrammerFile = (Button) target;
          this.ButtonExportProgrammerFile.Click += new RoutedEventHandler(this.ButtonExportProgrammerFile_Click);
          break;
        case 5:
          this.ButtonTableToExcel = (Button) target;
          this.ButtonTableToExcel.Click += new RoutedEventHandler(this.ButtonTableToExcel_Click);
          break;
        case 6:
          this.ButtonShowProgrammerFile = (Button) target;
          this.ButtonShowProgrammerFile.Click += new RoutedEventHandler(this.ButtonShowProgrammerFile_Click);
          break;
        case 7:
          this.ButtonDeleteSelectedFirmware = (Button) target;
          this.ButtonDeleteSelectedFirmware.Click += new RoutedEventHandler(this.ButtonDeleteSelectedFirmware_Click);
          break;
        case 8:
          this.ButtonDeleteSelectedFirmwareFile = (Button) target;
          this.ButtonDeleteSelectedFirmwareFile.Click += new RoutedEventHandler(this.ButtonDeleteSelectedFirmwareFile_Click);
          break;
        case 9:
          this.ButtonAddFirmware = (Button) target;
          this.ButtonAddFirmware.Click += new RoutedEventHandler(this.ButtonAddFirmware_Click);
          break;
        case 10:
          this.ButtonSaveChanges = (Button) target;
          this.ButtonSaveChanges.Click += new RoutedEventHandler(this.ButtonSaveChanges_Click);
          break;
        case 11:
          this.ButtonCompareSelected = (Button) target;
          this.ButtonCompareSelected.Click += new RoutedEventHandler(this.ButtonCompareSelected_Click);
          break;
        case 12:
          this.ButtonCompareAll = (Button) target;
          this.ButtonCompareAll.Click += new RoutedEventHandler(this.ButtonCompareAll_Click);
          break;
        case 13:
          this.ButtonCopySelected = (Button) target;
          this.ButtonCopySelected.Click += new RoutedEventHandler(this.ButtonCopySelected_Click);
          break;
        case 14:
          this.BorderVersionFromHandler = (Border) target;
          break;
        case 15:
          this.TextBoxFirmwareFromHandler = (TextBox) target;
          break;
        case 16:
          this.ButtonUseFirmwareFromHandler = (Button) target;
          this.ButtonUseFirmwareFromHandler.Click += new RoutedEventHandler(this.ButtonUseFirmwareFromHandler_Click);
          break;
        case 17:
          this.StackPanelBottom = (StackPanel) target;
          break;
        case 18:
          this.LabelStatus = (Label) target;
          break;
        case 19:
          this.StackPanelEditBoxes = (StackPanel) target;
          break;
        case 20:
          this.TextBoxFirmwareVersion = (TextBox) target;
          this.TextBoxFirmwareVersion.TextChanged += new TextChangedEventHandler(this.TextBox_TextChanged);
          break;
        case 21:
          this.TextBoxReleasedName = (TextBox) target;
          this.TextBoxReleasedName.TextChanged += new TextChangedEventHandler(this.TextBox_TextChanged);
          break;
        case 22:
          this.ButtonClearReleased = (Button) target;
          this.ButtonClearReleased.Click += new RoutedEventHandler(this.ButtonClearReleased_Click);
          break;
        case 23:
          this.ButtonSetReleased = (Button) target;
          this.ButtonSetReleased.Click += new RoutedEventHandler(this.ButtonSetReleased_Click);
          break;
        case 24:
          this.TextBoxCompatibleOverwriteGroups = (TextBox) target;
          this.TextBoxCompatibleOverwriteGroups.TextChanged += new TextChangedEventHandler(this.TextBox_TextChanged);
          break;
        case 25:
          this.CheckBoxNoCompression = (CheckBox) target;
          this.CheckBoxNoCompression.Checked += new RoutedEventHandler(this.CheckBoxNoCompression_Checked);
          this.CheckBoxNoCompression.Unchecked += new RoutedEventHandler(this.CheckBoxNoCompression_Checked);
          break;
        case 26:
          this.TextBoxOptions = (TextBox) target;
          this.TextBoxOptions.TextChanged += new TextChangedEventHandler(this.TextBox_TextChanged);
          break;
        case 27:
          this.TextBoxSourceInfo = (TextBox) target;
          this.TextBoxSourceInfo.TextChanged += new TextChangedEventHandler(this.TextBox_TextChanged);
          break;
        case 28:
          this.TextBoxReleaseComments = (TextBox) target;
          this.TextBoxReleaseComments.TextChanged += new TextChangedEventHandler(this.TextBox_TextChanged);
          break;
        case 29:
          this.ButtonFirmwareDependencies = (Button) target;
          this.ButtonFirmwareDependencies.Click += new RoutedEventHandler(this.ButtonFirmwareDependencies_Click);
          break;
        case 30:
          this.CheckBoxFirmwareDependenciesCleanUp = (CheckBox) target;
          break;
        case 31:
          this.TextBoxFirmwareDependencies = (TextBox) target;
          this.TextBoxFirmwareDependencies.MouseDoubleClick += new MouseButtonEventHandler(this.TextBoxFirmwareDependencies_MouseDoubleClick);
          this.TextBoxFirmwareDependencies.TextChanged += new TextChangedEventHandler(this.TextBox_TextChanged);
          break;
        case 32:
          this.DataGridOverview = (DataGrid) target;
          this.DataGridOverview.SelectionChanged += new SelectionChangedEventHandler(this.DataGridOverview_SelectionChanged);
          this.DataGridOverview.LoadingRow += new EventHandler<DataGridRowEventArgs>(this.DataGridOverview_LoadingRow);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }

    private enum RowCompareState
    {
      checkError,
      equal,
      different,
      notAvailable,
    }
  }
}


--- ConfigurationParameterListSupport.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ConfigurationParameterListSupport
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;
using System.Text;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class ConfigurationParameterListSupport
  {
    private SortedList<OverrideID, ConfigurationParameter> InitialParameterList;
    private HashSet<OverrideID> WorkedParameters;

    public ConfigurationParameterListSupport(
      SortedList<OverrideID, ConfigurationParameter> parameterList)
    {
      this.InitialParameterList = parameterList;
      this.WorkedParameters = new HashSet<OverrideID>();
    }

    public ConfigurationParameter GetWorkParameterFromList(OverrideID overrideID)
    {
      int index = this.InitialParameterList.IndexOfKey(overrideID);
      if (index < 0)
        return (ConfigurationParameter) null;
      if (this.WorkedParameters.Contains(overrideID))
        throw new Exception("Second work of ConfigurationParameter: " + overrideID.ToString());
      this.WorkedParameters.Add(overrideID);
      return this.InitialParameterList.Values[index];
    }

    public void CheckAllParametersWorked()
    {
      if (this.WorkedParameters.Count != this.InitialParameterList.Count)
      {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append("Not worked ConfigurationParameter: ");
        bool flag = true;
        foreach (OverrideID key in (IEnumerable<OverrideID>) this.InitialParameterList.Keys)
        {
          if (flag)
            flag = false;
          else
            stringBuilder.Append(",");
          if (!this.WorkedParameters.Contains(key))
            stringBuilder.Append(key.ToString());
        }
        throw new Exception(stringBuilder.ToString());
      }
    }
  }
}


--- ConfiguratorControl.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ConfiguratorControl
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommonWPF;
using GmmDbLib;
using HandlerLib.Properties;
using Microsoft.Win32;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class ConfiguratorControl : UserControl, IComponentConnector
  {
    private ProgressHandler progress;
    private IHandler handler;
    private bool dailyAutosaveOn = false;
    private List<ConfigurationLevel> AllowedLevels;
    private static string lastFilePath;
    internal TabControl tabCtrl;
    internal TabItem tab0;
    internal DataGrid DataGridParameterMain;
    internal TabItem tab1;
    internal DataGrid DataGridParameterSub1;
    internal TabItem tab2;
    internal DataGrid DataGridParameterSub2;
    internal TabItem tab3;
    internal DataGrid DataGridParameterSub3;
    internal Button ButtonSave;
    internal TextBlock TextBlockSave;
    internal ComboBox ComboBoxLevel;
    internal Button ButtonLoadValuesFromFile;
    internal Button ButtonRead;
    internal Button ButtonWrite;
    internal TextBox TextBlockParameterInfo;
    internal ProgressBar ProgressBar1;
    private bool _contentLoaded;

    public ConfiguratorControl()
    {
      this.InitializeComponent();
      WpfTranslatorSupport.TranslateUserControl(Tg.DeviceConfigurator, (UserControl) this);
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      else
        this.ProgressBar1.Value = obj.ProgressPercentage;
    }

    public void InitializeComponent(IHandler handler, bool showReadWriteButton = false)
    {
      this.handler = handler != null ? handler : throw new ArgumentNullException(nameof (handler));
      this.ProgressBar1.Visibility = Visibility.Hidden;
      this.tab0.Visibility = Visibility.Hidden;
      this.tab1.Visibility = Visibility.Hidden;
      this.tab2.Visibility = Visibility.Hidden;
      this.tab3.Visibility = Visibility.Hidden;
      this.tabCtrl.Visibility = Visibility.Hidden;
      if (!showReadWriteButton)
      {
        this.ButtonRead.Visibility = Visibility.Hidden;
        this.ButtonWrite.Visibility = Visibility.Hidden;
        if (UserManager.CheckPermission("Role\\Developer"))
          this.ButtonLoadValuesFromFile.Visibility = Visibility.Visible;
      }
      this.DataGridParameterMain.Tag = (object) null;
      this.DataGridParameterSub1.Tag = (object) null;
      this.DataGridParameterSub2.Tag = (object) null;
      this.DataGridParameterSub3.Tag = (object) null;
      this.AllowedLevels = new List<ConfigurationLevel>();
      if (UserManager.CheckPermission("Right\\ConfiguratorLevel\\Standard"))
        this.AllowedLevels.Add(ConfigurationLevel.Standard);
      if (UserManager.CheckPermission("Right\\ConfiguratorLevel\\Advanced"))
        this.AllowedLevels.Add(ConfigurationLevel.Advanced);
      if (UserManager.CheckPermission("Right\\ConfiguratorLevel\\Huge"))
        this.AllowedLevels.Add(ConfigurationLevel.Huge);
      if (UserManager.CheckPermission("Right\\ConfiguratorLevel\\Native"))
        this.AllowedLevels.Add(ConfigurationLevel.Native);
      if (this.AllowedLevels.Count == 0)
      {
        this.AllowedLevels.Add(ConfigurationLevel.Standard);
        this.AllowedLevels.Add(ConfigurationLevel.Advanced);
        this.AllowedLevels.Add(ConfigurationLevel.Huge);
        this.AllowedLevels.Add(ConfigurationLevel.Native);
      }
      this.ComboBoxLevel.ItemsSource = (IEnumerable) this.AllowedLevels.ToArray();
      this.ComboBoxLevel.SelectedValue = (object) (ConfigurationLevel) Enum.Parse(typeof (ConfigurationLevel), Settings.Default.ConfiguratorLevel);
      try
      {
        this.ShowConfigurationParameter();
      }
      catch (Exception ex)
      {
        if (!showReadWriteButton)
          ExceptionViewer.Show(ex);
        ZR_ClassLibMessages.ClearErrors();
      }
      this.dailyAutosaveOn = DatabaseIdentification.GetValue(DbBasis.PrimaryDB.BaseDbConnection, "DatabaseSaveOption") == "DailyAutosaveOn";
    }

    private void ShowConfigurationParameter()
    {
      SortedList<OverrideID, ConfigurationParameter> configurationParameters1 = this.handler.GetConfigurationParameters();
      if (configurationParameters1 != null && configurationParameters1.Count > 0)
      {
        this.tabCtrl.Visibility = Visibility.Visible;
        this.tab0.Visibility = Visibility.Visible;
        this.ShowParameter(this.DataGridParameterMain, configurationParameters1);
        this.tabCtrl.SelectedIndex = 0;
      }
      SortedList<OverrideID, ConfigurationParameter> configurationParameters2 = this.handler.GetConfigurationParameters(1);
      if (configurationParameters2 != null && configurationParameters2.Count > 0)
      {
        this.tab1.Visibility = Visibility.Visible;
        this.ShowParameter(this.DataGridParameterSub1, configurationParameters2);
      }
      SortedList<OverrideID, ConfigurationParameter> configurationParameters3 = this.handler.GetConfigurationParameters(2);
      if (configurationParameters3 != null && configurationParameters3.Count > 0)
      {
        this.tab2.Visibility = Visibility.Visible;
        this.ShowParameter(this.DataGridParameterSub2, configurationParameters3);
      }
      SortedList<OverrideID, ConfigurationParameter> configurationParameters4 = this.handler.GetConfigurationParameters(3);
      if (configurationParameters4 != null && configurationParameters4.Count > 0)
      {
        this.tab3.Visibility = Visibility.Visible;
        this.ShowParameter(this.DataGridParameterSub3, configurationParameters4);
      }
      this.ButtonSave.IsEnabled = true;
      this.tabCtrl.IsEnabled = true;
    }

    private void ShowParameter(
      DataGrid grid,
      SortedList<OverrideID, ConfigurationParameter> prms)
    {
      grid.ItemsSource = (IEnumerable) null;
      grid.Tag = (object) prms;
      if (prms == null)
        return;
      List<ConfigurationParameter> orderdList = ConfigurationParameter.GetOrderdList(prms);
      AsyncObservableCollection<ConfiguratorControl.Item> observableCollection = new AsyncObservableCollection<ConfiguratorControl.Item>();
      foreach (ConfigurationParameter configParameter in orderdList)
        observableCollection.Add(new ConfiguratorControl.Item(configParameter));
      grid.ItemsSource = (IEnumerable) observableCollection;
    }

    private void RefreshParameters()
    {
      if (this.tab0.Visibility == Visibility.Visible && this.tab0.IsSelected)
      {
        this.SaveParameter(0);
        this.ShowParameter(this.DataGridParameterMain, this.handler.GetConfigurationParameters());
      }
      if (this.tab1.Visibility == Visibility.Visible && this.tab1.IsSelected)
      {
        this.SaveParameter(1);
        this.ShowParameter(this.DataGridParameterSub1, this.handler.GetConfigurationParameters(1));
      }
      if (this.tab2.Visibility == Visibility.Visible && this.tab2.IsSelected)
      {
        this.SaveParameter(2);
        this.ShowParameter(this.DataGridParameterSub2, this.handler.GetConfigurationParameters(2));
      }
      if (this.tab3.Visibility != Visibility.Visible || !this.tab3.IsSelected)
        return;
      this.SaveParameter(3);
      this.ShowParameter(this.DataGridParameterSub3, this.handler.GetConfigurationParameters(3));
    }

    private void SaveParameter(int channel)
    {
      SortedList<OverrideID, ConfigurationParameter> tag1 = this.DataGridParameterMain.Tag as SortedList<OverrideID, ConfigurationParameter>;
      SortedList<OverrideID, ConfigurationParameter> tag2 = this.DataGridParameterSub1.Tag as SortedList<OverrideID, ConfigurationParameter>;
      SortedList<OverrideID, ConfigurationParameter> tag3 = this.DataGridParameterSub2.Tag as SortedList<OverrideID, ConfigurationParameter>;
      SortedList<OverrideID, ConfigurationParameter> tag4 = this.DataGridParameterSub3.Tag as SortedList<OverrideID, ConfigurationParameter>;
      try
      {
        if (tag1 != null && channel == 0)
        {
          SortedList<OverrideID, ConfigurationParameter> parameter = this.UpdateValues(this.DataGridParameterMain);
          if (parameter != null)
            this.handler.SetConfigurationParameters(parameter);
        }
        if (tag1 != null && channel == 1)
        {
          SortedList<OverrideID, ConfigurationParameter> parameter = this.UpdateValues(this.DataGridParameterSub1);
          if (parameter != null)
            this.handler.SetConfigurationParameters(parameter, 1);
        }
        if (tag1 != null && channel == 2)
        {
          SortedList<OverrideID, ConfigurationParameter> parameter = this.UpdateValues(this.DataGridParameterSub2);
          if (parameter != null)
            this.handler.SetConfigurationParameters(parameter, 2);
        }
        if (tag1 == null || channel != 3)
          return;
        SortedList<OverrideID, ConfigurationParameter> parameter1 = this.UpdateValues(this.DataGridParameterSub3);
        if (parameter1 != null)
          this.handler.SetConfigurationParameters(parameter1, 3);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private SortedList<OverrideID, ConfigurationParameter> UpdateValues(DataGrid grid)
    {
      SortedList<OverrideID, ConfigurationParameter> sortedList = new SortedList<OverrideID, ConfigurationParameter>();
      SortedList<OverrideID, ConfigurationParameter> tag = grid.Tag as SortedList<OverrideID, ConfigurationParameter>;
      foreach (ConfiguratorControl.Item obj in (Collection<ConfiguratorControl.Item>) (grid.ItemsSource as AsyncObservableCollection<ConfiguratorControl.Item>))
      {
        if (obj.IsChanged)
        {
          if (!string.IsNullOrEmpty(obj.Value) || obj.Options != null)
          {
            try
            {
              tag[obj.ConfigParameter.ParameterID].Pars(obj.Value);
              sortedList.Add(obj.ConfigParameter.ParameterID, tag[obj.ConfigParameter.ParameterID]);
            }
            catch (Exception ex)
            {
              ExceptionViewer.Show(ex, obj.ToString());
              this.TextBlockParameterInfo.Text = obj.ToString() + " Error: " + ex.Message;
            }
          }
        }
      }
      return sortedList.Count == 0 ? (SortedList<OverrideID, ConfigurationParameter>) null : sortedList;
    }

    private void DataGridParameter_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (e.AddedItems.Count != 1)
        return;
      ConfiguratorControl.Item addedItem = e.AddedItems[0] as ConfiguratorControl.Item;
      this.TextBlockParameterInfo.Text = addedItem != null ? addedItem.Info : string.Empty;
    }

    private void ButtonSave_Click(object sender, RoutedEventArgs e)
    {
      this.RefreshParameters();
      this.ButtonWrite.IsEnabled = true;
    }

    private void ComboBoxLevel_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      this.DataGridParameterMain.Tag = (object) null;
      this.DataGridParameterSub1.Tag = (object) null;
      this.DataGridParameterSub2.Tag = (object) null;
      this.DataGridParameterSub3.Tag = (object) null;
      if (this.ComboBoxLevel.SelectedItem == null)
        return;
      ConfigurationParameter.ActiveConfigurationLevel = (ConfigurationLevel) this.ComboBoxLevel.SelectedItem;
      Settings.Default.ConfiguratorLevel = ((ConfigurationLevel) this.ComboBoxLevel.SelectedItem).ToString();
      Settings.Default.Save();
      this.RefreshParameters();
    }

    private async void ButtonRead_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.ProgressBar1.Visibility = Visibility.Visible;
        this.progress.Reset();
        this.tabCtrl.Visibility = Visibility.Hidden;
        int num = await this.handler.ReadDeviceAsync(this.progress, CancellationToken.None, ReadPartsSelection.All);
        this.ShowConfigurationParameter();
        this.DailyAutosave();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex, "Read error");
      }
      finally
      {
        this.ProgressBar1.Visibility = Visibility.Hidden;
      }
    }

    private void DailyAutosave()
    {
      if (!this.dailyAutosaveOn)
        return;
      SortedList<OverrideID, ConfigurationParameter> configurationParameters = this.handler.GetConfigurationParameters();
      if (configurationParameters == null || !configurationParameters.ContainsKey(OverrideID.MeterID) || configurationParameters[OverrideID.MeterID].ParameterValue == null)
        return;
      try
      {
        int int32 = Convert.ToInt32(Convert.ToUInt64(configurationParameters[OverrideID.MeterID].ParameterValue));
        DateTime? nullable = GmmDbLib.MeterData.LoadLastBackupTimepoint(DbBasis.PrimaryDB.BaseDbConnection, int32);
        if (nullable.HasValue && !(nullable.Value < DateTime.Now.ToUniversalTime().Date))
          return;
        this.handler.SaveMeter();
      }
      catch (OverflowException ex)
      {
      }
    }

    private async void ButtonWrite_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.ProgressBar1.Visibility = Visibility.Visible;
        this.RefreshParameters();
        await this.handler.WriteDeviceAsync(this.progress, CancellationToken.None);
        this.ShowConfigurationParameter();
        DateTime? timepoint = this.handler.SaveMeter();
        this.ButtonSave.IsEnabled = false;
        this.ButtonWrite.IsEnabled = false;
        this.tabCtrl.IsEnabled = false;
        timepoint = new DateTime?();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex, "Write error");
      }
      finally
      {
        this.ProgressBar1.Visibility = Visibility.Hidden;
        this.tab0.Visibility = Visibility.Hidden;
        this.tab1.Visibility = Visibility.Hidden;
        this.tab2.Visibility = Visibility.Hidden;
        this.tab3.Visibility = Visibility.Hidden;
        this.tabCtrl.Visibility = Visibility.Hidden;
      }
    }

    private void ButtonLoadValuesFromFile_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        OpenFileDialog openFileDialog = new OpenFileDialog();
        openFileDialog.DefaultExt = ".txt";
        openFileDialog.CheckFileExists = true;
        openFileDialog.Filter = "Text file (.txt)|*.txt|All Files|*.*";
        if (ConfiguratorControl.lastFilePath != null)
          openFileDialog.InitialDirectory = ConfiguratorControl.lastFilePath;
        bool? nullable = openFileDialog.ShowDialog();
        bool flag = true;
        if (!(nullable.GetValueOrDefault() == flag & nullable.HasValue))
          return;
        ConfiguratorControl.lastFilePath = Path.GetDirectoryName(openFileDialog.FileName);
        using (StreamReader streamReader = new StreamReader(openFileDialog.FileName))
        {
label_15:
          string[] strArray;
          do
          {
            string str = streamReader.ReadLine();
            if (str != null)
              strArray = str.Split(new char[1]{ '=' }, StringSplitOptions.RemoveEmptyEntries);
            else
              goto label_7;
          }
          while (strArray.Length != 2);
          goto label_8;
label_7:
          return;
label_8:
          for (int index = 0; index < this.DataGridParameterMain.Items.Count; ++index)
          {
            object obj1 = this.DataGridParameterMain.Items[index];
            if (obj1 is ConfiguratorControl.Item)
            {
              ConfiguratorControl.Item obj2 = (ConfiguratorControl.Item) obj1;
              if (obj2.ConfigParameter.ParameterID.ToString() == strArray[0])
              {
                obj2.Value = strArray[1];
                obj2.ConfigParameter.SetValueFromStringWin(strArray[1]);
              }
            }
          }
          goto label_15;
        }
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/configuratorcontrol.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.tabCtrl = (TabControl) target;
          break;
        case 2:
          this.tab0 = (TabItem) target;
          break;
        case 3:
          this.DataGridParameterMain = (DataGrid) target;
          this.DataGridParameterMain.SelectionChanged += new SelectionChangedEventHandler(this.DataGridParameter_SelectionChanged);
          break;
        case 4:
          this.tab1 = (TabItem) target;
          break;
        case 5:
          this.DataGridParameterSub1 = (DataGrid) target;
          this.DataGridParameterSub1.SelectionChanged += new SelectionChangedEventHandler(this.DataGridParameter_SelectionChanged);
          break;
        case 6:
          this.tab2 = (TabItem) target;
          break;
        case 7:
          this.DataGridParameterSub2 = (DataGrid) target;
          this.DataGridParameterSub2.SelectionChanged += new SelectionChangedEventHandler(this.DataGridParameter_SelectionChanged);
          break;
        case 8:
          this.tab3 = (TabItem) target;
          break;
        case 9:
          this.DataGridParameterSub3 = (DataGrid) target;
          this.DataGridParameterSub3.SelectionChanged += new SelectionChangedEventHandler(this.DataGridParameter_SelectionChanged);
          break;
        case 10:
          this.ButtonSave = (Button) target;
          this.ButtonSave.Click += new RoutedEventHandler(this.ButtonSave_Click);
          break;
        case 11:
          this.TextBlockSave = (TextBlock) target;
          break;
        case 12:
          this.ComboBoxLevel = (ComboBox) target;
          this.ComboBoxLevel.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxLevel_SelectionChanged);
          break;
        case 13:
          this.ButtonLoadValuesFromFile = (Button) target;
          this.ButtonLoadValuesFromFile.Click += new RoutedEventHandler(this.ButtonLoadValuesFromFile_Click);
          break;
        case 14:
          this.ButtonRead = (Button) target;
          this.ButtonRead.Click += new RoutedEventHandler(this.ButtonRead_Click);
          break;
        case 15:
          this.ButtonWrite = (Button) target;
          this.ButtonWrite.Click += new RoutedEventHandler(this.ButtonWrite_Click);
          break;
        case 16:
          this.TextBlockParameterInfo = (TextBox) target;
          break;
        case 17:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }

    public enum ControlType
    {
      TextBox,
      CheckBox,
      ComboBox,
      ComboBoxWithCheckBox,
    }

    public class Options : List<ConfiguratorControl.OptionItem>
    {
      public string[] Parameter { get; set; }

      public Options(string[] allowed, string[] enabled)
      {
        this.Parameter = enabled;
        List<string> stringList = new List<string>((IEnumerable<string>) enabled);
        foreach (string str in allowed)
          this.Add(new ConfiguratorControl.OptionItem()
          {
            IsChecked = stringList.Contains(str),
            Name = str
          });
      }

      public string LimmitedSelectedNames
      {
        get
        {
          string selectedNames = this.SelectedNames;
          return selectedNames.Length > 24 ? selectedNames.Substring(0, 24) + "..." : selectedNames;
        }
        set
        {
        }
      }

      public string SelectedNames
      {
        get
        {
          StringBuilder stringBuilder = new StringBuilder();
          foreach (ConfiguratorControl.OptionItem optionItem in (List<ConfiguratorControl.OptionItem>) this)
          {
            if (optionItem.IsChecked)
              stringBuilder.Append(optionItem.Name).Append(';');
          }
          return stringBuilder.ToString().TrimEnd(';');
        }
        set
        {
        }
      }
    }

    public class OptionItem : INotifyPropertyChanged
    {
      private bool isChecked;

      public string Name { get; set; }

      public bool IsChecked
      {
        get => this.isChecked;
        set
        {
          if (this.isChecked == value)
            return;
          this.isChecked = value;
          if (this.PropertyChanged != null)
            this.PropertyChanged((object) this, new PropertyChangedEventArgs(nameof (IsChecked)));
        }
      }

      public event PropertyChangedEventHandler PropertyChanged;
    }

    [DebuggerDisplay("{Parameter} = {Value}")]
    public class Item : INotifyPropertyChanged
    {
      private string value;

      public event PropertyChangedEventHandler PropertyChanged;

      public ConfigurationParameter ConfigParameter { get; set; }

      public string Parameter { get; set; }

      public string ValueOriginal { get; set; }

      public string Value
      {
        get => this.value;
        set
        {
          if (!(this.value != value))
            return;
          this.value = value;
          this.NotifyPropertyChanged("IsChanged");
        }
      }

      public string Unit { get; set; }

      public string Info { get; set; }

      public bool IsEnabled { get; set; }

      public bool IsReadonly { get; set; }

      public bool IsFunction { get; set; }

      public bool IsEditable { get; set; }

      public bool IsChanged => this.ValueOriginal != this.Value;

      public List<string> PossibleValues { get; set; }

      public ConfiguratorControl.ControlType ControlType { get; set; }

      public ConfiguratorControl.Options Options { get; set; }

      public Item(ConfigurationParameter configParameter)
      {
        this.ConfigParameter = configParameter;
        this.Parameter = EnumTranslator.GetTranslatedEnumName((object) configParameter.ParameterID);
        this.ValueOriginal = configParameter.GetStringValueWin();
        this.Value = this.ValueOriginal;
        this.Unit = configParameter.Unit;
        this.IsReadonly = !configParameter.HasWritePermission;
        this.IsEnabled = !this.IsReadonly;
        this.IsFunction = configParameter.IsFunction;
        this.IsEditable = configParameter.IsEditable;
        Type enumType = (Type) null;
        if (configParameter.ParameterValue != null)
          enumType = configParameter.ParameterValue.GetType();
        if (this.IsFunction)
          this.ControlType = ConfiguratorControl.ControlType.CheckBox;
        else if (enumType != (Type) null && enumType == typeof (bool))
          this.ControlType = ConfiguratorControl.ControlType.CheckBox;
        else if (enumType != (Type) null && enumType.IsEnum && configParameter.AllowedValues != null && configParameter.AllowedValues.Length != 0)
        {
          List<string> stringList = new List<string>((IEnumerable<string>) configParameter.AllowedValues);
          for (int index = stringList.Count - 1; index >= 0; --index)
          {
            if (!Enum.IsDefined(enumType, (object) stringList[index]))
              stringList.RemoveAt(index);
          }
          this.ControlType = ConfiguratorControl.ControlType.ComboBox;
          this.PossibleValues = stringList;
        }
        else if (enumType != (Type) null && enumType == typeof (string[]) && configParameter.ParameterValue != null && configParameter.ParameterValue.GetType() == typeof (string[]) && configParameter.AllowedValues != null && configParameter.AllowedValues.GetType() == typeof (string[]))
        {
          this.ControlType = ConfiguratorControl.ControlType.ComboBoxWithCheckBox;
          this.Options = new ConfiguratorControl.Options(configParameter.AllowedValues, (string[]) configParameter.ParameterValue);
          foreach (INotifyPropertyChanged option in (List<ConfiguratorControl.OptionItem>) this.Options)
            option.PropertyChanged += new PropertyChangedEventHandler(this.Item_PropertyChanged);
        }
        else if (enumType != (Type) null && enumType.IsEnum)
        {
          this.ControlType = ConfiguratorControl.ControlType.ComboBox;
          this.PossibleValues = new List<string>((IEnumerable<string>) Enum.GetNames(enumType));
        }
        else if (configParameter.AllowedValues != null && configParameter.AllowedValues.Length != 0)
        {
          this.ControlType = ConfiguratorControl.ControlType.ComboBox;
          this.PossibleValues = new List<string>((IEnumerable<string>) configParameter.AllowedValues);
        }
        else
          this.ControlType = ConfiguratorControl.ControlType.TextBox;
        string str = EnumTranslator.GetTranslatedEnumDescription((object) configParameter.ParameterID);
        if (configParameter.MaxParameterValue != null || configParameter.MinParameterValue != null)
        {
          str = str + Environment.NewLine + Environment.NewLine;
          if (configParameter.MinParameterValue != null)
            str = str + "min: " + configParameter.MinParameterValue.ToString() + Environment.NewLine;
          if (configParameter.MaxParameterValue != null)
            str = str + "max: " + configParameter.MaxParameterValue.ToString() + Environment.NewLine;
        }
        this.Info = str;
      }

      private void Item_PropertyChanged(object sender, PropertyChangedEventArgs e)
      {
        List<string> stringList = new List<string>();
        foreach (ConfiguratorControl.OptionItem option in (List<ConfiguratorControl.OptionItem>) this.Options)
        {
          if (option.IsChecked)
            stringList.Add(option.Name);
        }
        this.Options.Parameter = stringList.ToArray();
        this.Value = this.Options.SelectedNames;
        this.ConfigParameter.SetValueFromStringWin(this.Value);
        this.NotifyPropertyChanged("Options");
      }

      public void NotifyPropertyChanged(string propName)
      {
        if (this.PropertyChanged == null)
          return;
        this.PropertyChanged((object) this, new PropertyChangedEventArgs(propName));
      }

      public override string ToString() => this.Parameter + " = " + this.Value;
    }
  }
}


--- ConfiguratorWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ConfiguratorWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows;
using System.Windows.Markup;

#nullable disable
namespace HandlerLib
{
  public class ConfiguratorWindow : Window, IComponentConnector
  {
    internal ConfiguratorControl ConfiguratorCtrl;
    private bool _contentLoaded;

    public ConfiguratorWindow() => this.InitializeComponent();

    public static void ShowDialog(Window owner, IHandler handler)
    {
      ConfiguratorWindow configuratorWindow = new ConfiguratorWindow();
      configuratorWindow.Owner = owner;
      ConfiguratorWindow owner1 = configuratorWindow;
      try
      {
        owner1.ConfiguratorCtrl.InitializeComponent(handler);
        if (owner1.ShowDialog().Value)
          ;
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) owner1, ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
    }

    public static void ShowDialog(IHandler handler)
    {
      ConfiguratorWindow owner = new ConfiguratorWindow();
      try
      {
        owner.ConfiguratorCtrl.InitializeComponent(handler);
        if (owner.ShowDialog().Value)
          ;
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) owner, ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/configuratorwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      if (connectionId == 1)
        this.ConfiguratorCtrl = (ConfiguratorControl) target;
      else
        this._contentLoaded = true;
    }
  }
}


--- CRC.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.CRC
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  public static class CRC
  {
    public static ushort CRC_CCITT(byte[] buffer, ushort offset, ushort size)
    {
      byte[] numArray = new byte[(int) size];
      Buffer.BlockCopy((Array) buffer, (int) offset, (Array) numArray, 0, (int) size);
      return CRC.CRC_CCITT(numArray);
    }

    public static ushort CRC_CCITT(byte[] buffer)
    {
      ushort num1 = ushort.MaxValue;
      ushort num2 = 4129;
      for (int index1 = 0; index1 < buffer.Length; ++index1)
      {
        num1 ^= (ushort) ((uint) buffer[index1] << 8);
        for (int index2 = 0; index2 < 8; ++index2)
        {
          if (((uint) num1 & 32768U) > 0U)
            num1 = (ushort) ((uint) num1 << 1 ^ (uint) num2);
          else
            num1 <<= 1;
        }
      }
      return num1;
    }

    public static ushort CRC_CCITT(byte[] buffer, ushort offset, ushort size, ushort initValue)
    {
      byte[] numArray = new byte[(int) size];
      Buffer.BlockCopy((Array) buffer, (int) offset, (Array) numArray, 0, (int) size);
      return CRC.CRC_CCITT(numArray, initValue);
    }

    public static ushort CRC_CCITT(byte[] buffer, ushort initValue)
    {
      ushort num1 = initValue;
      ushort num2 = 4129;
      for (int index1 = 0; index1 < buffer.Length; ++index1)
      {
        num1 ^= (ushort) ((uint) buffer[index1] << 8);
        for (int index2 = 0; index2 < 8; ++index2)
        {
          if (((uint) num1 & 32768U) > 0U)
            num1 = (ushort) ((uint) num1 << 1 ^ (uint) num2);
          else
            num1 <<= 1;
        }
      }
      return num1;
    }

    public static ushort CRC_16(byte[] buffer, ushort offset, ushort size)
    {
      byte[] numArray = new byte[(int) size];
      Buffer.BlockCopy((Array) buffer, (int) offset, (Array) numArray, 0, (int) size);
      return CRC.CRC_16(numArray, ushort.MaxValue);
    }

    public static ushort CRC_16(byte[] buffer, ushort initValue)
    {
      ushort num1 = initValue;
      ushort num2 = 32773;
      for (int index1 = 0; index1 < buffer.Length; ++index1)
      {
        num1 ^= (ushort) ((uint) buffer[index1] << 8);
        for (int index2 = 0; index2 < 8; ++index2)
        {
          if (((uint) num1 & 32768U) > 0U)
            num1 = (ushort) ((uint) num1 << 1 ^ (uint) num2);
          else
            num1 <<= 1;
        }
      }
      return num1;
    }

    public static ushort CRC_16(byte[] buffer) => CRC.CRC_16(buffer, ushort.MaxValue);

    public static uint CRC_32(byte[] buffer, ushort offset, ushort size)
    {
      byte[] numArray = new byte[(int) size];
      Buffer.BlockCopy((Array) buffer, (int) offset, (Array) numArray, 0, (int) size);
      return CRC.CRC_32(numArray);
    }

    public static uint CRC_32(byte[] buffer) => throw new NotImplementedException();
  }
}


--- DebugQueueData.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DebugQueueData
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace HandlerLib
{
  public class DebugQueueData
  {
    public SortedList<int, string> QueueEvents;
    public List<DebugQueueEntry> QueueEntries;

    public DebugQueueData()
    {
      this.QueueEntries = new List<DebugQueueEntry>();
      this.QueueEntries.Add(new DebugQueueEntry("Test1", new DateTime(2023, 1, 1), (ushort) 0));
      this.QueueEntries.Add(new DebugQueueEntry("Test1", new DateTime(2023, 1, 1), (ushort) 5));
      this.QueueEntries.Add(new DebugQueueEntry("Test2", new DateTime(2023, 1, 1), (ushort) 7));
      this.QueueEntries.Add(new DebugQueueEntry("Test1", new DateTime(2023, 1, 1), (ushort) 9));
      this.QueueEntries.Sort();
    }

    public DebugQueueData(
      SortedList<int, string> queueEvents,
      byte[] buffer,
      int offset,
      int byteSize)
    {
      this.QueueEvents = queueEvents;
      this.QueueEntries = new List<DebugQueueEntry>();
      int num = byteSize / 12;
      for (int index = 0; index < num; ++index)
      {
        this.QueueEntries.Add(new DebugQueueEntry(this.QueueEvents, buffer, offset));
        offset += 12;
      }
      this.QueueEntries.Sort();
    }
  }
}


--- DebugQueueEntry.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DebugQueueEntry
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace HandlerLib
{
  public class DebugQueueEntry : IComparable<DebugQueueEntry>
  {
    public string LogEvent;
    public DateTime EventTime;
    public ushort Tick;
    public byte Uint8_param;
    public uint Uint32_param;

    public DebugQueueEntry(
      string theEvent,
      DateTime theTime,
      ushort theTick,
      byte uint8Param = 0,
      uint uint32Param = 0)
    {
      this.LogEvent = theEvent;
      this.EventTime = theTime;
      this.Tick = theTick;
      this.Uint8_param = uint8Param;
      this.Uint32_param = uint32Param;
    }

    public DebugQueueEntry(SortedList<int, string> queueEvents, byte[] buffer, int offset)
    {
      this.LogEvent = queueEvents == null || !queueEvents.ContainsKey((int) buffer[offset]) ? "UnDef_0x" + buffer[offset].ToString("x02") : queueEvents[(int) buffer[offset]];
      this.Uint8_param = buffer[offset + 1];
      this.Tick = BitConverter.ToUInt16(buffer, offset + 2);
      this.EventTime = this.GetDateTimeFromSeconds2000(BitConverter.ToUInt32(buffer, offset + 4));
      this.Uint32_param = BitConverter.ToUInt32(buffer, offset + 8);
    }

    private uint GetSeconds2000(DateTime dateTime)
    {
      return (uint) dateTime.Subtract(new DateTime(2000, 1, 1)).TotalSeconds;
    }

    private DateTime GetDateTimeFromSeconds2000(uint secs2000)
    {
      return new DateTime(2000, 1, 1).AddSeconds((double) secs2000);
    }

    public int CompareTo(DebugQueueEntry obj)
    {
      if (obj == null)
        return 1;
      int num = this.EventTime.CompareTo(obj.EventTime);
      return num != 0 ? num : this.Tick.CompareTo(obj.Tick);
    }
  }
}


--- DebugQueueWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DebugQueueWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommonWPF;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using System.Windows.Media;
using System.Windows.Shapes;

#nullable disable
namespace HandlerLib
{
  public class DebugQueueWindow : Window, IComponentConnector
  {
    private DebugQueueWindow.ReadDebugQueueDataFunction ReadDebugQueueFunction;
    private DebugQueueData QueuedData;
    private SortedList<int, string> QueueEvents;
    private const int NumberOfGraphicRows = 5;
    private const double GraphicRowMargin = 2.0;
    private List<RowScaling> GraphicRows;
    internal DockPanel DockPanelButtons;
    internal StackPanel StackPanelBottomButtoms;
    internal Button ButtomReadLogger;
    internal StackPanel StackPanelTopButtoms;
    internal DockPanel DockPanelFunctions;
    internal StackPanel StackPanelFunctions;
    internal Grid GridGraphics;
    private bool _contentLoaded;

    public DebugQueueWindow(
      SortedList<int, string> eventList,
      DebugQueueWindow.ReadDebugQueueDataFunction readDebugQueueFunction)
    {
      this.QueueEvents = eventList;
      this.ReadDebugQueueFunction = readDebugQueueFunction;
      this.InitializeComponent();
    }

    private void ButtomReadLogger_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.QueuedData = this.ReadDebugQueueFunction();
        this.ResetGraphics();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ResetGraphics()
    {
      this.GridGraphics.Children.Clear();
      double num1 = this.GridGraphics.ActualWidth - 4.0;
      double num2 = (this.GridGraphics.ActualHeight - 12.0) / 5.0;
      this.GraphicRows = new List<RowScaling>();
      for (int index = 0; index < 5; ++index)
      {
        RowScaling rowScaling = new RowScaling()
        {
          Xmin = 2.0,
          Xmax = 2.0 + num1,
          Ymin = 2.0 + (double) index * (2.0 + num2)
        };
        rowScaling.Ymax = rowScaling.Ymin + num2;
        this.GraphicRows.Add(rowScaling);
      }
      this.DrawRowBaseLine(0, (Brush) Brushes.Red);
      this.DrawDashToRow(0, 0.0, (Brush) Brushes.Black);
      this.DrawDashToRow(0, 100.0, (Brush) Brushes.Black);
      this.DrawRowBaseLine(4, (Brush) Brushes.Red);
      this.DrawDashToRow(4, 0.0, (Brush) Brushes.Black);
      this.DrawDashToRow(4, 100.0, (Brush) Brushes.Black);
    }

    private void DrawRowBaseLine(int row, Brush brush)
    {
      if ((long) (uint) row >= (long) this.GraphicRows.Count)
        throw new Exception("Illegal row");
      Line element = new Line();
      element.X1 = this.GraphicRows[row].Xmin;
      element.Y1 = this.GraphicRows[row].Ymax;
      element.X2 = this.GraphicRows[row].Xmax;
      element.Y2 = this.GraphicRows[row].Ymax;
      element.Stroke = brush;
      element.StrokeThickness = 1.0;
      this.GridGraphics.Children.Add((UIElement) element);
    }

    private void DrawDashToRow(int row, double percent, Brush brush)
    {
      if ((long) (uint) row >= (long) this.GraphicRows.Count)
        throw new Exception("Illegal row");
      double num = this.GraphicRows[row].Xmin + (this.GraphicRows[row].Xmax - this.GraphicRows[row].Xmin) / 100.0 * percent;
      Line element = new Line();
      element.X1 = num;
      element.Y1 = this.GraphicRows[row].Ymin;
      element.X2 = num;
      element.Y2 = this.GraphicRows[row].Ymax;
      element.Stroke = brush;
      element.StrokeThickness = 1.0;
      this.GridGraphics.Children.Add((UIElement) element);
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/debugqueuewindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.DockPanelButtons = (DockPanel) target;
          break;
        case 2:
          this.StackPanelBottomButtoms = (StackPanel) target;
          break;
        case 3:
          this.ButtomReadLogger = (Button) target;
          this.ButtomReadLogger.Click += new RoutedEventHandler(this.ButtomReadLogger_Click);
          break;
        case 4:
          this.StackPanelTopButtoms = (StackPanel) target;
          break;
        case 5:
          this.DockPanelFunctions = (DockPanel) target;
          break;
        case 6:
          this.StackPanelFunctions = (StackPanel) target;
          break;
        case 7:
          this.GridGraphics = (Grid) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }

    public delegate DebugQueueData ReadDebugQueueDataFunction();
  }
}


--- DescComparer`1.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DescComparer`1
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System.Collections.Generic;

#nullable disable
namespace HandlerLib
{
  internal class DescComparer<T> : IComparer<T>
  {
    public int Compare(T x, T y) => Comparer<T>.Default.Compare(y, x);
  }
}


--- DescendingComparer.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DescendingComparer
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections;

#nullable disable
namespace HandlerLib
{
  internal class DescendingComparer : IComparer
  {
    public int Compare(object x, object y)
    {
      try
      {
        return Convert.ToInt32(x).CompareTo(Convert.ToInt32(y)) * -1;
      }
      catch
      {
        return x.ToString().CompareTo(y.ToString());
      }
    }
  }
}


--- DeviceCharacteristics.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceCharacteristics
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public class DeviceCharacteristics
  {
    public float MinimumFlowrateQ1_qmPerHour;
    public float TransitionalFlowrateQ2_qmPerHour;
    public float PermanentFlowrateQ3_qmPerHour;
    public float OverloadFlowrateQ4_qmPerHour;
  }
}


--- DeviceCommandsMBus.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceCommandsMBus
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using MBusLib;
using NLog;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class DeviceCommandsMBus : IZRCommand
  {
    private static Logger logger = LogManager.GetLogger(nameof (DeviceCommandsMBus));
    private DeviceVersionMBus connectedDeviceVersion;

    public MBus MBus { get; private set; }

    public DeviceVersionMBus ConnectedDeviceVersion
    {
      get => this.connectedDeviceVersion;
      set
      {
        this.connectedDeviceVersion = value;
        this.ConnectedReducedID = new byte[3];
        this.ConnectedReducedID[0] = this.connectedDeviceVersion.LongID[0];
        this.ConnectedReducedID[1] = this.connectedDeviceVersion.LongID[1];
        this.ConnectedReducedID[2] = (byte) 85;
        foreach (byte num in this.connectedDeviceVersion.LongID)
          this.ConnectedReducedID[2] += num;
      }
    }

    public byte[] ConnectedReducedID { get; private set; }

    public byte[] ConnectedProtectedID { get; private set; }

    public uint SeriesKey { get; private set; }

    public bool IsDeviceIdentified => this.ConnectedDeviceVersion != null;

    public DeviceCommandsMBus(IPort port)
    {
      this.MBus = port != null ? new MBus(port) : throw new ArgumentNullException(nameof (port));
    }

    public void SaveSeriesKey(uint key) => this.SeriesKey = key;

    public void ClearProtectedIdentification() => this.ConnectedProtectedID = (byte[]) null;

    public void SetProtectedIdentification(uint SeriesKey)
    {
      if (this.ConnectedReducedID == null)
        throw new HandlerMessageException("Protected identification can only be set if reduced identification available!");
      this.SeriesKey = SeriesKey;
      uint num1 = ((uint) this.ConnectedReducedID[0] << 8) + ((uint) this.ConnectedReducedID[1] << 16) + ((uint) this.ConnectedReducedID[2] << 24) + (uint) this.ConnectedReducedID[2];
      uint num2 = SeriesKey;
      uint num3 = SeriesKey;
      for (int index = 0; index < 8; ++index)
      {
        uint num4 = num3 + num1 + num2;
        num3 = num4 + num4;
        num1 >>= 1;
        num2 >>= 1;
      }
      this.ConnectedProtectedID = new byte[3];
      this.ConnectedProtectedID[0] = (byte) num3;
      this.ConnectedProtectedID[1] = (byte) (num3 >> 8);
      this.ConnectedProtectedID[2] = (byte) (num3 >> 16);
    }

    public virtual async Task<DeviceVersionMBus> ReadVersionAsync(
      ProgressHandler progress,
      CancellationToken token)
    {
      DeviceVersionMBus deviceVersionMbus = await Task.Run<DeviceVersionMBus>((Func<DeviceVersionMBus>) (() => this.ReadVersion(progress, token)), token);
      return deviceVersionMbus;
    }

    public DeviceVersionMBus ReadVersion(ProgressHandler progress, CancellationToken token)
    {
      DeviceCommandsMBus.logger.Trace(nameof (ReadVersion));
      if (token != CancellationToken.None)
        token.ThrowIfCancellationRequested();
      if (progress != null)
      {
        progress.Split(new double[2]{ 10.0, 90.0 });
        progress.Report("Read version");
      }
      MBusFrame resultFrame = this.MBus.Repeater.GetResultFrame(new MBusFrame(new byte[5]
      {
        (byte) 15,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 6
      }), progress, token);
      this.ConnectedDeviceVersion = resultFrame.Type == FrameType.LongFrame ? DeviceVersionMBus.Parse(resultFrame) : throw new Exception("Invalid M-Bus frame! Expected: LongFrame, Actual: " + resultFrame.Type.ToString());
      return this.ConnectedDeviceVersion;
    }

    public void SetIdentificationLikeInFirmware(
      uint serialNumberBCD,
      ushort manufacturerCode,
      byte generation,
      byte mediumCode)
    {
      DeviceCommandsMBus.logger.Trace(nameof (SetIdentificationLikeInFirmware));
      this.ConnectedDeviceVersion = new DeviceVersionMBus(serialNumberBCD, manufacturerCode, generation, mediumCode);
    }

    public static byte[] GetLongID(FixedDataHeader header)
    {
      byte[] byteArray = header.ToByteArray();
      byte[] dst = new byte[8];
      Buffer.BlockCopy((Array) byteArray, 0, (Array) dst, 0, 8);
      return dst;
    }

    public static byte[] GetLongID(
      uint serialNumberBCD,
      ushort manufacturerCode,
      byte generation,
      byte mediumCode)
    {
      List<byte> byteList = new List<byte>();
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(serialNumberBCD));
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(manufacturerCode));
      byteList.Add(generation);
      byteList.Add(mediumCode);
      return byteList.ToArray();
    }

    public static void CheckManufacturerResponse(MBusFrame response, byte[] requiredLongID)
    {
      byte[] numArray = response.Type == FrameType.LongFrame ? DeviceCommandsMBus.GetLongID(FixedDataHeader.Parse(response.UserData)) : throw new Exception("Long frame expected but not received");
      for (int index = 0; index < numArray.Length; ++index)
      {
        if ((int) numArray[index] != (int) requiredLongID[index])
          throw new Exception("Illegal device long ID");
      }
      if (response.UserData[12] != (byte) 15)
        throw new Exception("Illegal manufacturer DIF in receive frame");
    }

    public static byte[] Get_FC_EFC_AndData(MBusFrame response)
    {
      int count = response.UserData.Length - 13;
      byte[] dst = new byte[count];
      Buffer.BlockCopy((Array) response.UserData, 13, (Array) dst, 0, count);
      return dst;
    }

    public static void CheckManufacturerResponse(MBusFrameCrypt response, byte[] requiredLongID)
    {
      byte[] numArray = response.Type == FrameType.LongFrame ? DeviceCommandsMBus.GetLongID(FixedDataHeader.Parse(response.UserData)) : throw new Exception("Long frame expected but not received");
      for (int index = 0; index < numArray.Length; ++index)
      {
        if ((int) numArray[index] != (int) requiredLongID[index])
          throw new Exception("Illegal device long ID");
      }
      if (response.UserData[12] != (byte) 15)
        throw new Exception("Illegal manufacturer DIF in receive frame");
    }

    public static byte[] Get_FC_EFC_AndData(MBusFrameCrypt response)
    {
      int count = response.UserData.Length - 13;
      byte[] dst = new byte[count];
      Buffer.BlockCopy((Array) response.UserData, 13, (Array) dst, 0, count);
      return dst;
    }
  }
}


--- DeviceHistoryData.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceHistoryData
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  public class DeviceHistoryData
  {
    public string HistoryText = string.Empty;
    public Exception HistoryPrepareExceptions = (Exception) null;
  }
}


--- DeviceIdentification.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceIdentification
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using MBusLib;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  [Serializable]
  public class DeviceIdentification
  {
    protected uint? firmwareVersion;
    protected byte[] unique_ID;
    protected ushort? signatur;
    protected uint? svnRevision;
    protected DateTime? buildTime;
    protected uint? hardwareID;
    protected uint? deviceStatusFlags;
    protected uint? ndc_lib_version;
    protected byte[] printedSerialNumber;
    protected uint? iD_BCD;
    protected uint? fD_ID_BCD;
    protected ushort? manufacturer;
    protected ushort? fD_Manufacturer;
    protected byte? generation;
    protected byte? fD_Generation;
    protected byte? medium;
    protected byte? fD_Medium;
    protected byte[] aes_Key;
    protected byte[] fD_AES_Key;
    protected byte? primaryAddress;
    protected char? obisMedium;
    protected char? fD_ObisMedium;
    protected ulong? loRa_DevEUI;
    protected ulong? fD_FD_LoRa_DevEUI;
    protected ulong? loRa_JoinEUI;
    protected ulong? fD_LoRa_JoinEUI;
    protected byte[] loRa_AppKey;
    protected byte[] fD_LoRa_AppKey;
    protected uint? meterID;
    protected uint? hardwareTypeID;
    protected uint? meterInfoID;
    protected uint? meterTypeID;
    protected uint? baseTypeID;
    protected uint? subPartNumber;
    protected uint? sAP_MaterialNumber;
    protected string sAP_ProductionOrderNumber;

    public DeviceIdentification()
    {
    }

    public DeviceIdentification(uint firmwareVersion)
    {
      this.firmwareVersion = new uint?(firmwareVersion);
    }

    public DeviceIdentification(DeviceIdentification source)
    {
      this.firmwareVersion = source.FirmwareVersion;
      this.hardwareID = source.HardwareID;
      if (source.Unique_ID != null)
        this.unique_ID = (byte[]) source.Unique_ID.Clone();
      this.deviceStatusFlags = source.deviceStatusFlags;
      this.signatur = source.Signatur;
      this.svnRevision = source.SvnRevision;
      this.buildTime = source.BuildTime;
      this.iD_BCD = source.ID_BCD;
      this.manufacturer = source.Manufacturer;
      this.generation = source.Generation;
      this.medium = source.Medium;
      this.primaryAddress = source.PrimaryAddress;
      this.obisMedium = source.ObisMedium;
      this.meterID = source.MeterID;
      this.hardwareTypeID = source.HardwareTypeID;
      this.meterInfoID = source.MeterInfoID;
      this.meterTypeID = source.MeterTypeID;
      this.baseTypeID = source.BaseTypeID;
      this.sAP_MaterialNumber = source.SAP_MaterialNumber;
      this.sAP_ProductionOrderNumber = source.SAP_ProductionOrderNumber;
      this.loRa_DevEUI = source.LoRa_DevEUI;
      this.loRa_JoinEUI = source.LoRa_JoinEUI;
      if (source.LoRa_AppKey == null)
        return;
      this.loRa_AppKey = (byte[]) source.LoRa_AppKey.Clone();
    }

    public virtual DeviceIdentification Clone() => this.MemberwiseClone() as DeviceIdentification;

    public virtual uint? FirmwareVersion
    {
      get => this.firmwareVersion;
      set => throw new Exception("Write to FirmwareVersion not defined");
    }

    public string GetFirmwareVersionString()
    {
      return !this.FirmwareVersion.HasValue ? (string) null : new ZENNER.CommonLibrary.FirmwareVersion(this.FirmwareVersion.Value).ToString();
    }

    public ZENNER.CommonLibrary.FirmwareVersion FirmwareVersionObj
    {
      get
      {
        return this.FirmwareVersion.HasValue ? new ZENNER.CommonLibrary.FirmwareVersion(this.FirmwareVersion.Value) : throw new Exception("Firmware version not defined");
      }
    }

    public virtual byte[] Unique_ID => this.unique_ID;

    public string GetUnique_ID_String()
    {
      return this.Unique_ID == null ? (string) null : Util.ByteArrayToHexString(this.Unique_ID);
    }

    public virtual ushort? Signatur
    {
      get => this.signatur;
      set => throw new Exception("Write to Signatur not defined");
    }

    public string GetSignaturString()
    {
      if (!this.Signatur.HasValue)
        return (string) null;
      ushort? signatur = this.Signatur;
      string str1 = signatur.Value.ToString();
      signatur = this.Signatur;
      string str2 = signatur.Value.ToString("X04");
      return str1 + " = 0x" + str2;
    }

    public virtual uint? SvnRevision
    {
      get => this.svnRevision;
      set => throw new Exception("Write to SvnRevision not defined");
    }

    public string GetSvnRevisionString()
    {
      return !this.SvnRevision.HasValue ? (string) null : this.SvnRevision.ToString();
    }

    public virtual DateTime? BuildTime
    {
      get => this.buildTime;
      set => throw new Exception("Write to BuildTime not defined");
    }

    public string GetBuildTimeString()
    {
      if (!this.BuildTime.HasValue)
        return (string) null;
      DateTime? buildTime = this.BuildTime;
      string longDateString = buildTime.Value.ToLongDateString();
      buildTime = this.BuildTime;
      string longTimeString = buildTime.Value.ToLongTimeString();
      return longDateString + " " + longTimeString;
    }

    public virtual uint? HardwareID
    {
      get => this.hardwareID;
      set => throw new Exception("Write to HardwareID not defined");
    }

    public string GetHardwareIDString()
    {
      return !this.HardwareID.HasValue ? (string) null : this.HardwareID.Value.ToString("X08");
    }

    public virtual uint? DeviceStatusFlags
    {
      get => this.deviceStatusFlags;
      set => this.deviceStatusFlags = value;
    }

    public int[] SubChannels { get; set; }

    public virtual uint? NDC_Lib_Version
    {
      get => this.ndc_lib_version;
      set => this.ndc_lib_version = value;
    }

    public virtual byte[] PrintedSerialNumber
    {
      get => this.printedSerialNumber;
      set => throw new Exception("Write to PrintedSerialNumber not defined");
    }

    public string PrintedSerialNumberAsString
    {
      get => Utility.ZeroTerminatedAsciiStringToString(this.PrintedSerialNumber);
      set => this.PrintedSerialNumber = Utility.StringToZeroTerminatedAsciiString(value, 17);
    }

    public virtual uint? ID_BCD
    {
      get => this.iD_BCD;
      set => throw new Exception("Write to ID_BCD not defined");
    }

    public string ID_BCD_AsString
    {
      get => !this.ID_BCD.HasValue ? (string) null : this.ID_BCD.Value.ToString("X08");
      set
      {
        if (string.IsNullOrEmpty(value))
          this.ID_BCD = new uint?();
        uint result;
        if (!uint.TryParse(value, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          throw new Exception("Illegal ID_BCD string");
        this.ID_BCD = new uint?(result);
      }
    }

    public virtual uint? FD_ID_BCD
    {
      get => this.fD_ID_BCD;
      set => this.fD_ID_BCD = new uint?();
    }

    public string FD_ID_BCD_AsString
    {
      get => !this.FD_ID_BCD.HasValue ? (string) null : this.FD_ID_BCD.Value.ToString("X08");
    }

    public virtual ushort? Manufacturer
    {
      get => this.manufacturer;
      set => throw new Exception("Write to Manufacturer not defined");
    }

    public string ManufacturerAsString
    {
      get => !this.Manufacturer.HasValue ? (string) null : this.Manufacturer.Value.ToString("X04");
      set
      {
        this.Manufacturer = value.Length == 4 ? new ushort?(ushort.Parse(value, NumberStyles.HexNumber)) : throw new Exception("Illegal ManufacturerString length");
      }
    }

    public string ManufacturerName
    {
      get
      {
        return !this.Manufacturer.HasValue ? (string) null : MBusUtil.GetManufacturer(this.Manufacturer.Value);
      }
      set
      {
        this.Manufacturer = value.Length == 3 ? new ushort?(MBusUtil.GetManufacturerCode(value)) : throw new Exception("Illegal ManufacturerName length");
      }
    }

    public virtual ushort? FD_Manufacturer
    {
      get => this.fD_Manufacturer;
      set => this.fD_Manufacturer = new ushort?();
    }

    public string FD_ManufacturerAsString
    {
      get
      {
        return !this.FD_Manufacturer.HasValue ? (string) null : this.FD_Manufacturer.Value.ToString("X04");
      }
      set
      {
        this.FD_Manufacturer = value.Length == 4 ? new ushort?(ushort.Parse(value, NumberStyles.HexNumber)) : throw new Exception("Illegal FD_ManufacturerString length");
      }
    }

    public string FD_ManufacturerName
    {
      get
      {
        return !this.FD_Manufacturer.HasValue ? (string) null : MBusUtil.GetManufacturer(this.FD_Manufacturer.Value);
      }
      set
      {
        this.FD_Manufacturer = value.Length == 3 ? new ushort?(MBusUtil.GetManufacturerCode(value)) : throw new Exception("Illegal FD_ManufacturerName length");
      }
    }

    public virtual byte? Generation
    {
      get => this.generation;
      set => throw new Exception("Write to Generation not defined");
    }

    public string GenerationAsString
    {
      get => !this.Generation.HasValue ? (string) null : this.Generation.Value.ToString("X02");
      set
      {
        if (string.IsNullOrEmpty(value))
          this.Generation = new byte?();
        byte result;
        if (!byte.TryParse(value, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          throw new Exception("Illegal Generation string");
        this.Generation = new byte?(result);
      }
    }

    public virtual byte? FD_Generation
    {
      get => this.fD_Generation;
      set => this.fD_Generation = new byte?();
    }

    public string FD_GenerationAsString
    {
      get
      {
        return !this.FD_Generation.HasValue ? (string) null : this.FD_Generation.Value.ToString("X02");
      }
      set
      {
        if (string.IsNullOrEmpty(value))
          this.FD_Generation = new byte?();
        byte result;
        if (!byte.TryParse(value, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          throw new Exception("Illegal FD_Generation string");
        this.FD_Generation = new byte?(result);
      }
    }

    public virtual byte? Medium
    {
      get => this.medium;
      set => throw new Exception("Write to Medium not defined");
    }

    public string MediumAsString
    {
      get => this.Medium.HasValue ? this.Medium.Value.ToString("X02") : string.Empty;
      set => this.Medium = new byte?(byte.Parse(this.MediumAsString, NumberStyles.HexNumber));
    }

    public string GetMediumAsText()
    {
      return this.Medium.HasValue ? MBusUtil.GetMedium(this.Medium.Value) : string.Empty;
    }

    public virtual byte? FD_Medium
    {
      get => this.fD_Medium;
      set => this.fD_Medium = new byte?();
    }

    public string FD_MediumAsString
    {
      get => this.FD_Medium.HasValue ? this.FD_Medium.Value.ToString("X02") : string.Empty;
      set => this.FD_Medium = new byte?(byte.Parse(this.FD_MediumAsString, NumberStyles.HexNumber));
    }

    public string GetFD_MediumAsText()
    {
      return this.FD_Medium.HasValue ? MBusUtil.GetMedium(this.FD_Medium.Value) : string.Empty;
    }

    public virtual byte[] AES_Key
    {
      get => this.aes_Key;
      set => throw new Exception("Write of AES_Key not defined");
    }

    public string AES_Key_AsString
    {
      get => this.AES_Key == null ? (string) null : Util.ByteArrayToHexString(this.AES_Key);
      set
      {
        if (value == null)
          this.AES_Key = (byte[]) null;
        else
          this.AES_Key = Util.HexStringToByteArray(value);
      }
    }

    public virtual byte[] FD_AES_Key
    {
      get => this.fD_AES_Key;
      set => this.fD_AES_Key = (byte[]) null;
    }

    public string FD_AES_Key_AsString
    {
      get => this.FD_AES_Key == null ? (string) null : Util.ByteArrayToHexString(this.FD_AES_Key);
      set
      {
        if (value == null)
          this.FD_AES_Key = (byte[]) null;
        else
          this.FD_AES_Key = Util.HexStringToByteArray(value);
      }
    }

    public virtual byte? PrimaryAddress
    {
      get => this.primaryAddress;
      set => throw new Exception("Write to PrimaryAddress not defined");
    }

    public virtual char? ObisMedium
    {
      get => this.obisMedium.HasValue ? this.obisMedium : new char?();
      set => this.obisMedium = value;
    }

    public string GetObisMediumString()
    {
      return !this.ObisMedium.HasValue ? (string) null : this.ObisMedium.ToString();
    }

    public virtual char? FD_ObisMedium
    {
      get => this.fD_ObisMedium.HasValue ? this.fD_ObisMedium : new char?();
      set => this.fD_ObisMedium = value;
    }

    public string GetFD_ObisMediumString()
    {
      return !this.FD_ObisMedium.HasValue ? (string) null : this.FD_ObisMedium.ToString();
    }

    public virtual string IdentificationPrefix
    {
      get
      {
        try
        {
          char? obisMedium = this.ObisMedium;
          if (!obisMedium.HasValue || this.ManufacturerName == null || !this.Generation.HasValue)
            return (string) null;
          obisMedium = this.ObisMedium;
          return obisMedium.Value.ToString() + this.ManufacturerName + this.GenerationAsString;
        }
        catch
        {
        }
        return (string) null;
      }
      set
      {
        this.ObisMedium = value.Length == 6 ? new char?(value[0]) : throw new Exception("Illegal IdentificationPrefix length");
        this.ManufacturerName = value.Substring(1, 3);
        this.GenerationAsString = value.Substring(4, 2);
      }
    }

    public virtual string FD_IdentificationPrefix
    {
      get
      {
        return !this.FD_ObisMedium.HasValue || this.FD_ManufacturerName == null || !this.FD_Generation.HasValue ? (string) null : this.FD_ObisMedium.Value.ToString() + this.FD_ManufacturerName + this.FD_GenerationAsString;
      }
    }

    public virtual int? FabricationNumber
    {
      get
      {
        if (!this.ID_BCD.HasValue)
          return new int?();
        int result;
        return !int.TryParse(this.ID_BCD.Value.ToString("X08"), out result) ? new int?() : new int?(result);
      }
      set
      {
        int num1;
        if (value.HasValue)
        {
          int? nullable = value;
          int num2 = 0;
          if (!(nullable.GetValueOrDefault() < num2 & nullable.HasValue))
          {
            nullable = value;
            int num3 = 99999999;
            num1 = nullable.GetValueOrDefault() > num3 & nullable.HasValue ? 1 : 0;
            goto label_4;
          }
        }
        num1 = 1;
label_4:
        if (num1 != 0)
          throw new Exception("Illegal FabricationNumber");
        this.ID_BCD = new uint?(uint.Parse(value.ToString(), NumberStyles.HexNumber));
      }
    }

    public string FabricationNumberAsString
    {
      get
      {
        try
        {
          int? fabricationNumber = this.FabricationNumber;
          if (!fabricationNumber.HasValue)
            return (string) null;
          fabricationNumber = this.FabricationNumber;
          return fabricationNumber.Value.ToString("d08");
        }
        catch (Exception ex)
        {
          return "Err:" + ex.Message;
        }
      }
      set
      {
        if (string.IsNullOrEmpty(value))
          this.FabricationNumber = new int?();
        else
          this.FabricationNumber = new int?(int.Parse(value));
      }
    }

    public virtual int? FD_FabricationNumber
    {
      get
      {
        if (!this.FD_ID_BCD.HasValue)
          return new int?();
        int result;
        return !int.TryParse(this.FD_ID_BCD.Value.ToString("X08"), out result) ? new int?() : new int?(result);
      }
    }

    public string FD_FabricationNumberAsString
    {
      get
      {
        return !this.FD_FabricationNumber.HasValue ? (string) null : this.FD_FabricationNumber.Value.ToString("d08");
      }
    }

    public virtual string FullSerialNumber
    {
      get
      {
        int? fabricationNumber;
        int num;
        if (this.IdentificationPrefix != null)
        {
          fabricationNumber = this.FabricationNumber;
          num = !fabricationNumber.HasValue ? 1 : 0;
        }
        else
          num = 1;
        if (num != 0)
          return (string) null;
        string identificationPrefix = this.IdentificationPrefix;
        fabricationNumber = this.FabricationNumber;
        string str = fabricationNumber.Value.ToString("d08");
        return identificationPrefix + str;
      }
      set
      {
        if (value.Length != 14)
          throw new Exception("Illegal FullSerialNumber length");
        int result;
        this.IdentificationPrefix = int.TryParse(value.Substring(6), out result) ? value.Substring(0, 6) : throw new Exception("Illegal FullSerialNumber format in FabricationNumber");
        this.FabricationNumber = new int?(result);
      }
    }

    public virtual string FD_FullSerialNumber
    {
      get
      {
        try
        {
          return this.FD_IdentificationPrefix == null || !this.FD_FabricationNumber.HasValue ? (string) null : this.FD_IdentificationPrefix + this.FD_FabricationNumberAsString;
        }
        catch
        {
        }
        return (string) null;
      }
    }

    public virtual ulong? LoRa_DevEUI
    {
      get => this.loRa_DevEUI;
      set => throw new Exception("Write of LoRa_DevEUI not defined");
    }

    public string LoRa_DevEUI_AsString
    {
      get => !this.LoRa_DevEUI.HasValue ? (string) null : this.LoRa_DevEUI.Value.ToString("X016");
      set
      {
        ulong result;
        if (!ulong.TryParse(value, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          throw new NotSupportedException("Illegal number format");
        this.LoRa_DevEUI = new ulong?(result);
      }
    }

    public virtual ulong? FD_LoRa_DevEUI
    {
      get => this.fD_FD_LoRa_DevEUI;
      set => this.fD_FD_LoRa_DevEUI = new ulong?();
    }

    public string FD_LoRa_DevEUI_AsString
    {
      get
      {
        return !this.FD_LoRa_DevEUI.HasValue ? (string) null : this.FD_LoRa_DevEUI.Value.ToString("X016");
      }
      set
      {
        ulong result;
        if (!ulong.TryParse(value, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          throw new NotSupportedException("Illegal number format");
        this.FD_LoRa_DevEUI = new ulong?(result);
      }
    }

    public virtual ulong? LoRa_JoinEUI
    {
      get => this.loRa_JoinEUI;
      set => throw new Exception("Write of LoRa_JoinEUI not defined");
    }

    public string LoRa_JoinEUI_AsString
    {
      get => !this.LoRa_JoinEUI.HasValue ? (string) null : this.LoRa_JoinEUI.Value.ToString("X016");
      set
      {
        ulong result;
        if (!ulong.TryParse(value, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          throw new NotSupportedException("Illegal JoinEUI number format");
        this.LoRa_JoinEUI = new ulong?(result);
      }
    }

    public virtual ulong? FD_LoRa_JoinEUI
    {
      get => this.fD_LoRa_JoinEUI;
      set => this.fD_LoRa_JoinEUI = new ulong?();
    }

    public string FD_LoRa_JoinEUI_AsString
    {
      get
      {
        return !this.FD_LoRa_JoinEUI.HasValue ? (string) null : this.FD_LoRa_JoinEUI.Value.ToString("X016");
      }
      set
      {
        ulong result;
        if (!ulong.TryParse(value, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          throw new NotSupportedException("Illegal number format");
        this.FD_LoRa_JoinEUI = new ulong?(result);
      }
    }

    public virtual byte[] LoRa_AppKey
    {
      get => this.loRa_AppKey;
      set => throw new Exception("Write of LoRa_AppKey not defined");
    }

    public string LoRa_AppKey_AsString
    {
      get => this.LoRa_AppKey == null ? (string) null : Util.ByteArrayToHexString(this.LoRa_AppKey);
      set => this.LoRa_AppKey = Util.HexStringToByteArray(value);
    }

    public virtual byte[] FD_LoRa_AppKey
    {
      get => this.fD_LoRa_AppKey;
      set => this.fD_LoRa_AppKey = (byte[]) null;
    }

    public string FD_LoRa_AppKey_AsString
    {
      get
      {
        return this.FD_LoRa_AppKey == null ? (string) null : Util.ByteArrayToHexString(this.FD_LoRa_AppKey);
      }
      set => this.FD_LoRa_AppKey = Util.HexStringToByteArray(value);
    }

    public virtual uint? MeterID
    {
      get => this.meterID;
      set => throw new Exception("Write of MeterID not defined");
    }

    public string GetMeterID_String()
    {
      return !this.MeterID.HasValue ? (string) null : this.MeterID.ToString();
    }

    public virtual uint? HardwareTypeID
    {
      get => this.hardwareTypeID;
      set => throw new Exception("Write of HardwareTypeID not defined");
    }

    public string GetHardwareTypeID_String()
    {
      return !this.HardwareTypeID.HasValue ? (string) null : this.HardwareTypeID.ToString();
    }

    public virtual uint? MeterInfoID
    {
      get => this.meterInfoID;
      set => throw new Exception("Write of MeterInfoID not defined");
    }

    public string MeterInfoID_AsString
    {
      get => !this.MeterInfoID.HasValue ? (string) null : this.MeterInfoID.ToString();
      set
      {
        if (value == null)
          this.MeterInfoID = new uint?(0U);
        else if (string.IsNullOrEmpty(value.Trim()))
          this.MeterInfoID = new uint?(0U);
        else
          this.MeterInfoID = new uint?(uint.Parse(value));
      }
    }

    public virtual uint? MeterTypeID
    {
      get => this.meterTypeID;
      set => throw new Exception("Write of MeterTypeID not defined");
    }

    public string GetMeterTypeID_String()
    {
      return !this.MeterTypeID.HasValue ? (string) null : this.MeterTypeID.ToString();
    }

    public virtual uint? BaseTypeID
    {
      get => this.baseTypeID;
      set => throw new Exception("Write of BaseTypeID not defined");
    }

    public string GetBaseTypeID_String()
    {
      return !this.BaseTypeID.HasValue ? (string) null : this.BaseTypeID.ToString();
    }

    public virtual uint? SubPartNumber
    {
      get => this.subPartNumber;
      set => this.subPartNumber = value;
    }

    public string GetSubPartNumber_String()
    {
      return !this.SubPartNumber.HasValue ? (string) null : this.SubPartNumber.ToString();
    }

    public virtual uint? SAP_MaterialNumber
    {
      get => this.sAP_MaterialNumber;
      set => throw new Exception("Write of SAP_MaterialNumber not defined");
    }

    public string GetSAP_MaterialNumberString()
    {
      return !this.SAP_MaterialNumber.HasValue ? (string) null : this.SAP_MaterialNumber.ToString();
    }

    public virtual string SAP_ProductionOrderNumber
    {
      get => this.sAP_ProductionOrderNumber;
      set => throw new Exception("Write of SAP_ProductionOrderNumber not defined");
    }

    public virtual ushort? ApprovalRevision
    {
      get => new ushort?();
      set => throw new Exception("Write of ApprovalRevision not defined");
    }

    public string ApprovalRevisionAsString
    {
      get => !this.ApprovalRevision.HasValue ? "" : this.ApprovalRevision.Value.ToString();
      set => throw new Exception("Write of ApprovalRevisionAsString not defined");
    }

    public virtual void Set_FD_Values()
    {
      this.FD_ID_BCD = this.ID_BCD;
      this.FD_Generation = this.Generation;
      this.FD_Manufacturer = this.Manufacturer;
      this.FD_Medium = this.Medium;
      this.FD_ObisMedium = this.ObisMedium;
      this.FD_AES_Key = this.AES_Key;
      this.FD_LoRa_DevEUI = this.LoRa_DevEUI;
      this.FD_LoRa_JoinEUI = this.LoRa_JoinEUI;
      this.FD_LoRa_AppKey = this.LoRa_AppKey;
    }

    public override string ToString()
    {
      StringBuilder stringBuilder = new StringBuilder();
      if (this.FullSerialNumber != null)
        stringBuilder.AppendLine("SerialNumber: ...... " + this.FullSerialNumber);
      if (this.FirmwareVersion.HasValue)
        stringBuilder.AppendLine("Firmware version: " + this.GetFirmwareVersionString());
      if (this.HardwareID.HasValue)
        stringBuilder.AppendLine("HardwareID: 0x" + this.GetHardwareIDString());
      if (this.SvnRevision.HasValue)
        stringBuilder.AppendLine("SvnRevision: " + this.SvnRevision.Value.ToString());
      if (this.MeterID.HasValue)
        stringBuilder.AppendLine("MeterID: " + this.MeterID.Value.ToString());
      return stringBuilder.ToString();
    }

    public string ToString(string format, string firmwareInfo = null)
    {
      StringBuilder InfoString = new StringBuilder();
      switch (format)
      {
        case "f":
          if (this.IsAvailable("Firmware version: ", (object) this.FirmwareVersion, InfoString))
            InfoString.AppendLine(this.FirmwareVersionObj.ToString());
          uint? nullable1;
          if (this.IsAvailable("HardwareID: 0x", (object) this.HardwareID, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable1 = this.HardwareID;
            string str = nullable1.Value.ToString("X");
            stringBuilder.AppendLine(str);
          }
          if (this.IsAvailable("Unique_ID: ", (object) this.Unique_ID, InfoString))
            InfoString.AppendLine(Util.ByteArrayToHexString(this.Unique_ID));
          ushort? nullable2;
          if (this.IsAvailable("Signatur: ", (object) this.Signatur, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable2 = this.Signatur;
            string str = nullable2.ToString();
            stringBuilder.AppendLine(str);
          }
          if (this.IsAvailable("SvnRevision: ", (object) this.SvnRevision, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable1 = this.SvnRevision;
            string str = nullable1.Value.ToString();
            stringBuilder.AppendLine(str);
          }
          if (this.IsAvailable("BuildTime: ", (object) this.BuildTime, InfoString))
            InfoString.AppendLine(this.BuildTime.Value.ToString());
          if (this.IsAvailable("ID_BCD: 0x", (object) this.ID_BCD, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable1 = this.ID_BCD;
            string str = nullable1.Value.ToString("X08");
            stringBuilder.AppendLine(str);
          }
          if (this.IsAvailable("Manufacturer: 0x", (object) this.Manufacturer, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable2 = this.Manufacturer;
            string str = nullable2.Value.ToString("X04");
            stringBuilder.AppendLine(str);
          }
          byte? nullable3;
          if (this.IsAvailable("Generation: 0x", (object) this.Generation, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable3 = this.Generation;
            string str = nullable3.Value.ToString("X02");
            stringBuilder.AppendLine(str);
          }
          if (this.IsAvailable("Medium: 0x", (object) this.Medium, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable3 = this.Medium;
            string str = nullable3.Value.ToString("X02");
            stringBuilder.AppendLine(str);
          }
          if (this.IsAvailable("ObisMedium: ", (object) this.ObisMedium, InfoString))
            InfoString.AppendLine(this.ObisMedium.Value.ToString());
          try
          {
            if (this.IsAvailable("FullSerialNumber: ", (object) this.FullSerialNumber, InfoString))
              InfoString.AppendLine(this.FullSerialNumber);
          }
          catch (Exception ex)
          {
          }
          uint? nullable4;
          if (this.IsAvailable("MeterID: ", (object) this.MeterID, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable4 = this.MeterID;
            string str = nullable4.Value.ToString();
            stringBuilder.AppendLine(str);
          }
          if (this.IsAvailable("HardwareTypeID: ", (object) this.HardwareTypeID, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable4 = this.HardwareTypeID;
            string str = nullable4.Value.ToString();
            stringBuilder.AppendLine(str);
          }
          if (this.IsAvailable("MeterInfoID: ", (object) this.MeterInfoID, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable4 = this.MeterInfoID;
            string str = nullable4.Value.ToString();
            stringBuilder.AppendLine(str);
          }
          if (this.IsAvailable("MeterTypeID: ", (object) this.MeterTypeID, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable4 = this.MeterTypeID;
            string str = nullable4.Value.ToString();
            stringBuilder.AppendLine(str);
          }
          if (this.IsAvailable("BaseTypeID: ", (object) this.BaseTypeID, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable4 = this.BaseTypeID;
            string str = nullable4.Value.ToString();
            stringBuilder.AppendLine(str);
          }
          if (this.IsAvailable("SAP_MaterialNumber: ", (object) this.SAP_MaterialNumber, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable4 = this.SAP_MaterialNumber;
            string str = nullable4.Value.ToString();
            stringBuilder.AppendLine(str);
          }
          if (this.IsAvailable("SAP_ProductionOrderNumber: ", (object) this.SAP_ProductionOrderNumber, InfoString))
          {
            InfoString.AppendLine(this.SAP_ProductionOrderNumber);
            break;
          }
          break;
        case "h":
          uint? nullable5;
          uint num1;
          if (this.FirmwareVersion.HasValue && this.HardwareID.HasValue && this.SvnRevision.HasValue)
          {
            StringBuilder stringBuilder = InfoString;
            string[] strArray = new string[6]
            {
              "Firmware version: ",
              this.FirmwareVersionObj.ToString(),
              " ; HardwareID: 0x",
              this.HardwareID.Value.ToString("X"),
              " ; SvnRevision: ",
              null
            };
            nullable5 = this.SvnRevision;
            num1 = nullable5.Value;
            strArray[5] = num1.ToString();
            string str = string.Concat(strArray);
            stringBuilder.AppendLine(str);
          }
          else
          {
            if (this.IsAvailable("Firmware version: ", (object) this.FirmwareVersion, InfoString))
              InfoString.AppendLine(this.FirmwareVersionObj.ToString());
            if (this.IsAvailable("HardwareID: 0x", (object) this.HardwareID, InfoString))
            {
              StringBuilder stringBuilder = InfoString;
              nullable5 = this.HardwareID;
              string str = nullable5.Value.ToString("X");
              stringBuilder.AppendLine(str);
            }
            if (this.IsAvailable("SvnRevision: ", (object) this.SvnRevision, InfoString))
            {
              StringBuilder stringBuilder = InfoString;
              nullable5 = this.SvnRevision;
              string str = nullable5.Value.ToString();
              stringBuilder.AppendLine(str);
            }
          }
          if (firmwareInfo != null)
            InfoString.AppendLine("FirmwareInfo: " + firmwareInfo);
          nullable5 = this.MeterID;
          int num2;
          if (nullable5.HasValue && this.Medium.HasValue && this.Manufacturer.HasValue && this.Generation.HasValue)
          {
            nullable5 = this.ID_BCD;
            num2 = nullable5.HasValue ? 1 : 0;
          }
          else
            num2 = 0;
          if (num2 != 0)
          {
            StringBuilder stringBuilder = InfoString;
            nullable5 = this.MeterID;
            string str = "MeterID: " + nullable5.ToString() + " ; SerialNumber: " + this.FullSerialNumber;
            stringBuilder.AppendLine(str);
          }
          else if (this.IsAvailable("MeterID: ", (object) this.MeterID, InfoString))
          {
            StringBuilder stringBuilder = InfoString;
            nullable5 = this.MeterID;
            num1 = nullable5.Value;
            string str = num1.ToString();
            stringBuilder.AppendLine(str);
          }
          if (this.Unique_ID != null)
          {
            InfoString.AppendLine("ARM Unique_ID: " + Util.ByteArrayToHexString(this.Unique_ID));
            break;
          }
          break;
        default:
          InfoString.AppendLine("Illegal output format: '" + format + "'");
          break;
      }
      return InfoString.ToString();
    }

    private bool IsAvailable(string name, object testObject, StringBuilder InfoString)
    {
      InfoString.Append(name);
      if (testObject != null)
        return true;
      InfoString.AppendLine(" = null");
      return false;
    }

    public string Print(int spaces = 0) => Utility.PrintAvailableObjectProperties((object) this);

    public void SetObisMediumFromMBusMedium()
    {
      if (!this.Medium.HasValue)
        throw new Exception("MBus medium not defined");
      this.ObisMedium = new char?(DeviceIdentification.GetObisMediumFromMBusMedium(this.medium.Value));
    }

    public void PrintId(StringBuilder printText)
    {
      printText.AppendLine("Hardware: .......... " + this.GetHardwareIDString());
      printText.AppendLine("FirmwareVersion: ... " + this.GetFirmwareVersionString());
      printText.AppendLine("SerialNumber: ...... " + this.FullSerialNumber);
      printText.Append("PrintedSerialNumber: ");
      if (this.PrintedSerialNumber != null)
        printText.AppendLine(this.PrintedSerialNumberAsString);
      else
        printText.AppendLine("null");
      if (this.LoRa_DevEUI.HasValue)
        printText.AppendLine("LoRa_DevEUI: ....... " + this.LoRa_DevEUI_AsString);
      if (this.LoRa_JoinEUI.HasValue)
        printText.AppendLine("JoinEUI: ........... " + this.LoRa_JoinEUI_AsString);
      printText.AppendLine("SAP_Number: ........ " + this.GetSAP_MaterialNumberString());
      printText.AppendLine("MeterId: ........... " + this.MeterID.ToString());
      printText.AppendLine("MeterInfoId: ....... " + this.MeterInfoID.ToString());
      printText.AppendLine("BaseTypeId: ........ " + this.BaseTypeID.ToString());
    }

    public static char GetObisMediumFromMBusMedium(byte MBusMedium)
    {
      switch ((MBusLib.Medium) MBusMedium)
      {
        case MBusLib.Medium.OTHER:
          return 'F';
        case MBusLib.Medium.OIL:
          return 'F';
        case MBusLib.Medium.ELECTRICITY:
          return '1';
        case MBusLib.Medium.GAS:
          return '7';
        case MBusLib.Medium.HEAT_OUTLET:
          return '6';
        case MBusLib.Medium.STEAM:
          return 'F';
        case MBusLib.Medium.HOT_WATER:
          return '9';
        case MBusLib.Medium.WATER:
          return '8';
        case MBusLib.Medium.HCA:
          return '4';
        case MBusLib.Medium.COMPRESSED_AIR:
          return 'F';
        case MBusLib.Medium.COOL_OUTLET:
          return '5';
        case MBusLib.Medium.COOL_INLET:
          return '5';
        case MBusLib.Medium.HEAT_INLET:
          return '6';
        case MBusLib.Medium.HEAT_AND_COOL:
          return '6';
        case MBusLib.Medium.BUS_SYSTEM:
          return 'F';
        case MBusLib.Medium.UNKNOWN:
          return 'F';
        case MBusLib.Medium.HOT_WATER_90:
          return '9';
        case MBusLib.Medium.COLD_WATER:
          return '8';
        case MBusLib.Medium.HOT_AND_COLD_WATER:
          return '8';
        case MBusLib.Medium.PRESSURE:
          return 'F';
        case MBusLib.Medium.AD_CONVERTER:
          return 'F';
        case MBusLib.Medium.RF_Adapter:
          return 'F';
        default:
          throw new Exception("MBus medium unknown");
      }
    }

    public static MBusLib.Medium GetMBusMediumFromObisMedium(char ObisMedium)
    {
      switch (ObisMedium)
      {
        case '8':
          return MBusLib.Medium.WATER;
        case '9':
          return MBusLib.Medium.HOT_WATER;
        default:
          return MBusLib.Medium.OTHER;
      }
    }

    public static byte[] GetArmUniqueID(byte[] uniqueIdRange)
    {
      if (uniqueIdRange.Length != 24)
        throw new ArgumentException("Illegal UniqueIdRange length");
      byte[] dst = new byte[12];
      Buffer.BlockCopy((Array) uniqueIdRange, 0, (Array) dst, 0, 8);
      Buffer.BlockCopy((Array) uniqueIdRange, 20, (Array) dst, 8, 4);
      return dst;
    }

    public static string GetMacAddress(FirmwareType firmwareType, int nextID)
    {
      switch (firmwareType)
      {
        case FirmwareType.IDU:
          byte[] source1 = new byte[6]
          {
            (byte) 4,
            (byte) 182,
            (byte) 72,
            (byte) 16,
            (byte) 0,
            (byte) 0
          };
          byte[] bytes1 = BitConverter.GetBytes(nextID);
          source1[5] = bytes1[0];
          source1[4] = bytes1[1];
          source1[3] |= bytes1[2];
          return string.Join(":", ((IEnumerable<byte>) source1).Select<byte, string>((Func<byte, string>) (b => b.ToString("X2"))));
        case FirmwareType.ODU:
          byte[] source2 = new byte[6]
          {
            (byte) 4,
            (byte) 182,
            (byte) 72,
            (byte) 32,
            (byte) 0,
            (byte) 0
          };
          byte[] bytes2 = BitConverter.GetBytes(nextID);
          source2[5] = bytes2[0];
          source2[4] = bytes2[1];
          source2[3] |= bytes2[2];
          return string.Join(":", ((IEnumerable<byte>) source2).Select<byte, string>((Func<byte, string>) (b => b.ToString("X2"))));
        default:
          throw new NotImplementedException(firmwareType.ToString());
      }
    }
  }
}


--- DeviceMemory.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceMemory
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommonWPF;
using GmmDbLib;
using GmmDbLib.DataSets;
using HandlerLib.MapManagement;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Reflection;
using System.Text;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class DeviceMemory
  {
    public uint FirmwareVersion;
    public MapDefClassBase MapDef;
    public SortedList<string, Parameter32bit> UsedParametersByName;
    public MeterTypeNAME MeterTypeName;
    public bool CloneCreated = false;

    public SortedList<uint, DeviceMemoryStorage> MemoryBlockList { get; private set; }

    public DeviceMemory(uint FirmwareVersion)
    {
      this.FirmwareVersion = FirmwareVersion;
      this.MemoryBlockList = new SortedList<uint, DeviceMemoryStorage>();
    }

    public DeviceMemory(uint FirmwareVersion, Assembly handlerAssembly)
    {
      this.FirmwareVersion = FirmwareVersion;
      this.MemoryBlockList = new SortedList<uint, DeviceMemoryStorage>();
      this.MapDef = MapDefClassBase.GetMapObjectFromVersion(handlerAssembly, FirmwareVersion);
    }

    public DeviceMemory(byte[] compressedData)
    {
      this.MemoryBlockList = new SortedList<uint, DeviceMemoryStorage>();
      this.CreateFromCompressedData(compressedData);
    }

    public DeviceMemory(DeviceMemory sourceToClone)
    {
      this.FirmwareVersion = sourceToClone.FirmwareVersion;
      this.MemoryBlockList = new SortedList<uint, DeviceMemoryStorage>();
      foreach (DeviceMemoryStorage deviceMemoryStorage in (IEnumerable<DeviceMemoryStorage>) sourceToClone.MemoryBlockList.Values)
        this.MemoryBlockList.Add(deviceMemoryStorage.StartAddress, deviceMemoryStorage.Clone());
      this.MapDef = sourceToClone.MapDef;
      this.UsedParametersByName = sourceToClone.UsedParametersByName;
      sourceToClone.CloneCreated = true;
    }

    public void AddMemoryBlock(DeviceMemoryType deviceMemoryType, uint startAddess, uint byteSize)
    {
      DeviceMemoryStorage deviceMemoryStorage = new DeviceMemoryStorage(deviceMemoryType, startAddess, byteSize);
      this.MemoryBlockList.Add(deviceMemoryStorage.StartAddress, deviceMemoryStorage);
    }

    public void AddMemoryBlock(ReadPartsSelection readSelection, uint startAddess, uint byteSize)
    {
      DeviceMemoryType deviceMemoryType = DeviceMemoryType.FLASH;
      if ((readSelection & ReadPartsSelection.RAM_range) > ~(ReadPartsSelection.Dump | ReadPartsSelection.ProtocolOnlyMode))
        deviceMemoryType = DeviceMemoryType.DataRAM;
      DeviceMemoryStorage deviceMemoryStorage = new DeviceMemoryStorage(deviceMemoryType, startAddess, byteSize);
      deviceMemoryStorage.ReadSelection = readSelection;
      this.MemoryBlockList.Add(deviceMemoryStorage.StartAddress, deviceMemoryStorage);
    }

    public void AddMemoryBlock(
      DeviceMemoryType deviceMemoryType,
      uint startAddess,
      uint byteSize,
      uint writeSplitSize)
    {
      DeviceMemoryStorage deviceMemoryStorage = new DeviceMemoryStorage(deviceMemoryType, startAddess, byteSize, writeSplitSize);
      this.MemoryBlockList.Add(deviceMemoryStorage.StartAddress, deviceMemoryStorage);
    }

    public void AddMemoryBlock(DeviceMemoryType deviceMemoryType, AddressRange addressRangeObject)
    {
      if (addressRangeObject == null)
        return;
      this.AddMemoryBlock(deviceMemoryType, addressRangeObject.StartAddress, addressRangeObject.ByteSize);
    }

    public void AddMemoryBlock(
      DeviceMemoryType deviceMemoryType,
      AddressRange addressRangeObject,
      uint writeSplitSize)
    {
      this.AddMemoryBlock(deviceMemoryType, addressRangeObject.StartAddress, addressRangeObject.ByteSize, writeSplitSize);
    }

    public void GarantMemoryAvailable(AddressRange setRange)
    {
      if (this.AreMemoryBlocksAvailable(setRange))
        return;
      AddressRange theRange = new AddressRange(setRange.StartAddress == 0U ? 0U : setRange.StartAddress - 1U, setRange.ByteSize + 2U);
      SortedList<uint, DeviceMemoryStorage> storagesForAddressRange = this.GetDeviceMemoryStoragesForAddressRange(theRange);
      if (storagesForAddressRange.Count == 0)
      {
        DeviceMemoryStorage deviceMemoryStorage = new DeviceMemoryStorage(DeviceMemoryType.Unknown, setRange.StartAddress, setRange.ByteSize);
        this.MemoryBlockList.Add(deviceMemoryStorage.StartAddress, deviceMemoryStorage);
      }
      else
      {
        if (storagesForAddressRange.Keys[0] > setRange.StartAddress)
        {
          DeviceMemoryStorage partStorage = storagesForAddressRange.Values[0];
          DeviceMemoryStorage deviceMemoryStorage = new DeviceMemoryStorage(partStorage.MemoryType, setRange.StartAddress, (uint) ((int) partStorage.EndAddress - (int) setRange.StartAddress + 1));
          deviceMemoryStorage.IncludeDataFromPartStorage(partStorage);
          this.MemoryBlockList.Remove(partStorage.StartAddress);
          this.MemoryBlockList.Add(deviceMemoryStorage.StartAddress, deviceMemoryStorage);
          storagesForAddressRange = this.GetDeviceMemoryStoragesForAddressRange(theRange);
        }
        for (int index = 0; index < storagesForAddressRange.Count - 1; ++index)
        {
          if (storagesForAddressRange.Values[index].EndAddress < storagesForAddressRange.Values[index + 1].StartAddress)
          {
            DeviceMemoryStorage deviceMemoryStorage = new DeviceMemoryStorage(storagesForAddressRange.Values[index].MemoryType, storagesForAddressRange.Values[index].StartAddress, storagesForAddressRange.Values[index + 1].StartAddress - storagesForAddressRange.Values[index].StartAddress, storagesForAddressRange.Values[index].WriteSplitSize);
            deviceMemoryStorage.IncludeDataFromPartStorage(storagesForAddressRange.Values[index]);
            this.MemoryBlockList.Remove(storagesForAddressRange.Keys[index]);
            this.MemoryBlockList.Add(deviceMemoryStorage.StartAddress, deviceMemoryStorage);
          }
        }
        DeviceMemoryStorage partStorage1 = storagesForAddressRange.Values[storagesForAddressRange.Count - 1];
        if (partStorage1.EndAddress >= setRange.EndAddress)
          return;
        DeviceMemoryStorage deviceMemoryStorage1 = new DeviceMemoryStorage(partStorage1.MemoryType, partStorage1.StartAddress, (uint) ((int) setRange.EndAddress - (int) partStorage1.StartAddress + 1), partStorage1.WriteSplitSize);
        deviceMemoryStorage1.IncludeDataFromPartStorage(partStorage1);
        this.MemoryBlockList.Remove(partStorage1.StartAddress);
        this.MemoryBlockList.Add(deviceMemoryStorage1.StartAddress, deviceMemoryStorage1);
      }
    }

    private DeviceMemoryStorage GetDeviceMemoryStorageForAddress(uint address)
    {
      return this.MemoryBlockList.Values.FirstOrDefault<DeviceMemoryStorage>((System.Func<DeviceMemoryStorage, bool>) (x => address >= x.StartAddress && address <= x.EndAddress));
    }

    private DeviceMemoryStorage GetDeviceMemoryStorageForAddressRange(AddressRange theRange)
    {
      return this.MemoryBlockList.Values.FirstOrDefault<DeviceMemoryStorage>((System.Func<DeviceMemoryStorage, bool>) (x => theRange.StartAddress >= x.StartAddress && theRange.EndAddress <= x.EndAddress));
    }

    private DeviceMemoryStorage GetDeviceMemoryStorageForAddressRange(uint address, uint byteSize)
    {
      return this.GetDeviceMemoryStorageForAddressRange(new AddressRange(address, byteSize));
    }

    private SortedList<uint, DeviceMemoryStorage> GetDeviceMemoryStoragesForAddressRange(
      AddressRange theRange)
    {
      SortedList<uint, DeviceMemoryStorage> storagesForAddressRange = new SortedList<uint, DeviceMemoryStorage>();
      foreach (DeviceMemoryStorage deviceMemoryStorage in this.MemoryBlockList.Values.Where<DeviceMemoryStorage>((System.Func<DeviceMemoryStorage, bool>) (x =>
      {
        if (theRange.StartAddress >= x.StartAddress && theRange.StartAddress <= x.EndAddress || theRange.EndAddress >= x.StartAddress && theRange.EndAddress <= x.EndAddress)
          return true;
        return x.StartAddress >= theRange.StartAddress && x.StartAddress <= theRange.EndAddress;
      })))
        storagesForAddressRange.Add(deviceMemoryStorage.StartAddress, deviceMemoryStorage);
      return storagesForAddressRange;
    }

    public DeviceMemoryStorage GetDeviceMemoryTypeForData(
      uint address,
      uint byteSize,
      out string message)
    {
      try
      {
        DeviceMemoryStorage memoryTypeForData = (DeviceMemoryStorage) null;
        message = string.Empty;
        uint num = (uint) ((int) address + (int) byteSize - 1);
        foreach (DeviceMemoryStorage deviceMemoryStorage in (IEnumerable<DeviceMemoryStorage>) this.MemoryBlockList.Values)
        {
          if (address >= deviceMemoryStorage.StartAddress && num <= deviceMemoryStorage.EndAddress)
          {
            memoryTypeForData = deviceMemoryStorage;
            for (int index1 = 0; (long) index1 < (long) byteSize; ++index1)
            {
              int index2 = (int) ((long) (address - deviceMemoryStorage.StartAddress) + (long) index1);
              if (!deviceMemoryStorage.DataAvailable[index2])
                message = "Memory data not available... (E0)";
            }
            return memoryTypeForData;
          }
          if (address >= deviceMemoryStorage.StartAddress && address <= deviceMemoryStorage.EndAddress && num > deviceMemoryStorage.EndAddress)
          {
            memoryTypeForData = deviceMemoryStorage;
            message = "memory out of range!!! (E1)";
            return memoryTypeForData;
          }
          if (address >= deviceMemoryStorage.StartAddress && address <= deviceMemoryStorage.EndAddress || num >= deviceMemoryStorage.StartAddress && num <= deviceMemoryStorage.EndAddress)
          {
            memoryTypeForData = deviceMemoryStorage;
            message = "memory out of range!!! (E1)";
            return memoryTypeForData;
          }
          if (address <= deviceMemoryStorage.StartAddress && num >= deviceMemoryStorage.EndAddress)
          {
            memoryTypeForData = deviceMemoryStorage;
            message = "memory collision in range!!! (E1)";
            return memoryTypeForData;
          }
        }
        if (memoryTypeForData == null)
          message = "Out of defined memory blocks. (E2)";
        return memoryTypeForData;
      }
      catch (Exception ex)
      {
        message = "Out of defined memory blocks. (E2)";
        return (DeviceMemoryStorage) null;
      }
    }

    private bool AreMemoryBlocksAvailable(AddressRange testRange)
    {
      for (DeviceMemoryStorage storageForAddress = this.GetDeviceMemoryStorageForAddress(testRange.StartAddress); storageForAddress != null; storageForAddress = this.GetDeviceMemoryStorageForAddress(storageForAddress.EndAddress + 1U))
      {
        if (storageForAddress.EndAddress >= testRange.EndAddress)
          return true;
      }
      return false;
    }

    public byte? GetByte(uint address)
    {
      DeviceMemoryStorage storageForAddress = this.GetDeviceMemoryStorageForAddress(address);
      if (storageForAddress == null)
        throw new Exception("Access outside of defined memory blocks. Address: 0x" + address.ToString("x08"));
      uint index = address - storageForAddress.StartAddress;
      return !storageForAddress.DataAvailable[(int) index] ? new byte?() : new byte?(storageForAddress.Data[(int) index]);
    }

    public byte[] GetData(AddressRange addressRange, bool returnAvailableStartData = false)
    {
      return this.GetData(addressRange.StartAddress, addressRange.ByteSize, returnAvailableStartData);
    }

    public byte[] GetData(uint address, uint byteSize, bool returnAvailableStartData = false)
    {
      List<byte> byteList = new List<byte>();
      DeviceMemoryStorage storageForAddress = this.GetDeviceMemoryStorageForAddress(address);
      if (storageForAddress == null)
        return returnAvailableStartData ? byteList.ToArray() : (byte[]) null;
      uint num = address + byteSize;
      for (uint address1 = address; address1 < num; ++address1)
      {
        if (address1 > storageForAddress.EndAddress)
        {
          storageForAddress = this.GetDeviceMemoryStorageForAddress(address1);
          if (storageForAddress == null)
            return returnAvailableStartData ? byteList.ToArray() : (byte[]) null;
        }
        uint index = address1 - storageForAddress.StartAddress;
        if (!storageForAddress.DataAvailable[(int) index])
          return returnAvailableStartData ? byteList.ToArray() : (byte[]) null;
        byteList.Add(storageForAddress.Data[(int) index]);
      }
      return byteList.ToArray();
    }

    public byte[] GetAvailableData(uint address, uint maxByteSize)
    {
      List<byte> byteList = new List<byte>();
      DeviceMemoryStorage storageForAddress = this.GetDeviceMemoryStorageForAddress(address);
      if (storageForAddress != null)
      {
        while ((long) byteList.Count < (long) maxByteSize)
        {
          if (address > storageForAddress.EndAddress)
          {
            storageForAddress = this.GetDeviceMemoryStorageForAddress(address);
            if (storageForAddress == null)
              break;
          }
          uint index = address - storageForAddress.StartAddress;
          if (storageForAddress.DataAvailable[(int) index])
          {
            byteList.Add(storageForAddress.Data[(int) index]);
            ++address;
          }
          else
            break;
        }
      }
      return byteList.ToArray();
    }

    public byte[] GetAvailableData(uint address)
    {
      DeviceMemoryStorage storageForAddress = this.GetDeviceMemoryStorageForAddress(address);
      if (storageForAddress == null)
        return new byte[0];
      uint index = address - storageForAddress.StartAddress;
      uint byteSize = storageForAddress.ByteSize;
      List<byte> byteList = new List<byte>();
      while (index < byteSize && storageForAddress.DataAvailable[(int) index])
        byteList.Add(storageForAddress.Data[(int) index++]);
      return byteList.ToArray();
    }

    public void InsertAvailableData(byte[] data, uint dataStartAddress)
    {
      uint address = dataStartAddress;
      int index1 = 0;
      DeviceMemoryStorage deviceMemoryStorage = (DeviceMemoryStorage) null;
      uint index2 = 0;
      for (; index1 < data.Length; ++index1)
      {
        if (deviceMemoryStorage == null)
        {
          deviceMemoryStorage = this.GetDeviceMemoryStorageForAddress(address);
          if (deviceMemoryStorage != null)
            index2 = address - deviceMemoryStorage.StartAddress;
        }
        if (deviceMemoryStorage != null)
        {
          if (deviceMemoryStorage.DataAvailable[(int) index2])
            data[index1] = deviceMemoryStorage.Data[(int) index2];
          ++index2;
          if (index2 >= deviceMemoryStorage.ByteSize)
            deviceMemoryStorage = (DeviceMemoryStorage) null;
        }
        ++address;
      }
    }

    public SortedList<string, string> GetDataForSection(string Section)
    {
      if (string.IsNullOrEmpty(Section))
        throw new ArgumentNullException("Argument Segment is NULL or EMPTY.");
      if (!((IEnumerable<string>) this.MapDef.SectionList).Contains<string>(Section))
        throw new ArgumentNullException("Section not in SectionList.");
      SortedList<string, string> dataForSection = new SortedList<string, string>();
      foreach (Parameter32bit parameter32bit in this.MapDef.GetAllParameterForSection(Section))
      {
        if (this.IsParameterAvailable(parameter32bit.Name))
        {
          int index = this.UsedParametersByName.IndexOfKey(parameter32bit.Name);
          byte[] data = this.GetData(this.UsedParametersByName.Values[index].Address, this.UsedParametersByName.Values[index].Size);
          dataForSection.Add(parameter32bit.Name, Util.ByteArrayToString(data));
        }
      }
      return dataForSection;
    }

    public string[] GetDataAsHexStrings(uint address, uint byteSize)
    {
      string[] dataAsHexStrings = new string[(int) byteSize];
      DeviceMemoryStorage deviceMemoryStorage = (DeviceMemoryStorage) null;
      uint num = address + byteSize;
      for (uint address1 = address; address1 < num; ++address1)
      {
        if (deviceMemoryStorage == null || address1 > deviceMemoryStorage.EndAddress)
          deviceMemoryStorage = this.GetDeviceMemoryStorageForAddress(address1);
        if (deviceMemoryStorage == null)
        {
          dataAsHexStrings[(int) address1 - (int) address] = "..";
        }
        else
        {
          uint index = address1 - deviceMemoryStorage.StartAddress;
          dataAsHexStrings[(int) address1 - (int) address] = deviceMemoryStorage.DataAvailable[(int) index] ? deviceMemoryStorage.Data[(int) index].ToString("x02") : "--";
        }
      }
      return dataAsHexStrings;
    }

    public void SetData(DeviceMemory memory)
    {
      foreach (DeviceMemoryStorage deviceMemoryStorage in (IEnumerable<DeviceMemoryStorage>) memory.MemoryBlockList.Values)
        this.SetData(deviceMemoryStorage.StartAddress, deviceMemoryStorage.Data);
    }

    public void SetData(uint address, byte[] data)
    {
      this.SetData(new AddressRange(address, (uint) data.Length), data);
    }

    public void SetData(AddressRange theRange, byte[] data)
    {
      try
      {
        uint startAddress = theRange.StartAddress;
        DeviceMemoryStorage deviceMemoryStorage = this.GetDeviceMemoryStorageForAddressRange(theRange) ?? this.GetDeviceMemoryStorageForAddress(startAddress);
        if (deviceMemoryStorage == null)
          throw new Exception("DeviceMemory::SetData management (CurrentStorage) error.");
        uint num = (uint) ((ulong) startAddress + (ulong) data.Length);
        for (uint address = startAddress; address < num; ++address)
        {
          if (address > deviceMemoryStorage.EndAddress)
            deviceMemoryStorage = this.GetDeviceMemoryStorageForAddress(address);
          uint index = address - deviceMemoryStorage.StartAddress;
          deviceMemoryStorage.Data[(int) index] = data[(int) address - (int) startAddress];
          deviceMemoryStorage.DataAvailable[(int) index] = true;
        }
      }
      catch (Exception ex)
      {
        throw new Exception("SetData management error.", ex);
      }
    }

    public bool AreDataAvailable(AddressRange testRange)
    {
      return testRange != null && this.AreDataAvailable(testRange.StartAddress, testRange.ByteSize);
    }

    public bool AreDataAvailable(uint address, uint byteSize)
    {
      uint num = (uint) ((int) address + (int) byteSize - 1);
      foreach (DeviceMemoryStorage deviceMemoryStorage in this.MemoryBlockList.Values.Where<DeviceMemoryStorage>((System.Func<DeviceMemoryStorage, bool>) (x => x.ByteSize >= byteSize)).ToList<DeviceMemoryStorage>())
      {
        if (address >= deviceMemoryStorage.StartAddress && num <= deviceMemoryStorage.EndAddress)
        {
          for (int index1 = 0; (long) index1 < (long) byteSize; ++index1)
          {
            int index2 = (int) ((long) (address - deviceMemoryStorage.StartAddress) + (long) index1);
            if (!deviceMemoryStorage.DataAvailable[index2])
              return false;
          }
          return true;
        }
      }
      return false;
    }

    public List<AddressRange> GetAvailableByteRanges(uint fromAddress, uint toAddress)
    {
      List<AddressRange> availableByteRanges = new List<AddressRange>();
      uint startAddress = fromAddress;
      AddressRange addressRange = (AddressRange) null;
      foreach (DeviceMemoryStorage deviceMemoryStorage in this.MemoryBlockList.Values.Where<DeviceMemoryStorage>((System.Func<DeviceMemoryStorage, bool>) (x => x.EndAddress >= fromAddress && x.StartAddress <= toAddress)))
      {
        if (startAddress < deviceMemoryStorage.StartAddress)
        {
          startAddress = deviceMemoryStorage.StartAddress;
          if (addressRange != null)
          {
            availableByteRanges.Add(addressRange);
            addressRange = (AddressRange) null;
          }
        }
        for (; startAddress <= deviceMemoryStorage.EndAddress && startAddress <= toAddress; ++startAddress)
        {
          int index = (int) startAddress - (int) deviceMemoryStorage.StartAddress;
          if (deviceMemoryStorage.DataAvailable[index])
          {
            if (addressRange == null)
              addressRange = new AddressRange(startAddress, 1U);
            else
              ++addressRange.ByteSize;
          }
          else if (addressRange != null)
          {
            availableByteRanges.Add(addressRange);
            addressRange = (AddressRange) null;
          }
        }
      }
      if (addressRange != null)
        availableByteRanges.Add(addressRange);
      return availableByteRanges;
    }

    public AddressRange GetNextAvailableDataRange(uint address)
    {
      DeviceMemoryStorage storageForAddress = this.GetDeviceMemoryStorageForAddress(address);
      if (storageForAddress == null)
        return (AddressRange) null;
      uint index = address - storageForAddress.StartAddress;
      uint byteSize = storageForAddress.ByteSize;
      uint startAddress = address;
      while (index < byteSize && !storageForAddress.DataAvailable[(int) index])
      {
        ++index;
        ++startAddress;
      }
      uint size = 0;
      for (; index < byteSize && storageForAddress.DataAvailable[(int) index]; ++index)
        ++size;
      return size == 0U ? (AddressRange) null : new AddressRange(startAddress, size);
    }

    public T GetParameterValue<T>(string parameterName)
    {
      int index = this.UsedParametersByName != null ? this.UsedParametersByName.IndexOfKey(parameterName) : throw new HandlerMessageException("MAP not included for this device and firmware.");
      if (index < 0)
        throw new Exception("Parameter not supported:" + parameterName);
      return this.UsedParametersByName.Values[index].GetValue<T>(this);
    }

    public byte[] GetData(string parameterName)
    {
      int index = this.UsedParametersByName.IndexOfKey(parameterName);
      if (index < 0)
        throw new Exception("Parameter not supported: " + parameterName);
      Parameter32bit parameter32bit = this.UsedParametersByName.Values[index];
      return this.GetData(parameter32bit.Address, parameter32bit.Size);
    }

    public AddressRange GetAddressRange(string parameterName)
    {
      SortedList<string, Parameter32bit> mapVars = this.MapDef.MapVars;
      return !mapVars.ContainsKey(parameterName) ? (AddressRange) null : mapVars[parameterName].AddressRange;
    }

    public byte[] GetDataForParameter(string parameterName)
    {
      return this.GetData(this.GetAddressRange(parameterName));
    }

    public void SetParameterValue<T>(string parameterName, T theValue)
    {
      int index = this.UsedParametersByName.IndexOfKey(parameterName);
      if (index < 0)
        throw new Exception("Parameter not supported:" + parameterName);
      this.UsedParametersByName.Values[index].SetValue<T>(theValue, this);
    }

    public void SetData(string parameterName, byte[] buffer)
    {
      int index = this.UsedParametersByName.IndexOfKey(parameterName);
      if (index < 0)
        throw new Exception("Parameter not supported: " + parameterName);
      this.SetData(this.UsedParametersByName.Values[index].Address, buffer);
    }

    public void OverwriteUsedParameters(DeviceMemory fromMemory, string[] parameterNameList)
    {
      string key = "";
      try
      {
        for (int index = 0; index < parameterNameList.Length; ++index)
        {
          key = parameterNameList[index];
          if (fromMemory.UsedParametersByName.ContainsKey(key) && this.UsedParametersByName.ContainsKey(key))
            this.SetData(this.UsedParametersByName[key].Address, fromMemory.GetData(fromMemory.UsedParametersByName[key].AddressRange) ?? throw new Exception("Source data not found for: " + key));
        }
      }
      catch (Exception ex)
      {
        throw new Exception("Overwrite of parameter faild: " + key, ex);
      }
    }

    public uint GetParameterAddress(string parameterName)
    {
      int index = this.UsedParametersByName.IndexOfKey(parameterName);
      if (index < 0)
        throw new Exception("Parameter not supported:" + parameterName);
      return this.UsedParametersByName.Values[index].Address;
    }

    public AddressRange GetParameterAddressRange(string parameterName)
    {
      int index = this.UsedParametersByName.IndexOfKey(parameterName);
      return index < 0 ? (AddressRange) null : this.UsedParametersByName.Values[index].AddressRange;
    }

    public T GetValue<T>(uint address) => Parameter32bit.GetValue<T>(address, this);

    public void SetValue<T>(T value, uint address)
    {
      Parameter32bit.SetValue<T>(value, address, this);
    }

    public bool IsParameterAvailable(string parameterName)
    {
      if (this.UsedParametersByName == null)
        return false;
      int index = this.UsedParametersByName.IndexOfKey(parameterName);
      return index >= 0 && this.AreDataAvailable(this.UsedParametersByName.Values[index].Address, this.UsedParametersByName.Values[index].Size);
    }

    public bool IsParameterInMap(string parameterName)
    {
      return this.UsedParametersByName != null && this.UsedParametersByName.IndexOfKey(parameterName) >= 0;
    }

    public List<AddressRange> GetAllParameterReadingRanges(
      string[] excludeParameterNames,
      uint splitSize)
    {
      List<string> stringList = new List<string>();
      foreach (Parameter32bit parameter32bit in (IEnumerable<Parameter32bit>) this.MapDef.GetAllParametersList().Values)
      {
        if (!((IEnumerable<string>) excludeParameterNames).Contains<string>(parameter32bit.Name))
          stringList.Add(parameter32bit.Name);
      }
      return this.GetAllParameterReadingRanges(stringList.ToArray(), splitSize);
    }

    public List<AddressRange> GetDefinedParameterReadingRanges(
      string[] definedParameters,
      uint splitSize)
    {
      List<Parameter32bit> list1 = this.MapDef.GetAllParametersList().Values.ToList<Parameter32bit>();
      List<AddressRange> source = new List<AddressRange>();
      foreach (Parameter32bit parameter32bit in list1)
      {
        if (((IEnumerable<string>) definedParameters).Contains<string>(parameter32bit.Name))
          source.Add(parameter32bit.AddressRange);
      }
      List<AddressRange> list2 = source.OrderBy<AddressRange, uint>((System.Func<AddressRange, uint>) (x => x.StartAddress)).ToList<AddressRange>();
      int index = 0;
      while (index < list2.Count - 1)
      {
        if (this.GetDeviceMemoryStorageForAddressRange(new AddressRange(list2[index].EndAddress, (uint) ((int) list2[index + 1].StartAddress - (int) list2[index].EndAddress + 1))) != null && list2[index + 1].StartAddress - list2[index].EndAddress <= splitSize)
        {
          list2[index].EndAddress = list2[index + 1].EndAddress;
          list2.RemoveAt(index + 1);
        }
        else
          ++index;
      }
      return list2;
    }

    public List<AddressRange> GetChangedDataRanges(DeviceMemory changedFrom)
    {
      List<AddressRange> changedDataRanges = new List<AddressRange>();
      if (this.MemoryBlockList.Count != changedFrom.MemoryBlockList.Count)
        throw new Exception("GetChangedDataRanges has different count of MemoryBlocks");
      for (int index = 0; index < this.MemoryBlockList.Count; ++index)
      {
        if ((int) this.MemoryBlockList.Values[index].ByteSize != (int) changedFrom.MemoryBlockList.Values[index].ByteSize)
          throw new Exception("GetChangedDataRanges has different MemoryBlock ByteSize on block: " + index.ToString());
      }
      if (this.MemoryBlockList.Count > 0)
      {
        foreach (DeviceMemoryStorage deviceMemoryStorage1 in (IEnumerable<DeviceMemoryStorage>) this.MemoryBlockList.Values)
        {
          uint endAddress = deviceMemoryStorage1.EndAddress;
          DeviceMemoryStorage deviceMemoryStorage2 = deviceMemoryStorage1;
          AddressRange addressRange = (AddressRange) null;
          for (uint startAddress = deviceMemoryStorage1.StartAddress; startAddress <= endAddress; ++startAddress)
          {
            byte? nullable1 = this.GetByte(startAddress);
            byte? nullable2 = changedFrom.GetByte(startAddress);
            if (!nullable1.HasValue)
            {
              if (addressRange != null)
              {
                changedDataRanges.Add(addressRange);
                addressRange = (AddressRange) null;
              }
            }
            else if (!nullable2.HasValue || (int) nullable1.Value != (int) nullable2.Value)
            {
              if (addressRange == null)
                addressRange = new AddressRange(startAddress, 1U);
              else if (startAddress > addressRange.EndAddress + 1U + deviceMemoryStorage2.WriteSplitSize)
              {
                changedDataRanges.Add(addressRange);
                addressRange = new AddressRange(startAddress, 1U);
              }
              else
                addressRange.EndAddress = startAddress;
            }
          }
          if (addressRange != null)
            changedDataRanges.Add(addressRange);
        }
      }
      return changedDataRanges;
    }

    public List<AddressRange> GetExistingDataRanges()
    {
      List<AddressRange> existingDataRanges = new List<AddressRange>();
      if (this.MemoryBlockList.Count > 0)
      {
        foreach (DeviceMemoryStorage deviceMemoryStorage1 in (IEnumerable<DeviceMemoryStorage>) this.MemoryBlockList.Values)
        {
          uint endAddress = deviceMemoryStorage1.EndAddress;
          DeviceMemoryStorage deviceMemoryStorage2 = deviceMemoryStorage1;
          AddressRange addressRange = (AddressRange) null;
          for (uint startAddress = deviceMemoryStorage1.StartAddress; startAddress <= endAddress; ++startAddress)
          {
            if (!this.GetByte(startAddress).HasValue)
            {
              if (addressRange != null)
              {
                existingDataRanges.Add(addressRange);
                addressRange = (AddressRange) null;
              }
            }
            else if (addressRange == null)
              addressRange = new AddressRange(startAddress, 1U);
            else if (startAddress > addressRange.EndAddress + 1U + deviceMemoryStorage2.WriteSplitSize)
            {
              existingDataRanges.Add(addressRange);
              addressRange = new AddressRange(startAddress, 1U);
            }
            else
              addressRange.EndAddress = startAddress;
          }
          if (addressRange != null)
            existingDataRanges.Add(addressRange);
        }
      }
      return existingDataRanges;
    }

    public List<AddressRange> GetAllAddressRanges(DeviceMemoryType? memoryType = null)
    {
      List<AddressRange> allAddressRanges = new List<AddressRange>();
      foreach (DeviceMemoryStorage deviceMemoryStorage in (IEnumerable<DeviceMemoryStorage>) this.MemoryBlockList.Values)
      {
        int num;
        if (memoryType.HasValue)
        {
          int memoryType1 = (int) deviceMemoryStorage.MemoryType;
          DeviceMemoryType? nullable = memoryType;
          int valueOrDefault = (int) nullable.GetValueOrDefault();
          num = memoryType1 == valueOrDefault & nullable.HasValue ? 1 : 0;
        }
        else
          num = 1;
        if (num != 0)
          allAddressRanges.Add(new AddressRange(deviceMemoryStorage.StartAddress, deviceMemoryStorage.ByteSize));
      }
      return allAddressRanges;
    }

    public List<AddressRangeInfo> GetAllAddressRangeInfos(DeviceMemoryType? memoryType = null)
    {
      List<AddressRangeInfo> addressRangeInfos = new List<AddressRangeInfo>();
      foreach (DeviceMemoryStorage deviceMemoryStorage in (IEnumerable<DeviceMemoryStorage>) this.MemoryBlockList.Values)
      {
        int num;
        if (memoryType.HasValue)
        {
          int memoryType1 = (int) deviceMemoryStorage.MemoryType;
          DeviceMemoryType? nullable = memoryType;
          int valueOrDefault = (int) nullable.GetValueOrDefault();
          num = memoryType1 == valueOrDefault & nullable.HasValue ? 1 : 0;
        }
        else
          num = 1;
        if (num != 0)
          addressRangeInfos.Add(new AddressRangeInfo(deviceMemoryStorage.MemoryType.ToString() + " WriteSplitSize:" + deviceMemoryStorage.WriteSplitSize.ToString(), deviceMemoryStorage.GetAddressRange()));
      }
      return addressRangeInfos;
    }

    public List<AddressRange> GetRangesForRead(List<string> ignoreParameter, int maxGapSize)
    {
      IList<Parameter32bit> values = this.MapDef.GetAllParametersList().Values;
      List<AddressRange> rangesForRead = new List<AddressRange>();
      int num1 = 0;
      uint startAddress = 0;
      uint num2 = 0;
      foreach (DeviceMemoryStorage deviceMemoryStorage in (IEnumerable<DeviceMemoryStorage>) this.MemoryBlockList.Values)
      {
        uint num3 = (uint) ((int) deviceMemoryStorage.StartAddress + (int) deviceMemoryStorage.ByteSize - 1);
        uint address = deviceMemoryStorage.StartAddress;
        while (address <= num3)
        {
          Parameter32bit parameter32bit = values.FirstOrDefault<Parameter32bit>((System.Func<Parameter32bit, bool>) (x => (int) x.Address == (int) address && !ignoreParameter.Contains(x.Name)));
          if (parameter32bit != null)
          {
            if (startAddress == 0U)
            {
              startAddress = parameter32bit.Address;
              num1 = 0;
            }
            num2 = parameter32bit.EndAddress;
            address += parameter32bit.Size;
          }
          else
          {
            ++num1;
            address++;
          }
          if (startAddress > 0U && num1 > maxGapSize)
          {
            rangesForRead.Add(new AddressRange(startAddress, (uint) ((int) num2 - (int) startAddress + 1)));
            startAddress = 0U;
            num2 = 0U;
            num1 = 0;
          }
        }
        if (startAddress > 0U)
        {
          rangesForRead.Add(new AddressRange(startAddress, (uint) ((int) num2 - (int) startAddress + 1)));
          startAddress = 0U;
          num2 = 0U;
          num1 = 0;
        }
      }
      return rangesForRead;
    }

    private void CreateFromCompressedData(byte[] compressedData)
    {
      byte[] array;
      using (MemoryStream memoryStream = new MemoryStream(compressedData))
      {
        using (MemoryStream destination = new MemoryStream())
        {
          using (GZipStream gzipStream = new GZipStream((Stream) memoryStream, CompressionMode.Decompress))
          {
            gzipStream.CopyTo((Stream) destination);
            gzipStream.Flush();
          }
          array = destination.ToArray();
        }
      }
      StringBuilder stringBuilder = new StringBuilder();
      int num1 = 0;
      byte[] numArray1 = array;
      int index1 = num1;
      int startIndex1 = index1 + 1;
      if (numArray1[index1] > (byte) 0)
        throw new Exception("Illegal compressed format");
      this.FirmwareVersion = BitConverter.ToUInt32(array, startIndex1);
      int num2 = startIndex1 + 4;
      byte[] numArray2 = array;
      int index2 = num2;
      int srcOffset = index2 + 1;
      int num3 = (int) numArray2[index2];
      List<DeviceMemoryStorage> deviceMemoryStorageList = new List<DeviceMemoryStorage>();
      for (int index3 = 0; index3 < num3; ++index3)
      {
        stringBuilder.Clear();
        byte[] numArray3 = array;
        int index4 = srcOffset;
        int startIndex2 = index4 + 1;
        int num4 = (int) numArray3[index4];
        for (int index5 = 0; index5 < num4; ++index5)
          stringBuilder.Append((char) array[startIndex2++]);
        DeviceMemoryType result;
        Enum.TryParse<DeviceMemoryType>(stringBuilder.ToString(), out result);
        uint uint32_1 = BitConverter.ToUInt32(array, startIndex2);
        int startIndex3 = startIndex2 + 4;
        uint uint32_2 = BitConverter.ToUInt32(array, startIndex3);
        srcOffset = startIndex3 + 4;
        deviceMemoryStorageList.Add(new DeviceMemoryStorage(result, uint32_1, uint32_2));
      }
      foreach (DeviceMemoryStorage deviceMemoryStorage in deviceMemoryStorageList)
      {
        Buffer.BlockCopy((Array) array, srcOffset, (Array) deviceMemoryStorage.Data, 0, (int) deviceMemoryStorage.ByteSize);
        srcOffset += (int) deviceMemoryStorage.ByteSize;
        byte num5 = 0;
        for (int index6 = 0; (long) index6 < (long) deviceMemoryStorage.ByteSize; ++index6)
        {
          if ((index6 & 7) == 0)
            num5 = array[srcOffset++];
          else
            num5 >>= 1;
          if (((int) num5 & 1) == 1)
            deviceMemoryStorage.DataAvailable[index6] = true;
        }
      }
      foreach (DeviceMemoryStorage deviceMemoryStorage in deviceMemoryStorageList)
      {
        if (!this.MemoryBlockList.ContainsKey(deviceMemoryStorage.StartAddress))
          this.MemoryBlockList.Add(deviceMemoryStorage.StartAddress, deviceMemoryStorage);
      }
    }

    public byte[] GetCompressedData()
    {
      List<byte> byteList = new List<byte>();
      int num = 0;
      byteList.Add((byte) 0);
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(this.FirmwareVersion));
      byteList.Add((byte) this.MemoryBlockList.Count);
      List<byte[]> numArrayList = new List<byte[]>();
      for (int index1 = 0; index1 < this.MemoryBlockList.Count; ++index1)
      {
        DeviceMemoryStorage deviceMemoryStorage = this.MemoryBlockList.Values[index1];
        byte[] numArray = DeviceMemory.PackBoolArray(deviceMemoryStorage.DataAvailable);
        numArrayList.Add(numArray);
        num = num + deviceMemoryStorage.Data.Length + numArray.Length;
        string str = deviceMemoryStorage.MemoryType.ToString();
        byte[] collection = new byte[str.Length + 1];
        collection[0] = (byte) str.Length;
        for (int index2 = 0; index2 < str.Length; ++index2)
          collection[index2 + 1] = (byte) str[index2];
        byteList.AddRange((IEnumerable<byte>) collection);
        byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(deviceMemoryStorage.StartAddress));
        byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(deviceMemoryStorage.Data.Length));
      }
      byte[] numArray1 = new byte[byteList.Count + num];
      Buffer.BlockCopy((Array) byteList.ToArray(), 0, (Array) numArray1, 0, byteList.Count);
      int dstOffset1 = byteList.Count;
      for (int index = 0; index < this.MemoryBlockList.Count; ++index)
      {
        DeviceMemoryStorage deviceMemoryStorage = this.MemoryBlockList.Values[index];
        Buffer.BlockCopy((Array) deviceMemoryStorage.Data, 0, (Array) numArray1, dstOffset1, deviceMemoryStorage.Data.Length);
        int dstOffset2 = dstOffset1 + deviceMemoryStorage.Data.Length;
        byte[] src = numArrayList[index];
        Buffer.BlockCopy((Array) src, 0, (Array) numArray1, dstOffset2, src.Length);
        dstOffset1 = dstOffset2 + src.Length;
      }
      byte[] array;
      using (MemoryStream memoryStream = new MemoryStream())
      {
        using (GZipStream destination = new GZipStream((Stream) memoryStream, CompressionMode.Compress))
        {
          new MemoryStream(numArray1).CopyTo((Stream) destination);
          destination.Flush();
        }
        array = memoryStream.ToArray();
      }
      return array;
    }

    public static byte[] PackBoolArray(bool[] boolArray)
    {
      List<byte> byteList = new List<byte>();
      int num1 = 256;
      int num2 = 0;
      bool flag = false;
      for (int index = 0; index < boolArray.Length; ++index)
      {
        if (num1 >= 256)
        {
          if (flag)
            byteList.Add((byte) num2);
          num2 = 0;
          num1 = 1;
        }
        if (boolArray[index])
          num2 |= num1;
        flag = true;
        num1 <<= 1;
      }
      if (flag)
        byteList.Add((byte) num2);
      return byteList.ToArray();
    }

    public void SaveDeviceToDatabase(
      BaseDbConnection db,
      DbConnection meterUpdateCon,
      DbTransaction TheTransaction,
      DeviceIdentification DeviceId,
      byte[] CompressedMemory)
    {
      DbDataAdapter dataAdapter = db.GetDataAdapter("SELECT * FROM MeterData", meterUpdateCon, TheTransaction, out DbCommandBuilder _);
      BaseTables.MeterDataDataTable meterDataDataTable = new BaseTables.MeterDataDataTable();
      BaseTables.MeterDataRow row = meterDataDataTable.NewMeterDataRow();
      row.MeterID = (int) DeviceId.MeterID.Value;
      uint? nullable;
      int num1;
      if (DeviceId.FirmwareVersion.HasValue)
      {
        nullable = DeviceId.FirmwareVersion;
        num1 = (int) nullable.Value;
      }
      else
        num1 = -1;
      uint num2 = (uint) num1;
      nullable = DeviceId.HardwareTypeID;
      if (nullable.HasValue)
      {
        nullable = DeviceId.HardwareTypeID;
        -1 = (int) nullable.Value;
      }
      row.PValue = "0x" + num2.ToString("x8");
      DateTime now = DateTime.Now;
      row.TimePoint = now.AddMilliseconds((double) (now.Millisecond * -1));
      row.PValueID = 1;
      row.PValueBinary = CompressedMemory;
      meterDataDataTable.AddMeterDataRow(row);
      dataAdapter.Update((DataTable) meterDataDataTable);
    }

    public void ShowParameterInfo(
      string fileTitel,
      string originalTag,
      bool SuppressAddresses = false,
      bool SuppressKnownDifferences = false,
      CommonOverwriteGroups[] overwrites = null)
    {
      string str = this.WriteParameterInfoLogFile(fileTitel + "_" + originalTag, originalTag, SuppressAddresses, SuppressKnownDifferences, overwrites);
      new Process() { StartInfo = { FileName = str } }.Start();
    }

    public void CompareParameterInfo(
      string fileTitel,
      string originalTag,
      string compareTag,
      DeviceMemory compareMemory,
      bool SuppressAddresses = false,
      bool SuppressKnownDifferences = false,
      CommonOverwriteGroups[] overwrites = null)
    {
      string str1 = this.WriteParameterInfoLogFile(fileTitel + "_" + originalTag, originalTag, SuppressAddresses, SuppressKnownDifferences, overwrites);
      string str2 = compareMemory.WriteParameterInfoLogFile(fileTitel + "_" + compareTag, compareTag, SuppressAddresses, SuppressKnownDifferences, overwrites);
      new Process()
      {
        StartInfo = {
          FileName = "TortoiseMerge",
          Arguments = ("/base:\"" + str1 + "\" /theirs:\"" + str2 + "\"")
        }
      }.Start();
    }

    public void CompareSortedParameterInfo(
      string fileTitel,
      string originalTag,
      string compareTag,
      DeviceMemory compareMemory)
    {
      string str1 = this.WriteSortedParameterInfoLogFile(fileTitel + "_p_org", originalTag);
      string str2 = compareMemory.WriteSortedParameterInfoLogFile(fileTitel + "_p_cmp", compareTag);
      new Process()
      {
        StartInfo = {
          FileName = "TortoiseMerge",
          Arguments = ("/base:\"" + str1 + "\" /theirs:\"" + str2 + "\"")
        }
      }.Start();
    }

    public void ShowParameterInfo(string HeaderInfo = null)
    {
      NotepadHelper.ShowMessage(this.GetParameterInfo(HeaderInfo), "DeviceMemory info");
    }

    public string WriteParameterInfoLogFile(
      string fileTitel,
      string HeaderInfo = null,
      bool SuppressAddresses = false,
      bool SuppressKnownDifferences = false,
      CommonOverwriteGroups[] overwrites = null)
    {
      if (fileTitel == null)
        throw new HandlerMessageException("File titel for DeviceMemory.SaveToFile not defined.");
      string parameterInfo = this.GetParameterInfo(HeaderInfo, SuppressAddresses, SuppressKnownDifferences, overwrites);
      string path2 = DateTime.Now.ToString("yyyyMMdd_HHmmss_FFFF_") + fileTitel + ".txt";
      string path = Path.Combine(SystemValues.LoggDataPath, path2);
      using (StreamWriter streamWriter = new StreamWriter(path, false, Encoding.ASCII))
      {
        streamWriter.Write(parameterInfo);
        streamWriter.Flush();
        streamWriter.Close();
      }
      return path;
    }

    public string WriteSortedParameterInfoLogFile(string fileTitel, string HeaderInfo = null)
    {
      if (fileTitel == null)
        throw new HandlerMessageException("File titel for DeviceMemory.SaveToFile not defined.");
      string sortedParameterInfo = this.GetSortedParameterInfo(HeaderInfo);
      string path2 = DateTime.Now.ToString("yyyyMMdd_HHmmss_FFFF_") + fileTitel + ".txt";
      string path = Path.Combine(SystemValues.LoggDataPath, path2);
      using (StreamWriter streamWriter = new StreamWriter(path, false, Encoding.ASCII))
      {
        streamWriter.Write(sortedParameterInfo);
        streamWriter.Flush();
        streamWriter.Close();
      }
      return path;
    }

    public virtual string GetParameterInfo(
      string HeaderInfo = null,
      bool SuppressAddresses = false,
      bool SuppressKnownDifferences = false,
      CommonOverwriteGroups[] overwrites = null)
    {
      List<KeyValuePair<string, Parameter32bit>> list = ((this.MapDef != null ? this.MapDef.GetAllParametersList() : throw new HandlerMessageException("Map in DeviceMemory.SaveToFile not defined.")) ?? throw new HandlerMessageException("No parameters defined for DeviceMemory.SaveToFile")).ToList<KeyValuePair<string, Parameter32bit>>();
      list.Sort((Comparison<KeyValuePair<string, Parameter32bit>>) ((a, b) => a.Value.Address.CompareTo(b.Value.Address)));
      StringBuilder sb = new StringBuilder();
      if (HeaderInfo != null)
        sb.AppendLine(HeaderInfo);
      sb.Append(new ZENNER.CommonLibrary.FirmwareVersion(this.FirmwareVersion).ToString());
      sb.AppendLine(" (" + DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss") + ")");
      sb.AppendLine();
      sb.AppendLine("ADDRESS   SIZE   SECTION                    NAME                               DATA_HEX");
      sb.AppendLine("-------------------------------------------------------------------------------------");
      list.ForEach((Action<KeyValuePair<string, Parameter32bit>>) (x => sb.AppendFormat("{0:X8}  {1,-6} {2,-26} {3,-35} {4}", (object) x.Value.Address, (object) x.Value.Size, x.Value.Section == "UNKNOWN" ? (object) "-" : (object) x.Value.Section, (object) x.Value.Name, (object) this.GetParameterData(x.Value)).AppendLine()));
      return sb.ToString();
    }

    public string GetSortedParameterInfo(string HeaderInfo = null)
    {
      List<KeyValuePair<string, Parameter32bit>> list = ((this.MapDef != null ? this.MapDef.GetAllParametersList() : throw new HandlerMessageException("Map in DeviceMemory.SaveToFile not defined.")) ?? throw new HandlerMessageException("No parameters defined for DeviceMemory.SaveToFile")).ToList<KeyValuePair<string, Parameter32bit>>();
      list.Sort((Comparison<KeyValuePair<string, Parameter32bit>>) ((a, b) => a.Value.Name.CompareTo(b.Value.Name)));
      StringBuilder sb = new StringBuilder();
      if (HeaderInfo != null)
        sb.AppendLine(HeaderInfo);
      sb.Append(new ZENNER.CommonLibrary.FirmwareVersion(this.FirmwareVersion).ToString());
      sb.AppendLine(" (" + DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss") + ")");
      sb.AppendLine();
      sb.AppendLine("NAME                               DATA_HEX");
      sb.AppendLine("-----------------------------------------");
      list.ForEach((Action<KeyValuePair<string, Parameter32bit>>) (x => sb.AppendFormat("{0,-35} {1}", (object) x.Value.Name, (object) this.GetParameterData(x.Value)).AppendLine()));
      return sb.ToString();
    }

    public string GetParameterData(Parameter32bit p)
    {
      return Utility.ByteArrayToHexString(Parameter32bit.GetValueByteArray(p.Address, p.Size, this));
    }

    public void CompareMemoryInfo(
      string fileTitel,
      string originalTag,
      string compareTag,
      DeviceMemory compareMemory)
    {
      string str1 = this.WriteMemoryInfoLogFile(fileTitel + "_m_org", originalTag);
      string str2 = compareMemory.WriteMemoryInfoLogFile(fileTitel + "_m_cmp", compareTag);
      new Process()
      {
        StartInfo = {
          FileName = "TortoiseMerge",
          Arguments = ("/base:\"" + str1 + "\" /theirs:\"" + str2 + "\"")
        }
      }.Start();
    }

    public void ShowMemoryInfo(string HeaderInfo = null)
    {
      NotepadHelper.ShowMessage(this.GetMemoryInfo(HeaderInfo), "DeviceMemory info");
    }

    public string WriteMemoryInfoLogFile(string fileTitel, string HeaderInfo = null)
    {
      if (fileTitel == null)
        throw new HandlerMessageException("File titel for DeviceMemory.SaveToFile not defined.");
      string memoryInfo = this.GetMemoryInfo(HeaderInfo);
      string path2 = DateTime.Now.ToString("yyyyMMdd_HHmmss_FFFF_") + fileTitel + ".txt";
      string path = Path.Combine(SystemValues.LoggDataPath, path2);
      using (StreamWriter streamWriter = new StreamWriter(path, false, Encoding.ASCII))
      {
        streamWriter.Write(memoryInfo);
        streamWriter.Flush();
        streamWriter.Close();
      }
      return path;
    }

    public string GetMemoryInfo(string HeaderInfo = null)
    {
      StringBuilder stringBuilder = new StringBuilder();
      if (HeaderInfo != null)
        stringBuilder.AppendLine(HeaderInfo);
      stringBuilder.Append(new ZENNER.CommonLibrary.FirmwareVersion(this.FirmwareVersion).ToString());
      stringBuilder.Append(" (" + DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss") + ")");
      for (int index1 = 0; index1 < this.MemoryBlockList.Count; ++index1)
      {
        DeviceMemoryStorage deviceMemoryStorage = this.MemoryBlockList.Values[index1];
        stringBuilder.AppendLine();
        stringBuilder.AppendLine();
        stringBuilder.Append("Block: 0x" + deviceMemoryStorage.StartAddress.ToString("x08") + " to 0x" + deviceMemoryStorage.EndAddress.ToString("x08") + " ; WriteSplitSize = " + deviceMemoryStorage.WriteSplitSize.ToString());
        for (uint index2 = deviceMemoryStorage.StartAddress & 4294967280U; index2 <= deviceMemoryStorage.EndAddress; ++index2)
        {
          if (((int) index2 & 15) == 0)
          {
            stringBuilder.AppendLine();
            stringBuilder.Append(index2.ToString("x08") + ": ");
          }
          else if (((int) index2 & 3) == 0)
            stringBuilder.Append(".");
          else
            stringBuilder.Append(" ");
          if (index2 < deviceMemoryStorage.StartAddress)
          {
            stringBuilder.Append("  ");
          }
          else
          {
            uint index3 = index2 - deviceMemoryStorage.StartAddress;
            if (!deviceMemoryStorage.DataAvailable[(int) index3])
              stringBuilder.Append("--");
            else
              stringBuilder.Append(deviceMemoryStorage.Data[(int) index3].ToString("x02"));
          }
        }
      }
      return stringBuilder.ToString();
    }

    public void ShowUsedParameterRanges()
    {
      StringBuilder stringBuilder1 = new StringBuilder();
      if (this.UsedParametersByName == null || this.UsedParametersByName.Count == 0)
      {
        stringBuilder1.AppendLine("No parameters defined");
      }
      else
      {
        List<Parameter32bit> list = this.UsedParametersByName.Values.ToList<Parameter32bit>();
        list.Sort();
        foreach (Parameter32bit parameter32bit in list)
        {
          StringBuilder stringBuilder2 = stringBuilder1;
          string[] strArray = new string[8];
          strArray[0] = "0x";
          uint num = parameter32bit.Address;
          strArray[1] = num.ToString("x08");
          strArray[2] = " - 0x";
          num = parameter32bit.EndAddress;
          strArray[3] = num.ToString("x08");
          strArray[4] = "; size: 0x";
          num = parameter32bit.Size;
          strArray[5] = num.ToString();
          strArray[6] = "; ";
          strArray[7] = parameter32bit.Name;
          string str = string.Concat(strArray);
          stringBuilder2.AppendLine(str);
        }
      }
      GmmMessage.Show_Ok(stringBuilder1.ToString(), "Used handler variables and ranges");
    }
  }
}


--- DeviceMemoryStorage.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceMemoryStorage
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class DeviceMemoryStorage
  {
    public ReadPartsSelection ReadSelection;
    public int WriteOrder;
    private uint oldStartAddress;
    private uint _startAdr;
    internal uint EndAddress;
    internal byte[] Data;
    internal bool[] DataAvailable;
    public uint WriteSplitSize = 0;

    public DeviceMemoryType MemoryType { get; internal set; }

    public uint StartAddress
    {
      get => this._startAdr;
      set
      {
        this.oldStartAddress = this._startAdr;
        this._startAdr = value;
      }
    }

    public uint ByteSize
    {
      get => (uint) ((int) this.EndAddress - (int) this.StartAddress + 1);
      set
      {
        this.EndAddress = (uint) ((int) this.StartAddress + (int) value - 1);
        this.Resize();
      }
    }

    internal void Resize()
    {
      int destinationIndex = this.oldStartAddress > this.StartAddress ? (int) this.oldStartAddress - (int) this.StartAddress : 0;
      Array.Resize<byte>(ref this.Data, (int) this.ByteSize);
      Array.Resize<bool>(ref this.DataAvailable, (int) this.ByteSize);
      if (destinationIndex == 0)
        return;
      byte[] numArray = new byte[(int) this.ByteSize];
      bool[] flagArray = new bool[(int) this.ByteSize];
      Array.Copy((Array) this.Data, 0L, (Array) numArray, (long) destinationIndex, (long) this.ByteSize - (long) destinationIndex);
      Array.Copy((Array) this.DataAvailable, 0L, (Array) flagArray, (long) destinationIndex, (long) this.ByteSize - (long) destinationIndex);
      Array.Copy((Array) numArray, (Array) this.Data, (long) this.ByteSize);
      Array.Copy((Array) flagArray, (Array) this.DataAvailable, (long) this.ByteSize);
    }

    internal DeviceMemoryStorage(
      DeviceMemoryType deviceMemoryType,
      uint startAddress,
      uint byteSize)
    {
      this.MemoryType = deviceMemoryType;
      this.StartAddress = startAddress;
      this.EndAddress = (uint) ((int) startAddress + (int) byteSize - 1);
      this.Data = new byte[(int) byteSize];
      this.DataAvailable = new bool[(int) byteSize];
    }

    internal DeviceMemoryStorage(
      DeviceMemoryType deviceMemoryType,
      uint startAddress,
      uint byteSize,
      uint WriteSplitSize)
      : this(deviceMemoryType, startAddress, byteSize)
    {
      this.WriteSplitSize = WriteSplitSize;
    }

    public DeviceMemoryStorage Clone()
    {
      DeviceMemoryStorage deviceMemoryStorage = new DeviceMemoryStorage(this.MemoryType, this.StartAddress, this.ByteSize);
      deviceMemoryStorage.Data = new byte[(int) this.ByteSize];
      deviceMemoryStorage.DataAvailable = new bool[(int) this.ByteSize];
      Buffer.BlockCopy((Array) this.Data, 0, (Array) deviceMemoryStorage.Data, 0, (int) this.ByteSize);
      Buffer.BlockCopy((Array) this.DataAvailable, 0, (Array) deviceMemoryStorage.DataAvailable, 0, (int) this.ByteSize);
      deviceMemoryStorage.WriteSplitSize = this.WriteSplitSize;
      return deviceMemoryStorage;
    }

    public void IncludeDataFromPartStorage(DeviceMemoryStorage partStorage)
    {
      if (partStorage.StartAddress < this.StartAddress)
        throw new Exception("PartStorage lower then Storage");
      uint dstOffset = partStorage.StartAddress - this.StartAddress;
      if (dstOffset + partStorage.ByteSize > this.ByteSize)
        throw new Exception("PartStorage higher then Storage");
      Buffer.BlockCopy((Array) partStorage.Data, 0, (Array) this.Data, (int) dstOffset, (int) partStorage.ByteSize);
      Buffer.BlockCopy((Array) partStorage.DataAvailable, 0, (Array) this.DataAvailable, (int) dstOffset, (int) partStorage.ByteSize);
    }

    public AddressRange GetAddressRange() => new AddressRange(this.StartAddress, this.ByteSize);

    public override string ToString()
    {
      return "0x" + this.StartAddress.ToString("x8") + "-0x" + this.EndAddress.ToString("x8") + " size: 0x" + this.ByteSize.ToString("x4");
    }
  }
}


--- DeviceMemoryType.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceMemoryType
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum DeviceMemoryType
  {
    DataRAM,
    FLASH,
    EEPROM,
    Unknown,
    NotAvail,
  }
}


--- DeviceMessageException.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceMessageException
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Runtime.Serialization;

#nullable disable
namespace HandlerLib
{
  internal class DeviceMessageException : Exception
  {
    public DeviceMessageException()
    {
    }

    public DeviceMessageException(string message)
      : base(message)
    {
    }

    public DeviceMessageException(string message, Exception inner)
      : base(message, inner)
    {
    }

    protected DeviceMessageException(SerializationInfo info, StreamingContext context)
    {
    }
  }
}


--- DeviceReadRangeSelection.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceReadRangeSelection
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;

#nullable disable
namespace HandlerLib
{
  public class DeviceReadRangeSelection : Window, IComponentConnector
  {
    private static List<DeviceReadRangeSelection.RangeInfos> _rangeInfos = new List<DeviceReadRangeSelection.RangeInfos>();
    internal Button BottonOk;
    internal StackPanel StackPanelProtocolOnly;
    internal CheckBox CheckBoxProtocolOnlyMode;
    internal StackPanel StackPanelSetup;
    private bool _contentLoaded;

    static DeviceReadRangeSelection()
    {
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.RAM_range, "RAM", "All defined RAM ranges"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.FLASH_range, "FLASH", "All defined FLASH ranges"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.BACKUP_range, "BACKUP", "Ranges to write to the data base as complete backup"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.CLONE_range, "CLONE", "Parts of the BACKUP ranges which are used to write to the device by cloning"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.FirmwareVersion, "FirmwareVersion", "Us only get version protocol to read the identification of a device."));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.Identification, "Identification", "All given identification data of device and used types."));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.EnhancedIdentification, "EnhancedIdentification", "Additional identifications like compiler versions and chip id's, "));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.BasicConfiguration, "BasicConfiguration", "Most used configuration data"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.Calibration, "Calibration", "Calibaration part of configuration"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.CurrentMeasurementValues, "CurrentMeasurementValues", "Current accumulated and measured values."));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.LoggersMask, "AllLoggers", "Key date values, month values and other logger values"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.KeyData, "KeyData", "Key date storages and loggers"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.MonthLogger, "MonthLogger", "Month logger storages"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.SmartFunctionLoggers, "SmartFunctionLoggers", "SmartFunctionLoggerStorages"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.SmartFunctions, "SmartFunctions", "Smart function memory ranges"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.ScenarioConfiguration, "ScenarioConfiguration", "Communication scenario configuration memory range"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.BackupBlocks, "BackupBlocks", "Firmware internal data backups"));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.RamDiagnosticParameters, "RamDiagnosticParameters", ""));
      DeviceReadRangeSelection._rangeInfos.Add(new DeviceReadRangeSelection.RangeInfos(ReadPartsSelection.ProtocolOnlyMode, "ProtocolOnlyMode", "No memory access used."));
    }

    public static void DefineReadPartsSelections(
      ReadPartsSelection supportedSelections,
      ref ReadPartsSelection selection,
      Window owner)
    {
      DeviceReadRangeSelection readRangeSelection = new DeviceReadRangeSelection(supportedSelections, selection);
      readRangeSelection.Owner = owner;
      if (!readRangeSelection.ShowDialog().Value)
        return;
      selection = readRangeSelection.GetSelection();
    }

    internal DeviceReadRangeSelection(
      ReadPartsSelection supportedSelections,
      ReadPartsSelection selection)
    {
      this.InitializeComponent();
      ReadPartsSelection readPartsSelection = supportedSelections & ReadPartsSelection.Dump;
      foreach (DeviceReadRangeSelection.RangeInfos rangeInfo in DeviceReadRangeSelection._rangeInfos)
      {
        if ((rangeInfo.SelectBits & readPartsSelection) == rangeInfo.SelectBits)
        {
          DockPanel element1 = new DockPanel();
          Separator element2 = new Separator();
          DockPanel.SetDock((UIElement) element2, Dock.Top);
          element1.Children.Add((UIElement) element2);
          StackPanel element3 = new StackPanel();
          element3.Orientation = Orientation.Horizontal;
          element3.VerticalAlignment = VerticalAlignment.Top;
          DockPanel.SetDock((UIElement) element3, Dock.Left);
          element1.Children.Add((UIElement) element3);
          CheckBox element4 = new CheckBox();
          element4.Tag = (object) rangeInfo.SelectBits;
          if ((selection & rangeInfo.SelectBits) == rangeInfo.SelectBits)
            element4.IsChecked = new bool?(true);
          element3.Children.Add((UIElement) element4);
          element3.Children.Add((UIElement) new TextBlock()
          {
            Text = rangeInfo.ShortDescription
          });
          element1.Children.Add((UIElement) new TextBlock()
          {
            TextWrapping = TextWrapping.WrapWithOverflow,
            Text = rangeInfo.Description
          });
          this.StackPanelSetup.Children.Add((UIElement) element1);
        }
      }
      if ((supportedSelections & ReadPartsSelection.ProtocolOnlyMode) == ~(ReadPartsSelection.Dump | ReadPartsSelection.ProtocolOnlyMode))
        this.StackPanelProtocolOnly.Visibility = Visibility.Hidden;
      else
        this.CheckBoxProtocolOnlyMode.IsChecked = new bool?((selection & ReadPartsSelection.ProtocolOnlyMode) > ~(ReadPartsSelection.Dump | ReadPartsSelection.ProtocolOnlyMode));
    }

    private void BottonOk_Click(object sender, RoutedEventArgs e)
    {
      this.DialogResult = new bool?(true);
      this.Close();
    }

    internal ReadPartsSelection GetSelection()
    {
      ReadPartsSelection selection = ~(ReadPartsSelection.Dump | ReadPartsSelection.ProtocolOnlyMode);
      this.AddSelectedBits(ref selection, this.StackPanelSetup.Children);
      if (this.StackPanelProtocolOnly.Visibility != Visibility.Hidden)
      {
        bool? isChecked = this.CheckBoxProtocolOnlyMode.IsChecked;
        bool flag = true;
        if (isChecked.GetValueOrDefault() == flag & isChecked.HasValue)
          selection |= ReadPartsSelection.ProtocolOnlyMode;
      }
      return selection;
    }

    private void AddSelectedBits(ref ReadPartsSelection selection, UIElementCollection childs)
    {
      foreach (object child in childs)
      {
        if (child is CheckBox)
        {
          CheckBox checkBox = (CheckBox) child;
          if (!checkBox.IsChecked.Value)
            break;
          selection |= (ReadPartsSelection) checkBox.Tag;
          break;
        }
        if (child is DockPanel)
          this.AddSelectedBits(ref selection, ((Panel) child).Children);
        if (child is StackPanel)
        {
          this.AddSelectedBits(ref selection, ((Panel) child).Children);
          break;
        }
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/devicereadrangeselection.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.BottonOk = (Button) target;
          this.BottonOk.Click += new RoutedEventHandler(this.BottonOk_Click);
          break;
        case 2:
          this.StackPanelProtocolOnly = (StackPanel) target;
          break;
        case 3:
          this.CheckBoxProtocolOnlyMode = (CheckBox) target;
          break;
        case 4:
          this.StackPanelSetup = (StackPanel) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }

    internal class RangeInfos
    {
      internal ReadPartsSelection SelectBits;
      internal string ShortDescription;
      internal string Description;

      internal RangeInfos(
        ReadPartsSelection selectBit,
        string shortDescription,
        string description)
      {
        this.SelectBits = selectBit;
        this.ShortDescription = shortDescription;
        this.Description = description;
      }
    }
  }
}


--- DeviceStateCounter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceStateCounter
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;
using System.Text;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class DeviceStateCounter
  {
    private SortedList<DeviceStateCounterID, uint> StateCounters;

    private DeviceStateCounter()
    {
      this.StateCounters = new SortedList<DeviceStateCounterID, uint>();
    }

    public DeviceStateCounter(byte[] receivedData)
      : this()
    {
      int offset = 0;
      while (offset < receivedData.Length)
      {
        byte key = ByteArrayScanner.ScanByte(receivedData, ref offset);
        if (!Enum.IsDefined(typeof (DeviceStateCounterID), (object) key))
        {
          offset += 4;
        }
        else
        {
          uint num = ByteArrayScanner.ScanUInt32(receivedData, ref offset);
          this.StateCounters.Add((DeviceStateCounterID) key, num);
        }
      }
    }

    public override string ToString()
    {
      StringBuilder stringBuilder = new StringBuilder();
      foreach (KeyValuePair<DeviceStateCounterID, uint> stateCounter in this.StateCounters)
      {
        if (stringBuilder.Length > 0)
          stringBuilder.Append("; ");
        stringBuilder.Append(stateCounter.Key.ToString() + ":" + stateCounter.Value.ToString());
      }
      return stringBuilder.ToString();
    }

    public string ToTextBlock()
    {
      StringBuilder stringBuilder1 = new StringBuilder();
      int num1 = 0;
      foreach (KeyValuePair<DeviceStateCounterID, uint> stateCounter in this.StateCounters)
      {
        if (num1 == 3)
        {
          stringBuilder1.AppendLine();
          num1 = 1;
        }
        else
          ++num1;
        string str1 = stateCounter.Key.ToString();
        string str2 = (str1 + ": ").PadRight(27, '.').PadRight(28);
        stringBuilder1.Append(str2);
        uint num2;
        double num3;
        if (str1.EndsWith("MsTime"))
        {
          num2 = stateCounter.Value;
          string str3 = num2.ToString() + " ms";
          stringBuilder1.Append(str3.PadRight(11));
          StringBuilder stringBuilder2 = stringBuilder1;
          num3 = (double) stateCounter.Value / 1000.0 / 3600.0;
          string str4 = " = " + num3.ToString("0.000") + " hours";
          stringBuilder2.Append(str4);
        }
        else if (str1.EndsWith("Time"))
        {
          num2 = stateCounter.Value;
          string str5 = num2.ToString() + " s";
          stringBuilder1.Append(str5.PadRight(11));
          StringBuilder stringBuilder3 = stringBuilder1;
          num3 = (double) stateCounter.Value / 86400.0;
          string str6 = " = " + num3.ToString("0.00") + " days";
          stringBuilder3.Append(str6);
        }
        else
        {
          StringBuilder stringBuilder4 = stringBuilder1;
          num2 = stateCounter.Value;
          string str7 = num2.ToString();
          stringBuilder4.Append(str7);
        }
        stringBuilder1.AppendLine();
      }
      return stringBuilder1.ToString();
    }

    public static void DeleteStateInMemory(
      DeviceMemory theMemory,
      SortedList<DeviceStateCounterID, AddressRange> memoryRanges)
    {
      foreach (KeyValuePair<DeviceStateCounterID, AddressRange> memoryRange in memoryRanges)
      {
        if (theMemory.AreDataAvailable(memoryRange.Value))
          theMemory.SetValue<uint>(0U, memoryRange.Value.StartAddress);
      }
    }

    public static DeviceStateCounter CreateObjectFromMemory(
      DeviceMemory theMemory,
      SortedList<DeviceStateCounterID, AddressRange> memoryRanges)
    {
      DeviceStateCounter objectFromMemory = new DeviceStateCounter();
      foreach (KeyValuePair<DeviceStateCounterID, AddressRange> memoryRange in memoryRanges)
      {
        if (theMemory.AreDataAvailable(memoryRange.Value))
        {
          uint num = theMemory.GetValue<uint>(memoryRange.Value.StartAddress);
          objectFromMemory.StateCounters.Add(memoryRange.Key, num);
        }
      }
      return objectFromMemory;
    }
  }
}


--- DeviceStateCounterID.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceStateCounterID
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum DeviceStateCounterID : byte
  {
    OperationTime = 1,
    ZeroFlowTime = 2,
    FlowTime = 3,
    BackFlowTime = 4,
    AirInTubeTime = 5,
    OverloadTime = 6,
    NFC_ActivationTime = 7,
    RadioActivationCounts = 8,
    TemperatureSensorErrorTime = 9,
    OneSensorPairErrorTime = 10, // 0x0A
    ResetCounts = 11, // 0x0B
    WatchDogCounts = 12, // 0x0C
    TDCResetCounts = 13, // 0x0D
    SmartFunctionsCpuMsTime = 14, // 0x0E
  }
}


--- DeviceVersion.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceVersion
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using MBusLib;
using System;
using System.Collections.Generic;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class DeviceVersion : IPrintable
  {
    public uint FirmwareVersion { get; set; }

    public ushort Signatur { get; set; }

    public uint HardwareTypeID { get; set; }

    public virtual uint ID_BCD { get; set; }

    public virtual ushort Manufacturer { get; set; }

    public virtual byte Generation { get; set; }

    public virtual byte Medium { get; set; }

    public virtual uint HardwareID { get; set; }

    public virtual uint SvnRevision { get; set; }

    public virtual DateTime? BuildTime { get; set; }

    public virtual ushort CompilerChecksum { get; set; }

    public uint ID_Bin => Utility.ConvertBcdUInt32ToUInt32(this.ID_BCD);

    public string ManufacturerName => MBusUtil.GetManufacturer(this.Manufacturer);

    public string MediumName => MBusUtil.GetMedium(this.Medium);

    public ZENNER.CommonLibrary.FirmwareVersion FirmwareVersionObj
    {
      get => new ZENNER.CommonLibrary.FirmwareVersion(this.FirmwareVersion);
    }

    public DeviceVersion()
    {
    }

    public DeviceVersion(
      uint serialNumberBCD,
      ushort manufacturerCode,
      byte generation,
      byte mediumCode)
    {
      this.ID_BCD = serialNumberBCD;
      this.Generation = generation;
      this.Manufacturer = manufacturerCode;
      this.Medium = mediumCode;
    }

    public override string ToString() => this.FirmwareVersion.ToString();

    public virtual string Print(int spaces = 0) => Utility.PrintObject((object) this);

    public byte[] GetBytes()
    {
      List<byte> byteList = new List<byte>(18);
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(this.FirmwareVersion));
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(this.HardwareTypeID));
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(this.SvnRevision));
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(0));
      byteList.AddRange((IEnumerable<byte>) BitConverter.GetBytes(this.Signatur));
      if (byteList.Count != 18)
      {
        int num = 18;
        string str1 = num.ToString();
        num = byteList.Count;
        string str2 = num.ToString();
        throw new ArgumentOutOfRangeException("Invalid size of versions buffer! Expected: " + str1 + ", Actual: " + str2);
      }
      return byteList.ToArray();
    }

    public virtual DeviceVersion Clone() => this.MemberwiseClone() as DeviceVersion;
  }
}


--- DeviceVersionMBus.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DeviceVersionMBus
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using MBusLib;
using System;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class DeviceVersionMBus : DeviceIdentification, IPrintable
  {
    public byte[] LongID { get; set; }

    public VersionProtocolTypes VersionProtocolType { get; set; }

    public override uint? ID_BCD
    {
      get => new uint?(BitConverter.ToUInt32(this.LongID, 0));
      set
      {
        Buffer.BlockCopy((Array) BitConverter.GetBytes(value.Value), 0, (Array) this.LongID, 0, 4);
      }
    }

    public override ushort? Manufacturer
    {
      get => new ushort?(BitConverter.ToUInt16(this.LongID, 4));
      set
      {
        Buffer.BlockCopy((Array) BitConverter.GetBytes(value.Value), 0, (Array) this.LongID, 4, 2);
      }
    }

    public override byte? Generation
    {
      get => new byte?(this.LongID[6]);
      set => this.LongID[6] = value.Value;
    }

    public override byte? Medium
    {
      get => new byte?(this.LongID[7]);
      set => this.LongID[7] = value.Value;
    }

    public DeviceVersionMBus() => this.LongID = new byte[8];

    public DeviceVersionMBus(
      uint serialNumberBCD,
      ushort manufacturerCode,
      byte generation,
      byte mediumCode)
    {
      this.ID_BCD = new uint?(serialNumberBCD);
      this.Manufacturer = new ushort?(manufacturerCode);
      this.Generation = new byte?(generation);
      this.Medium = new byte?(mediumCode);
      this.LongID = new byte[8];
      this.VersionProtocolType = VersionProtocolTypes.Series4;
    }

    public static DeviceVersionMBus Parse(MBusFrame frame)
    {
      VariableDataStructure variableDataStructure = VariableDataStructure.Parse(frame);
      DeviceCommandsMBus.GetLongID(variableDataStructure.Header);
      if (variableDataStructure.MfgData.Length == 4)
      {
        uint uint32 = BitConverter.ToUInt32(variableDataStructure.MfgData, 0);
        DeviceVersionMBus deviceVersionMbus = new DeviceVersionMBus();
        deviceVersionMbus.LongID = DeviceCommandsMBus.GetLongID(variableDataStructure.Header);
        deviceVersionMbus.VersionProtocolType = VersionProtocolTypes.Series2;
        deviceVersionMbus.firmwareVersion = new uint?(uint32);
        deviceVersionMbus.primaryAddress = new byte?(frame.Address);
        return deviceVersionMbus;
      }
      if (variableDataStructure.MfgData.Length == 10)
      {
        uint uint32 = BitConverter.ToUInt32(variableDataStructure.MfgData, 0);
        if (!new ZENNER.CommonLibrary.FirmwareVersion(uint32).TypeString.StartsWith("C5"))
        {
          ushort uint16 = BitConverter.ToUInt16(new byte[2]
          {
            variableDataStructure.MfgData[7],
            (byte) ((uint) variableDataStructure.MfgData[6] >> 4)
          }, 0);
          DeviceVersionMBus deviceVersionMbus = new DeviceVersionMBus();
          deviceVersionMbus.LongID = DeviceCommandsMBus.GetLongID(variableDataStructure.Header);
          deviceVersionMbus.VersionProtocolType = VersionProtocolTypes.SmokeDetector;
          deviceVersionMbus.firmwareVersion = new uint?(uint32);
          deviceVersionMbus.hardwareID = new uint?((uint) uint16);
          deviceVersionMbus.primaryAddress = new byte?(frame.Address);
          return deviceVersionMbus;
        }
        DeviceVersionMBus deviceVersionMbus1 = new DeviceVersionMBus();
        deviceVersionMbus1.LongID = DeviceCommandsMBus.GetLongID(variableDataStructure.Header);
        deviceVersionMbus1.VersionProtocolType = VersionProtocolTypes.Series3;
        deviceVersionMbus1.firmwareVersion = new uint?(uint32);
        deviceVersionMbus1.svnRevision = new uint?(BitConverter.ToUInt32(variableDataStructure.MfgData, 4));
        deviceVersionMbus1.hardwareID = new uint?((uint) BitConverter.ToUInt16(variableDataStructure.MfgData, 8));
        return deviceVersionMbus1;
      }
      VersionProtocolTypes versionProtocolTypes;
      uint uint32_1;
      uint uint32_2;
      uint uint32_3;
      DateTime? dateMbusCp16TypeG;
      ushort uint16_1;
      if (variableDataStructure.MfgData.Length == 18)
      {
        versionProtocolTypes = VersionProtocolTypes.Series3;
        uint32_1 = BitConverter.ToUInt32(variableDataStructure.MfgData, 0);
        uint32_2 = BitConverter.ToUInt32(variableDataStructure.MfgData, 4);
        uint32_3 = BitConverter.ToUInt32(variableDataStructure.MfgData, 8);
        dateMbusCp16TypeG = MBusUtil.ConvertToDate_MBus_CP16_TypeG(variableDataStructure.MfgData, 12);
        uint16_1 = BitConverter.ToUInt16(variableDataStructure.MfgData, 16);
      }
      else
      {
        if (variableDataStructure.MfgData.Length != 19)
          throw new Exception("Illegal GetVersion response length");
        if (variableDataStructure.MfgData[0] != (byte) 6)
          throw new Exception("Illegal FC code in GetVersion response: 0x" + variableDataStructure.MfgData[0].ToString("x02"));
        versionProtocolTypes = VersionProtocolTypes.Series4;
        uint32_1 = BitConverter.ToUInt32(variableDataStructure.MfgData, 1);
        uint32_2 = BitConverter.ToUInt32(variableDataStructure.MfgData, 5);
        uint32_3 = BitConverter.ToUInt32(variableDataStructure.MfgData, 9);
        dateMbusCp16TypeG = MBusUtil.ConvertToDate_MBus_CP16_TypeG(variableDataStructure.MfgData, 13);
        uint16_1 = BitConverter.ToUInt16(variableDataStructure.MfgData, 17);
      }
      DeviceVersionMBus deviceVersionMbus2 = new DeviceVersionMBus();
      deviceVersionMbus2.LongID = DeviceCommandsMBus.GetLongID(variableDataStructure.Header);
      deviceVersionMbus2.VersionProtocolType = versionProtocolTypes;
      deviceVersionMbus2.firmwareVersion = new uint?(uint32_1);
      deviceVersionMbus2.hardwareID = new uint?(uint32_2);
      deviceVersionMbus2.svnRevision = new uint?(uint32_3);
      deviceVersionMbus2.buildTime = dateMbusCp16TypeG;
      deviceVersionMbus2.signatur = new ushort?(uint16_1);
      deviceVersionMbus2.primaryAddress = new byte?(frame.Address);
      return deviceVersionMbus2;
    }

    public override string ToString() => this.FirmwareVersion.ToString();

    public new string Print(int spaces = 0) => Utility.PrintObject((object) this);
  }
}


--- Double2ulong.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.Double2ulong
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System.Runtime.InteropServices;

#nullable disable
namespace HandlerLib
{
  [StructLayout(LayoutKind.Explicit)]
  internal struct Double2ulong
  {
    [FieldOffset(0)]
    public double d;
    [FieldOffset(0)]
    public ulong ul;
  }
}


--- DownLinkTestSetup.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DownLinkTestSetup
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum DownLinkTestSetup
  {
    ServerTestByManualStepManagement,
    ServerTestByAutomaticFlowControl,
    ServerTestByAutomaticFlowAndHiddenWindow,
  }
}


--- DownLinkTestWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.DownLinkTestWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommonWPF;
using HandlerLib.NFC;
using Newtonsoft.Json;
using NLog;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class DownLinkTestWindow : Window, IComponentConnector
  {
    private static Logger DownLinkTestLogger = LogManager.GetLogger("DownLinkTest");
    public const string TriggerConfirmedProtocolData = "FFA55AF5AF";
    private const string ConfigKey = "HandlerLibDownLinkTestWindow";
    public DownLinkTestSetup TestSetup;
    public string ApiKey;
    private byte[] UplinkData;
    private string DevEUI;
    private bool IsPlugin;
    private DownLinkTestWindow.UploadData UploadBefore;
    private DownLinkTestWindow.SendProtocol TriggerFunction;
    private NfcFrame NfcFrame;
    private ProgressHandler Progress;
    private CancellationToken CancelToken;
    internal StartupLib.GmmCorporateControl gmmCorporateControl1;
    internal TextBox TextBoxElementURL;
    internal TextBox TextBoxElementApiKey;
    internal ComboBox ComboBoxTestSetup;
    internal TextBlock TextBlockDownlinkBytes;
    internal TextBox TextBoxDownlinkProtocol;
    internal Button ButtonPrepareLoRaServerForDownlink;
    internal TextBlock TextBlockLastPrepareTime;
    internal Button ButtonSendDeviceCommand;
    internal TextBlock TextBlockLastSendTime;
    internal Button ButtonLoadUplinkDataFromLoRaServer;
    internal TextBlock TextBlockLastLoadTime;
    internal TextBlock TextBlockUplinkBytes;
    internal TextBox TextBoxUplinkProtocol;
    internal Button ButtonWorkUplinkProtocol;
    private bool _contentLoaded;

    public DownLinkTestWindow(ulong devEUI, bool isPlugin = false)
    {
      this.DevEUI = devEUI.ToString("X016");
      this.IsPlugin = isPlugin;
      this.InitializeComponent();
      this.Title = this.Title + "   DevEUI: " + this.DevEUI;
      DownLinkTestWindow.DownLinkTestLogger.Trace("Prepared for devEUI: " + this.DevEUI);
      this.TextBoxElementURL.Text = "https://stage.element-iot.com/";
      this.TextBoxElementApiKey.Text = "b44a6cccabe2a2a3f06a7c52c18db300";
      this.TestSetup = DownLinkTestSetup.ServerTestByManualStepManagement;
      string str1 = PlugInLoader.GmmConfiguration.GetValue("HandlerLibDownLinkTestWindow", DownLinkTestWindow.ConfigVariables.TestSetup.ToString());
      if (!string.IsNullOrEmpty(str1))
        System.Enum.TryParse<DownLinkTestSetup>(str1, out this.TestSetup);
      string str2 = PlugInLoader.GmmConfiguration.GetValue("HandlerLibDownLinkTestWindow", DownLinkTestWindow.ConfigVariables.ElementURL.ToString());
      if (!string.IsNullOrEmpty(str2))
        this.TextBoxElementURL.Text = str2;
      string str3 = PlugInLoader.GmmConfiguration.GetValue("HandlerLibDownLinkTestWindow", DownLinkTestWindow.ConfigVariables.ElementApiKey.ToString());
      if (!string.IsNullOrEmpty(str3))
        this.TextBoxElementApiKey.Text = str3;
      this.ComboBoxTestSetup.SelectedIndex = (int) this.TestSetup;
    }

    private void TextBoxElementURL_LostFocus(object sender, RoutedEventArgs e)
    {
      if (!this.IsPlugin)
        return;
      PlugInLoader.GmmConfiguration.SetOrUpdateValue("HandlerLibDownLinkTestWindow", DownLinkTestWindow.ConfigVariables.ElementURL.ToString(), this.TextBoxElementURL.Text);
    }

    private void TextBoxElementApiKey_LostFocus(object sender, RoutedEventArgs e)
    {
      if (!this.IsPlugin)
        return;
      PlugInLoader.GmmConfiguration.SetOrUpdateValue("HandlerLibDownLinkTestWindow", DownLinkTestWindow.ConfigVariables.ElementApiKey.ToString(), this.TextBoxElementApiKey.Text);
    }

    private void Report(string reportString)
    {
      if (this.Progress == null)
        return;
      this.Progress.Report(reportString);
    }

    public byte[] GetUplinkBytes(
      byte[] downlinkProtocol,
      DownLinkTestWindow.SendProtocol triggerFunction,
      NfcFrame nfcFrame,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (!this.CheckAccess())
        return this.Dispatcher.Invoke<byte[]>((Func<byte[]>) (() => this.GetUplinkBytes(downlinkProtocol, triggerFunction, nfcFrame, progress, cancelToken)));
      this.TriggerFunction = triggerFunction;
      this.NfcFrame = nfcFrame;
      this.Progress = progress;
      this.CancelToken = cancelToken;
      this.ButtonPrepareLoRaServerForDownlink.IsEnabled = true;
      this.ButtonSendDeviceCommand.IsEnabled = true;
      this.ButtonLoadUplinkDataFromLoRaServer.IsEnabled = true;
      this.TextBlockDownlinkBytes.Text = downlinkProtocol.Length.ToString();
      byte[] buffer = new byte[downlinkProtocol.Length + 2];
      downlinkProtocol.CopyTo((Array) buffer, 0);
      BitConverter.GetBytes(CRC.CRC_16(downlinkProtocol)).CopyTo((Array) buffer, buffer.Length - 2);
      this.TextBoxDownlinkProtocol.Text = Util.ByteArrayToHexString(buffer);
      this.TextBoxUplinkProtocol.Clear();
      this.TextBlockLastPrepareTime.Visibility = Visibility.Collapsed;
      this.TextBlockLastPrepareTime.Text = string.Empty;
      this.TextBlockLastSendTime.Visibility = Visibility.Collapsed;
      this.TextBlockLastSendTime.Text = string.Empty;
      this.TextBlockLastLoadTime.Visibility = Visibility.Collapsed;
      this.TextBlockLastLoadTime.Text = string.Empty;
      this.UplinkData = (byte[]) null;
      DownLinkTestWindow.DownLinkTestLogger.Trace("Started for protocol: " + this.TextBoxDownlinkProtocol.Text);
      if (this.TestSetup != 0)
      {
        this.ButtonPrepareLoRaServerForDownlink_Click((object) this, (RoutedEventArgs) null);
        this.ButtonSendDeviceCommand_Click((object) this, (RoutedEventArgs) null);
        this.ButtonLoadUplinkDataFromLoRaServer_Click((object) this, (RoutedEventArgs) null);
      }
      if (this.TestSetup != DownLinkTestSetup.ServerTestByAutomaticFlowAndHiddenWindow)
        this.ShowDialog();
      return this.UplinkData;
    }

    private void ButtonSendDeviceCommand_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.Report("Send ConfirmedData trigger by device");
        DownLinkTestWindow.DownLinkTestLogger.Trace("Device: Upload ConfirmedData");
        this.TriggerFunction(this.NfcFrame, this.Progress, this.CancelToken, 0);
        this.TextBlockLastSendTime.Visibility = Visibility.Visible;
        this.TextBlockLastSendTime.Text = DateTime.Now.ToString("HH:mm:ss.FFF");
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex, "Send device command error.");
      }
    }

    private void TextBoxUplinkProtocol_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.TextBoxUplinkProtocol.Text.Length > 2)
        this.ButtonWorkUplinkProtocol.IsEnabled = true;
      else
        this.ButtonWorkUplinkProtocol.IsEnabled = false;
    }

    private void ButtonWorkUplinkProtocol_Click(object sender, RoutedEventArgs e) => this.Hide();

    private void ButtonPrepareLoRaServerForDownlink_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.Report("Prepare download by LoRa server");
        DownLinkTestWindow.DownLinkTestLogger.Trace("Prepare download by LoRa server");
        this.PrapareDownload();
        this.TextBlockLastPrepareTime.Visibility = Visibility.Visible;
        if (this.UploadBefore != null)
          this.TextBlockLastPrepareTime.Text = DateTime.Now.ToString("HH:mm:ss.FFF") + " (" + this.UploadBefore.UploadTime.ToString("HH:mm:ss.FFF") + ")";
        else
          this.TextBlockLastPrepareTime.Text = DateTime.Now.ToString("HH:mm:ss.FFF");
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonLoadUplinkDataFromLoRaServer_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.Report("Wait upload by LoRa server");
        DownLinkTestWindow.DownLinkTestLogger.Trace("Wait upload by LoRa server");
        DownLinkTestWindow.UploadData upload = this.WaitAndGetUpload();
        if (string.IsNullOrEmpty(upload.UploadDataString))
        {
          this.UplinkData = (byte[]) null;
          this.TextBlockUplinkBytes.Text = (string) null;
        }
        else
        {
          this.UplinkData = Util.HexStringToByteArray(upload.UploadDataString);
          this.TextBlockUplinkBytes.Text = this.UplinkData.Length.ToString();
        }
        this.TextBoxUplinkProtocol.Text = upload.UploadDataString;
        this.Report("Upload by LoRa server done");
        DownLinkTestWindow.DownLinkTestLogger.Trace("Upload done: " + this.TextBoxUplinkProtocol.Text);
        this.TextBlockLastLoadTime.Visibility = Visibility.Visible;
        if (upload != null)
          this.TextBlockLastLoadTime.Text = DateTime.Now.ToString("HH:mm:ss.FFF") + " (" + upload.UploadTime.ToString("HH:mm:ss.FFF") + ")";
        else
          this.TextBlockLastLoadTime.Text = DateTime.Now.ToString("HH:mm:ss.FFF");
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ComboBoxTestSetup_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      this.TestSetup = (DownLinkTestSetup) this.ComboBoxTestSetup.SelectedIndex;
      if (!this.IsPlugin)
        return;
      PlugInLoader.GmmConfiguration.SetOrUpdateValue("HandlerLibDownLinkTestWindow", DownLinkTestWindow.ConfigVariables.TestSetup.ToString(), this.TestSetup.ToString());
    }

    private void Window_Closing(object sender, CancelEventArgs e)
    {
      e.Cancel = true;
      this.Hide();
    }

    private void PrapareDownload()
    {
      this.UploadBefore = this.GetUpload();
      DownLinkTestWindow.POST(this.TextBoxElementURL.Text + "api/v1/devices/by-eui/" + this.DevEUI + "/actions/send_down_frame?auth=" + this.TextBoxElementApiKey.Text, "{\"opts\":{\"payload\":\"" + this.TextBoxDownlinkProtocol.Text + "\",\"port\":1}}");
    }

    private DownLinkTestWindow.UploadData WaitAndGetUpload()
    {
      DateTime dateTime1 = DateTime.Now.AddSeconds(20.0);
      DateTime dateTime2 = DateTime.MinValue;
      DownLinkTestWindow.UploadData upload;
      while (true)
      {
        if (!(DateTime.Now > dateTime1))
        {
          upload = this.GetUpload();
          if (upload != null)
          {
            if (this.UploadBefore == null || upload.UploadTime > this.UploadBefore.UploadTime)
            {
              if (!(upload.UploadDataString != "FFA55AF5AF"))
              {
                if (dateTime2 == upload.UploadTime)
                {
                  DownLinkTestWindow.DownLinkTestLogger.Trace("Last data repeated by server polling");
                }
                else
                {
                  this.Report("ConfirmedData trigger by LoRa server received");
                  DownLinkTestWindow.DownLinkTestLogger.Trace("ConfirmedData trigger by LoRa server received");
                }
              }
              else
                goto label_5;
            }
            else
              DownLinkTestWindow.DownLinkTestLogger.Trace("Server polling. Last data repeated by server");
            dateTime2 = upload.UploadTime;
          }
          else
            DownLinkTestWindow.DownLinkTestLogger.Trace("UploadData == null");
          Thread.Sleep(1000);
        }
        else
          break;
      }
      throw new TimeoutException();
label_5:
      DownLinkTestWindow.DownLinkTestLogger.Trace("Server polling. Deliverd upload != ConfirmedProtocol data");
      return upload;
    }

    private DownLinkTestWindow.UploadData GetUpload()
    {
      DownLinkTestWindow.Root root = JsonConvert.DeserializeObject<DownLinkTestWindow.Root>(DownLinkTestWindow.GET(this.TextBoxElementURL.Text + "api/v1/devices/by-eui/" + this.DevEUI + "/packets?limit=1&packet_type=up&auth=" + this.TextBoxElementApiKey.Text));
      if (root == null || root.body.Count <= 0)
        return (DownLinkTestWindow.UploadData) null;
      return new DownLinkTestWindow.UploadData()
      {
        UploadDataString = root.body[0].payload,
        UploadTime = root.body[0].inserted_at
      };
    }

    public static string POST(string url, string jsonContent)
    {
      ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
      HttpWebRequest httpWebRequest = (HttpWebRequest) WebRequest.Create(url);
      httpWebRequest.Method = nameof (POST);
      byte[] bytes = new UTF8Encoding().GetBytes(jsonContent);
      httpWebRequest.ContentLength = (long) bytes.Length;
      httpWebRequest.ContentType = "application/json";
      using (Stream requestStream = httpWebRequest.GetRequestStream())
        requestStream.Write(bytes, 0, bytes.Length);
      using (HttpWebResponse response = (HttpWebResponse) httpWebRequest.GetResponse())
      {
        using (Stream responseStream = response.GetResponseStream())
          return new StreamReader(responseStream, Encoding.UTF8).ReadToEnd();
      }
    }

    public static string GET(string url)
    {
      ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
      using (Stream responseStream = WebRequest.Create(url).GetResponse().GetResponseStream())
        return new StreamReader(responseStream, Encoding.UTF8).ReadToEnd();
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/downlinktestwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          ((Window) target).Closing += new CancelEventHandler(this.Window_Closing);
          break;
        case 2:
          this.gmmCorporateControl1 = (StartupLib.GmmCorporateControl) target;
          break;
        case 3:
          this.TextBoxElementURL = (TextBox) target;
          this.TextBoxElementURL.LostFocus += new RoutedEventHandler(this.TextBoxElementURL_LostFocus);
          break;
        case 4:
          this.TextBoxElementApiKey = (TextBox) target;
          this.TextBoxElementApiKey.LostFocus += new RoutedEventHandler(this.TextBoxElementApiKey_LostFocus);
          break;
        case 5:
          this.ComboBoxTestSetup = (ComboBox) target;
          this.ComboBoxTestSetup.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxTestSetup_SelectionChanged);
          break;
        case 6:
          this.TextBlockDownlinkBytes = (TextBlock) target;
          break;
        case 7:
          this.TextBoxDownlinkProtocol = (TextBox) target;
          break;
        case 8:
          this.ButtonPrepareLoRaServerForDownlink = (Button) target;
          this.ButtonPrepareLoRaServerForDownlink.Click += new RoutedEventHandler(this.ButtonPrepareLoRaServerForDownlink_Click);
          break;
        case 9:
          this.TextBlockLastPrepareTime = (TextBlock) target;
          break;
        case 10:
          this.ButtonSendDeviceCommand = (Button) target;
          this.ButtonSendDeviceCommand.Click += new RoutedEventHandler(this.ButtonSendDeviceCommand_Click);
          break;
        case 11:
          this.TextBlockLastSendTime = (TextBlock) target;
          break;
        case 12:
          this.ButtonLoadUplinkDataFromLoRaServer = (Button) target;
          this.ButtonLoadUplinkDataFromLoRaServer.Click += new RoutedEventHandler(this.ButtonLoadUplinkDataFromLoRaServer_Click);
          break;
        case 13:
          this.TextBlockLastLoadTime = (TextBlock) target;
          break;
        case 14:
          this.TextBlockUplinkBytes = (TextBlock) target;
          break;
        case 15:
          this.TextBoxUplinkProtocol = (TextBox) target;
          this.TextBoxUplinkProtocol.TextChanged += new TextChangedEventHandler(this.TextBoxUplinkProtocol_TextChanged);
          break;
        case 16:
          this.ButtonWorkUplinkProtocol = (Button) target;
          this.ButtonWorkUplinkProtocol.Click += new RoutedEventHandler(this.ButtonWorkUplinkProtocol_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }

    private enum ConfigVariables
    {
      TestSetup,
      ElementURL,
      ElementApiKey,
    }

    public delegate void SendProtocol(
      NfcFrame nfcFrame,
      ProgressHandler progres,
      CancellationToken cancelToken,
      int readTimeOffset);

    private class UploadData
    {
      internal DateTime UploadTime;
      internal string UploadDataString;
    }

    public class GatewayStat
    {
      public long router_id { get; set; }

      public string router_id_hex { get; set; }

      public int rssi { get; set; }

      public double snr { get; set; }

      public long tmst { get; set; }
    }

    public class RegionMeta
    {
      public int bandwidth { get; set; }

      public int bitrate { get; set; }

      public string code { get; set; }

      public int datarate { get; set; }

      public string name { get; set; }

      public int spreadingfactor { get; set; }
    }

    public class Meta
    {
      public bool ack { get; set; }

      public bool adr_ack_req { get; set; }

      public object chan { get; set; }

      public string codr { get; set; }

      public bool confirm { get; set; }

      public int data_rate { get; set; }

      public string datr { get; set; }

      public object dev_nonce { get; set; }

      public int frame_count_up { get; set; }

      public int frame_port { get; set; }

      public double frequency { get; set; }

      public List<DownLinkTestWindow.GatewayStat> gateway_stats { get; set; }

      public object ipol { get; set; }

      public string lns_packet_uuid { get; set; }

      public double lorawan_toa_ms { get; set; }

      public List<object> mac_commands { get; set; }

      public string modu { get; set; }

      public object powe { get; set; }

      public string region { get; set; }

      public DownLinkTestWindow.RegionMeta region_meta { get; set; }

      public object rfch { get; set; }

      public object rx { get; set; }

      public int size { get; set; }

      public int stat { get; set; }
    }

    public class Body
    {
      public object driver { get; set; }

      public string device_id { get; set; }

      public string interface_id { get; set; }

      public bool is_meta { get; set; }

      public DownLinkTestWindow.Meta meta { get; set; }

      public DateTime inserted_at { get; set; }

      public DateTime transceived_at { get; set; }

      public string packet_type { get; set; }

      public string payload_encoding { get; set; }

      public string payload { get; set; }

      public string id { get; set; }
    }

    public class Root
    {
      public List<DownLinkTestWindow.Body> body { get; set; }

      public bool ok { get; set; }

      public string retrieve_after_id { get; set; }

      public int status { get; set; }
    }
  }
}


--- EDC_Warning.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.EDC_Warning
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  [Flags]
  internal enum EDC_Warning : ushort
  {
    OK = 0,
    ABNORMAL = 2,
    BATT_LOW = 4,
    PERMANENT_ERROR = 8,
    INTERFERE = 16384, // 0x4000
    TAMPER_A = 64, // 0x0040
    REMOVAL_A = 128, // 0x0080
    LEAK = 8192, // 0x2000
    LEAK_A = 32, // 0x0020
    BLOCK_A = 1024, // 0x0400
    BACKFLOW = 2048, // 0x0800
    BACKFLOW_A = 4096, // 0x1000
    UNDERSIZE = 512, // 0x0200
    OVERSIZE = 256, // 0x0100
    BURST = 32768, // 0x8000
    TEMPORARY = 16, // 0x0010
  }
}


--- eIoTestFunctions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.eIoTestFunctions
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum eIoTestFunctions
  {
    IoTest_Run,
    IoTest_ActivateIoTestMode,
    IoTest_DeactivateIoTestMode,
  }
}


--- eWR4_VOL_INPUT_STATE.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.eWR4_VOL_INPUT_STATE
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum eWR4_VOL_INPUT_STATE
  {
    Unknown,
    WaitSetCycle,
    SetCycle,
    WaitReceiveVolume,
    ReceiveVolume,
    WaitRequestID,
    RequestID,
  }
}


--- FirmwareBlockInfoClass.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.FirmwareBlockInfoClass
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public class FirmwareBlockInfoClass
  {
    public uint startAddress = uint.MaxValue;
    public uint endAddress = 0;
    public uint blockSize = 0;
    public bool isLocal = false;
    private byte[] _blockBytes = (byte[]) null;

    public ushort crc16 { get; private set; }

    public ushort crc16_CCITT { get; private set; }

    public byte[] BlockBytes
    {
      get => this._blockBytes;
      set
      {
        this._blockBytes = value;
        this.blockSize = (uint) this.BlockBytes.Length;
        this.endAddress = this.startAddress + this.blockSize;
        this.crc16_CCITT = CRC.CRC_CCITT(this._blockBytes);
        this.crc16 = CRC.CRC_16(this._blockBytes);
      }
    }

    public string ToString(uint blockNr = 0)
    {
      return "\r ... INFO for Firmware Block " + (blockNr > 0U ? blockNr.ToString() : "") + " \r Startaddress: 0x" + this.startAddress.ToString("x8") + "\r Endaddress:   0x" + this.endAddress.ToString("x8") + "\r Size:           " + this.blockSize.ToString() + " Bytes \r CRC_CCiTT:    0x" + this.crc16.ToString("x4") + "\r";
    }
  }
}


--- FirmwareData.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.FirmwareData
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System.Collections.Generic;
using System.IO;

#nullable disable
namespace HandlerLib
{
  public class FirmwareData
  {
    public string ProgrammerFileAsString;
    public string ProgFileName;
    public string SourceInfo;
    public List<KeyValuePair<string, string>> Options = new List<KeyValuePair<string, string>>();

    public void WriteToFile(string filePathAndName)
    {
      using (StreamWriter streamWriter = new StreamWriter(filePathAndName))
        streamWriter.Write(this.ProgrammerFileAsString);
    }
  }
}


--- FirmwareInfoClass.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.FirmwareInfoClass
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public class FirmwareInfoClass
  {
    public uint firstAddress = uint.MaxValue;
    public uint lastAddress = 0;
    public uint stepSize = 0;
    public uint oldKeyAdr = 0;
    public uint gapCounter = 0;
    public string gapMessage = string.Empty;

    public override string ToString()
    {
      return " ... INFO ... \r Startaddress: 0x" + this.firstAddress.ToString("x8") + "\r Endaddress:   0x" + this.lastAddress.ToString("x8") + "\r Stepsize:     " + this.stepSize.ToString() + "\r Gaps:         " + this.gapCounter.ToString() + "\r" + this.gapMessage;
    }
  }
}


--- FirmwareParameterInfo.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.FirmwareParameterInfo
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System.Xml.Serialization;

#nullable disable
namespace HandlerLib
{
  public class FirmwareParameterInfo
  {
    [XmlElement("ParameterName")]
    public string ParameterName { get; set; }

    [XmlElement("ParameterType")]
    public ParameterType ParameterType { get; set; }

    public override string ToString()
    {
      return this.ParameterName + ": " + this.ParameterType.ParameterTypeSaved;
    }
  }
}


--- FirmwareParameterManager.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.FirmwareParameterManager
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using HandlerLib.MapManagement;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Xml.Serialization;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public sealed class FirmwareParameterManager
  {
    public List<FirmwareParameterInfo> ParameterInfos { get; set; }

    public Assembly HandlerAssembly { get; private set; }

    public static string FileNameWithPath { get; set; }

    public bool isDeveloperVersion { get; set; }

    public static string FileNameUserSettings { get; private set; }

    private static Dictionary<string, string> oSettingsDic { get; set; }

    public FirmwareParameterManager(Assembly handlerAssembly)
    {
      this.ParameterInfos = new List<FirmwareParameterInfo>();
      this.HandlerAssembly = handlerAssembly;
      FirmwareParameterManager.FileNameWithPath = this.revealFilename(this.HandlerAssembly);
    }

    public FirmwareParameterManager(string filenameWithPath)
    {
      this.ParameterInfos = new List<FirmwareParameterInfo>();
      this.HandlerAssembly = (Assembly) null;
      FirmwareParameterManager.FileNameWithPath = filenameWithPath;
    }

    public static List<FirmwareParameterInfo> LoadParameterInfos()
    {
      string fileNameWithPath = FirmwareParameterManager.FileNameWithPath;
      if (!File.Exists(fileNameWithPath))
        return (List<FirmwareParameterInfo>) null;
      XmlSerializer xmlSerializer = new XmlSerializer(typeof (List<FirmwareParameterInfo>));
      TextReader textReader = (TextReader) new StreamReader(fileNameWithPath);
      List<FirmwareParameterInfo> firmwareParameterInfoList = (List<FirmwareParameterInfo>) xmlSerializer.Deserialize(textReader);
      textReader.Close();
      return firmwareParameterInfoList;
    }

    public static void SaveParameterInfos(List<FirmwareParameterInfo> theInfos)
    {
      string fileNameWithPath = FirmwareParameterManager.FileNameWithPath;
      using (TextWriter textWriter = (TextWriter) new StreamWriter(fileNameWithPath))
      {
        new XmlSerializer(typeof (List<FirmwareParameterInfo>)).Serialize(textWriter, (object) theInfos);
        textWriter.Flush();
        textWriter.Close();
      }
    }

    public string revealFilename(Assembly handlerAssembly)
    {
      this.isDeveloperVersion = false;
      string str1 = handlerAssembly.ManifestModule.Name.Replace(".dll", "");
      string str2 = str1 + "_ParameterDefinedFile.xml";
      string directoryName1 = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
      this.isDeveloperVersion = Debugger.IsAttached;
      string directoryName2 = Path.GetDirectoryName(directoryName1);
      Path.GetDirectoryName(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData));
      string dataPath = SystemValues.DataPath;
      string path1 = Path.Combine(directoryName2, "Source", "Handlers", str1, "MapClasses", str2);
      string path2 = Path.Combine(directoryName1, str2);
      string path3 = Path.Combine(directoryName1, "MapClasses", str2);
      string path4 = Path.Combine(dataPath, "MapClasses", str2);
      if (this.isDeveloperVersion && File.Exists(path1))
        return path1;
      if (File.Exists(path3))
        return path3;
      if (File.Exists(path2))
        return path2;
      return File.Exists(path4) ? path4 : string.Empty;
    }

    private void checkPathAndCreateIfNotExists(string fileNameWithPath)
    {
      if (Directory.Exists(Path.GetDirectoryName(fileNameWithPath)))
        return;
      Directory.CreateDirectory(Path.GetDirectoryName(fileNameWithPath));
    }

    public static void GenerateParameterInfo(
      MapDefClassBase mapDef,
      ref FirmwareParameterManager fwMGR)
    {
      if (fwMGR.ParameterInfos == null)
      {
        fwMGR.ParameterInfos = new List<FirmwareParameterInfo>();
        fwMGR.ParameterInfos.Clear();
      }
      uint[] source = new uint[3]{ 1U, 2U, 4U };
      foreach (Parameter32bit parameter32bit in (IEnumerable<Parameter32bit>) mapDef.GetAllParametersList().Values)
      {
        Parameter32bit p32Bit = parameter32bit;
        if (fwMGR.ParameterInfos.SingleOrDefault<FirmwareParameterInfo>((Func<FirmwareParameterInfo, bool>) (kvp => kvp.ParameterName == p32Bit.Name)) == null)
        {
          Type type = MapReader.ConvertToRealType(p32Bit.Typ);
          if (p32Bit.Typ.Contains("UNKNOWN") && ((IEnumerable<uint>) source).Contains<uint>(p32Bit.Size))
          {
            type = MapReader.getDefaultTypeForSize(p32Bit.Size);
            Parameter32bit.SetType(type, p32Bit);
          }
          ParameterType parameterType = new ParameterType()
          {
            ParameterTypeSaved = type == (Type) null ? "UNKNOWN" : type.Name,
            ParameterTypeColPreset = 0
          };
          fwMGR.ParameterInfos.Add(new FirmwareParameterInfo()
          {
            ParameterName = p32Bit.Name,
            ParameterType = parameterType
          });
        }
      }
    }

    public static string getStringFromUserSettings(string settingName)
    {
      string fromUserSettings = string.Empty;
      string nameUserSettings = FirmwareParameterManager.FileNameUserSettings;
      if (File.Exists(nameUserSettings))
      {
        FirmwareParameterManager.loadDictionaryDataFromFile(nameUserSettings);
        Dictionary<string, string> oSettingsDic = FirmwareParameterManager.oSettingsDic;
        if (oSettingsDic.ContainsKey(settingName))
          fromUserSettings = oSettingsDic[settingName].ToLower();
      }
      return fromUserSettings;
    }

    public static void setStringToUserSettings(string settingName, string settingValue)
    {
      if (!File.Exists(FirmwareParameterManager.FileNameUserSettings))
        return;
      Dictionary<string, string> oSettingsDic = FirmwareParameterManager.oSettingsDic;
      if (oSettingsDic.ContainsKey(settingName))
        oSettingsDic[settingName] = settingValue;
      else
        oSettingsDic.Add(settingName, settingValue);
      FirmwareParameterManager.saveDictionaryDataToFile();
    }

    private static void loadDictionaryDataFromFile(string file)
    {
      Dictionary<string, string> dictionary = new Dictionary<string, string>();
      if (File.Exists(FirmwareParameterManager.FileNameUserSettings))
      {
        StreamReader streamReader = File.OpenText(FirmwareParameterManager.FileNameUserSettings);
        string[] strArray1 = streamReader.ReadToEnd().Replace("\n", "").Replace("\r", "").Split(';');
        for (int index = 0; index < strArray1.Length - 1; ++index)
        {
          string[] strArray2 = strArray1[index].Split('=');
          dictionary.Add(strArray2[0], strArray2[1]);
        }
        streamReader.Close();
      }
      FirmwareParameterManager.oSettingsDic = dictionary;
    }

    private static void saveDictionaryDataToFile()
    {
      StreamWriter text = File.CreateText(FirmwareParameterManager.FileNameUserSettings);
      Dictionary<string, string> oSettingsDic = FirmwareParameterManager.oSettingsDic;
      if (text != null && oSettingsDic != null)
      {
        foreach (string key in oSettingsDic.Keys)
        {
          string str = key + "=" + oSettingsDic[key] + ";";
          text.WriteLine(str);
        }
        text.Flush();
        text.Close();
      }
      else
      {
        if (text == null || oSettingsDic != null)
          return;
        text.Close();
      }
    }
  }
}


--- FirmwareReleaseInfo.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.FirmwareReleaseInfo
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using GmmDbLib.DataSets;
using System;

#nullable disable
namespace HandlerLib
{
  public class FirmwareReleaseInfo : IComparable<FirmwareReleaseInfo>
  {
    public int MapID { get; internal set; }

    public string FirmwareVersionString { get; internal set; }

    public int FirmwareVersion { get; internal set; }

    public string ProgFilName { get; internal set; }

    public string ReleaseText { get; internal set; }

    public string ReleaseDescription { get; internal set; }

    public int CompareTo(FirmwareReleaseInfo compareObject)
    {
      return ((uint) this.FirmwareVersion).CompareTo((uint) compareObject.FirmwareVersion) * -1;
    }

    public override string ToString()
    {
      return this.MapID.ToString() + "; " + this.FirmwareVersionString + "; " + this.ReleaseText;
    }

    public static FirmwareReleaseInfo ToFirmwareReleaseInfo(HardwareTypeTables.ProgFilesRow pfRow)
    {
      FirmwareReleaseInfo firmwareReleaseInfo = new FirmwareReleaseInfo()
      {
        MapID = pfRow.MapID,
        FirmwareVersion = pfRow.FirmwareVersion
      };
      firmwareReleaseInfo.FirmwareVersionString = new ZENNER.CommonLibrary.FirmwareVersion((uint) firmwareReleaseInfo.FirmwareVersion).ToString();
      firmwareReleaseInfo.ProgFilName = pfRow.IsProgFileNameNull() ? string.Empty : pfRow.ProgFileName;
      firmwareReleaseInfo.ReleaseText = pfRow.IsReleasedNameNull() ? string.Empty : pfRow.ReleasedName;
      firmwareReleaseInfo.ReleaseDescription = pfRow.IsReleaseCommentsNull() ? string.Empty : pfRow.ReleaseComments;
      return firmwareReleaseInfo;
    }
  }
}


--- FirmwareUpdateFunctions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.FirmwareUpdateFunctions
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.Functions;
using GmmDbLib;
using GmmDbLib.DataSets;
using Microsoft.Win32;
using ReadoutConfiguration;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class FirmwareUpdateFunctions
  {
    internal string strFileName = string.Empty;
    internal string strFirmwareFile = string.Empty;
    internal string strBootloaderFile = string.Empty;
    internal byte[] baVectorInitTable;
    internal byte[] baFirstEightBytesFromHexFile;
    private CommunicationPortFunctions myPort = (CommunicationPortFunctions) null;
    private int mapID = -1;
    private SortedDictionary<uint, byte[]> dicBytesToFlash = (SortedDictionary<uint, byte[]>) null;
    internal SortedDictionary<uint, byte[]> dicBytesToFlashBOOTLOADER = (SortedDictionary<uint, byte[]>) null;
    internal SortedDictionary<uint, byte[]> dicBytesToFlashFIRMWARE = (SortedDictionary<uint, byte[]>) null;
    internal SortedDictionary<uint, byte[]> dicBytesToFlashMERGE = (SortedDictionary<uint, byte[]>) null;
    internal SortedDictionary<uint, byte[]> dicBytesToFlashBACKPACK = (SortedDictionary<uint, byte[]>) null;
    internal List<FirmwareBlockInfoClass> blockInfo_Firmware = (List<FirmwareBlockInfoClass>) null;
    internal List<FirmwareBlockInfoClass> blockInfo_Bootloader = (List<FirmwareBlockInfoClass>) null;
    internal List<FirmwareBlockInfoClass> blockInfo_NoVerify = (List<FirmwareBlockInfoClass>) null;
    internal SortedList<uint, HardwareTypeTables.ProgFilesRow> availBootloaderProgFiles = (SortedList<uint, HardwareTypeTables.ProgFilesRow>) null;
    internal SortedList<uint, HardwareTypeTables.ProgFilesRow> availFirmwareProgFiles = (SortedList<uint, HardwareTypeTables.ProgFilesRow>) null;
    internal bool isReady2GO;
    internal bool isReady2WriteFW;
    public bool isReady2EraseFW;
    public uint iFlashStartAdr = 134217728;
    public bool isFirstEightBytesLoaded;
    public bool isVectorTableLoaded;
    private FirmwareUpdateToolDeviceCommands fwUpdateToolCMDs;
    private BootLoaderFunctions BTLFunctions;
    public FirmwareVersion BSLversion = new FirmwareVersion(16781346U);
    public AddressRange ArmIdRange = new AddressRange(536346704U, 24U);
    internal FirmwareData dataOfBootloader = (FirmwareData) null;
    internal FirmwareData dataOfFrmware = (FirmwareData) null;
    internal List<FirmwareData> ListOfLoadedBootloader = (List<FirmwareData>) null;
    internal List<FirmwareData> ListOfLoadedFrmware = (List<FirmwareData>) null;
    internal uint iMeterKey = 134742016;
    internal uint iVectorTable = 134217728;
    private bool writeNOW;
    public bool isHandlerAvailable = false;
    public bool isHandlerFunctionsAvailable = false;
    private HandlerFunctionsForProduction _myHandlerForProduction;
    private IHandler _myHandlerFunctions;
    public string CoreVersion = "1.0.14";
    private FirmwareUpdateFunctions.UpdateDataBlock myUpDateBlock = (FirmwareUpdateFunctions.UpdateDataBlock) null;

    public bool isBSLrunning { get; private set; }

    public bool isBootLoaderFile { get; private set; }

    public bool isFirmWareFile { get; private set; }

    public uint iBootLoaderStartAddress { get; private set; }

    public uint iBootLoaderEndAddress { get; private set; }

    public DeviceIdentification deviceIdentification { get; private set; }

    public DeviceIdentification deviceIdentificationForBackup { get; private set; }

    public AddressRange BSL_AddressRange { get; private set; }

    public AddressRange FW_AddressRange { get; private set; }

    public uint verifyPageSize { get; set; }

    public string HardwareName { get; set; }

    public string firmwareFileData { get; private set; }

    public byte[] zippedBackUpData { get; private set; }

    public bool isDeviceIUW_NFC { get; set; }

    public HandlerFunctionsForProduction myHandlerForProduction
    {
      get => this._myHandlerForProduction;
      set
      {
        this._myHandlerForProduction = value;
        this.isHandlerAvailable = value != null;
      }
    }

    public IHandler myHandlerFunctions
    {
      get => this._myHandlerFunctions;
      set
      {
        this._myHandlerFunctions = value;
        this.isHandlerFunctionsAvailable = value != null;
      }
    }

    public IZDebugInfo oFUI { get; set; }

    public bool bIsFirmwareVerifyError { get; private set; }

    public bool bIsBootloaderVerifyError { get; private set; }

    public FirmwareUpdateFunctions(
      CommunicationPortFunctions port,
      FirmwareUpdateToolDeviceCommands fwUpToolDeviceCMD)
    {
      this.myPort = port;
      this.fwUpdateToolCMDs = fwUpToolDeviceCMD;
      this.BTLFunctions = new BootLoaderFunctions(this.myPort, this.fwUpdateToolCMDs);
      this.isReady2GO = false;
      this.isBootLoaderFile = false;
      this.isReady2EraseFW = false;
      this.isReady2WriteFW = false;
      this.isFirstEightBytesLoaded = false;
      this.isVectorTableLoaded = false;
      this.iBootLoaderStartAddress = 0U;
      this.iBootLoaderEndAddress = 0U;
      this.verifyPageSize = 128U;
      this.baFirstEightBytesFromHexFile = new byte[8];
      this.baVectorInitTable = new byte[192];
      this.dicBytesToFlash = new SortedDictionary<uint, byte[]>();
      this.deviceIdentification = (DeviceIdentification) null;
      this.ListOfLoadedBootloader = new List<FirmwareData>();
      this.ListOfLoadedFrmware = new List<FirmwareData>();
    }

    public void SetMapID(int mapID = 255) => this.mapID = mapID;

    public void clearVariables()
    {
      this.dicBytesToFlash = (SortedDictionary<uint, byte[]>) null;
      this.dicBytesToFlashBOOTLOADER = (SortedDictionary<uint, byte[]>) null;
      this.dicBytesToFlashFIRMWARE = (SortedDictionary<uint, byte[]>) null;
      this.dicBytesToFlashMERGE = (SortedDictionary<uint, byte[]>) null;
      this.dicBytesToFlashBACKPACK = (SortedDictionary<uint, byte[]>) null;
      this.availBootloaderProgFiles = (SortedList<uint, HardwareTypeTables.ProgFilesRow>) null;
      this.availFirmwareProgFiles = (SortedList<uint, HardwareTypeTables.ProgFilesRow>) null;
      this.isReady2GO = false;
      this.isReady2WriteFW = false;
      this.isReady2EraseFW = false;
      this.isBSLrunning = false;
      this.isBootLoaderFile = false;
      this.isFirmWareFile = false;
      this.iBootLoaderStartAddress = 0U;
      this.iBootLoaderEndAddress = 0U;
      this.iFlashStartAdr = 134217728U;
      this.isFirstEightBytesLoaded = false;
      this.isVectorTableLoaded = false;
      this.BSL_AddressRange = (AddressRange) null;
      this.deviceIdentification = (DeviceIdentification) null;
      this.bIsBootloaderVerifyError = false;
      this.bIsFirmwareVerifyError = false;
    }

    public async Task<DeviceIdentification> ReadVersionAsync(
      ProgressHandler progress,
      CancellationToken token)
    {
      DeviceIdentification deviceIdentification = await this.fwUpdateToolCMDs.ReadVersionAsync(progress, token);
      this.deviceIdentification = deviceIdentification;
      deviceIdentification = (DeviceIdentification) null;
      ConfigList locCfgList = this.myPort.GetReadoutConfiguration();
      ConnectionProfileIdentification conProfileIdent = new ConnectionProfileIdentification(locCfgList.ConnectionProfileID);
      bool isNON_NFC = Enum.IsDefined(typeof (BTL_NON_NFC_Devices), (object) conProfileIdent.DeviceModelID);
      this.isDeviceIUW_NFC = locCfgList.BusMode.Contains("NFC") && !isNON_NFC;
      this.verifyPageSize = this.isDeviceIUW_NFC ? 512U : 128U;
      this.isBSLrunning = false;
      DeviceIdentification deviceIdentification1 = this.deviceIdentification;
      locCfgList = (ConfigList) null;
      conProfileIdent = (ConnectionProfileIdentification) null;
      return deviceIdentification1;
    }

    public async Task prepareUpdate(
      ProgressHandler progress,
      CancellationTokenSource token,
      uint flashStartAddress = 134217728)
    {
      if (this.isDeviceIUW_NFC)
      {
        this.readFirstEightBytesFromBootLoader();
        if (this.oFUI != null)
          this.oFUI.setDebugInfo("\rreading first eight bytes from bootloader ... Done.");
        await this.writeFirstEightBytesToFLASH(progress, token.Token);
        if (this.oFUI != null)
          this.oFUI.setDebugInfo("\rwrite first eight bytes to FLASH ... Done.");
        await this.doSystemResetFunction(progress, token);
        if (this.oFUI != null)
          this.oFUI.setDebugInfo("\rdo System RESET ... Done.");
      }
      else
      {
        this.iFlashStartAdr = flashStartAddress;
        if (this.oFUI != null)
          this.oFUI.setDebugInfo("\rprepare for entering BOOTLOADER mode ... Done.");
        this.readFirstEightBytesFromBootLoader(this.iFlashStartAdr);
        if (this.oFUI != null)
          this.oFUI.setDebugInfo("\rreading first eight bytes from bootloader ... Done.");
        await this.readVectorTableFromDevice(progress, token, this.iFlashStartAdr);
        if (this.oFUI != null)
          this.oFUI.setDebugInfo("\rread vector table from FLASH ... Done.");
        this.writeFirstEightBytesToFLASH(progress, token.Token, this.baFirstEightBytesFromHexFile, this.iFlashStartAdr).Wait(2000);
        if (this.oFUI != null)
          this.oFUI.setDebugInfo("\rwrite first eight bytes to FLASH ... Done.");
        this.doSystemResetFunction(progress, token).Wait(2000);
        if (this.oFUI != null)
          this.oFUI.setDebugInfo("\rdo System RESET ... Done.");
      }
      this.isReady2EraseFW = true;
    }

    public void readFirstEightBytesFromBootLoader(uint flashStartAddress = 134217728)
    {
      this.baFirstEightBytesFromHexFile = this.getFirstEightBytesFromBootLoader(flashStartAddress);
    }

    public byte[] getFirstEightBytesFromBootLoader(uint flashStartAddress = 134217728)
    {
      byte[] dst = new byte[8];
      if (this.dicBytesToFlashBOOTLOADER.Count == 0)
        throw new Exception("ERROR: BOOTLOADER file empty or not loaded correctly.");
      if ((int) flashStartAddress != (int) this.iFlashStartAdr)
        this.iFlashStartAdr = flashStartAddress;
      if (!this.isBootLoaderFile)
        throw new Exception("Please, select a BOOTLOADER file first.");
      using (IEnumerator<uint> enumerator = this.dicBytesToFlashBOOTLOADER.Keys.Where<uint>((System.Func<uint, bool>) (x => x >= this.iFlashStartAdr)).GetEnumerator())
      {
        if (enumerator.MoveNext())
        {
          Buffer.BlockCopy((Array) this.dicBytesToFlashBOOTLOADER[enumerator.Current], 0, (Array) dst, 0, 8);
          this.isFirstEightBytesLoaded = true;
        }
      }
      return dst;
    }

    public byte[] getFirstEightBytesFromFirmware(uint flashStartAddress = 134217728)
    {
      byte[] dst = new byte[8];
      if (this.dicBytesToFlashFIRMWARE.Count == 0)
        throw new Exception("ERROR: FIRMWARE file empty or not loaded correctly.");
      if ((int) flashStartAddress != (int) this.iFlashStartAdr)
        this.iFlashStartAdr = flashStartAddress;
      using (IEnumerator<uint> enumerator = this.dicBytesToFlashFIRMWARE.Keys.Where<uint>((System.Func<uint, bool>) (x => x >= this.iFlashStartAdr)).GetEnumerator())
      {
        if (enumerator.MoveNext())
          Buffer.BlockCopy((Array) this.dicBytesToFlashFIRMWARE[enumerator.Current], 0, (Array) dst, 0, 8);
      }
      return dst;
    }

    public byte[] getVectorTableFromFirmware(uint flashStartAddress = 134217728)
    {
      int length = 192;
      byte[] dst = new byte[length];
      if (this.dicBytesToFlashFIRMWARE.Count == 0)
        throw new Exception("ERROR: FIRMWARE file empty or not loaded correctly.");
      if ((int) flashStartAddress != (int) this.iFlashStartAdr)
        this.iFlashStartAdr = flashStartAddress;
      foreach (uint key in this.dicBytesToFlashFIRMWARE.Keys.Where<uint>((System.Func<uint, bool>) (x => x >= this.iFlashStartAdr)))
      {
        byte[] src = this.dicBytesToFlashFIRMWARE[key];
        Buffer.BlockCopy((Array) src, 0, (Array) dst, dst.Length, src.Length);
        if (dst.Length >= length)
          break;
      }
      return dst;
    }

    public async Task readVectorTableFromDevice(
      ProgressHandler progress,
      CancellationTokenSource token,
      uint flashStartAddress = 134217728)
    {
      byte[] numArray = await this.getVectorTableFromDevice(progress, token, flashStartAddress);
      this.baVectorInitTable = numArray;
      numArray = (byte[]) null;
    }

    public async Task<byte[]> getVectorTableFromDevice(
      ProgressHandler progress,
      CancellationTokenSource token,
      uint flashStartAddress = 134217728)
    {
      uint iSize = 192;
      byte[] ba = new byte[(int) iSize];
      ba = await this.fwUpdateToolCMDs.ReadMemoryAsync(progress, token.Token, flashStartAddress, iSize, (byte) 128);
      byte[] vectorTableFromDevice = ba;
      ba = (byte[]) null;
      return vectorTableFromDevice;
    }

    public async Task<byte[]> getFirstEightBytesFromDevice(
      ProgressHandler progress,
      CancellationTokenSource token,
      uint flashStartAddress = 134217728)
    {
      uint iSize = 8;
      byte[] ba = new byte[(int) iSize];
      ba = await this.fwUpdateToolCMDs.ReadMemoryAsync(progress, token.Token, flashStartAddress, iSize, (byte) 128);
      byte[] eightBytesFromDevice = ba;
      ba = (byte[]) null;
      return eightBytesFromDevice;
    }

    public async Task writeFirstEightBytesToFLASH(
      ProgressHandler progress,
      CancellationToken token,
      uint startAddress = 134217728)
    {
      await this.writeFirstEightBytesToFLASH(progress, token, this.baFirstEightBytesFromHexFile, startAddress);
    }

    public async Task writeFirstEightBytesToFLASH(
      ProgressHandler progress,
      CancellationToken token,
      byte[] bytesToWrite,
      uint startAddress = 134217728)
    {
      try
      {
        await this.fwUpdateToolCMDs.WriteMemoryAsync(progress, token, startAddress, bytesToWrite);
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR while writing first 8 byte to FLASH memory of connected device.", ex);
      }
    }

    public async Task writeVectorTableToFLASH(
      ProgressHandler progress,
      CancellationTokenSource token,
      uint startAddress = 134217728)
    {
      await this.writeVectorTableToFLASH(progress, token, this.baVectorInitTable, startAddress);
    }

    public async Task writeVectorTableToFLASH(
      ProgressHandler progress,
      CancellationTokenSource token,
      byte[] bytesToWrite,
      uint startAddress = 134217728)
    {
      try
      {
        if (this.baVectorInitTable.Length == 0)
          throw new Exception("Vector Init table was not loaded correctly, try again please.");
        if (this.isBSLrunning)
          await this.BTLFunctions.writeMemoryAsync(progress, token, startAddress, bytesToWrite);
        else
          await this.fwUpdateToolCMDs.WriteMemoryAsync(progress, token.Token, startAddress, bytesToWrite);
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR while writing vector table to FLASH memory of connected device.", ex);
      }
    }

    public bool isFirmwarecompatibleWithActualSelectedBootloader(out string errorMessage)
    {
      errorMessage = string.Empty;
      string str1 = string.Empty;
      bool flag1 = true;
      if (this.dicBytesToFlashFIRMWARE == null || this.dicBytesToFlashFIRMWARE != null && this.dicBytesToFlashFIRMWARE.Count < 1)
        throw new Exception("Please select a FIRMWARE file first...");
      if (this.dicBytesToFlashBOOTLOADER == null || this.dicBytesToFlashBOOTLOADER != null && this.dicBytesToFlashBOOTLOADER.Count < 1)
        throw new Exception("Please select a BOOTLOADER file first...");
      int num1 = 0;
      foreach (uint key in this.dicBytesToFlashBOOTLOADER.Keys)
        num1 += this.dicBytesToFlashBOOTLOADER[key].Length;
      int num2 = 0;
      foreach (uint key in this.dicBytesToFlashFIRMWARE.Keys)
        num2 += this.dicBytesToFlashFIRMWARE[key].Length;
      int num3 = (int) Math.Ceiling((double) (num2 / this.dicBytesToFlashFIRMWARE.Keys.Count)) + 1;
      ref string local1 = ref errorMessage;
      string str2 = errorMessage;
      uint num4 = this.dicBytesToFlashBOOTLOADER.Keys.First<uint>();
      string str3 = num4.ToString("X8");
      string str4 = str2 + "\rStartaddress of Bootloader: 0x" + str3;
      local1 = str4;
      errorMessage = errorMessage + ", Size: " + num1.ToString() + " Bytes.";
      ref string local2 = ref errorMessage;
      string str5 = errorMessage;
      num4 = this.dicBytesToFlashFIRMWARE.Keys.First<uint>();
      string str6 = num4.ToString("X8");
      string str7 = str5 + "\rStartaddress of Firmware: 0x" + str6;
      local2 = str7;
      errorMessage = errorMessage + ", Size: " + num2.ToString() + " Bytes.";
      bool flag2 = false;
      foreach (uint key1 in this.dicBytesToFlashBOOTLOADER.Keys)
      {
        for (uint key2 = key1; (long) key2 < (long) key1 + (long) num3; ++key2)
        {
          if (this.dicBytesToFlashFIRMWARE.Keys.Contains<uint>(key2))
          {
            byte[] numArray = this.dicBytesToFlashFIRMWARE[key2];
            for (int index = 0; index < numArray.Length; ++index)
            {
              if (numArray[index] != byte.MaxValue && numArray[index] > (byte) 0)
              {
                str1 = string.Empty;
                str1 = str1 + "\rFirmware overlaps with bootloader!!!\rAddress: " + key2.ToString("x4");
                errorMessage = str1;
                return false;
              }
              if (!flag2)
                str1 += "\rFirmware overlaps with bootloader but uses 0x00 or 0xFF !!!";
              flag2 = true;
            }
          }
        }
      }
      errorMessage = str1;
      return flag1;
    }

    public async Task verifyFirmwareCRCAsync(
      ProgressHandler progress,
      CancellationTokenSource cancel)
    {
      this.bIsFirmwareVerifyError = false;
      if (this.blockInfo_Firmware == null || this.blockInfo_Firmware.Count <= 0)
        return;
      bool next = true;
      short step = 0;
      int maxBlockSize = 8192;
      FirmwareBlockInfoClass localFWBIC = (FirmwareBlockInfoClass) null;
      foreach (FirmwareBlockInfoClass fwBIC in this.blockInfo_Firmware)
      {
        next = true;
        do
        {
          if ((long) fwBIC.blockSize > (long) maxBlockSize)
          {
            localFWBIC = new FirmwareBlockInfoClass();
            uint addADRstart = fwBIC.startAddress + (uint) step * (uint) maxBlockSize;
            uint addADRende = (uint) ((int) fwBIC.startAddress + (int) ++step * maxBlockSize - 1);
            localFWBIC.startAddress = addADRstart;
            localFWBIC.endAddress = addADRende;
            if (localFWBIC.endAddress > fwBIC.endAddress)
            {
              localFWBIC.endAddress = fwBIC.endAddress;
              next = false;
            }
            if (localFWBIC.startAddress < localFWBIC.endAddress)
            {
              byte[] locBA = new byte[(int) localFWBIC.endAddress - (int) localFWBIC.startAddress];
              int offset = ((int) step - 1) * maxBlockSize;
              Buffer.BlockCopy((Array) fwBIC.BlockBytes, offset, (Array) locBA, 0, locBA.Length);
              localFWBIC.BlockBytes = locBA;
              localFWBIC.isLocal = true;
              locBA = (byte[]) null;
            }
            else
              break;
          }
          else
          {
            localFWBIC = fwBIC;
            localFWBIC.isLocal = false;
            next = false;
          }
          if (localFWBIC.startAddress > 134217983U && (this.blockInfo_NoVerify == null || this.blockInfo_NoVerify != null && !this.blockInfo_NoVerify.Contains(localFWBIC)))
          {
            ushort crc16 = 0;
            if (!localFWBIC.isLocal)
              crc16 = await this.fwUpdateToolCMDs.VerifyMemoryAsync(progress, cancel.Token, localFWBIC.startAddress, localFWBIC.endAddress);
            else
              crc16 = await this.fwUpdateToolCMDs.VerifyMemoryAsync(progress, cancel.Token, localFWBIC.startAddress, localFWBIC.endAddress - 1U);
            if (this.oFUI != null)
            {
              this.oFUI.setDebugInfo(" ... verify in block: 0x" + localFWBIC.startAddress.ToString("x8") + " - 0x" + localFWBIC.endAddress.ToString("x8"));
              this.oFUI.setDebugInfo(" ... device_CRC: 0x" + crc16.ToString("x4") + " / block_CRC: 0x" + localFWBIC.crc16_CCITT.ToString("x4"));
            }
            if ((int) crc16 != (int) localFWBIC.crc16_CCITT)
            {
              this.bIsFirmwareVerifyError = true;
              int num;
              if (this.oFUI != null)
              {
                bool? nullable = this.oFUI.ignoreError();
                bool flag = false;
                num = nullable.GetValueOrDefault() == flag & nullable.HasValue ? 1 : 0;
              }
              else
                num = 0;
              if (num != 0)
                throw new Exception("verify error in firmware!!!");
            }
          }
          else if (localFWBIC.startAddress > 134217983U && (this.blockInfo_NoVerify == null || this.blockInfo_NoVerify != null && this.blockInfo_NoVerify.Contains(localFWBIC)))
          {
            if (this.oFUI != null)
              this.oFUI.setDebugInfo(" ... NO verify at: 0x" + localFWBIC.startAddress.ToString("x8") + " - 0x" + localFWBIC.endAddress.ToString("x8"));
          }
          else if (this.oFUI != null)
            this.oFUI.setDebugInfo(" NO verify in block: 0x" + localFWBIC.startAddress.ToString("x8") + " - 0x" + localFWBIC.endAddress.ToString("x8"));
        }
        while (next);
      }
      localFWBIC = (FirmwareBlockInfoClass) null;
    }

    public async Task verifyBootloaderCRCAsync(
      ProgressHandler progress,
      CancellationTokenSource cancel)
    {
      this.bIsBootloaderVerifyError = false;
      if (this.blockInfo_Bootloader == null || this.blockInfo_Bootloader.Count <= 0)
        return;
      foreach (FirmwareBlockInfoClass fwBIC in this.blockInfo_Bootloader)
      {
        ushort num = await this.fwUpdateToolCMDs.VerifyMemoryAsync(progress, cancel.Token, fwBIC.startAddress, fwBIC.endAddress);
        uint crc16 = (uint) num;
        if ((int) crc16 != (int) fwBIC.crc16)
        {
          this.bIsBootloaderVerifyError = true;
          if (this.oFUI != null)
            this.oFUI.setErrorInfo("\r ... verify ERROR in block: " + fwBIC.startAddress.ToString("x8") + " - " + fwBIC.endAddress.ToString("x8"));
          int num1;
          if (this.oFUI != null)
          {
            bool? nullable = this.oFUI.ignoreError();
            bool flag = false;
            num1 = nullable.GetValueOrDefault() == flag & nullable.HasValue ? 1 : 0;
          }
          else
            num1 = 0;
          if (num1 != 0)
            throw new Exception("verify error for bootloader!!!");
        }
      }
    }

    public async Task verifyFirmwareAsync(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      AddressRange noCheckRange = null)
    {
      List<AddressRange> adrLST = new List<AddressRange>()
      {
        noCheckRange
      };
      await this.verifyFirmwareAsync(progress, cancel, adrLST);
      adrLST = (List<AddressRange>) null;
    }

    public async Task verifyFirmwareAsync(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      List<AddressRange> noCheckRanges = null)
    {
      int t_out = 0;
      int offset = 0;
      uint pageSize = this.verifyPageSize;
      uint extSize = 16;
      List<byte> byte2Read = new List<byte>();
      int loops = 0;
      uint uiAddress = 0;
      bool isNoCheck = false;
      int actualPageSize = 16;
      int normalPageSize = 16;
      bool isTakeBytes = true;
      bool readDONE = false;
      bool isGAP = false;
      uint oldAddress = 0;
      byte[] oldDicBuf = (byte[]) null;
      int iSplitSize = this.dicBytesToFlashFIRMWARE.Count * 16 / (int) pageSize;
      progress.Split(iSplitSize);
      this.bIsFirmwareVerifyError = false;
      int lineLen = 0;
      foreach (uint address in this.dicBytesToFlashFIRMWARE.Keys)
        lineLen += this.dicBytesToFlashFIRMWARE[address].Length;
      double tempNP = (double) (lineLen / this.dicBytesToFlashFIRMWARE.Keys.Count);
      normalPageSize = (int) Math.Ceiling(tempNP) + 1;
      foreach (uint address in this.dicBytesToFlashFIRMWARE.Keys)
      {
        this.writeNOW = false;
        actualPageSize = this.dicBytesToFlashFIRMWARE[address].Length;
        readDONE = false;
        if (oldDicBuf != null)
        {
          byte2Read.AddRange((IEnumerable<byte>) oldDicBuf);
          uiAddress = oldAddress;
        }
        if (oldAddress > 0U && (long) oldAddress + (long) actualPageSize < (long) address)
        {
          isGAP = true;
          oldDicBuf = new byte[actualPageSize];
        }
        else
        {
          isGAP = false;
          oldDicBuf = (byte[]) null;
        }
        if (address >= 134217728U && address < 134217920U && address <= 134217920U || noCheckRanges != null && this.checkAddressIsInAddressRanges(address, (uint) actualPageSize, noCheckRanges))
        {
          extSize += (uint) actualPageSize;
          isNoCheck = true;
          if (byte2Read.Count == 0)
          {
            oldAddress = address;
            extSize = (uint) normalPageSize;
            if (this.oFUI != null)
            {
              this.oFUI.setDebugInfo(" ... no check on this adress (" + address.ToString("x8") + ")...");
              continue;
            }
            continue;
          }
          oldAddress = address;
          extSize = (uint) byte2Read.Count;
          if (this.oFUI != null)
            this.oFUI.setDebugInfo(" ... no check on this adress (" + address.ToString("x8") + ")...");
        }
        else
        {
          isTakeBytes = true;
          AddressRange noCheckRange = this.getAddressRangeFromRanges(address, noCheckRanges);
          if (noCheckRange != null && address < noCheckRange.StartAddress && (long) address + (long) actualPageSize >= (long) noCheckRange.StartAddress)
            actualPageSize = (int) noCheckRange.StartAddress - (int) address;
          else if (noCheckRange != null && address < noCheckRange.EndAddress && (long) address + (long) actualPageSize > (long) noCheckRange.EndAddress)
          {
            actualPageSize -= (int) ((long) address + (long) actualPageSize - (long) noCheckRange.EndAddress);
            isTakeBytes = false;
          }
          else if (this.BSL_AddressRange != null && address < this.BSL_AddressRange.StartAddress && (long) address + (long) actualPageSize >= (long) this.BSL_AddressRange.StartAddress)
            actualPageSize = (int) this.BSL_AddressRange.StartAddress - (int) address;
          else if (this.BSL_AddressRange != null && address <= this.BSL_AddressRange.EndAddress && (long) address + (long) actualPageSize > (long) this.BSL_AddressRange.EndAddress)
          {
            actualPageSize -= (int) ((long) address + (long) actualPageSize - (long) this.BSL_AddressRange.EndAddress);
            isTakeBytes = false;
          }
          isNoCheck = false;
          noCheckRange = (AddressRange) null;
        }
        if (byte2Read.Count == 0)
          uiAddress = address;
        byte[] dicBuf = this.dicBytesToFlashFIRMWARE[address];
        if (oldDicBuf != null)
          oldDicBuf = dicBuf;
        if (actualPageSize != normalPageSize)
        {
          if (isTakeBytes)
          {
            dicBuf = ((IEnumerable<byte>) this.dicBytesToFlashFIRMWARE[address]).Take<byte>(actualPageSize).ToArray<byte>();
          }
          else
          {
            dicBuf = ((IEnumerable<byte>) this.dicBytesToFlashFIRMWARE[address]).Skip<byte>(actualPageSize).ToArray<byte>();
            uiAddress = (uint) ((ulong) address + (ulong) actualPageSize + 1UL);
          }
          this.writeNOW = true;
        }
        if (dicBuf.Length < normalPageSize)
          offset = normalPageSize - dicBuf.Length;
        if (!isNoCheck && !isGAP)
          byte2Read.AddRange((IEnumerable<byte>) dicBuf);
        if ((long) byte2Read.Count == (long) pageSize || (long) byte2Read.Count + (long) extSize > (long) pageSize || loops == this.dicBytesToFlashFIRMWARE.Count || byte2Read.Count > 0 & isNoCheck || this.writeNOW || byte2Read.Count > 0 & isGAP)
        {
          uint pSize = (uint) byte2Read.Count;
          byte[] pBuffer = new byte[(int) pSize];
          byte[] locBuf = new byte[(int) pSize];
          locBuf = byte2Read.ToArray<byte>();
          if (pSize > 0U)
          {
            while (!readDONE)
            {
              try
              {
                pBuffer = await this.BSL_readFromDeviceAsync(progress, cancel, uiAddress, pSize);
                readDONE = true;
                t_out = 0;
              }
              catch (Exception ex)
              {
                if (t_out > 3)
                {
                  if (this.oFUI != null)
                    this.oFUI.setErrorInfo(" ... reading ERROR (TIMEOUT) ... adr: " + uiAddress.ToString("x8") + " - size: " + pSize.ToString());
                  throw new Exception("Timeout\n" + ex.Message);
                }
                ++t_out;
                if (this.oFUI != null)
                {
                  this.oFUI.setDebugInfo(" ... reading ERROR at address: " + uiAddress.ToString("x8"));
                  this.oFUI.setDebugInfo(" -> read again - Attempt(" + t_out.ToString() + ")!!! ");
                  bool? nullable = this.oFUI.ignoreError();
                  bool flag = true;
                  if (nullable.GetValueOrDefault() == flag & nullable.HasValue)
                  {
                    this.oFUI.setErrorInfo("-E-> verify error at address: " + uiAddress.ToString("x8"));
                    this.oFUI.setErrorInfo("-E-> " + ex.Message);
                  }
                }
                readDONE = false;
              }
              finally
              {
                extSize = (uint) normalPageSize;
                byte2Read.Clear();
              }
            }
            if (!((IEnumerable<byte>) pBuffer).SequenceEqual<byte>((IEnumerable<byte>) locBuf))
            {
              pBuffer = ((IEnumerable<byte>) pBuffer).Take<byte>(pBuffer.Length - offset).ToArray<byte>();
              locBuf = ((IEnumerable<byte>) locBuf).Take<byte>(locBuf.Length - offset).ToArray<byte>();
              if (locBuf.Length != 0 && pBuffer.Length != 0)
              {
                int pos = 0;
                while (pos < locBuf.Length && pos < pBuffer.Length && (int) locBuf[pos] == (int) pBuffer[pos])
                  ++pos;
                bool allNullAndEmpty = this.isByteArrayNULLorEmpty(pBuffer) && this.isByteArrayNULLorEmpty(locBuf);
                if (!allNullAndEmpty && !((IEnumerable<byte>) pBuffer).SequenceEqual<byte>((IEnumerable<byte>) locBuf))
                {
                  if (this.oFUI != null)
                    this.oFUI.setDebugInfo(" ... VERIFY ERROR ... ");
                  bool? nullable;
                  int num1;
                  if (this.oFUI != null)
                  {
                    nullable = this.oFUI.ignoreError();
                    bool flag = true;
                    num1 = nullable.GetValueOrDefault() == flag & nullable.HasValue ? 1 : 0;
                  }
                  else
                    num1 = 0;
                  long num2;
                  if (num1 != 0)
                    this.oFUI.setDebugInfo("-E-> Firmware verify error at address: 0x" + ((long) uiAddress + (long) pos).ToString("x8"));
                  else if (this.oFUI != null)
                  {
                    IZDebugInfo oFui = this.oFUI;
                    num2 = (long) uiAddress + (long) pos;
                    string txt = " VERIFY mismatch at (0x" + num2.ToString("x8") + ") ... ";
                    oFui.setDebugInfo(txt);
                    this.oFUI.setDebugInfo(" Buffer file:   " + ZR_ClassLibrary.Util.ByteArrayToHexString(locBuf));
                    this.oFUI.setDebugInfo(" Buffer device: " + ZR_ClassLibrary.Util.ByteArrayToHexString(pBuffer));
                  }
                  this.bIsFirmwareVerifyError = true;
                  int num3;
                  if (this.oFUI != null)
                  {
                    nullable = this.oFUI.ignoreError();
                    bool flag = true;
                    num3 = !(nullable.GetValueOrDefault() == flag & nullable.HasValue) ? 1 : 0;
                  }
                  else
                    num3 = 0;
                  if (num3 != 0)
                  {
                    num2 = (long) uiAddress + (long) pos;
                    throw new Exception("Firmware verify error at address: 0x" + num2.ToString("x8"));
                  }
                  num2 = (long) uiAddress + (long) pos;
                  throw new Exception("Firmware verify error at address: 0x" + num2.ToString("x8"));
                }
              }
            }
            else if (this.oFUI != null)
              this.oFUI.setDebugInfo(" ... verify of adr: 0x" + uiAddress.ToString("x8") + " - size: " + pSize.ToString() + " was OK.");
            if (isNoCheck)
              offset = 0;
            progress.Report("verifying Adress: 0x" + uiAddress.ToString("x8"));
          }
          pBuffer = (byte[]) null;
          locBuf = (byte[]) null;
        }
        oldAddress = address;
        ++loops;
        dicBuf = (byte[]) null;
      }
      byte2Read = (List<byte>) null;
      oldDicBuf = (byte[]) null;
    }

    private bool isByteArrayNULLorEmpty(byte[] local)
    {
      bool flag = false;
      foreach (byte num in local)
        flag = num == (byte) 0 || num == byte.MaxValue;
      return flag;
    }

    private AddressRange getAddressRangeFromRanges(uint address, List<AddressRange> noCheckRanges)
    {
      if (noCheckRanges != null)
      {
        foreach (AddressRange noCheckRange in noCheckRanges)
        {
          if (address >= noCheckRange.StartAddress && address <= noCheckRange.EndAddress)
            return noCheckRange;
        }
      }
      return (AddressRange) null;
    }

    private bool checkAddressIsInAddressRanges(
      uint address,
      uint actualPageSize,
      List<AddressRange> adrRanges)
    {
      bool flag = false;
      foreach (AddressRange adrRange in adrRanges)
      {
        if (address >= adrRange.StartAddress && address <= adrRange.EndAddress || this.BSL_AddressRange != null && address >= this.BSL_AddressRange.StartAddress && address <= this.BSL_AddressRange.EndAddress)
          return true;
      }
      return flag;
    }

    public async Task verifyBootLoaderAsync(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      AddressRange noCheckRange = null,
      uint pageSize = 512)
    {
      int t_out = 0;
      uint bSize = pageSize;
      List<byte> byte2Write = new List<byte>();
      int loops = 0;
      uint Address = 0;
      uint lastAddress = this.BSL_AddressRange.EndAddress;
      Stopwatch watch = new Stopwatch();
      Stopwatch watchDur = new Stopwatch();
      watch.Start();
      foreach (uint adress in this.dicBytesToFlashBOOTLOADER.Keys)
      {
        if (noCheckRange == null || adress < noCheckRange.StartAddress && adress > noCheckRange.EndAddress)
        {
          watchDur.Restart();
          if (byte2Write.Count == 0)
            Address = adress;
          byte[] dicBuf = this.dicBytesToFlashBOOTLOADER[adress];
          byte2Write.AddRange((IEnumerable<byte>) dicBuf);
          if ((long) byte2Write.Count == (long) pageSize || loops == this.dicBytesToFlashBOOTLOADER.Count || lastAddress <= Address + pageSize)
          {
            bSize = (uint) byte2Write.Count;
            byte[] pBuffer = new byte[(int) bSize];
            byte[] locBuf = new byte[(int) bSize];
            locBuf = byte2Write.ToArray<byte>();
            bool? nullable;
            try
            {
              pBuffer = await this.fwUpdateToolCMDs.ReadMemoryAsync(progress, cancel.Token, Address, bSize);
            }
            catch (Exception ex)
            {
              if (t_out > 3)
              {
                int num;
                if (this.oFUI != null)
                {
                  nullable = this.oFUI.ignoreError();
                  bool flag = true;
                  num = !(nullable.GetValueOrDefault() == flag & nullable.HasValue) ? 1 : 0;
                }
                else
                  num = 0;
                if (num != 0)
                  throw new Exception("Timeout\n" + ex.Message);
              }
              ++t_out;
              if (this.oFUI != null)
              {
                this.oFUI.setErrorInfo("-E-> verify error at address: " + Address.ToString("x8"));
                this.oFUI.setErrorInfo("-E-> read attempt: " + t_out.ToString());
              }
            }
            if (!((IEnumerable<byte>) pBuffer).SequenceEqual<byte>((IEnumerable<byte>) locBuf))
            {
              int num;
              if (this.oFUI != null)
              {
                nullable = this.oFUI.ignoreError();
                bool flag = true;
                num = !(nullable.GetValueOrDefault() == flag & nullable.HasValue) ? 1 : 0;
              }
              else
                num = 0;
              if (num != 0)
                throw new Exception("Bootloader verify error at address: " + Address.ToString("x8"));
              this.oFUI.setErrorInfo("-E-> verify mismatch at address: " + Address.ToString("x8"));
            }
            else if (this.oFUI != null)
              this.oFUI.setDebugInfo("... verify at address: " + Address.ToString("x8") + " / Bytes: " + bSize.ToString() + " .. OK.");
            progress.Report("verifying Adress: " + Address.ToString("x8"));
            if (this.oFUI != null)
              this.oFUI.setDebugInfo("verify time: " + watchDur.Elapsed.TotalSeconds.ToString("000.00") + " sec.");
            byte2Write.Clear();
            pBuffer = (byte[]) null;
            locBuf = (byte[]) null;
          }
          ++loops;
          dicBuf = (byte[]) null;
        }
      }
      if (this.oFUI == null)
      {
        byte2Write = (List<byte>) null;
        watch = (Stopwatch) null;
        watchDur = (Stopwatch) null;
      }
      else
      {
        this.oFUI.setDebugInfo("verify complete time: " + watch.Elapsed.TotalSeconds.ToString("000.00") + " sec.");
        byte2Write = (List<byte>) null;
        watch = (Stopwatch) null;
        watchDur = (Stopwatch) null;
      }
    }

    public async Task writeBootLoaderToDevice128kb(
      ProgressHandler progress,
      CancellationToken token)
    {
      uint startAddress = 0;
      uint iPageSize = 128;
      int offset = 0;
      int loops = 0;
      byte[] bytesToWrite = new byte[(int) iPageSize];
      byte[] byteBlock = new byte[0];
      try
      {
        if (!this.isBootLoaderFile)
          throw new Exception("No BOOTLOADER file was loaded !!!");
        int iSplitSize = this.dicBytesToFlashBOOTLOADER.Count * 16 / (int) iPageSize * 2;
        progress.Split(iSplitSize);
        Stopwatch watch = new Stopwatch();
        Stopwatch watchDur = new Stopwatch();
        watch.Start();
        foreach (uint address in this.dicBytesToFlashBOOTLOADER.Keys)
        {
          watchDur.Restart();
          if (offset == 0)
            startAddress = address;
          Buffer.BlockCopy((Array) this.dicBytesToFlashBOOTLOADER[address], 0, (Array) bytesToWrite, offset, this.dicBytesToFlashBOOTLOADER[address].Length);
          offset += this.dicBytesToFlashBOOTLOADER[address].Length;
          ++loops;
          if ((long) offset == (long) iPageSize || this.dicBytesToFlashBOOTLOADER.Count == loops)
          {
            byte[] bootBytes = new byte[offset];
            Buffer.BlockCopy((Array) bytesToWrite, 0, (Array) bootBytes, 0, offset);
            string debugInfo = "Write at adress (" + startAddress.ToString("x8") + ") - " + bootBytes.Length.ToString() + " Bytes in " + watch.Elapsed.TotalSeconds.ToString("000.00") + " sec.";
            progress.Report(debugInfo);
            await this.fwUpdateToolCMDs.WriteMemoryAsync(progress, token, startAddress, bootBytes);
            if (this.oFUI != null)
              this.oFUI.setDebugInfo("writing BOOTLOADER ... (" + startAddress.ToString("x8") + " - " + ((long) startAddress + (long) bootBytes.Length).ToString("x8") + ") - time:" + watchDur.Elapsed.TotalSeconds.ToString("000.00") + " sec.");
            offset = 0;
            bytesToWrite = new byte[(int) iPageSize];
            bootBytes = (byte[]) null;
            debugInfo = (string) null;
          }
        }
        if (this.oFUI != null)
          this.oFUI.setDebugInfo("writing BOOTLOADER took" + watch.Elapsed.TotalSeconds.ToString("000.00") + " sec.");
        watchDur.Stop();
        watch.Stop();
        watch = (Stopwatch) null;
        watchDur = (Stopwatch) null;
        bytesToWrite = (byte[]) null;
        byteBlock = (byte[]) null;
      }
      catch (Exception ex)
      {
        if (this.oFUI != null)
          this.oFUI.setErrorInfo("-E-> verify error at address: " + startAddress.ToString("x8"));
        int num;
        if (this.oFUI != null)
        {
          bool? nullable = this.oFUI.ignoreError();
          bool flag = true;
          num = !(nullable.GetValueOrDefault() == flag & nullable.HasValue) ? 1 : 0;
        }
        else
          num = 0;
        if (num == 0)
        {
          bytesToWrite = (byte[]) null;
          byteBlock = (byte[]) null;
        }
        else
          throw new Exception("writeBootLoaderToDevice128kb:\nStartaddress: " + startAddress.ToString("x8") + "\nBytes: " + ZR_ClassLibrary.Util.ByteArrayToHexString(bytesToWrite) + "\nMessage: " + ex.Message);
      }
    }

    public async Task doSystemResetOverRegister(
      ProgressHandler progress,
      CancellationTokenSource cancel)
    {
      uint startAdress = 3758157068;
      byte[] value = BitConverter.GetBytes(100270084);
      await this.fwUpdateToolCMDs.WriteMemoryAsync(progress, cancel.Token, startAdress, value);
      value = (byte[]) null;
    }

    public async Task doSystemResetFunction(
      ProgressHandler progress,
      CancellationTokenSource cancel)
    {
      await this.fwUpdateToolCMDs.ResetDeviceAsync(progress, cancel.Token);
      this.isReady2EraseFW = true;
    }

    public long revealMapIDForBSLFirmwareFromDatabase(out string allowedFW, uint firmwareVersion = 0)
    {
      long num = 0;
      allowedFW = string.Empty;
      try
      {
        using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          string str = "SELECT * from ProgFiles " + (firmwareVersion > 0U ? "where (FirmwareVersion = " + firmwareVersion.ToString() + ") and HardwareName in ('Bootloader') " : "where HardwareName in ('Bootloader') ") + " order by FirmwareVersion desc";
          DbDataAdapter dataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(str.ToString(), newConnection);
          HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
          dataAdapter.Fill((DataTable) progFilesDataTable);
          HardwareTypeTables.HardwareOverviewDataTable overviewDataTable = new HardwareTypeTables.HardwareOverviewDataTable();
          if (progFilesDataTable.Count > 0)
          {
            for (int index = 0; index < 1; ++index)
            {
              num = (long) progFilesDataTable[index].MapID;
              if (!progFilesDataTable[index].IsFirmwareDependenciesNull())
                allowedFW = progFilesDataTable[index].FirmwareDependencies;
            }
          }
        }
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR while revealing mapid from database... ", ex);
      }
      return num;
    }

    public long revealHardwareTypeMapIDForBSLFirmwareFromDatabase(
      out string allowedFW,
      uint firmwareVersion = 0)
    {
      long num = 0;
      allowedFW = string.Empty;
      try
      {
        using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          string str = "SELECT * from ProgFiles " + (firmwareVersion > 0U ? "where (FirmwareVersion = " + firmwareVersion.ToString() + ") and HardwareName in ('Bootloader') " : "where HardwareName in ('Bootloader') ") + " order by FirmwareVersion desc";
          DbDataAdapter dataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(str.ToString(), newConnection);
          HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
          dataAdapter.Fill((DataTable) progFilesDataTable);
          HardwareTypeTables.HardwareOverviewDataTable overviewDataTable = new HardwareTypeTables.HardwareOverviewDataTable();
          if (progFilesDataTable.Count > 0)
          {
            for (int index = 0; index < 1; ++index)
            {
              num = (long) progFilesDataTable[index].HardwareTypeMapID;
              if (!progFilesDataTable[index].IsFirmwareDependenciesNull())
                allowedFW = progFilesDataTable[index].FirmwareDependencies;
            }
          }
        }
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR while revealing mapid from database... ", ex);
      }
      return num;
    }

    public uint revealMapIDForHardwareTypeFromDatabase(uint HardwareTypID)
    {
      string empty = string.Empty;
      if (HardwareTypID == 0U)
        throw new Exception("HardwareName is not set correctly.");
      uint hardwareTypeTable;
      try
      {
        hardwareTypeTable = HardwareTypeSupport.GetMapIDForHardwareTypeFromHardwareTypeTable(HardwareTypID);
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR while loading BootLoader data from database", ex);
      }
      return hardwareTypeTable;
    }

    public List<FirmwareReleaseInfo> revealAllPossibleFirmwareForBootloaderFromDatabase(
      uint firmwareVersionBSL = 0)
    {
      return this.revealLatestFirmwareForBootloaderFromDatabase(firmwareVersionBSL, false, true);
    }

    public List<FirmwareReleaseInfo> revealLatestFirmwareForBootloaderFromDatabase(
      uint firmwareVersionBSL = 0,
      bool latest = true,
      bool allFiles = false)
    {
      if (firmwareVersionBSL == 0U)
        throw new Exception("FirmwareVersion is not set correctly");
      List<FirmwareReleaseInfo> firmwareReleaseInfoList = new List<FirmwareReleaseInfo>();
      DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection();
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.Append("SELECT * from Progfiles WHERE FirmwareVersion = " + firmwareVersionBSL.ToString());
      DbDataAdapter dataAdapter1 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
      HardwareTypeTables.ProgFilesDataTable progFilesDataTable1 = new HardwareTypeTables.ProgFilesDataTable();
      dataAdapter1.Fill((DataTable) progFilesDataTable1);
      string str1 = progFilesDataTable1[0].FirmwareDependencies.Replace(';', ',');
      string str2 = string.Empty;
      string str3 = str1;
      char[] chArray = new char[1]{ ',' };
      foreach (string s in ((IEnumerable<string>) str3.Split(chArray)).ToList<string>())
      {
        uint result = 0;
        if (!string.IsNullOrEmpty(s))
        {
          uint.TryParse(s, NumberStyles.HexNumber, (IFormatProvider) null, out result);
          str2 = str2 + result.ToString() + ",";
        }
      }
      stringBuilder.Clear();
      string str4 = str2.Substring(0, str2.Length - 1);
      stringBuilder.Append(" SELECT * from Progfiles ");
      stringBuilder.Append(" WHERE ProgFileName IS NOT NULL ");
      if (!allFiles)
      {
        stringBuilder.Append(" and ( ReleasedName LIKE '%Latest%' ");
        if (!latest)
          stringBuilder.Append("  OR ReleasedName lIKE '%Released%' ");
        stringBuilder.Append(" ) ");
      }
      stringBuilder.Append(" and FirmwareVersion IN (" + str4 + ") ORDER BY mapid desc");
      DbDataAdapter dataAdapter2 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
      HardwareTypeTables.ProgFilesDataTable progFilesDataTable2 = new HardwareTypeTables.ProgFilesDataTable();
      dataAdapter2.Fill((DataTable) progFilesDataTable2);
      foreach (HardwareTypeTables.ProgFilesRow progFilesRow in (TypedTableBase<HardwareTypeTables.ProgFilesRow>) progFilesDataTable2)
      {
        string str5 = new FirmwareVersion((uint) progFilesRow.FirmwareVersion).ToString();
        string str6 = (string) null;
        if (!progFilesRow.IsReleaseCommentsNull())
          str6 = progFilesRow.ReleaseComments;
        firmwareReleaseInfoList.Add(new FirmwareReleaseInfo()
        {
          MapID = progFilesRow.MapID,
          ProgFilName = progFilesRow.ProgFileName,
          ReleaseText = progFilesRow.ReleasedName,
          FirmwareVersion = progFilesRow.FirmwareVersion,
          FirmwareVersionString = str5,
          ReleaseDescription = str6
        });
      }
      return firmwareReleaseInfoList;
    }

    public SortedList<uint, HardwareTypeTables.ProgFilesRow> revealAllPossibleFirmwareFromDatabase(
      uint firmwareVersion = 0,
      string hardwareName = "",
      string allPossibleFW4BSL = "")
    {
      uint num1 = firmwareVersion != 0U ? (uint) (ushort) (firmwareVersion >> 12 & 4095U) : 0U;
      SortedList<uint, HardwareTypeTables.ProgFilesRow> sortedList = new SortedList<uint, HardwareTypeTables.ProgFilesRow>((IComparer<uint>) new DescComparer<uint>());
      FirmwareVersion firmwareVersion1 = new FirmwareVersion(firmwareVersion);
      string str1 = string.Empty;
      if (!string.IsNullOrEmpty(allPossibleFW4BSL))
      {
        int num2 = 0;
        string str2 = allPossibleFW4BSL;
        char[] chArray = new char[1]{ ';' };
        foreach (string str3 in ((IEnumerable<string>) str2.Split(chArray)).ToList<string>())
        {
          if (!string.IsNullOrEmpty(str3.Trim()))
          {
            uint uint32 = Convert.ToUInt32(str3.Trim(), 16);
            str1 = str1 + (num2 == 0 ? "" : ", ") + uint32.ToString();
            ++num2;
          }
        }
      }
      try
      {
        using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.Append("SELECT MapID, ProgFileName, options,sourceinfo, hardwarename, hardwaretypemapid, firmwareversion, releasedname,compatibleoverwritegroups, releasecomments, firmwaredependencies FROM Progfiles WHERE HardwareName not IN ('Bootloader') AND HexText IS NOT NULL AND ProgFileName IS NOT NULL " + (string.IsNullOrEmpty(str1) ? " " : " AND FirmwareVersion IN (" + str1 + ") ") + " ORDER BY MapID, FirmwareVersion DESC");
          DbDataAdapter dataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
          HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
          dataAdapter.Fill((DataTable) progFilesDataTable);
          List<FirmwareReleaseInfo> firmwareReleaseInfoList = new List<FirmwareReleaseInfo>();
          if (progFilesDataTable.Count > 0)
          {
            int num3 = 0;
            bool flag = true;
            while (flag)
            {
              for (int index = 0; index < progFilesDataTable.Count; ++index)
              {
                HardwareTypeTables.ProgFilesRow progFilesRow = progFilesDataTable.NewProgFilesRow();
                progFilesRow.HardwareName = progFilesDataTable[index].HardwareName;
                if (string.IsNullOrEmpty(hardwareName) || progFilesRow.HardwareName.Contains(hardwareName))
                {
                  progFilesRow.FirmwareVersion = progFilesDataTable[index].FirmwareVersion;
                  progFilesRow.HardwareTypeMapID = progFilesDataTable[index].HardwareTypeMapID;
                  progFilesRow.MapID = progFilesDataTable[index].MapID;
                  if (!progFilesDataTable[index].IsFirmwareDependenciesNull())
                    progFilesRow.FirmwareDependencies = progFilesDataTable[index].FirmwareDependencies;
                  if (!progFilesDataTable[index].IsProgFileNameNull())
                    progFilesRow.ProgFileName = progFilesDataTable[index].ProgFileName;
                  if (!progFilesDataTable[index].IsOptionsNull())
                    progFilesRow.Options = progFilesDataTable[index].Options;
                  if (!progFilesDataTable[index].IsReleasedNameNull())
                    progFilesRow.ReleasedName = progFilesDataTable[index].ReleasedName;
                  if (!progFilesDataTable[index].IsReleaseCommentsNull())
                    progFilesRow.ReleaseComments = progFilesDataTable[index].ReleaseComments;
                  if (!sortedList.ContainsKey((uint) index))
                    sortedList.Add((uint) index, progFilesRow);
                }
              }
              flag = sortedList.Count == 0;
              if (flag && num3 < 2)
                hardwareName = string.Empty;
              else if (flag && num3 >= 2)
                flag = false;
              ++num3;
            }
          }
        }
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR while loading firmware data from database", ex);
      }
      return sortedList;
    }

    public List<FirmwareReleaseInfo> revealAllPossibleFirmwareFromDatabase(uint hardwareTypeMapID)
    {
      List<FirmwareReleaseInfo> firmwareReleaseInfoList = new List<FirmwareReleaseInfo>();
      List<FirmwareReleaseInfo> infoForHardwareType;
      try
      {
        infoForHardwareType = HardwareTypeSupport.GetAllReleasedFirmwareReleaseInfoForHardwareType((int) hardwareTypeMapID);
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR while loading firmware data from database", ex);
      }
      return infoForHardwareType;
    }

    public SortedList<uint, HardwareTypeTables.ProgFilesRow> revealLatestBootloaderForVersionFromDatabase(
      uint firmwareVersion = 0,
      string hardwareName = "Bootloader")
    {
      return this.revealAllPossibleBootloaderFromDatabase(firmwareVersion, hardwareName, true);
    }

    public SortedList<uint, HardwareTypeTables.ProgFilesRow> revealAllPossibleBootloaderFromDatabase(
      uint firmwareVersion = 0,
      string hardwareName = "Bootloader",
      bool getBootloader = false)
    {
      if (firmwareVersion == 0U)
        throw new Exception("No Device connected, please connect to a device and read Version first !!!");
      if (string.IsNullOrEmpty(hardwareName))
        throw new Exception("HardwareName is not set correctly.");
      this.availBootloaderProgFiles = new SortedList<uint, HardwareTypeTables.ProgFilesRow>();
      ushort num = (ushort) (firmwareVersion & 4095U);
      try
      {
        using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.Append("SELECT * from Progfiles  where HardwareName like '%" + hardwareName + "%' order by FirmwareVersion desc");
          DbDataAdapter dataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
          HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
          dataAdapter.Fill((DataTable) progFilesDataTable);
          if (progFilesDataTable.Count > 0)
          {
            for (int index = 0; index < progFilesDataTable.Count; ++index)
            {
              HardwareTypeTables.ProgFilesRow progFilesRow = progFilesDataTable.NewProgFilesRow();
              progFilesRow.HardwareName = progFilesDataTable[index].HardwareName;
              progFilesRow.FirmwareVersion = progFilesDataTable[index].FirmwareVersion;
              progFilesRow.HardwareTypeMapID = progFilesDataTable[index].HardwareTypeMapID;
              progFilesRow.MapID = progFilesDataTable[index].MapID;
              if (!progFilesDataTable[index].IsProgFileNameNull())
                progFilesRow.ProgFileName = progFilesDataTable[index].ProgFileName;
              if (!progFilesDataTable[index].IsOptionsNull())
                progFilesRow.Options = progFilesDataTable[index].Options;
              if (!progFilesDataTable[index].IsHexTextNull())
                progFilesRow.HexText = progFilesDataTable[index].HexText;
              if (!progFilesDataTable[index].IsFirmwareDependenciesNull())
                progFilesRow.FirmwareDependencies = progFilesDataTable[index].FirmwareDependencies;
              string str = firmwareVersion.ToString("x8");
              if (!getBootloader)
              {
                if (!progFilesRow.IsFirmwareDependenciesNull() && progFilesRow.FirmwareDependencies.Contains(str))
                  this.availBootloaderProgFiles.Add((uint) index, progFilesRow);
              }
              else if ((long) progFilesRow.FirmwareVersion == (long) firmwareVersion)
                this.availBootloaderProgFiles.Add((uint) index, progFilesRow);
            }
          }
        }
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR while loading BootLoader data from database", ex);
      }
      return this.availBootloaderProgFiles;
    }

    public SortedList<uint, FirmwareReleaseInfo> revealAllBootloaderFromDatabase(uint FWVersion = 0)
    {
      if (FWVersion == 0U)
        throw new Exception("Firmware is not set correctly.");
      SortedList<uint, FirmwareReleaseInfo> sortedList = new SortedList<uint, FirmwareReleaseInfo>();
      List<FirmwareReleaseInfo> firmwareReleaseInfoList = new List<FirmwareReleaseInfo>();
      try
      {
        foreach (FirmwareReleaseInfo firmwareReleaseInfo in HardwareTypeSupport.GetBslFirmwareReleaseInfosForFirmwareVersion(FWVersion))
          sortedList.Add((uint) firmwareReleaseInfo.MapID, firmwareReleaseInfo);
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR while loading BootLoader data from database", ex);
      }
      return sortedList;
    }

    public SortedDictionary<uint, byte[]> getDictionaryWithFirmware(bool getBootLoaderFirmware = false)
    {
      return getBootLoaderFirmware ? this.dicBytesToFlashBOOTLOADER : this.dicBytesToFlashFIRMWARE;
    }

    public bool loadFirmwareFromString(string locString, bool checkForBootloader = true)
    {
      try
      {
        this.strFirmwareFile = locString;
        this.dicBytesToFlashFIRMWARE = ProgFileTools.parseINTEL_HEX_file(this.strFirmwareFile);
        if (checkForBootloader)
        {
          if (!this.checkForBootLoaderFW(this.dicBytesToFlashFIRMWARE))
            this.blockInfo_Firmware = this.getBlocksFromFirmware();
          else
            this.blockInfo_Bootloader = this.getBlocksFromFirmware(true);
        }
      }
      catch (Exception ex)
      {
        return false;
      }
      return true;
    }

    public bool loadFirmwareFromFile(string FileName, bool checkForBootloader = true)
    {
      this.strFileName = FileName;
      try
      {
        TextReader textReader = (TextReader) File.OpenText(this.strFileName);
        this.strFirmwareFile = textReader.ReadToEnd();
        this.dicBytesToFlashFIRMWARE = ProgFileTools.parseINTEL_HEX_file(this.strFirmwareFile);
        if (checkForBootloader)
        {
          if (!this.checkForBootLoaderFW(this.dicBytesToFlashFIRMWARE))
            this.blockInfo_Firmware = this.getBlocksFromFirmware();
          else
            this.blockInfo_Bootloader = this.getBlocksFromFirmware(true);
        }
        textReader.Close();
        return true;
      }
      catch (Exception ex)
      {
        return false;
      }
    }

    public string loadFirmwareFromFile(bool checkForBootloader = true)
    {
      OpenFileDialog openFileDialog = new OpenFileDialog();
      openFileDialog.Filter = "HEX files (*.hex)|*.hex|txt files (*.txt)|*.txt|All files (*.*)|*.*";
      bool? nullable = openFileDialog.ShowDialog();
      bool flag = true;
      if (!(nullable.GetValueOrDefault() == flag & nullable.HasValue))
        return (string) null;
      this.strFileName = openFileDialog.FileName;
      if (this.strFileName == string.Empty)
        return (string) null;
      try
      {
        TextReader textReader = (TextReader) File.OpenText(this.strFileName);
        this.strFirmwareFile = textReader.ReadToEnd();
        this.dicBytesToFlashFIRMWARE = ProgFileTools.parseINTEL_HEX_file(this.strFirmwareFile);
        if (checkForBootloader)
        {
          if (!this.checkForBootLoaderFW(this.dicBytesToFlashFIRMWARE))
            this.blockInfo_Firmware = this.getBlocksFromFirmware();
          else
            this.blockInfo_Bootloader = this.getBlocksFromFirmware(true);
        }
        textReader.Close();
        return this.strFileName;
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR while reading firmware file", ex);
      }
    }

    public string loadFirmwareFromFileToMerge()
    {
      OpenFileDialog openFileDialog = new OpenFileDialog();
      openFileDialog.Filter = "HEX files (*.hex)|*.hex|txt files (*.txt)|*.txt|All files (*.*)|*.*";
      bool? nullable = openFileDialog.ShowDialog();
      bool flag = true;
      if (!(nullable.GetValueOrDefault() == flag & nullable.HasValue))
        return (string) null;
      string fileName = openFileDialog.FileName;
      if (fileName == string.Empty)
        return (string) null;
      try
      {
        TextReader textReader = (TextReader) File.OpenText(fileName);
        this.dicBytesToFlashMERGE = ProgFileTools.parseINTEL_HEX_file(textReader.ReadToEnd());
        textReader.Close();
        return fileName;
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR while reading firmware file", ex);
      }
    }

    public void loadFirmwareFileFromDB(uint mapID = 0, bool parseFile = true, AddressRange excludeAddresses = null)
    {
      this.firmwareFileData = mapID != 0U ? HardwareTypeSupport.GetFirmwareData(mapID).ProgrammerFileAsString : throw new Exception("MapID is not set correct for loading from DataBase...");
      if (!parseFile)
        return;
      this.dicBytesToFlashFIRMWARE = ProgFileTools.parseINTEL_HEX_file(this.firmwareFileData);
      if (!this.checkForBootLoaderFW(this.dicBytesToFlashFIRMWARE))
        this.blockInfo_Firmware = this.getBlocksFromFirmware(excludeAddresses: excludeAddresses);
      else
        this.blockInfo_Bootloader = this.getBlocksFromFirmware(true);
    }

    public string loadFirmwareFileFromDBasString(uint mapID = 0)
    {
      return mapID != 0U ? HardwareTypeSupport.GetFirmwareData(mapID).ProgrammerFileAsString : throw new Exception("MapID is not set correct for loading from DataBase...");
    }

    public SortedDictionary<uint, byte[]> loadFirmwareFileFromDBasSortedDictionary(
      uint mapID = 0,
      bool parseFile = true)
    {
      SortedDictionary<uint, byte[]> sortedDictionary = new SortedDictionary<uint, byte[]>();
      FirmwareData firmwareData = mapID != 0U ? HardwareTypeSupport.GetFirmwareData(mapID) : throw new Exception("MapID is not set correct for loading from DataBase...");
      if (parseFile)
        sortedDictionary = ProgFileTools.parseINTEL_HEX_file(firmwareData.ProgrammerFileAsString);
      return sortedDictionary;
    }

    public void setLoadedBootloader(FirmwareData bootloaderFWData)
    {
      this.dataOfBootloader = bootloaderFWData;
    }

    public FirmwareData getLoadedBootloader()
    {
      if (this.dataOfBootloader != null)
      {
        this.dicBytesToFlashBOOTLOADER = ProgFileTools.parseINTEL_HEX_file(this.dataOfBootloader.ProgrammerFileAsString);
        if (!this.checkForBootLoaderFW(this.dicBytesToFlashBOOTLOADER))
          this.blockInfo_Firmware = this.getBlocksFromFirmware();
        else
          this.blockInfo_Bootloader = this.getBlocksFromFirmware(true);
      }
      return this.dataOfBootloader;
    }

    public FirmwareData loadNewestBootloaderFileFromDB(uint actualFWVersion, uint newFWVersion)
    {
      if (actualFWVersion == 0U)
        throw new Exception("Actual Firmware Version is not set correct, please connect to a device first...");
      this.dataOfBootloader = newFWVersion != 0U ? HardwareTypeSupport.GetNewestBSLFromProgFilesTable(actualFWVersion, newFWVersion) : throw new Exception("New Firmware Version is not set correct, please select a correct firmware file first...");
      if (this.dataOfBootloader != null)
      {
        this.dicBytesToFlashBOOTLOADER = ProgFileTools.parseINTEL_HEX_file(this.dataOfBootloader.ProgrammerFileAsString);
        if (!this.checkForBootLoaderFW(this.dicBytesToFlashBOOTLOADER))
        {
          this.blockInfo_Firmware = this.getBlocksFromFirmware();
        }
        else
        {
          this.blockInfo_Bootloader = this.getBlocksFromFirmware(true);
          this.ListOfLoadedBootloader.Add(this.dataOfBootloader);
        }
      }
      return this.dataOfBootloader;
    }

    public string loadThatBootloaderFileFromDB(uint mapID, bool store = false)
    {
      bool flag = false;
      if (mapID <= 0U)
        throw new Exception("No BootLoader selected, please select BSL first ...");
      if (this.ListOfLoadedBootloader.Count > 0)
      {
        foreach (FirmwareData firmwareData in this.ListOfLoadedBootloader)
        {
          if (firmwareData.Options.Contains(new KeyValuePair<string, string>("MapID", mapID.ToString())))
          {
            this.dataOfBootloader = firmwareData;
            flag = true;
          }
        }
      }
      if (!flag)
      {
        this.dataOfBootloader = HardwareTypeSupport.GetFirmwareData(mapID);
        if (this.dataOfBootloader == null)
          throw new Exception("Error while loading bootloader file from database.");
      }
      this.dicBytesToFlashBOOTLOADER = ProgFileTools.parseINTEL_HEX_file(this.dataOfBootloader.ProgrammerFileAsString);
      if (!this.checkForBootLoaderFW(this.dicBytesToFlashBOOTLOADER))
      {
        this.blockInfo_Firmware = this.getBlocksFromFirmware();
      }
      else
      {
        this.blockInfo_Bootloader = this.getBlocksFromFirmware(true);
        if (!flag)
          this.ListOfLoadedBootloader.Add(this.dataOfBootloader);
      }
      return this.dataOfBootloader.ProgFileName;
    }

    public bool loadBootloaderFromFile(string FileName)
    {
      this.strFileName = FileName;
      try
      {
        TextReader textReader = (TextReader) File.OpenText(this.strFileName);
        this.strBootloaderFile = textReader.ReadToEnd();
        this.dicBytesToFlashBOOTLOADER = ProgFileTools.parseINTEL_HEX_file(this.strBootloaderFile);
        if (!this.checkForBootLoaderFW(this.dicBytesToFlashBOOTLOADER))
          this.blockInfo_Firmware = this.getBlocksFromFirmware();
        else
          this.blockInfo_Bootloader = this.getBlocksFromFirmware(true);
        textReader.Close();
        return true;
      }
      catch (Exception ex)
      {
        return false;
      }
    }

    public void loadBootloaderFromFile()
    {
      OpenFileDialog openFileDialog = new OpenFileDialog();
      openFileDialog.Filter = "HEX files (*.hex)|*.hex|txt files (*.txt)|*.txt|All files (*.*)|*.*";
      bool? nullable = openFileDialog.ShowDialog();
      bool flag = true;
      if (!(nullable.GetValueOrDefault() == flag & nullable.HasValue))
        return;
      this.strFileName = openFileDialog.FileName;
      if (this.strFileName == string.Empty)
        return;
      try
      {
        TextReader textReader = (TextReader) File.OpenText(this.strFileName);
        this.strBootloaderFile = textReader.ReadToEnd();
        this.dicBytesToFlashBOOTLOADER = ProgFileTools.parseINTEL_HEX_file(this.strBootloaderFile);
        if (!this.checkForBootLoaderFW(this.dicBytesToFlashBOOTLOADER))
          this.blockInfo_Firmware = this.getBlocksFromFirmware();
        else
          this.blockInfo_Bootloader = this.getBlocksFromFirmware(true);
        textReader.Close();
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR while reading firmware file", ex);
      }
    }

    public bool loadBootloaderFromstring(string locString)
    {
      try
      {
        this.strBootloaderFile = locString;
        this.dicBytesToFlashBOOTLOADER = ProgFileTools.parseINTEL_HEX_file(this.strBootloaderFile);
        if (!this.checkForBootLoaderFW(this.dicBytesToFlashBOOTLOADER))
          this.blockInfo_Firmware = this.getBlocksFromFirmware();
        else
          this.blockInfo_Bootloader = this.getBlocksFromFirmware(true);
      }
      catch (Exception ex)
      {
        return false;
      }
      return true;
    }

    public bool checkBootloaderFileName(string name)
    {
      if (string.IsNullOrEmpty(name) || !name.Contains("_V0x"))
        return false;
      try
      {
        this.BSLversion = new FirmwareVersion(this.getFirmwareVersionFromFilename(name));
        return true;
      }
      catch
      {
        return false;
      }
    }

    public uint getFirmwareVersionFromFilename(string filename)
    {
      if (string.IsNullOrEmpty(filename) || !filename.Contains("_V0x"))
        return 0;
      string str = filename.Substring(filename.IndexOf("_V0x") + 2, 10);
      try
      {
        return Convert.ToUInt32(str, 16);
      }
      catch
      {
        return 0;
      }
    }

    public bool checkForBootLoaderFW(SortedDictionary<uint, byte[]> dicFlashBytes)
    {
      int num1 = 0;
      bool flag = false;
      uint startAddress = 0;
      uint num2 = 0;
      this.dicBytesToFlash = dicFlashBytes;
      foreach (uint key in this.dicBytesToFlash.Keys)
      {
        if (!flag)
        {
          if (num1 == 0 && (key >= 134217984U && key < 134742016U || key >= 536870912U))
          {
            this.iBootLoaderStartAddress = key;
            this.isBootLoaderFile = true;
            this.isFirmWareFile = false;
          }
          else if (num1 == 0)
          {
            startAddress = key;
            this.isFirmWareFile = true;
            this.isBootLoaderFile = false;
          }
          flag = true;
          ++num1;
        }
        else if (flag && !this.isFirmWareFile)
        {
          if (this.isBootLoaderFile)
            this.iBootLoaderEndAddress = key + (uint) this.dicBytesToFlashBOOTLOADER[key].Length;
          if (this.isFirmWareFile)
            num2 = key + (uint) this.dicBytesToFlashFIRMWARE[key].Length;
        }
      }
      if (this.isBootLoaderFile)
        this.BSL_AddressRange = new AddressRange(this.iBootLoaderStartAddress, this.iBootLoaderEndAddress - this.iBootLoaderStartAddress);
      else
        this.FW_AddressRange = new AddressRange(startAddress, num2 - startAddress);
      return this.isBootLoaderFile;
    }

    public async Task<byte[]> BSL_readFromDeviceAsync(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      uint startAddress,
      uint size)
    {
      byte[] numArray = await this.BTLFunctions.readMemoryAsync(progress, cancel, startAddress, size);
      return numArray;
    }

    public async Task<uint> BSL_getVersion(ProgressHandler progress, CancellationTokenSource cancel)
    {
      byte[] baVersion = await this.BTLFunctions.getVersionAsync(progress, cancel);
      this.isReady2EraseFW = true;
      this.isBSLrunning = true;
      uint fw = BitConverter.ToUInt32(baVersion, 0);
      this.BSLversion = new FirmwareVersion(fw);
      uint version = fw;
      baVersion = (byte[]) null;
      return version;
    }

    public async Task<ushort> BSL_getFLASHSize(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      bool readFromBSL = true)
    {
      uint adrFlashSize = 536346748;
      byte[] baSize = new byte[2];
      if (readFromBSL)
        baSize = await this.BTLFunctions.readMemoryAsync(progress, cancel, adrFlashSize, 2U);
      else
        baSize = await this.fwUpdateToolCMDs.ReadMemoryAsync(progress, cancel.Token, adrFlashSize, 2U);
      ushort uint16 = BitConverter.ToUInt16(baSize, 0);
      baSize = (byte[]) null;
      return uint16;
    }

    public async Task<byte[]> BSL_getARM_ID(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      bool readFromBSL = true)
    {
      uint adrARM_ID = this.ArmIdRange.StartAddress;
      uint size = this.ArmIdRange.ByteSize;
      byte[] baSize = new byte[(int) size];
      if (readFromBSL)
        baSize = await this.BTLFunctions.readMemoryAsync(progress, cancel, adrARM_ID, size);
      else
        baSize = await this.fwUpdateToolCMDs.ReadMemoryAsync(progress, cancel.Token, adrARM_ID, size);
      byte[] id = DeviceIdentification.GetArmUniqueID(baSize);
      byte[] armId = id;
      baSize = (byte[]) null;
      id = (byte[]) null;
      return armId;
    }

    public async Task<uint?> getMeterIDFromARM_ID(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      byte[] armUID)
    {
      uint? meterID = new uint?();
      if (armUID != null)
      {
        MeterUniqueIdByARM oMeterArmUID = new MeterUniqueIdByARM(DbBasis.PrimaryDB.BaseDbConnection);
        int num = await Task.Run<bool>((Func<bool>) (() => oMeterArmUID.ManageMeterID(armUID, ref meterID, true))) ? 1 : 0;
      }
      return meterID;
    }

    public async Task<uint?> createMeterIDFromARM_ID(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      byte[] armUID)
    {
      uint? meterID = new uint?();
      if (armUID != null)
      {
        MeterUniqueIdByARM oMeterArmUID = new MeterUniqueIdByARM(DbBasis.PrimaryDB.BaseDbConnection);
        int num = await Task.Run<bool>((Func<bool>) (() => oMeterArmUID.ManageMeterID(armUID, ref meterID))) ? 1 : 0;
      }
      return meterID;
    }

    public async Task BSL_eraseOldFW(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      uint StartAddresse = 134217728)
    {
      try
      {
        if (!this.isReady2EraseFW)
          throw new Exception("Device is not ready to write firmware to device...");
        uint pageSize = 128;
        ushort flashSize = await this.BSL_getFLASHSize(progress, cancel);
        uint loops = (uint) ((ulong) ((int) flashSize * 1024) / (ulong) pageSize);
        progress.Reset();
        progress.Split((int) loops);
        int num;
        for (int i = 0; (long) i < (long) loops; num = i++)
        {
          bool eraseNext = false;
          int tries = 0;
          while (!eraseNext)
          {
            try
            {
              num = i + 1;
              string message = "erasing Page " + num.ToString() + " of " + loops.ToString();
              progress.Report(message);
              await this.BTLFunctions.eraseMemoryAsync(progress, cancel, StartAddresse, pageSize);
              if (this.oFUI != null)
                this.oFUI.setDebugInfo("\r... Erasing address (" + StartAddresse.ToString("x8") + ")");
              StartAddresse += pageSize;
              eraseNext = true;
              message = (string) null;
            }
            catch (Exception ex)
            {
              if (tries++ > 3)
                throw new Exception("ERROR:" + ex.Message);
            }
          }
        }
        this.isReady2WriteFW = true;
      }
      catch (Exception ex)
      {
        this.isReady2WriteFW = false;
        if (this.oFUI != null)
          this.oFUI.setErrorInfo("\r-E-> Error erasing old firmware at address: " + StartAddresse.ToString("x8"));
        int num;
        if (this.oFUI != null)
        {
          bool? nullable = this.oFUI.ignoreError();
          bool flag = true;
          num = nullable.GetValueOrDefault() == flag & nullable.HasValue ? 1 : 0;
        }
        else
          num = 0;
        if (num != 0)
          throw new Exception("Error while erasing firmware from device.\nAddress: " + StartAddresse.ToString("x8") + "\nMessage: " + ex.Message);
        if (this.oFUI == null)
          return;
        this.oFUI.setErrorInfo("\r-E-> Error erasing old firmware at address: " + StartAddresse.ToString("x8"));
      }
    }

    public async Task BSL_eraseOldFW_FAST(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      uint StartAddresse = 134217728)
    {
      try
      {
        if (!this.isReady2EraseFW)
          throw new Exception("Device is not ready to write firmware to device...");
        ushort flashSize = await this.BSL_getFLASHSize(progress, cancel);
        flashSize = (ushort) ((int) flashSize * 4096 - 1);
        uint FLASH_StartAdress = StartAddresse;
        uint BSL_StartAdress = this.BSL_AddressRange.StartAddress;
        uint BSL_EndAdress = this.BSL_AddressRange.EndAddress;
        uint pageSize = BSL_StartAdress - StartAddresse;
        progress.Reset();
        progress.Split(2);
        string message = "erasing FLASH starting at " + StartAddresse.ToString("x08") + " Bytes: " + pageSize.ToString();
        progress.Report(message);
        await this.BTLFunctions.eraseMemoryAsync(progress, cancel, StartAddresse, pageSize);
        if (this.oFUI != null)
          this.oFUI.setDebugInfo("... erasing FLASH starting at " + StartAddresse.ToString("x08") + " Bytes: " + pageSize.ToString() + ") ... Done.");
        if (BSL_EndAdress < FLASH_StartAdress + (uint) flashSize)
        {
          StartAddresse = BSL_EndAdress + 1U;
          pageSize = (uint) ((int) FLASH_StartAdress + (int) flashSize - (int) StartAddresse + 1);
          message = "erasing FLASH starting at " + StartAddresse.ToString("x08") + " Bytes: " + pageSize.ToString();
          progress.Report(message);
          await this.BTLFunctions.eraseMemoryAsync(progress, cancel, StartAddresse, pageSize);
          if (this.oFUI != null)
            this.oFUI.setDebugInfo("... erasing FLASH starting at " + StartAddresse.ToString("x08") + " Bytes: " + pageSize.ToString() + ") ... Done.");
        }
        this.isReady2WriteFW = true;
        message = (string) null;
      }
      catch (Exception ex)
      {
        this.isReady2WriteFW = false;
        if (this.oFUI != null)
          this.oFUI.setErrorInfo("-E-> Error erasing old firmware at address: " + StartAddresse.ToString("x8"));
        int num;
        if (this.oFUI != null)
        {
          bool? nullable = this.oFUI.ignoreError();
          bool flag = true;
          num = nullable.GetValueOrDefault() == flag & nullable.HasValue ? 1 : 0;
        }
        else
          num = 0;
        if (num != 0)
          throw new Exception("Error while erasing firmware from device.\nAddress: " + StartAddresse.ToString("x8") + "\nMessage: " + ex.Message);
        if (this.oFUI == null)
          return;
        this.oFUI.setErrorInfo("-E-> Error erasing old firmware at address: " + StartAddresse.ToString("x8"));
      }
    }

    public bool BSL_isIUW() => this.BTLFunctions.isIUW;

    public async Task BSL_writeNewFW(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      AddressRange[] noWriteRanges = null,
      uint pageSize = 448)
    {
      Stopwatch watch = new Stopwatch();
      Stopwatch watchDur = new Stopwatch();
      this.isReady2WriteFW = true;
      if (!this.isReady2WriteFW)
        throw new Exception("Old firmware was not erased!!!\n\nPlease, erase old firmware first.");
      if (this.dicBytesToFlashFIRMWARE == null || this.dicBytesToFlashFIRMWARE.Count == 0)
        throw new Exception("Firmware file was not loaded correctly.\nPlease load firmware file again.");
      if (pageSize % 4U > 0U)
        throw new Exception("PageSize not set correctly, needs to be a modulo 4!!!.\nPlease set a correct size for writing firmware file to device.");
      this.dicBytesToFlash = this.dicBytesToFlashFIRMWARE;
      uint startAddress = 0;
      uint startAddressOLD = 0;
      uint oldAddress = 0;
      uint iPageSize = pageSize;
      int iByteArrayLen = 0;
      int adrOffset = 0;
      int offset = 0;
      bool nextPage = true;
      byte[] bytesToWrite = new byte[(int) iPageSize];
      byte[] byteBlock = new byte[0];
      List<byte> tempBTW = new List<byte>();
      uint loop = 0;
      progress.Reset();
      int split = (int) ((long) (this.dicBytesToFlash.Count * 16) / (long) iPageSize);
      progress.Split(split);
      watch.Reset();
      watch.Start();
      try
      {
        foreach (uint address in this.dicBytesToFlash.Keys)
        {
          ++loop;
          if (iByteArrayLen == 0)
            iByteArrayLen = this.dicBytesToFlash[address].Length;
          if (this.BSL_AddressRange != null && address >= this.BSL_AddressRange.StartAddress && address <= this.BSL_AddressRange.EndAddress)
          {
            string debugInfo2_1 = "NO write at address (" + startAddress.ToString("x8") + ") - BOOTLOADER area !!!";
          }
          else
          {
            if (nextPage)
            {
              startAddress = adrOffset != 0 ? (uint) ((ulong) oldAddress + (ulong) adrOffset) : address;
              nextPage = false;
              if (startAddress % 4U > 0U)
                startAddress = startAddressOLD + iPageSize;
            }
            int num;
            TimeSpan elapsed;
            double totalSeconds;
            if ((long) (address - oldAddress) <= (long) iByteArrayLen || oldAddress == 0U)
            {
              if (byteBlock != null && (long) (byteBlock.Length + tempBTW.Count) > (long) iPageSize)
              {
                int itake = (int) ((long) byteBlock.Length - ((long) (byteBlock.Length + tempBTW.Count) - (long) iPageSize));
                tempBTW.AddRange(((IEnumerable<byte>) byteBlock).Take<byte>(itake));
                byteBlock = ((IEnumerable<byte>) byteBlock).Skip<byte>(itake).ToArray<byte>();
                Buffer.BlockCopy((Array) this.dicBytesToFlash[address], 0, (Array) byteBlock, byteBlock.Length, this.dicBytesToFlash[address].Length);
              }
              else
              {
                if (byteBlock != null && byteBlock.Length != 0)
                {
                  tempBTW.AddRange((IEnumerable<byte>) byteBlock);
                  byteBlock = ((IEnumerable<byte>) byteBlock).Skip<byte>(byteBlock.Length).ToArray<byte>();
                }
                int iLocalLenght = this.dicBytesToFlash[address].Length;
                if (iLocalLenght != iByteArrayLen || (long) (iLocalLenght + tempBTW.Count) > (long) iPageSize)
                {
                  if (byteBlock.Length != 0 && (long) (tempBTW.Count + byteBlock.Length) > (long) iPageSize)
                  {
                    uint iOff = (uint) ((ulong) iPageSize - (ulong) tempBTW.Count);
                    byte[] bta = new byte[(int) iOff];
                    Buffer.BlockCopy((Array) byteBlock, 0, (Array) bta, 0, (int) iOff);
                    tempBTW.AddRange((IEnumerable<byte>) bta);
                    byteBlock = ((IEnumerable<byte>) byteBlock).Skip<byte>((int) iOff).ToArray<byte>();
                    offset = iByteArrayLen - (int) iOff;
                    bta = (byte[]) null;
                  }
                  else if (byteBlock != null && byteBlock.Length == 0 && (long) (iLocalLenght + tempBTW.Count) > (long) iPageSize)
                  {
                    offset = (int) iPageSize - tempBTW.Count;
                    adrOffset = offset;
                    tempBTW.AddRange(((IEnumerable<byte>) this.dicBytesToFlash[address]).Take<byte>(offset));
                    byteBlock = ((IEnumerable<byte>) this.dicBytesToFlash[address]).Skip<byte>(offset).ToArray<byte>();
                  }
                  else if (byteBlock != null && byteBlock.Length == 0 && (long) (iLocalLenght + tempBTW.Count) <= (long) iPageSize)
                    tempBTW.AddRange((IEnumerable<byte>) this.dicBytesToFlash[address]);
                }
                else
                  tempBTW.AddRange((IEnumerable<byte>) this.dicBytesToFlash[address]);
              }
            }
            else
            {
              int addCnt = tempBTW.Count % 4;
              if (addCnt != 0)
              {
                List<byte> addByte = new List<byte>();
                for (int i = 0; i < addCnt; num = i++)
                  addByte.Add(byte.MaxValue);
                Buffer.BlockCopy((Array) tempBTW.ToArray<byte>(), 0, (Array) bytesToWrite, 0, tempBTW.ToArray<byte>().Length);
                Buffer.BlockCopy((Array) addByte.ToArray<byte>(), 0, (Array) bytesToWrite, tempBTW.ToArray<byte>().Length + 1, addCnt);
                addByte = (List<byte>) null;
              }
              else
                bytesToWrite = tempBTW.ToArray<byte>();
              int doWrite = 0;
              while (true)
              {
                try
                {
                  await this.BTLFunctions.writeMemoryAsync(progress, cancel, startAddress, bytesToWrite);
                  break;
                }
                catch (Exception ex)
                {
                  if (ex.Message.ToLower().Contains("timeout") && doWrite < 3)
                    ++doWrite;
                  else
                    break;
                }
              }
              string[] strArray = new string[7]
              {
                "Write at adress (",
                startAddress.ToString("x8"),
                ") - ",
                null,
                null,
                null,
                null
              };
              num = tempBTW.Count;
              strArray[3] = num.ToString();
              strArray[4] = " Bytes in ";
              elapsed = watchDur.Elapsed;
              totalSeconds = elapsed.TotalSeconds;
              strArray[5] = totalSeconds.ToString("000.00");
              strArray[6] = " sec.";
              string debugInfo2_2 = string.Concat(strArray);
              if (this.oFUI != null)
                this.oFUI.setDebugInfo(debugInfo2_2);
              tempBTW.Clear();
              nextPage = false;
              offset = 0;
              startAddress = address;
              tempBTW.AddRange((IEnumerable<byte>) this.dicBytesToFlash[address]);
              debugInfo2_2 = (string) null;
            }
            if ((long) tempBTW.Count >= (long) iPageSize || (long) loop == (long) this.dicBytesToFlash.Count)
            {
              string[] strArray1 = new string[7]
              {
                "Write at adress (",
                startAddress.ToString("x8"),
                ") - ",
                null,
                null,
                null,
                null
              };
              num = tempBTW.Count;
              strArray1[3] = num.ToString();
              strArray1[4] = " Bytes in ";
              elapsed = watch.Elapsed;
              totalSeconds = elapsed.TotalSeconds;
              strArray1[5] = totalSeconds.ToString("000.00");
              strArray1[6] = " sec.";
              string debugInfo = string.Concat(strArray1);
              progress.Report(debugInfo);
              watchDur.Restart();
              bytesToWrite = tempBTW.ToArray<byte>();
              int doWrite = 0;
              while (true)
              {
                try
                {
                  await this.BTLFunctions.writeMemoryAsync(progress, cancel, startAddress, bytesToWrite);
                  break;
                }
                catch (Exception ex)
                {
                  if (ex.Message.ToLower().Contains("timeout") && doWrite < 3)
                    ++doWrite;
                  else
                    break;
                }
              }
              string[] strArray2 = new string[7]
              {
                "Write at address (",
                startAddress.ToString("x8"),
                ") - ",
                null,
                null,
                null,
                null
              };
              num = tempBTW.Count;
              strArray2[3] = num.ToString();
              strArray2[4] = " Bytes in ";
              elapsed = watchDur.Elapsed;
              totalSeconds = elapsed.TotalSeconds;
              strArray2[5] = totalSeconds.ToString("000.00");
              strArray2[6] = " sec.";
              string debugInfo2_3 = string.Concat(strArray2);
              if (this.oFUI != null)
                this.oFUI.setDebugInfo(debugInfo2_3);
              tempBTW.Clear();
              startAddressOLD = startAddress;
              nextPage = true;
              debugInfo = (string) null;
              debugInfo2_3 = (string) null;
            }
            oldAddress = address;
          }
        }
        if (cancel.IsCancellationRequested)
          throw new Exception("Task cancelled by user !!!");
        this.isReady2GO = true;
        watch = (Stopwatch) null;
        watchDur = (Stopwatch) null;
        bytesToWrite = (byte[]) null;
        byteBlock = (byte[]) null;
        tempBTW = (List<byte>) null;
      }
      catch (Exception ex)
      {
        this.isReady2GO = false;
        if (this.oFUI != null)
          this.oFUI.setErrorInfo("-E-> write error at address: " + startAddress.ToString("x8"));
        int num;
        if (this.oFUI != null)
        {
          bool? nullable = this.oFUI.ignoreError();
          bool flag = true;
          num = !(nullable.GetValueOrDefault() == flag & nullable.HasValue) ? 1 : 0;
        }
        else
          num = 0;
        if (num == 0)
        {
          watch = (Stopwatch) null;
          watchDur = (Stopwatch) null;
          bytesToWrite = (byte[]) null;
          byteBlock = (byte[]) null;
          tempBTW = (List<byte>) null;
        }
        else
          throw new Exception("Error while writing firmware to device.\nStartaddress: " + startAddress.ToString("x8") + "\nBytes:" + ZR_ClassLibrary.Util.ByteArrayToHexString(bytesToWrite) + "\nMessage: " + ex.Message);
      }
    }

    public async Task BSL_writeNewFW_IUW(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      AddressRange[] noWriteRanges = null,
      bool dontWriteAtBootloaderAddress = true)
    {
      Stopwatch watch = new Stopwatch();
      Stopwatch watchDur = new Stopwatch();
      this.isReady2WriteFW = true;
      if (!this.isReady2WriteFW)
        throw new Exception("Old firmware was not erased!!!\n\nPlease, erase old firmware first.");
      this.dicBytesToFlash = this.dicBytesToFlashFIRMWARE != null && this.dicBytesToFlashFIRMWARE.Count != 0 ? this.dicBytesToFlashFIRMWARE : throw new Exception("Firmware file was not loaded correctly.\nPlease load firmware file again.");
      uint startAddress = 0;
      uint startAddressOLD = 0;
      uint oldAdress = 0;
      uint iPageSize = 524287;
      int iByteArrayLen = 0;
      int adrOffset = 0;
      int offset = 0;
      bool nextPage = true;
      byte[] bytesToWrite = new byte[(int) iPageSize];
      byte[] byteBlock = new byte[0];
      List<byte> tempBTW = new List<byte>();
      uint loop = 0;
      progress.Reset();
      int split = this.dicBytesToFlash.Count * 16 / 448;
      progress.Split(split);
      watch.Reset();
      watch.Start();
      try
      {
        foreach (uint address in this.dicBytesToFlash.Keys)
        {
          ++loop;
          if (iByteArrayLen == 0)
            iByteArrayLen = this.dicBytesToFlash[address].Length;
          if (dontWriteAtBootloaderAddress && this.BSL_AddressRange != null && address >= this.BSL_AddressRange.StartAddress && address <= this.BSL_AddressRange.EndAddress)
          {
            if (this.oFUI != null)
              this.oFUI.setDebugInfo("NO write at address (" + startAddress.ToString("x8") + ") - BOOTLOADER area !!!");
          }
          else
          {
            if (nextPage)
            {
              startAddress = adrOffset != 0 ? (uint) ((ulong) oldAdress + (ulong) adrOffset) : address;
              nextPage = false;
              if (startAddress % 4U > 0U)
                startAddress = startAddressOLD + iPageSize;
            }
            int num;
            TimeSpan elapsed;
            double totalSeconds;
            if ((long) (address - oldAdress) <= (long) iByteArrayLen || oldAdress == 0U)
            {
              if (byteBlock != null && (long) (byteBlock.Length + tempBTW.Count) > (long) iPageSize)
              {
                int itake = (int) ((long) byteBlock.Length - ((long) (byteBlock.Length + tempBTW.Count) - (long) iPageSize));
                tempBTW.AddRange(((IEnumerable<byte>) byteBlock).Take<byte>(itake));
                byteBlock = ((IEnumerable<byte>) byteBlock).Skip<byte>(itake).ToArray<byte>();
                Buffer.BlockCopy((Array) this.dicBytesToFlash[address], 0, (Array) byteBlock, byteBlock.Length, this.dicBytesToFlash[address].Length);
              }
              else
              {
                if (byteBlock != null && byteBlock.Length != 0)
                {
                  tempBTW.AddRange((IEnumerable<byte>) byteBlock);
                  byteBlock = ((IEnumerable<byte>) byteBlock).Skip<byte>(byteBlock.Length).ToArray<byte>();
                }
                int iLocalLenght = this.dicBytesToFlash[address].Length;
                if (iLocalLenght != iByteArrayLen || (long) (iLocalLenght + tempBTW.Count) > (long) iPageSize)
                {
                  if (byteBlock.Length != 0 && (long) (tempBTW.Count + byteBlock.Length) > (long) iPageSize)
                  {
                    uint iOff = (uint) ((ulong) iPageSize - (ulong) tempBTW.Count);
                    byte[] bta = new byte[(int) iOff];
                    Buffer.BlockCopy((Array) byteBlock, 0, (Array) bta, 0, (int) iOff);
                    tempBTW.AddRange((IEnumerable<byte>) bta);
                    byteBlock = ((IEnumerable<byte>) byteBlock).Skip<byte>((int) iOff).ToArray<byte>();
                    offset = iByteArrayLen - (int) iOff;
                    bta = (byte[]) null;
                  }
                  else if (byteBlock != null && byteBlock.Length == 0 && (long) (iLocalLenght + tempBTW.Count) > (long) iPageSize)
                  {
                    offset = (int) iPageSize - tempBTW.Count;
                    adrOffset = offset;
                    tempBTW.AddRange(((IEnumerable<byte>) this.dicBytesToFlash[address]).Take<byte>(offset));
                    byteBlock = ((IEnumerable<byte>) this.dicBytesToFlash[address]).Skip<byte>(offset).ToArray<byte>();
                  }
                  else if (byteBlock != null && byteBlock.Length == 0 && (long) (iLocalLenght + tempBTW.Count) <= (long) iPageSize)
                    tempBTW.AddRange((IEnumerable<byte>) this.dicBytesToFlash[address]);
                }
                else
                  tempBTW.AddRange((IEnumerable<byte>) this.dicBytesToFlash[address]);
              }
            }
            else
            {
              int addCnt = tempBTW.Count % 4;
              if (addCnt != 0)
              {
                List<byte> addByte = new List<byte>();
                for (int i = 0; i < addCnt; num = i++)
                  addByte.Add(byte.MaxValue);
                Buffer.BlockCopy((Array) tempBTW.ToArray<byte>(), 0, (Array) bytesToWrite, 0, tempBTW.ToArray<byte>().Length);
                Buffer.BlockCopy((Array) addByte.ToArray<byte>(), 0, (Array) bytesToWrite, tempBTW.ToArray<byte>().Length + 1, addCnt);
                addByte = (List<byte>) null;
              }
              else
                bytesToWrite = tempBTW.ToArray<byte>();
              int doWrite = 0;
              while (true)
              {
                try
                {
                  await this.BTLFunctions.writeMemoryAsync(progress, cancel, startAddress, bytesToWrite);
                  break;
                }
                catch (Exception ex)
                {
                  if (ex.Message.ToLower().Contains("timeout") && doWrite < 3)
                  {
                    if (this.oFUI != null)
                      this.oFUI.setDebugInfo(" --> write at adress (" + startAddress.ToString("x8") + ") - timeout !!!");
                    ++doWrite;
                  }
                  else
                    break;
                }
              }
              string[] strArray = new string[7]
              {
                "Write at address (",
                startAddress.ToString("x8"),
                ") - ",
                null,
                null,
                null,
                null
              };
              num = tempBTW.Count;
              strArray[3] = num.ToString();
              strArray[4] = " Bytes in ";
              elapsed = watchDur.Elapsed;
              totalSeconds = elapsed.TotalSeconds;
              strArray[5] = totalSeconds.ToString("000.00");
              strArray[6] = " sec.";
              string debugInfo2 = string.Concat(strArray);
              if (this.oFUI != null)
                this.oFUI.setDebugInfo(debugInfo2);
              tempBTW.Clear();
              nextPage = false;
              offset = 0;
              startAddress = address;
              tempBTW.AddRange((IEnumerable<byte>) this.dicBytesToFlash[address]);
              debugInfo2 = (string) null;
            }
            if ((long) tempBTW.Count >= (long) iPageSize || (long) loop == (long) this.dicBytesToFlash.Count)
            {
              string[] strArray1 = new string[7]
              {
                "Write at address (",
                startAddress.ToString("x8"),
                ") - ",
                null,
                null,
                null,
                null
              };
              num = tempBTW.Count;
              strArray1[3] = num.ToString();
              strArray1[4] = " Bytes in ";
              elapsed = watch.Elapsed;
              totalSeconds = elapsed.TotalSeconds;
              strArray1[5] = totalSeconds.ToString("000.00");
              strArray1[6] = " sec.";
              string debugInfo = string.Concat(strArray1);
              progress.Report(debugInfo);
              watchDur.Restart();
              bytesToWrite = tempBTW.ToArray<byte>();
              int doWrite = 0;
              while (true)
              {
                try
                {
                  await this.BTLFunctions.writeMemoryAsync(progress, cancel, startAddress, bytesToWrite);
                  break;
                }
                catch (Exception ex)
                {
                  if (ex.Message.ToLower().Contains("timeout") && doWrite < 3)
                  {
                    if (this.oFUI != null)
                      this.oFUI.setDebugInfo(" --> write at address (" + startAddress.ToString("x8") + ") - timeout !!!");
                    ++doWrite;
                  }
                  else
                    break;
                }
              }
              string[] strArray2 = new string[7]
              {
                "Write at address (",
                startAddress.ToString("x8"),
                ") - ",
                null,
                null,
                null,
                null
              };
              num = tempBTW.Count;
              strArray2[3] = num.ToString();
              strArray2[4] = " Bytes in ";
              elapsed = watchDur.Elapsed;
              totalSeconds = elapsed.TotalSeconds;
              strArray2[5] = totalSeconds.ToString("000.00");
              strArray2[6] = " sec.";
              string debugInfo2 = string.Concat(strArray2);
              if (this.oFUI != null)
                this.oFUI.setDebugInfo(debugInfo2);
              tempBTW.Clear();
              startAddressOLD = startAddress;
              nextPage = true;
              debugInfo = (string) null;
              debugInfo2 = (string) null;
            }
            oldAdress = address;
          }
        }
        if (cancel.IsCancellationRequested)
          throw new Exception("Task cancelled by user !!!");
        this.isReady2GO = true;
        watch = (Stopwatch) null;
        watchDur = (Stopwatch) null;
        bytesToWrite = (byte[]) null;
        byteBlock = (byte[]) null;
        tempBTW = (List<byte>) null;
      }
      catch (Exception ex)
      {
        this.isReady2GO = false;
        if (this.oFUI != null)
          this.oFUI.setErrorInfo("-E-> write error at address: " + startAddress.ToString("x8"));
        int num;
        if (this.oFUI != null)
        {
          bool? nullable = this.oFUI.ignoreError();
          bool flag = true;
          num = !(nullable.GetValueOrDefault() == flag & nullable.HasValue) ? 1 : 0;
        }
        else
          num = 0;
        if (num == 0)
        {
          watch = (Stopwatch) null;
          watchDur = (Stopwatch) null;
          bytesToWrite = (byte[]) null;
          byteBlock = (byte[]) null;
          tempBTW = (List<byte>) null;
        }
        else
          throw new Exception("Error while writing firmware to device.\nStartaddress: " + startAddress.ToString("x8") + "\nBytes:" + ZR_ClassLibrary.Util.ByteArrayToHexString(bytesToWrite) + "\nMessage: " + ex.Message);
      }
    }

    public async Task BSL_writeNewFW_IUW_BLOCKMODE(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      AddressRange[] noWriteRanges = null)
    {
      Stopwatch watch = new Stopwatch();
      Stopwatch watchdur = new Stopwatch();
      this.isReady2GO = false;
      this.isReady2WriteFW = true;
      if (!this.isReady2WriteFW)
        throw new Exception("Old firmware was not erased!!!\n\nPlease, erase old firmware first.");
      this.dicBytesToFlash = this.dicBytesToFlashFIRMWARE != null && this.dicBytesToFlashFIRMWARE.Count != 0 ? this.dicBytesToFlashFIRMWARE : throw new Exception("Firmware file was not loaded correctly.\nPlease load firmware file again.");
      this.blockInfo_NoVerify = new List<FirmwareBlockInfoClass>();
      progress.Reset();
      watch.Start();
      if (this.blockInfo_Firmware == null || this.blockInfo_Firmware.Count <= 0)
      {
        watch = (Stopwatch) null;
        watchdur = (Stopwatch) null;
      }
      else
      {
        foreach (FirmwareBlockInfoClass fwBI in this.blockInfo_Firmware)
        {
          watchdur.Reset();
          watchdur.Start();
          int doWrite = 0;
          while (true)
          {
            try
            {
              if (this.oFUI != null)
                this.oFUI.setDebugInfo(" --> write at address (" + fwBI.startAddress.ToString("x8") + ") ");
              await this.BTLFunctions.writeMemoryAsync(progress, cancel, fwBI.startAddress, fwBI.BlockBytes);
              if (this.oFUI != null)
              {
                this.oFUI.setDebugInfo(" --> duration: " + watchdur.Elapsed.TotalSeconds.ToString("000.00") + " sec.");
                break;
              }
              break;
            }
            catch (Exception ex)
            {
              if (ex.Message.ToLower().Contains("timeout") && doWrite < 3)
              {
                if (this.oFUI != null)
                  this.oFUI.setDebugInfo(" --> write at address (" + fwBI.startAddress.ToString("x8") + ") - timeout !!!");
                ++doWrite;
              }
              else
              {
                if (ex.Message.ToUpper().Contains("NFC_ERR_WRTPRM"))
                {
                  this.blockInfo_NoVerify.Add(fwBI);
                  if (this.oFUI != null)
                  {
                    this.oFUI.setDebugInfo(" -!-> ERROR: " + ex.Message.Replace("\r", "").Replace("\n", "").Trim());
                    this.oFUI.setDebugInfo(" -!-> Block: " + fwBI.ToString(0U));
                    break;
                  }
                  break;
                }
                int num;
                if (this.oFUI != null)
                {
                  bool? nullable = this.oFUI.ignoreError();
                  bool flag = true;
                  num = nullable.GetValueOrDefault() == flag & nullable.HasValue ? 1 : 0;
                }
                else
                  num = 0;
                if (num == 0)
                  throw ex;
                this.oFUI.setDebugInfo(" --> ERROR: " + ex.Message);
                break;
              }
            }
          }
        }
        this.isReady2GO = true;
        if (this.oFUI != null)
          this.oFUI.setDebugInfo(" --> complete duration: " + watch.Elapsed.TotalSeconds.ToString("000.00") + " sec.");
        watch = (Stopwatch) null;
        watchdur = (Stopwatch) null;
      }
    }

    public List<FirmwareBlockInfoClass> getBlocksFromFirmware(
      bool isBootloader = false,
      AddressRange excludeAddresses = null)
    {
      Stopwatch stopwatch1 = new Stopwatch();
      Stopwatch stopwatch2 = new Stopwatch();
      if (isBootloader)
        this.dicBytesToFlash = this.dicBytesToFlashBOOTLOADER != null && this.dicBytesToFlashBOOTLOADER.Count != 0 ? this.dicBytesToFlashBOOTLOADER : throw new Exception("Bootloader file was not loaded correctly.\nPlease load bootloader file again.");
      else
        this.dicBytesToFlash = this.dicBytesToFlashFIRMWARE != null && this.dicBytesToFlashFIRMWARE.Count != 0 ? this.dicBytesToFlashFIRMWARE : throw new Exception("Firmware file was not loaded correctly.\nPlease load firmware file again.");
      List<FirmwareBlockInfoClass> blocksFromFirmware = new List<FirmwareBlockInfoClass>();
      uint num1 = 0;
      uint num2 = 0;
      uint num3 = 0;
      int num4 = 0;
      List<byte> byteList = (List<byte>) null;
      byte[] numArray = (byte[]) null;
      stopwatch1.Reset();
      stopwatch1.Start();
      try
      {
        FirmwareBlockInfoClass firmwareBlockInfoClass = (FirmwareBlockInfoClass) null;
        uint num5 = this.dicBytesToFlash.Keys.Last<uint>();
        foreach (uint key in this.dicBytesToFlash.Keys)
        {
          if (num4 == 0)
            num4 = this.dicBytesToFlash[key].Length;
          bool flag = false;
          if (num2 == 0U)
          {
            num1 = num3 > 0U ? num3 : key;
            firmwareBlockInfoClass = new FirmwareBlockInfoClass();
            firmwareBlockInfoClass.startAddress = num1;
            byteList = new List<byte>();
            if (numArray != null && numArray.Length != 0)
              byteList.AddRange((IEnumerable<byte>) numArray);
            numArray = (byte[]) null;
            num3 = 0U;
          }
          if ((long) (key - num2) == (long) num4 || num2 == 0U)
          {
            if (excludeAddresses != null)
            {
              if (key < excludeAddresses.StartAddress || key > excludeAddresses.EndAddress)
                byteList.AddRange((IEnumerable<byte>) this.dicBytesToFlash[key]);
            }
            else
              byteList.AddRange((IEnumerable<byte>) this.dicBytesToFlash[key]);
            flag = true;
          }
          if (num2 != 0U && (int) key != (int) num2 && (long) (key - num2) != (long) num4 || (int) key == (int) num5)
          {
            numArray = new byte[this.dicBytesToFlash[key].Length];
            Buffer.BlockCopy((Array) this.dicBytesToFlash[key], 0, (Array) numArray, 0, numArray.Length);
            num3 = key;
            firmwareBlockInfoClass.BlockBytes = byteList.ToArray();
            firmwareBlockInfoClass.blockSize = (uint) firmwareBlockInfoClass.BlockBytes.Length;
            firmwareBlockInfoClass.endAddress = (uint) ((int) firmwareBlockInfoClass.startAddress + (int) firmwareBlockInfoClass.blockSize - 1);
            blocksFromFirmware.Add(firmwareBlockInfoClass);
            num2 = 0U;
          }
          if (flag)
            num2 = key;
        }
      }
      catch (Exception ex)
      {
        if (this.oFUI != null)
          this.oFUI.setErrorInfo("\r-E-> write error at address: " + num1.ToString("x8"));
        int num6;
        if (this.oFUI != null)
        {
          bool? nullable = this.oFUI.ignoreError();
          bool flag = true;
          num6 = !(nullable.GetValueOrDefault() == flag & nullable.HasValue) ? 1 : 0;
        }
        else
          num6 = 0;
        if (num6 != 0)
          throw new Exception("Error while creating blocks for firmware.\nStartadress: " + num1.ToString("x8") + "\nMessage: " + ex.Message);
      }
      return blocksFromFirmware;
    }

    public async Task BSL_GO(ProgressHandler progress, CancellationTokenSource cancel)
    {
      if (!this.isReady2GO)
      {
        if (this.oFUI != null)
          this.oFUI.setErrorInfo("\r-E-> Device is not prepared.");
        int num;
        if (this.oFUI != null)
        {
          bool? nullable = this.oFUI.ignoreError();
          bool flag = true;
          num = !(nullable.GetValueOrDefault() == flag & nullable.HasValue) ? 1 : 0;
        }
        else
          num = 0;
        if (num != 0)
          throw new Exception("Device is not prepared!!!\n\nPlease, prepare, erase old and write new firmware first.");
      }
      await this.BTLFunctions.GO_Async(progress, cancel);
    }

    public async Task BSL_FORCE_GO(ProgressHandler progress, CancellationTokenSource cancel)
    {
      await this.BTLFunctions.GO_Async(progress, cancel);
    }

    public async Task<byte[]> BSL_readMeterKey(
      ProgressHandler progress,
      CancellationTokenSource cancelTokenSource)
    {
      if (!this.BSL_isIUW())
      {
        this.oFUI.setErrorInfo("\r-E-> Function for IUWs devices only !!!");
        return (byte[]) null;
      }
      byte[] numArray = await this.BTLFunctions.readMemoryAsync(progress, cancelTokenSource, this.iMeterKey, 4U);
      return numArray;
    }

    public async Task BSL_writeMeterKey(
      ProgressHandler progress,
      CancellationTokenSource cancelTokenSource,
      byte[] meterkey = null)
    {
      if (!this.BSL_isIUW())
      {
        this.oFUI.setErrorInfo("\r-E-> Function for IUWs devices only !!!");
      }
      else
      {
        if (meterkey == null)
          meterkey = new byte[4];
        await this.fwUpdateToolCMDs.WriteMemoryAsync(progress, cancelTokenSource.Token, this.iMeterKey, meterkey);
      }
    }

    public async Task BSL_writeVectorTable(
      ProgressHandler progress,
      CancellationTokenSource cancelTokenSource,
      byte[] vector)
    {
      if (!this.BSL_isIUW())
      {
        this.oFUI.setErrorInfo("\r-E-> Function for IUWs devices only !!!");
      }
      else
      {
        if (vector == null || vector.Length > 8 || vector.Length < 8)
          throw new Exception("Wrong Vector for restarting firmware !!!");
        await this.fwUpdateToolCMDs.WriteMemoryAsync(progress, cancelTokenSource.Token, this.iVectorTable, vector);
      }
    }

    public async Task deleteBSLfromDevice(ProgressHandler progress, CancellationTokenSource cancel)
    {
      await this.deleteBSLfromDevice(progress, cancel, 0U, 0U);
    }

    internal async Task deleteBSLfromDevice(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      uint startAdr,
      uint size)
    {
      try
      {
        if (!this.isBootLoaderFile)
          throw new Exception("Bootloader file is not loaded, please load a correct bootloader for this device...");
        if (startAdr == 0U)
        {
          startAdr = this.BSL_AddressRange.StartAddress;
          size = this.BSL_AddressRange.EndAddress - this.BSL_AddressRange.StartAddress;
        }
        uint pageSize = 128;
        ushort flashSize = (ushort) size;
        uint loops = (uint) flashSize / pageSize;
        byte[] bytesToWrite = new byte[128];
        for (int i = 0; i < bytesToWrite.Length; ++i)
          bytesToWrite[i] = byte.MaxValue;
        progress.Reset();
        progress.Split((int) loops);
        for (int i = 0; (long) i < (long) loops; ++i)
        {
          progress.Report("erasing Page " + (i + 1).ToString() + " of " + loops.ToString());
          await this.fwUpdateToolCMDs.WriteMemoryAsync(progress, cancel.Token, startAdr, bytesToWrite);
          if (this.oFUI != null)
            this.oFUI.setDebugInfo("\r... erasing bootloader - adr: " + startAdr.ToString("x8") + " size: " + size.ToString());
          startAdr += pageSize;
        }
        bytesToWrite = (byte[]) null;
      }
      catch (Exception ex)
      {
        this.isReady2WriteFW = false;
        if (this.oFUI != null)
          this.oFUI.setErrorInfo("\r-E-> Error while erasing bootloader - adr: " + startAdr.ToString("x8") + " size: " + size.ToString());
        int num;
        if (this.oFUI != null)
        {
          bool? nullable = this.oFUI.ignoreError();
          bool flag = true;
          num = !(nullable.GetValueOrDefault() == flag & nullable.HasValue) ? 1 : 0;
        }
        else
          num = 0;
        if (num != 0)
          throw new Exception("Error while deleting BOOTLOADER from device.\n\n" + ex.Message);
      }
    }

    public async Task<bool> overwriteBSLfromDevice(
      ProgressHandler progress,
      CancellationTokenSource cancel)
    {
      bool flag = await this.overwriteBSLfromDevice(progress, cancel, 0U);
      return flag;
    }

    internal async Task<bool> overwriteBSLfromDevice(
      ProgressHandler progress,
      CancellationTokenSource cancel,
      uint startAddressBSL)
    {
      try
      {
        uint size = 0;
        uint pageSize = 128;
        uint startAdr = startAddressBSL;
        if (this.dicBytesToFlashBOOTLOADER == null || this.dicBytesToFlashBOOTLOADER.Count == 0)
          throw new Exception("Bootloader file is not loaded, please load a correct bootloader for this device...");
        if (this.dicBytesToFlashFIRMWARE == null || this.dicBytesToFlashFIRMWARE.Count == 0)
          throw new Exception("Firmware file is not loaded, please load a correct firmwarefile for this device...");
        if (startAdr == 0U)
          startAdr = this.BSL_AddressRange.StartAddress;
        if (startAdr < this.FW_AddressRange.EndAddress)
        {
          bool foundFWstartAdr = false;
          while (!foundFWstartAdr)
          {
            if (this.dicBytesToFlashFIRMWARE.ContainsKey(startAdr))
              foundFWstartAdr = true;
            else
              --startAdr;
          }
          size = this.BSL_AddressRange.EndAddress - this.BSL_AddressRange.StartAddress;
          uint loops = size / pageSize;
          progress.Reset();
          progress.Split((int) loops);
          while (startAdr <= this.BSL_AddressRange.EndAddress)
          {
            int offset = 0;
            bool isReady = false;
            byte[] bytesToWrite = new byte[(int) pageSize];
            while (!isReady)
            {
              int adressSize = this.dicBytesToFlashFIRMWARE[startAdr].Length;
              Buffer.BlockCopy((Array) this.dicBytesToFlashFIRMWARE[startAdr], 0, (Array) bytesToWrite, offset, adressSize);
              offset += adressSize;
              startAdr += (uint) adressSize;
              if (startAdr > this.BSL_AddressRange.EndAddress)
                isReady = true;
              if ((long) offset >= (long) pageSize)
                isReady = true;
            }
            await this.fwUpdateToolCMDs.WriteMemoryAsync(progress, cancel.Token, startAdr, bytesToWrite);
            if (this.oFUI != null)
              this.oFUI.setDebugInfo("\r... overwrite bootloader - adr: " + startAdr.ToString("x8") + " size: " + pageSize.ToString());
            bytesToWrite = (byte[]) null;
          }
          return true;
        }
        this.oFUI.setDebugInfo("\r... no data available for overwriting ... DONE.");
        return false;
      }
      catch (Exception ex)
      {
        this.isReady2WriteFW = false;
        if (this.oFUI != null)
          this.oFUI.setErrorInfo("\r-E-> Error while erasing bootloader - adr: " + startAddressBSL.ToString("x8"));
        int num;
        if (this.oFUI != null)
        {
          bool? nullable = this.oFUI.ignoreError();
          bool flag = true;
          num = !(nullable.GetValueOrDefault() == flag & nullable.HasValue) ? 1 : 0;
        }
        else
          num = 0;
        if (num != 0)
          throw new Exception("Error while overwriting BOOTLOADER on device.\n\n" + ex.Message);
        return false;
      }
    }

    public string getInfoFromFirmwareFile(ref FirmwareInfoClass fwInfo, bool infoFromMergeFile = false)
    {
      SortedDictionary<uint, byte[]> sortedDictionary1 = new SortedDictionary<uint, byte[]>();
      SortedDictionary<uint, byte[]> sortedDictionary2 = this.dicBytesToFlashFIRMWARE;
      if (infoFromMergeFile)
        sortedDictionary2 = this.dicBytesToFlashMERGE;
      if (sortedDictionary2 == null || sortedDictionary2.Count <= 0)
        return (string) null;
      fwInfo.firstAddress = uint.MaxValue;
      fwInfo.lastAddress = 0U;
      fwInfo.stepSize = 0U;
      fwInfo.gapCounter = 0U;
      fwInfo.gapMessage = string.Empty;
      uint num1 = 0;
      foreach (uint key in sortedDictionary2.Keys)
      {
        fwInfo.firstAddress = key < fwInfo.firstAddress ? key : fwInfo.firstAddress;
        fwInfo.lastAddress = key > fwInfo.lastAddress ? key : fwInfo.lastAddress;
        uint num2 = key - fwInfo.oldKeyAdr;
        if (num1 > 0U && fwInfo.stepSize == 0U)
          fwInfo.stepSize = num2;
        if (num1 > 0U && fwInfo.stepSize > 0U)
          fwInfo.stepSize = (int) fwInfo.stepSize != (int) num2 ? fwInfo.stepSize : num2;
        if (num1 > 1U && (int) fwInfo.stepSize != (int) num2)
        {
          ++fwInfo.gapCounter;
          FirmwareInfoClass firmwareInfoClass = fwInfo;
          firmwareInfoClass.gapMessage = firmwareInfoClass.gapMessage + " -> GAP(" + fwInfo.gapCounter.ToString() + ") at 0x" + fwInfo.oldKeyAdr.ToString("x8") + " ... 0x" + key.ToString("x8") + "\r";
        }
        fwInfo.oldKeyAdr = key;
        ++num1;
      }
      return fwInfo.ToString();
    }

    public void createBackPack(FirmwareInfoClass fwFirmwareInfo)
    {
      uint length = (uint) this.dicBytesToFlashFIRMWARE[fwFirmwareInfo.lastAddress].Length;
      uint num1 = length % 4U;
      uint num2 = fwFirmwareInfo.lastAddress + length + num1;
      SortedDictionary<uint, byte[]> sortedDictionary = new SortedDictionary<uint, byte[]>();
      uint num3 = 0;
      foreach (uint key1 in this.dicBytesToFlashMERGE.Keys)
      {
        byte[] numArray = this.dicBytesToFlashMERGE[key1];
        uint num4 = num3 > 0U ? key1 - num3 : 0U;
        uint key2 = num2 + num4;
        num3 = key1;
        sortedDictionary.Add(key2, numArray);
        num2 = key2;
      }
      this.dicBytesToFlashBACKPACK = sortedDictionary;
    }

    public void mergeFirmwareAndBackPackFile()
    {
      foreach (uint key in this.dicBytesToFlashBACKPACK.Keys)
      {
        byte[] numArray = this.dicBytesToFlashBACKPACK[key];
        this.dicBytesToFlashFIRMWARE.Add(key, numArray);
      }
    }

    public void showBackUps(uint meterID)
    {
      this.zippedBackUpData = BackupWindow.ShowDialog((Window) null, new uint?(meterID));
    }

    public void loadLastBackupForDevice(uint meterID)
    {
      if (!this.myHandlerForProduction.LoadLastBackup((int) meterID))
        throw new Exception("unable to load Backup for meterid => " + meterID.ToString());
    }

    public void setBackupData()
    {
      if (this.zippedBackUpData != null && !this.myHandlerForProduction.SetBackup(this.zippedBackUpData))
        throw new Exception("Can not set backup to device !!!");
    }

    public async Task<bool> makeBackUp(ProgressHandler progress, CancellationToken token)
    {
      if (this.myHandlerForProduction == null)
        throw new Exception("Handler object was not set or deleted already!!!");
      if (this.oFUI != null)
        this.oFUI.setDebugInfo(" ... reading device for backup(DUMP) ...");
      this.myHandlerForProduction.MapCheckDisabled = true;
      int retVal = await this.myHandlerForProduction.ReadDeviceAsync(progress, token, ReadPartsSelection.Dump);
      this.deviceIdentificationForBackup = this.myHandlerForProduction.GetDeviceIdentification();
      if (this.oFUI != null)
      {
        this.oFUI.setDebugInfo(" ... DONE. ");
        this.oFUI.setDebugInfo(" ... write backup to database ...");
      }
      this.myHandlerForProduction.SaveMeterObject(HandlerMeterObjects.WorkMeter);
      this.myHandlerForProduction.SaveMeter();
      if (this.oFUI != null)
        this.oFUI.setDebugInfo(" ... DONE. ");
      return true;
    }

    public async Task<bool> writeBackUpToDevice(
      ProgressHandler progress,
      CancellationToken token,
      bool setBackDataExplizit = true)
    {
      bool overwriteOk = true;
      bool is_S4_Handler = this.myHandlerForProduction.ToString().Contains("S4_Handler");
      if (this.myHandlerForProduction == null)
        throw new Exception("Handler object was not set or deleted already!!!");
      if (this.oFUI != null)
        this.oFUI.setDebugInfo("\r...reading data from device to overwrite ...");
      int retVal = await this.myHandlerForProduction.ReadDeviceAsync(progress, token, ReadPartsSelection.AllWithoutLogger);
      if (this.zippedBackUpData != null & setBackDataExplizit)
        this.setBackupData();
      else if (this.zippedBackUpData == null & setBackDataExplizit)
        throw new Exception("Backup data not found !!!");
      if (this.oFUI != null)
        this.oFUI.setDebugInfo("...overwrite data ...");
      List<CommonOverwriteGroups> overwriteGroups;
      if (is_S4_Handler)
        overwriteGroups = new List<CommonOverwriteGroups>()
        {
          CommonOverwriteGroups.IdentData,
          CommonOverwriteGroups.ZeroFlowCalibration,
          CommonOverwriteGroups.RTC_Calibration,
          CommonOverwriteGroups.CarrierFrequencyCalibration,
          CommonOverwriteGroups.TemperatureSettings,
          CommonOverwriteGroups.TypeIdentification,
          CommonOverwriteGroups.UltrasonicHydraulicTestSetup,
          CommonOverwriteGroups.ConfigurationParameters,
          CommonOverwriteGroups.RamData,
          CommonOverwriteGroups.BasicConfiguration,
          CommonOverwriteGroups.DeviceProtection,
          CommonOverwriteGroups.MenuDefinition
        };
      else
        overwriteGroups = new List<CommonOverwriteGroups>()
        {
          CommonOverwriteGroups.IdentData
        };
      foreach (CommonOverwriteGroups group in overwriteGroups)
      {
        string actualGroup = string.Empty;
        try
        {
          CommonOverwriteGroups[] whatToOverwrite = new CommonOverwriteGroups[1]
          {
            group
          };
          if (this.oFUI != null)
          {
            actualGroup = group.ToString();
            this.oFUI.setDebugInfo(" --> Overwrite data group - " + actualGroup);
          }
          this.myHandlerForProduction.OverwriteSrcToDest(HandlerMeterObjects.BackupMeter, HandlerMeterObjects.WorkMeter, whatToOverwrite);
          whatToOverwrite = (CommonOverwriteGroups[]) null;
        }
        catch (Exception ex)
        {
          if (this.oFUI != null)
          {
            this.oFUI.setDebugInfo(" !!! ERROR while overriding group (" + actualGroup + ")");
            this.oFUI.setErrorInfo(" Origin Error: \r" + ex.Message);
          }
          overwriteOk = false;
        }
        actualGroup = (string) null;
      }
      if (this.oFUI != null)
        this.oFUI.setDebugInfo(" Overwrite data groups from backup ... DONE.");
      try
      {
        await this.myHandlerForProduction.WriteDeviceAsync(progress, token);
        if (this.oFUI != null)
          this.oFUI.setDebugInfo(" --> Backup successfully written!");
      }
      catch
      {
        if (this.oFUI != null)
          this.oFUI.setDebugInfo(" --> Error on write backup data to device!!!");
        overwriteOk = false;
      }
      if (is_S4_Handler)
      {
        try
        {
          await this.myHandlerForProduction.ResetDeviceAsync(progress, token);
          if (this.oFUI != null)
            this.oFUI.setDebugInfo(" --> Software reset done!");
        }
        catch
        {
          if (this.oFUI != null)
            this.oFUI.setDebugInfo(" --> Error on Software reset!!!");
          overwriteOk = false;
        }
      }
      bool device = overwriteOk;
      overwriteGroups = (List<CommonOverwriteGroups>) null;
      return device;
    }

    public string getBootloaderInfoString()
    {
      string bootloaderInfoString = string.Empty;
      if (this.blockInfo_Bootloader != null && this.dataOfBootloader != null)
      {
        string str = bootloaderInfoString + "\r-----------------------------------------------------" + "\r - Bootloader file: " + this.dataOfBootloader.ProgFileName + "\r - Blocks: " + this.blockInfo_Bootloader.Count.ToString();
        uint num = 1;
        foreach (FirmwareBlockInfoClass firmwareBlockInfoClass in this.blockInfo_Bootloader)
          str = str + "\r" + firmwareBlockInfoClass.ToString(num++);
        bootloaderInfoString = str + "\r-----------------------------------------------------";
      }
      return bootloaderInfoString;
    }

    public async Task<string> removeProtectionFromIUW(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      string retVal = string.Empty;
      if (this.myHandlerForProduction.IsProtected())
      {
        retVal += "\r-----------------------------------------------------";
        retVal += "\rThe device is write protected!";
        retVal += "\r --> Remove write protection: ";
        await this.myHandlerForProduction.ProtectionResetByDb(progress, cancelToken, DbBasis.PrimaryDB.BaseDbConnection);
        retVal += "OK";
      }
      string str = retVal;
      retVal = (string) null;
      return str;
    }

    public void setDeviceToUpdateBlock(DeviceIdentification devIdent)
    {
      if (this.myUpDateBlock == null)
        this.myUpDateBlock = new FirmwareUpdateFunctions.UpdateDataBlock();
      this.myUpDateBlock.deviceIdent = devIdent;
    }

    public async Task<bool> DoRunFirmwareUpdateInONE(
      ProgressHandler progress,
      CancellationTokenSource cancelTS)
    {
      bool retVal = false;
      if (this.myUpDateBlock == null)
      {
        this.oFUI.setDebugInfo("Please connect to a device first and update data!");
        return false;
      }
      string allowedFW = string.Empty;
      FirmwareUpdateFunctions.UpdateDataBlock updateDataBlock = this.myUpDateBlock;
      uint version = await this.BSL_getVersion(progress, cancelTS);
      updateDataBlock.BSL_Version = version;
      updateDataBlock = (FirmwareUpdateFunctions.UpdateDataBlock) null;
      if (this.myUpDateBlock.BSL_Version > 0U)
      {
        this.oFUI.setDebugInfo("This device is already in BOOTLOADER mode.");
        FirmwareVersion locFW = new FirmwareVersion(this.myUpDateBlock.BSL_Version);
        this.oFUI.setDebugInfo(" --> BOOTLOADER Version: " + locFW.Major.ToString() + "." + locFW.Minor.ToString() + " - " + locFW.TypeString + " for " + locFW.TypeBSLString);
        long mapid = this.revealMapIDForBSLFirmwareFromDatabase(out allowedFW, this.myUpDateBlock.BSL_Version);
        string bootLoaderFirmware = this.loadThatBootloaderFileFromDB((uint) mapid);
        this.getAllPossibleFWfromDB(allowedFW, true);
        this.oFUI.setDebugInfo("Choose a firmware to flash, now.");
        locFW = new FirmwareVersion();
        bootLoaderFirmware = (string) null;
      }
      return retVal;
    }

    private void getAllPossibleFWfromDB(
      string possibleFWforBootloader = "",
      bool isBootLoaderMode = false,
      bool isMinoBLE = false)
    {
      try
      {
        SortedList<uint, HardwareTypeTables.ProgFilesRow> sortedList;
        if (!isBootLoaderMode)
        {
          string hardwareName = this.myUpDateBlock.deviceIdent.FirmwareVersionObj.TypeString;
          switch (this.myUpDateBlock.deviceIdent.FirmwareVersionObj.Type)
          {
            case 18:
              hardwareName = "EDC_mBus";
              break;
            case 33:
              hardwareName = "EDC_ModBus";
              break;
          }
          sortedList = this.loadAllFirmwareFromDatabase(this.myUpDateBlock.deviceIdent.FirmwareVersion.Value, hardwareName, possibleFWforBootloader);
        }
        else
        {
          DeviceIdentification deviceIdentification = new DeviceIdentification(this.myUpDateBlock.BSL_Version);
          sortedList = this.loadAllFirmwareFromDatabase(deviceIdentification.FirmwareVersion.Value, deviceIdentification.FirmwareVersionObj.TypeBSLString, possibleFWforBootloader);
        }
        uint num = 0;
        if (sortedList.Count > 0)
        {
          List<int> intList = new List<int>();
          for (int index = 0; index < 3; ++index)
          {
            foreach (uint key in (IEnumerable<uint>) sortedList.Keys)
            {
              HardwareTypeTables.ProgFilesRow progFilesRow = sortedList[key];
              uint firmwareVersion1 = (uint) progFilesRow.FirmwareVersion;
              if ((!isMinoBLE || firmwareVersion1 > 50331721U) && (isMinoBLE || firmwareVersion1 < 50331721U))
              {
                if (firmwareVersion1 > num)
                  num = firmwareVersion1;
                FirmwareVersion firmwareVersion2 = new FirmwareVersion(firmwareVersion1);
                string str1 = ((IEnumerable<string>) progFilesRow.Options.Split(';')).SingleOrDefault<string>((System.Func<string, bool>) (x => x.ToLower().Contains("build")));
                string str2 = "FW: " + firmwareVersion2.VersionString + " / " + progFilesRow.HardwareName + (string.IsNullOrEmpty(str1) ? "" : " / " + str1);
                string str3 = (string) null;
                if (!progFilesRow.IsReleasedNameNull() && progFilesRow.ReleasedName.Length > 0)
                {
                  str3 = progFilesRow.ReleasedName;
                  str2 = str2 + " \"" + str3 + "\"";
                }
                switch (index)
                {
                  case 0:
                    if (str3 != null && str3.ToLower().Contains("released"))
                      break;
                    continue;
                  case 1:
                    if (str3 != null)
                      break;
                    continue;
                }
                string str4 = str2 + " - MAP: " + progFilesRow.MapID.ToString();
                if (!intList.Contains(progFilesRow.MapID))
                {
                  intList.Add(progFilesRow.MapID);
                  this.oFUI.setDebugInfo(string.Empty + "FW_" + progFilesRow.FirmwareVersion.ToString() + str4);
                }
              }
            }
          }
        }
        else
          this.oFUI.setErrorInfo("\rNo Firmware found in this database.\rMaybe you should use another database.");
      }
      catch (Exception ex)
      {
        this.oFUI.setErrorInfo("Message:\n" + ex.Message);
      }
    }

    public SortedList<uint, HardwareTypeTables.ProgFilesRow> loadAllFirmwareFromDatabase(
      uint firmwareVersion = 0,
      string hardwareName = "",
      string possibleFWFromBSL = "")
    {
      if (string.IsNullOrEmpty(hardwareName))
        throw new Exception("HardwareName is not set correctly.");
      SortedList<uint, HardwareTypeTables.ProgFilesRow> sortedList = new SortedList<uint, HardwareTypeTables.ProgFilesRow>();
      return this.revealAllPossibleFirmwareFromDatabase(firmwareVersion, hardwareName, possibleFWFromBSL);
    }

    private class UpdateDataBlock
    {
      public uint BlockId;
      public DeviceIdentification deviceIdent;
      public uint BSL_Version;
      public string bootLoaderFileData;
      public string firmwareFileData;
    }
  }
}


--- FirmwareUpdateFunctionsUI.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.FirmwareUpdateFunctionsUI
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using GmmDbLib.DataSets;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class FirmwareUpdateFunctionsUI : Window, IZDebugInfo, IComponentConnector
  {
    private const string translaterBaseKey = "FirmwareUpdateTool_";
    internal readonly List<string> HardwareNames = new List<string>()
    {
      "FWUpdateToolUI"
    };
    private FirmwareUpdateFunctions oFWUpFunc;
    private Cursor defaultCursor;
    private CancellationTokenSource cancelTokenSource;
    private ProgressHandler progress;
    private DeviceIdentification deviceID;
    private uint loopsToVerify;
    private uint? MeterID;
    internal Menu menuMain;
    internal MenuItem MenuItemComponents;
    internal GmmCorporateControl gmmCorporateControl1;
    internal TextBlock TextBlockStatus;
    internal ProgressBar ProgressBar1;
    internal GroupBox GroupBoxConnected;
    internal TextBox TextBoxFWDB;
    internal ComboBox ComboBoxFWDB;
    internal TextBox TextBoxBSLDB;
    internal ComboBox ComboBoxBSLDB;
    internal TextBox TextBoxInfo;
    internal Button ButtonBackUPDevice;
    internal Button ButtonLoadBackUP;
    internal Button ButtonOverrideDevice;
    internal TextBox TextBoxMeterID;
    internal Button ButtonCreatefromArmID;
    internal StackPanel StackPanalButtons;
    internal Label LabelByteSize;
    internal TextBox TextBoxVerifyReadByteSize;
    internal Label LabelLoops;
    internal TextBox TextBoxVerifyLoops;
    internal Button ButtonFWConnect;
    internal Button ButtonFWReadARMID;
    internal Button ButtonFWLoadFromFile;
    internal Button ButtonFWLoadFromDB;
    internal Button ButtonFWDeleteOnDevice;
    internal Button ButtonFWWriteToDevice;
    internal Button ButtonFWVerifyOnDevice;
    internal Button ButtonFWReadFlashSize;
    internal Button ButtonFWReadVectorTable;
    internal Button ButtonFWWriteVectorTable;
    internal Button ButtonGo;
    internal Button ButtonFWReadMeterKey;
    internal Label LabelRange;
    internal TextBox TextBoxStartRange;
    internal TextBox TextBoxEndRange;
    internal Button ButtonBSLConnect;
    internal Button ButtonBSLReadARMID;
    internal Button ButtonBSLLoadFromFile;
    internal Button ButtonBSLLoadFromDB;
    internal Button ButtonBSLWriteToDevice;
    internal Button ButtonBSLVerifyOnDevice;
    internal Button ButtonBSLDeleteOnDevice;
    internal Button ButtonBSLOverwriteOnDevice;
    internal Button ButtonBSLReadFlashSize;
    internal Button ButtonBSLResetMeterKey;
    internal Button ButtonBSLReadFirst8Byte;
    internal Button ButtonBSLWriteFirst8Byte;
    internal Button ButtonDeviceReset;
    internal CheckBox CheckShowDetails;
    internal CheckBox CheckIgnoreError;
    internal Button ButtonWriteBSLtoDB;
    internal Button ButtonCheckFWworkWithBSL;
    internal Button ButtonClear;
    internal Button ButtonBreak;
    private bool _contentLoaded;

    public FirmwareUpdateFunctionsUI(
      FirmwareUpdateFunctions fwUpdateFunc,
      DeviceIdentification devID = null)
    {
      this.oFWUpFunc = fwUpdateFunc;
      this.oFWUpFunc.oFUI = (IZDebugInfo) this;
      this.deviceID = devID;
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
      this.loopsToVerify = 1U;
      this.MeterID = new uint?();
      this.InitializeComponent();
      this.Title = this.Title + "Firmware Update Tool UI - CoreVersion: " + fwUpdateFunc.CoreVersion;
      if (this.deviceID != null)
      {
        this.getAllPossibleBSLfromDB();
        this.getAllPossibleFWfromDB();
        this.SetStopState();
      }
      else
        this.SetStopState(false);
    }

    private void SetRunState()
    {
      this.progress.Reset("connecting...");
      this.cancelTokenSource = new CancellationTokenSource();
      this.progress.Reset();
      this.progress.Split(new double[2]{ 2.0, 98.0 });
      this.progress.Report("Run");
      this.GroupBoxConnected.IsEnabled = false;
      this.StackPanalButtons.IsEnabled = false;
      this.setButtonsEnabled(false);
      this.ButtonBreak.IsEnabled = true;
      this.defaultCursor = this.Cursor;
      this.Cursor = Cursors.Wait;
    }

    private void SetStopState(bool state = true)
    {
      this.TextBoxVerifyLoops.Text = this.loopsToVerify.ToString();
      this.TextBoxVerifyReadByteSize.Text = this.oFWUpFunc.verifyPageSize.ToString();
      this.GroupBoxConnected.IsEnabled = true;
      this.StackPanalButtons.IsEnabled = true;
      this.ButtonBreak.IsEnabled = false;
      if (this.defaultCursor != Cursors.Wait)
        this.Cursor = this.defaultCursor;
      else
        this.Cursor = Cursors.Arrow;
      this.setButtonsEnabled(state);
      this.progress.Reset();
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.ProgressBar1.Value = obj.ProgressPercentage;
        this.TextBlockStatus.Text = obj.Message;
      }
    }

    private void ButtonBreak_Click(object sender, RoutedEventArgs e)
    {
      this.cancelTokenSource.Cancel();
    }

    private void ButtonClear_Click(object sender, RoutedEventArgs e)
    {
      this.SetRunState();
      this.oFWUpFunc.clearVariables();
      this.setInfoText(DateTime.Now.ToString(), true);
      this.SetStopState();
    }

    private void getAllPossibleFWfromDB()
    {
      try
      {
        this.SetRunState();
        this.ComboBoxFWDB.Items.Clear();
        SortedList<uint, HardwareTypeTables.ProgFilesRow> sortedList1 = new SortedList<uint, HardwareTypeTables.ProgFilesRow>();
        SortedList<uint, HardwareTypeTables.ProgFilesRow> sortedList2 = this.deviceID == null ? this.oFWUpFunc.revealAllPossibleFirmwareFromDatabase() : this.oFWUpFunc.revealAllPossibleFirmwareFromDatabase(this.deviceID.FirmwareVersion.Value, this.deviceID.FirmwareVersionObj.TypeString);
        if (sortedList2.Count > 0)
        {
          foreach (uint key in (IEnumerable<uint>) sortedList2.Keys)
          {
            HardwareTypeTables.ProgFilesRow progFilesRow = sortedList2[key];
            ListBoxItem newItem = new ListBoxItem();
            FirmwareVersion firmwareVersion = new FirmwareVersion((uint) progFilesRow.FirmwareVersion);
            string[] strArray = new string[6]
            {
              "FW: ",
              firmwareVersion.VersionString,
              " / ",
              firmwareVersion.TypeString,
              " - MAP: ",
              null
            };
            int num = progFilesRow.MapID;
            strArray[5] = num.ToString();
            string str1 = string.Concat(strArray);
            newItem.Tag = (object) progFilesRow;
            ListBoxItem listBoxItem = newItem;
            num = progFilesRow.FirmwareVersion;
            string str2 = "FW_" + num.ToString();
            listBoxItem.Name = str2;
            newItem.Content = (object) str1;
            this.ComboBoxFWDB.Items.Add((object) newItem);
          }
          this.ComboBoxFWDB.Text = " -- select a firmware from here -- ";
        }
        else
        {
          this.ComboBoxFWDB.Items.Clear();
          this.ComboBoxFWDB.Text = "No Firmware found in this database.";
        }
      }
      finally
      {
        this.SetStopState();
      }
    }

    private void getAllPossibleBSLfromDB()
    {
      try
      {
        this.SetRunState();
        this.ComboBoxBSLDB.Items.Clear();
        SortedList<uint, HardwareTypeTables.ProgFilesRow> sortedList1 = new SortedList<uint, HardwareTypeTables.ProgFilesRow>();
        SortedList<uint, HardwareTypeTables.ProgFilesRow> sortedList2 = this.deviceID == null ? this.oFWUpFunc.revealAllPossibleBootloaderFromDatabase() : this.oFWUpFunc.revealAllPossibleBootloaderFromDatabase(this.deviceID.FirmwareVersion.Value);
        if (sortedList2.Count > 0)
        {
          foreach (uint key in (IEnumerable<uint>) sortedList2.Keys)
          {
            HardwareTypeTables.ProgFilesRow progFilesRow = sortedList2[key];
            ListBoxItem newItem = new ListBoxItem();
            FirmwareVersion firmwareVersion = new FirmwareVersion((uint) progFilesRow.FirmwareVersion);
            string[] strArray = new string[6]
            {
              "FW: ",
              firmwareVersion.VersionString,
              " / ",
              firmwareVersion.TypeBSLString,
              " MAP: ",
              null
            };
            int mapId = progFilesRow.MapID;
            strArray[5] = mapId.ToString();
            string str1 = string.Concat(strArray);
            newItem.Tag = (object) progFilesRow;
            ListBoxItem listBoxItem = newItem;
            string str2 = progFilesRow.HardwareName.Replace(" ", "");
            mapId = progFilesRow.MapID;
            string str3 = mapId.ToString();
            string str4 = str2 + "_" + str3;
            listBoxItem.Name = str4;
            newItem.Content = (object) str1;
            this.ComboBoxBSLDB.Items.Add((object) newItem);
          }
          this.ComboBoxBSLDB.Text = " -- select a firmware from here -- ";
        }
        else
        {
          this.ComboBoxBSLDB.Items.Clear();
          this.ComboBoxBSLDB.Text = "No Firmware found in this database.";
        }
      }
      finally
      {
        this.SetStopState();
      }
    }

    public bool? ignoreError()
    {
      return this.CheckIgnoreError.Dispatcher.Invoke<bool?>((Func<bool?>) (() => this.CheckIgnoreError.IsChecked));
    }

    public void setDeviceID(DeviceIdentification devID)
    {
      this.Dispatcher.Invoke((Action) (() => this.deviceID = devID));
      if (this.deviceID == null)
        return;
      this.MeterID = this.deviceID.MeterID;
    }

    public void setDebugInfo(string txt)
    {
      bool? nullable1 = this.CheckShowDetails.Dispatcher.Invoke<bool?>((Func<bool?>) (() => this.CheckShowDetails.IsChecked));
      int num;
      if (nullable1.HasValue)
      {
        bool? nullable2 = nullable1;
        bool flag = true;
        num = nullable2.GetValueOrDefault() == flag & nullable2.HasValue ? 1 : 0;
      }
      else
        num = 0;
      if (num == 0)
        return;
      this.Dispatcher.Invoke((Action) (() => this.setInfoText(txt)));
    }

    public void setDebugInfo(string txt, bool clear = false, int clearRows = 0)
    {
      bool? nullable1 = this.CheckShowDetails.Dispatcher.Invoke<bool?>((Func<bool?>) (() => this.CheckShowDetails.IsChecked));
      int num;
      if (nullable1.HasValue)
      {
        bool? nullable2 = nullable1;
        bool flag = true;
        num = nullable2.GetValueOrDefault() == flag & nullable2.HasValue ? 1 : 0;
      }
      else
        num = 0;
      if (num == 0)
        return;
      this.Dispatcher.Invoke((Action) (() => this.setInfoText(txt, clear, clearRows)));
    }

    public void setErrorInfo(string txt)
    {
      bool? nullable1 = this.CheckIgnoreError.Dispatcher.Invoke<bool?>((Func<bool?>) (() => this.CheckIgnoreError.IsChecked));
      int num;
      if (nullable1.HasValue)
      {
        bool? nullable2 = nullable1;
        bool flag = true;
        num = nullable2.GetValueOrDefault() == flag & nullable2.HasValue ? 1 : 0;
      }
      else
        num = 0;
      if (num == 0)
        return;
      this.Dispatcher.Invoke((Action) (() => this.setInfoText(txt)));
    }

    private void setInfoText(string txt, bool clear = false, int clearRows = 0)
    {
      if (clear)
        this.TextBoxInfo.Text = txt;
      else
        this.TextBoxInfo.Text += txt;
      this.TextBoxInfo.SelectionStart = this.TextBoxInfo.Text.Length;
      this.TextBoxInfo.ScrollToEnd();
    }

    private void setButtonsEnabled(bool enableFW = true)
    {
      this.ButtonFWConnect.IsEnabled = true;
      this.ButtonFWLoadFromFile.IsEnabled = true;
      this.ButtonFWLoadFromDB.IsEnabled = true;
      this.ButtonBSLLoadFromFile.IsEnabled = true;
      this.ButtonBSLLoadFromDB.IsEnabled = true;
      this.ButtonFWDeleteOnDevice.IsEnabled = enableFW;
      this.ButtonFWWriteToDevice.IsEnabled = enableFW;
      this.ButtonFWReadFlashSize.IsEnabled = enableFW;
      this.ButtonFWVerifyOnDevice.IsEnabled = enableFW;
      this.ButtonBSLWriteToDevice.IsEnabled = enableFW;
      this.ButtonBSLVerifyOnDevice.IsEnabled = enableFW;
      this.ButtonBSLDeleteOnDevice.IsEnabled = enableFW;
      this.ButtonBSLOverwriteOnDevice.IsEnabled = enableFW;
      this.ButtonBSLReadFlashSize.IsEnabled = enableFW;
      this.ButtonBSLReadFirst8Byte.IsEnabled = enableFW;
      this.ButtonBSLWriteFirst8Byte.IsEnabled = enableFW;
      this.ButtonDeviceReset.IsEnabled = enableFW;
      this.ButtonBSLResetMeterKey.IsEnabled = enableFW;
      this.ButtonFWReadMeterKey.IsEnabled = enableFW;
      this.ButtonGo.IsEnabled = enableFW && this.oFWUpFunc.isReady2GO;
      this.ButtonFWWriteVectorTable.Background = this.oFWUpFunc.isVectorTableLoaded ? (Brush) Brushes.Lime : (Brush) Brushes.Gainsboro;
      this.ButtonBSLWriteFirst8Byte.Background = this.oFWUpFunc.isFirstEightBytesLoaded ? (Brush) Brushes.Lime : (Brush) Brushes.Gainsboro;
      this.CheckShowDetails.IsEnabled = enableFW;
      this.TextBoxVerifyLoops.IsEnabled = enableFW;
      this.TextBoxVerifyReadByteSize.IsEnabled = enableFW;
      this.ButtonBackUPDevice.IsEnabled = enableFW && this.MeterID.HasValue;
      this.ButtonLoadBackUP.IsEnabled = enableFW && this.MeterID.HasValue;
      this.ButtonOverrideDevice.IsEnabled = enableFW && this.MeterID.HasValue && this.oFWUpFunc.zippedBackUpData != null;
      this.ButtonCreatefromArmID.IsEnabled = enableFW;
      this.ButtonFWReadVectorTable.IsEnabled = enableFW;
      this.ButtonFWWriteVectorTable.IsEnabled = enableFW;
      this.ButtonWriteBSLtoDB.IsEnabled = true;
    }

    private async void ButtonHandlerDoEvent_Click(object sender, RoutedEventArgs e)
    {
      Stopwatch myStopWatch = new Stopwatch();
      this.SetRunState();
      try
      {
        this.progress.Reset();
        if (this.cancelTokenSource == null)
          this.cancelTokenSource = new CancellationTokenSource();
        if ((Button) sender == this.ButtonFWConnect)
        {
          this.ComboBoxFWDB.Items.Clear();
          this.ComboBoxBSLDB.Items.Clear();
          myStopWatch.Start();
          DeviceIdentification deviceIdentification = await this.oFWUpFunc.ReadVersionAsync(this.progress, this.cancelTokenSource.Token);
          this.deviceID = deviceIdentification;
          deviceIdentification = (DeviceIdentification) null;
          myStopWatch.Stop();
          FirmwareVersion FWVersion = new FirmwareVersion(this.deviceID.FirmwareVersion.Value);
          SortedList<uint, HardwareTypeTables.ProgFilesRow> FWrows = this.oFWUpFunc.revealAllPossibleFirmwareFromDatabase(FWVersion.Version, FWVersion.TypeString);
          if (FWrows.Count > 0)
          {
            foreach (HardwareTypeTables.ProgFilesRow myRow in (IEnumerable<HardwareTypeTables.ProgFilesRow>) FWrows.Values)
            {
              FirmwareVersion oFWVer = new FirmwareVersion((uint) myRow.FirmwareVersion);
              ListBoxItem lbx = new ListBoxItem();
              string strBX = "FW: " + oFWVer.VersionString + " / " + myRow.HardwareName + " - MAP: " + myRow.MapID.ToString();
              lbx.Tag = (object) myRow;
              lbx.Name = "FW_" + myRow.FirmwareVersion.ToString();
              lbx.Content = (object) strBX;
              this.ComboBoxFWDB.Items.Add((object) lbx);
              oFWVer = new FirmwareVersion();
              lbx = (ListBoxItem) null;
              strBX = (string) null;
            }
            this.ComboBoxFWDB.SelectedIndex = 0;
          }
          SortedList<uint, HardwareTypeTables.ProgFilesRow> BSLrows = this.oFWUpFunc.revealAllPossibleBootloaderFromDatabase(FWVersion.Version);
          if (BSLrows.Count > 0)
          {
            foreach (HardwareTypeTables.ProgFilesRow myRow in (IEnumerable<HardwareTypeTables.ProgFilesRow>) BSLrows.Values)
            {
              FirmwareVersion oFWVer = new FirmwareVersion((uint) myRow.FirmwareVersion);
              ListBoxItem lbx = new ListBoxItem();
              string strBX = "FW: " + oFWVer.VersionString + " / " + myRow.HardwareName + " - MAP: " + myRow.MapID.ToString();
              lbx.Tag = (object) myRow;
              lbx.Name = myRow.HardwareName.Replace(" ", "") + "_" + myRow.MapID.ToString();
              lbx.Content = (object) strBX;
              this.ComboBoxBSLDB.Items.Add((object) lbx);
              oFWVer = new FirmwareVersion();
              lbx = (ListBoxItem) null;
              strBX = (string) null;
            }
            this.ComboBoxBSLDB.SelectedIndex = 0;
          }
          this.setInfoText("\n");
          this.setInfoText(this.getDeviceInfoString(this.deviceID));
          this.setInfoText("\nElapsed time: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          FWVersion = new FirmwareVersion();
          FWrows = (SortedList<uint, HardwareTypeTables.ProgFilesRow>) null;
          BSLrows = (SortedList<uint, HardwareTypeTables.ProgFilesRow>) null;
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonBSLConnect)
        {
          myStopWatch.Start();
          this.ComboBoxFWDB.Items.Clear();
          string allowedFW = string.Empty;
          uint BSLVersion = await this.oFWUpFunc.BSL_getVersion(this.progress, this.cancelTokenSource);
          long mapid = this.oFWUpFunc.revealMapIDForBSLFirmwareFromDatabase(out allowedFW, BSLVersion);
          if (mapid > 0L)
            this.oFWUpFunc.loadThatBootloaderFileFromDB((uint) mapid);
          DeviceIdentification BSL = new DeviceIdentification(BSLVersion);
          SortedList<uint, HardwareTypeTables.ProgFilesRow> FWrows = this.oFWUpFunc.revealAllPossibleFirmwareFromDatabase(BSL.FirmwareVersion.Value, BSL.FirmwareVersionObj.TypeBSLString, allowedFW);
          if (FWrows.Count > 0)
          {
            foreach (HardwareTypeTables.ProgFilesRow myRow in (IEnumerable<HardwareTypeTables.ProgFilesRow>) FWrows.Values)
            {
              FirmwareVersion oFWVer = new FirmwareVersion((uint) myRow.FirmwareVersion);
              ListBoxItem lbx = new ListBoxItem();
              string strBX = "FW: " + oFWVer.VersionString + " / " + myRow.HardwareName + " - MAP: " + myRow.MapID.ToString();
              lbx.Tag = (object) myRow;
              lbx.Name = "FW_" + myRow.FirmwareVersion.ToString();
              lbx.Content = (object) strBX;
              this.ComboBoxFWDB.Items.Add((object) lbx);
              oFWVer = new FirmwareVersion();
              lbx = (ListBoxItem) null;
              strBX = (string) null;
            }
            this.ComboBoxFWDB.SelectedIndex = 0;
          }
          myStopWatch.Stop();
          this.setInfoText("\n");
          this.setInfoText("\nBOOTLOADER: " + this.oFWUpFunc.BSLversion.ToString());
          this.setInfoText("\nElapsed time: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          allowedFW = (string) null;
          BSL = (DeviceIdentification) null;
          FWrows = (SortedList<uint, HardwareTypeTables.ProgFilesRow>) null;
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonBSLWriteToDevice)
        {
          myStopWatch.Start();
          this.setInfoText("\nStart writing Bootloader to device... ");
          await this.oFWUpFunc.writeBootLoaderToDevice128kb(this.progress, this.cancelTokenSource.Token);
          myStopWatch.Stop();
          this.setInfoText("\nDONE, written BOOTLOADER to device in " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonFWWriteToDevice)
        {
          myStopWatch.Start();
          this.setInfoText("\nStart writing NEW FIRMWARE to device... ");
          if (this.oFWUpFunc.BSL_isIUW())
          {
            if (this.oFWUpFunc.blockInfo_Firmware != null)
              await this.oFWUpFunc.BSL_writeNewFW_IUW_BLOCKMODE(this.progress, this.cancelTokenSource);
            else
              await this.oFWUpFunc.BSL_writeNewFW_IUW(this.progress, this.cancelTokenSource);
          }
          else
            await this.oFWUpFunc.BSL_writeNewFW(this.progress, this.cancelTokenSource);
          myStopWatch.Stop();
          this.setInfoText("\nDONE, written firmware to device in " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonFWVerifyOnDevice)
        {
          if (this.oFWUpFunc.dicBytesToFlashFIRMWARE == null || this.oFWUpFunc.dicBytesToFlashFIRMWARE.Count < 1)
            throw new Exception("Select FIRMWARE first !!!");
          List<AddressRange> listADR = new List<AddressRange>();
          AddressRange gapBSL = (AddressRange) null;
          if (this.oFWUpFunc.iBootLoaderStartAddress > 0U && this.oFWUpFunc.iBootLoaderEndAddress > 0U)
          {
            gapBSL = new AddressRange(this.oFWUpFunc.iBootLoaderStartAddress);
            gapBSL.EndAddress = this.oFWUpFunc.iBootLoaderEndAddress;
            listADR.Add(gapBSL);
          }
          else
            this.CheckIgnoreError.IsChecked = new bool?(true);
          uint loops = 1;
          uint size = 128;
          uint.TryParse(this.TextBoxVerifyReadByteSize.Text, out size);
          uint.TryParse(this.TextBoxVerifyLoops.Text, out loops);
          this.oFWUpFunc.verifyPageSize = size;
          uint runs = 1;
          while (runs <= loops)
          {
            this.setInfoText("\nVerify FIRMWARE ...START...");
            this.setInfoText("\nreading size set to (" + size.ToString() + ") bytes.");
            this.setInfoText("\nlooping verify (" + runs.ToString() + "/" + loops.ToString() + ")");
            myStopWatch.Restart();
            if (this.oFWUpFunc.BSL_isIUW())
            {
              await this.oFWUpFunc.verifyFirmwareCRCAsync(this.progress, this.cancelTokenSource);
              break;
            }
            bool isGapVerify = true;
            uint startRange = 0;
            uint endRange = 0;
            isGapVerify &= FirmwareUpdateFunctionsUI.TryParseHex(this.TextBoxStartRange.Text, out startRange);
            isGapVerify &= FirmwareUpdateFunctionsUI.TryParseHex(this.TextBoxEndRange.Text, out endRange);
            if (isGapVerify)
            {
              AddressRange gapVerify = new AddressRange(startRange);
              gapVerify.EndAddress = endRange;
              listADR.Add(gapVerify);
              gapVerify = (AddressRange) null;
            }
            await this.oFWUpFunc.verifyFirmwareAsync(this.progress, this.cancelTokenSource, listADR);
            myStopWatch.Stop();
            this.setInfoText("\nVerify FIRMWARE ... running: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
            ++runs;
            if (loops == 99U)
            {
              if (size >= 1024U)
                size = 64U;
              this.oFWUpFunc.verifyPageSize = (size += 64U);
            }
          }
          listADR = (List<AddressRange>) null;
          gapBSL = (AddressRange) null;
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonBSLVerifyOnDevice)
        {
          myStopWatch.Start();
          uint pageSize = 128;
          if (uint.TryParse(this.TextBoxVerifyReadByteSize.Text, out pageSize))
          {
            if (this.oFWUpFunc.BSL_isIUW())
              await this.oFWUpFunc.verifyBootloaderCRCAsync(this.progress, this.cancelTokenSource);
            else
              await this.oFWUpFunc.verifyBootLoaderAsync(this.progress, this.cancelTokenSource, pageSize: pageSize);
          }
          else
            this.setErrorInfo("ByteSize has wrong format !!! Please enter correct value.");
          myStopWatch.Stop();
          this.setInfoText("\nVerify BOOTLOADER ... running: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonGo)
        {
          myStopWatch.Start();
          this.oFWUpFunc.BSL_GO(this.progress, this.cancelTokenSource).Wait(1500);
          myStopWatch.Stop();
          this.setInfoText("\nstarting FW init process ... running: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          this.setInfoText("\nDONE.");
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonBSLReadFlashSize)
        {
          myStopWatch.Start();
          ushort BTL_FlashSize = await this.oFWUpFunc.BSL_getFLASHSize(this.progress, this.cancelTokenSource);
          this.setInfoText("\nFlashSize: " + BTL_FlashSize.ToString() + "kByte");
          myStopWatch.Stop();
          this.setInfoText("\nRead Flash size from device ... running: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonFWReadFlashSize)
        {
          myStopWatch.Start();
          ushort BTL_FlashSize = await this.oFWUpFunc.BSL_getFLASHSize(this.progress, this.cancelTokenSource, false);
          this.setInfoText("\nFlashSize: " + BTL_FlashSize.ToString() + "kByte");
          myStopWatch.Stop();
          this.setInfoText("\nRead Flash size from device ... running: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonBSLReadARMID)
        {
          myStopWatch.Start();
          byte[] ArmID = await this.oFWUpFunc.BSL_getARM_ID(this.progress, this.cancelTokenSource);
          this.setInfoText("\nUnique ID: " + Util.ByteArrayToHexString(ArmID));
          uint? nullable = await this.oFWUpFunc.getMeterIDFromARM_ID(this.progress, this.cancelTokenSource, ArmID);
          this.MeterID = nullable;
          nullable = new uint?();
          this.setInfoText("\nMeterID: " + (this.MeterID.HasValue ? this.MeterID.Value.ToString() : " ---> no MeterID found !!!"));
          this.TextBoxMeterID.Text = this.MeterID.ToString();
          myStopWatch.Stop();
          this.setInfoText("\nRead Flash size from device ... running: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          ArmID = (byte[]) null;
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonFWReadARMID)
        {
          myStopWatch.Start();
          byte[] ArmID = await this.oFWUpFunc.BSL_getARM_ID(this.progress, this.cancelTokenSource, false);
          this.setInfoText("\nUnique ID: " + Util.ByteArrayToHexString(ArmID));
          uint? nullable = await this.oFWUpFunc.getMeterIDFromARM_ID(this.progress, this.cancelTokenSource, ArmID);
          this.MeterID = nullable;
          nullable = new uint?();
          this.setInfoText("\nMeterID: " + (this.MeterID.HasValue ? this.MeterID.Value.ToString() : " ---> no MeterID found !!!"));
          this.TextBoxMeterID.Text = this.MeterID.ToString();
          myStopWatch.Stop();
          this.setInfoText("\nRead Flash size from device ... running: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          ArmID = (byte[]) null;
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonFWDeleteOnDevice)
        {
          myStopWatch.Start();
          await this.oFWUpFunc.BSL_eraseOldFW(this.progress, this.cancelTokenSource);
          myStopWatch.Stop();
          this.setInfoText("\nErase old FIRMWARE ... running: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonBSLDeleteOnDevice)
        {
          myStopWatch.Start();
          uint size = this.oFWUpFunc.iBootLoaderEndAddress - this.oFWUpFunc.iBootLoaderStartAddress;
          await this.oFWUpFunc.deleteBSLfromDevice(this.progress, this.cancelTokenSource, this.oFWUpFunc.iBootLoaderStartAddress, size);
          myStopWatch.Stop();
          this.setInfoText("\nDelete BOOTLOADER from device ... running: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonFWReadVectorTable)
        {
          myStopWatch.Start();
          await this.oFWUpFunc.readVectorTableFromDevice(this.progress, this.cancelTokenSource, this.oFWUpFunc.iFlashStartAdr);
          myStopWatch.Stop();
          this.setInfoText("\nRead vector table from device ... running: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonFWWriteVectorTable)
        {
          myStopWatch.Start();
          await this.oFWUpFunc.writeVectorTableToFLASH(this.progress, this.cancelTokenSource);
          myStopWatch.Stop();
          this.setInfoText("\nWrite vector table to device ... running: " + ((double) myStopWatch.ElapsedMilliseconds / 1000.0).ToString() + " sec.");
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonFWLoadFromFile)
        {
          myStopWatch.Start();
          this.oFWUpFunc.loadFirmwareFromFile();
          foreach (FirmwareBlockInfoClass fwBI in this.oFWUpFunc.blockInfo_Firmware)
            this.setInfoText(fwBI.ToString(0U));
          myStopWatch.Stop();
          this.setInfoText("\nLoad FW for device: " + this.oFWUpFunc.strFileName);
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonBSLLoadFromFile)
        {
          myStopWatch.Start();
          this.oFWUpFunc.loadBootloaderFromFile();
          if (this.oFWUpFunc.blockInfo_Bootloader != null)
          {
            foreach (FirmwareBlockInfoClass fwBI in this.oFWUpFunc.blockInfo_Bootloader)
              this.setInfoText(fwBI.ToString(0U));
            myStopWatch.Stop();
            this.setInfoText("\nLoad BSL file for device: " + this.oFWUpFunc.strFileName);
            myStopWatch = (Stopwatch) null;
          }
          else
          {
            this.setInfoText("\nno bootloader selected!!!");
            myStopWatch = (Stopwatch) null;
          }
        }
        else if ((Button) sender == this.ButtonBSLReadFirst8Byte)
        {
          myStopWatch.Start();
          this.oFWUpFunc.readFirstEightBytesFromBootLoader();
          myStopWatch.Stop();
          this.setInfoText("\nRead first eight bytes: " + Util.ByteArrayToHexString(this.oFWUpFunc.baFirstEightBytesFromHexFile));
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonBSLWriteFirst8Byte)
        {
          myStopWatch.Start();
          await this.oFWUpFunc.writeFirstEightBytesToFLASH(this.progress, this.cancelTokenSource.Token);
          myStopWatch.Stop();
          this.setInfoText("\nFirst eight bytes written successfully to device.");
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonDeviceReset)
        {
          myStopWatch.Start();
          this.oFWUpFunc.readFirstEightBytesFromBootLoader();
          await this.oFWUpFunc.writeFirstEightBytesToFLASH(this.progress, this.cancelTokenSource.Token);
          await this.oFWUpFunc.doSystemResetFunction(this.progress, this.cancelTokenSource);
          myStopWatch.Stop();
          this.setInfoText("\nSystem Reset done....");
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonBSLLoadFromDB)
        {
          this.setInfoText("\nLoading selected bootloader from database...");
          if (this.ComboBoxBSLDB.SelectedItem != null)
          {
            myStopWatch.Start();
            HardwareTypeTables.ProgFilesRow select = (HardwareTypeTables.ProgFilesRow) ((FrameworkElement) this.ComboBoxBSLDB.SelectedItem).Tag;
            string fileName = this.oFWUpFunc.loadThatBootloaderFileFromDB((uint) select.MapID);
            myStopWatch.Stop();
            this.setInfoText("\nBSL: " + fileName);
            this.setInfoText("\nBootloader successfully loaded...");
            select = (HardwareTypeTables.ProgFilesRow) null;
            fileName = (string) null;
            myStopWatch = (Stopwatch) null;
          }
          else
          {
            this.setInfoText("Please select a Bootloader from ComboBox first ...");
            myStopWatch = (Stopwatch) null;
          }
        }
        else if ((Button) sender == this.ButtonFWLoadFromDB)
        {
          this.setInfoText("\nLoading selected firmware from database...");
          if (this.ComboBoxFWDB.SelectedItem != null)
          {
            myStopWatch.Start();
            HardwareTypeTables.ProgFilesRow select = (HardwareTypeTables.ProgFilesRow) ((FrameworkElement) this.ComboBoxFWDB.SelectedItem).Tag;
            this.oFWUpFunc.loadFirmwareFileFromDB((uint) select.MapID);
            myStopWatch.Stop();
            if (this.oFWUpFunc.dicBytesToFlashFIRMWARE.Count > 0)
              this.setInfoText("\nFirmware successfully loaded...");
            else
              this.setInfoText("\nFirmware NOT loaded, please connect again to the device ...");
            select = (HardwareTypeTables.ProgFilesRow) null;
            myStopWatch = (Stopwatch) null;
          }
          else
          {
            this.setInfoText("Please select a Firmware from ComboBox first ...");
            myStopWatch = (Stopwatch) null;
          }
        }
        else if ((Button) sender == this.ButtonWriteBSLtoDB)
        {
          CompatibleFirmwareWindow compatibleFirmwareWindow = new CompatibleFirmwareWindow(105, "Bootloader", new uint?(this.oFWUpFunc.BSLversion.Version));
          compatibleFirmwareWindow.ShowDialog();
          compatibleFirmwareWindow = (CompatibleFirmwareWindow) null;
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonCheckFWworkWithBSL)
        {
          this.setInfoText("\nChecking firmware and bootloader memory area...");
          string strMessage = string.Empty;
          if (!this.oFWUpFunc.isFirmwarecompatibleWithActualSelectedBootloader(out strMessage))
            this.setInfoText("\nAttention!!!" + strMessage + "\nCONFLICTS !!! ... FAIL !!!");
          else
            this.setInfoText(strMessage + "\nNO CONFLICTS ... OK");
          strMessage = (string) null;
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonBSLOverwriteOnDevice)
        {
          this.setInfoText("\nOverwriting bootloader with firmware ...");
          string strMessage = string.Empty;
          int num = await this.oFWUpFunc.overwriteBSLfromDevice(this.progress, this.cancelTokenSource) ? 1 : 0;
          this.setInfoText("\nOverwrite DONE!");
          strMessage = (string) null;
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender == this.ButtonFWReadMeterKey)
        {
          await this.readOrResetMeterKey(true);
          myStopWatch = (Stopwatch) null;
        }
        else if ((Button) sender != this.ButtonBSLResetMeterKey)
        {
          myStopWatch = (Stopwatch) null;
        }
        else
        {
          this.setInfoText("\n\nResetting MeterKey for protection ... ");
          await this.readOrResetMeterKey();
          this.setInfoText("done.");
          this.setInfoText("\nRESET of MeterKey DONE!");
          myStopWatch = (Stopwatch) null;
        }
      }
      catch (Exception ex)
      {
        this.setInfoText("\nError occured while button was pressed... \n" + ex.Message + "\n" + ex.InnerException?.ToString());
        myStopWatch = (Stopwatch) null;
      }
      finally
      {
        this.SetStopState();
      }
    }

    internal async Task readOrResetMeterKey(bool bReadOnly = false)
    {
      string strMessage = string.Empty;
      byte[] baVectorTables = (byte[]) null;
      if (!this.oFWUpFunc.isBSLrunning && !bReadOnly)
      {
        this.setInfoText("\n--> reading first 8 bytes from device... ");
        baVectorTables = await this.oFWUpFunc.getVectorTableFromDevice(this.progress, this.cancelTokenSource);
        this.setInfoText("done.");
        this.setInfoText("\n--> loading bootloader from database... ");
        HardwareTypeTables.ProgFilesRow select = (HardwareTypeTables.ProgFilesRow) ((FrameworkElement) this.ComboBoxBSLDB.SelectedItem).Tag;
        string fileName = this.oFWUpFunc.loadThatBootloaderFileFromDB((uint) select.MapID);
        this.setInfoText("\n--> BSL: " + fileName);
        this.setInfoText("\n--> Bootloader successfully loaded...");
        this.setInfoText("\n--> writing bootloader to device... ");
        await this.oFWUpFunc.writeBootLoaderToDevice128kb(this.progress, this.cancelTokenSource.Token);
        this.setInfoText("done.");
        this.setInfoText("\n--> starting bootloader ... ");
        await this.oFWUpFunc.prepareUpdate(this.progress, this.cancelTokenSource);
        this.setInfoText("done.");
        select = (HardwareTypeTables.ProgFilesRow) null;
        fileName = (string) null;
      }
      this.setInfoText("\n--> reading MeterKey from device ... ");
      try
      {
        byte[] meterKey = await this.oFWUpFunc.BSL_readMeterKey(this.progress, this.cancelTokenSource);
        string strMeterKey = Utility.ByteArrayToHexString(meterKey);
        this.setInfoText("done.");
        this.setInfoText("\n--> MeterKey = " + strMeterKey);
        if (!bReadOnly)
        {
          this.setInfoText("\n--> reset MeterKey ... ");
          await this.oFWUpFunc.BSL_writeMeterKey(this.progress, this.cancelTokenSource);
          this.setInfoText("done.");
        }
        meterKey = (byte[]) null;
        strMeterKey = (string) null;
      }
      catch (Exception ex)
      {
        this.setInfoText("\n Message :\n" + ex.Message);
        this.setInfoText("\n--> not able to read MeterKey from device !!! ");
        this.setInfoText("\n--> reboot device to actual firmware ");
      }
      if (bReadOnly)
      {
        strMessage = (string) null;
        baVectorTables = (byte[]) null;
      }
      else
      {
        this.setInfoText("\n--> set vector table ... ");
        if (baVectorTables == null)
          baVectorTables = this.oFWUpFunc.getVectorTableFromFirmware();
        await this.oFWUpFunc.writeVectorTableToFLASH(this.progress, this.cancelTokenSource, baVectorTables);
        this.setInfoText("done.");
        this.setInfoText("\n--> init firmware ... ");
        this.oFWUpFunc.isReady2GO = true;
        await this.oFWUpFunc.BSL_GO(this.progress, this.cancelTokenSource);
        this.oFWUpFunc.isReady2GO = false;
        strMessage = (string) null;
        baVectorTables = (byte[]) null;
      }
    }

    internal string getDeviceInfoString(DeviceIdentification deviceIdentification)
    {
      if (deviceIdentification == null)
        throw new Exception("ERROR: DeviceIdentification not set.");
      string[] strArray = new string[6]
      {
        string.Empty + "\n",
        "FirmwareVersion:   ",
        null,
        null,
        null,
        null
      };
      FirmwareVersion firmwareVersionObj = deviceIdentification.FirmwareVersionObj;
      strArray[2] = firmwareVersionObj.Version.ToString("x8");
      strArray[3] = " - (";
      firmwareVersionObj = deviceIdentification.FirmwareVersionObj;
      strArray[4] = firmwareVersionObj.ToString();
      strArray[5] = ")\r";
      return string.Concat(strArray) + "SerialNo.:         " + (deviceIdentification.FullSerialNumber != null ? deviceIdentification.FullSerialNumber.ToString() : "n/a") + "\r" + "Manufacturer:      " + (!string.IsNullOrEmpty(deviceIdentification.ManufacturerName) ? deviceIdentification.ManufacturerName : "n/a") + "\r" + "Medium:            " + (!string.IsNullOrEmpty(deviceIdentification.GetMediumAsText()) ? deviceIdentification.GetMediumAsText() : "n/a") + "\r" + "MeterID:           " + (deviceIdentification.MeterID.HasValue ? deviceIdentification.MeterID.ToString() : "n/a") + "\r" + "SAP OrderNo.:      " + (deviceIdentification.SAP_ProductionOrderNumber != null ? deviceIdentification.SAP_ProductionOrderNumber : "n/a") + "\r";
    }

    private async void ButtonBackUPDevice_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.setInfoText("\n...read and backup identification of connected device ...");
        bool retVal = await this.oFWUpFunc.makeBackUp(new ProgressHandler(new Action<ProgressArg>(this.OnProgress)), new CancellationToken());
        this.TextBoxMeterID.Text = this.oFWUpFunc.deviceIdentificationForBackup.MeterID.ToString();
        this.setInfoText("\n...done.... " + retVal.ToString());
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show("Error:\n" + ex.Message);
      }
    }

    private async void ButtonOverrideDevice_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        string MeterID = this.TextBoxMeterID.Text;
        uint uiMeterID = 0;
        bool isMeterID_OK = uint.TryParse(MeterID, out uiMeterID);
        if (!isMeterID_OK && (this.oFWUpFunc.deviceIdentificationForBackup == null || !this.oFWUpFunc.deviceIdentificationForBackup.MeterID.HasValue))
        {
          this.setInfoText("\n...identification for device is not set correctly! (MeterID) ");
        }
        else
        {
          this.setInfoText("\n...writing backup for device with meterid = " + uiMeterID.ToString());
          int num = await this.oFWUpFunc.writeBackUpToDevice(new ProgressHandler(new Action<ProgressArg>(this.OnProgress)), new CancellationToken()) ? 1 : 0;
          this.setInfoText("\n...DONE. ");
          MeterID = (string) null;
        }
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show("Error:\n" + ex.Message);
      }
    }

    private void ButtonLoadBackUP_Click(object sender, RoutedEventArgs e)
    {
      this.setInfoText("\n...select Backup from database ...");
      this.oFWUpFunc.showBackUps(this.MeterID.Value);
      if (this.oFWUpFunc.zippedBackUpData != null)
      {
        this.setInfoText("\n...successfully load backup from database ...");
        this.oFWUpFunc.setBackupData();
        this.setInfoText("\n...set backup data for overwrite ...");
        this.ButtonOverrideDevice.IsEnabled = true;
        this.setInfoText("\n...DONE. ");
      }
      else
      {
        this.setInfoText("\n...no backup loaded !!!");
        this.ButtonOverrideDevice.IsEnabled = false;
      }
    }

    private async void ButtonCreatefromArmID_Click(object sender, RoutedEventArgs e)
    {
      this.setInfoText("\n...creating METERID from ArmID ...");
      byte[] ArmID = await this.oFWUpFunc.BSL_getARM_ID(this.progress, this.cancelTokenSource, false);
      this.setInfoText("\nUnique ID: " + Util.ByteArrayToHexString(ArmID));
      uint? nullable = await this.oFWUpFunc.createMeterIDFromARM_ID(this.progress, this.cancelTokenSource, ArmID);
      uint? localMeterID = nullable;
      nullable = new uint?();
      uint num = localMeterID.Value;
      this.setInfoText("\nMeterID: " + num.ToString());
      this.MeterID = localMeterID;
      TextBox textBoxMeterId = this.TextBoxMeterID;
      num = this.MeterID.Value;
      string str = num.ToString();
      textBoxMeterId.Text = str;
      ArmID = (byte[]) null;
    }

    private static bool TryParseHex(string hex, out uint result)
    {
      result = 0U;
      if (hex == null)
        return false;
      try
      {
        result = Convert.ToUInt32(hex, 16);
        return true;
      }
      catch
      {
        return false;
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/hardwaremanagement/firmwareupdatefunctionsui.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.menuMain = (Menu) target;
          break;
        case 2:
          this.MenuItemComponents = (MenuItem) target;
          break;
        case 3:
          this.gmmCorporateControl1 = (GmmCorporateControl) target;
          break;
        case 4:
          this.TextBlockStatus = (TextBlock) target;
          break;
        case 5:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        case 6:
          this.GroupBoxConnected = (GroupBox) target;
          break;
        case 7:
          this.TextBoxFWDB = (TextBox) target;
          break;
        case 8:
          this.ComboBoxFWDB = (ComboBox) target;
          break;
        case 9:
          this.TextBoxBSLDB = (TextBox) target;
          break;
        case 10:
          this.ComboBoxBSLDB = (ComboBox) target;
          break;
        case 11:
          this.TextBoxInfo = (TextBox) target;
          break;
        case 12:
          this.ButtonBackUPDevice = (Button) target;
          this.ButtonBackUPDevice.Click += new RoutedEventHandler(this.ButtonBackUPDevice_Click);
          break;
        case 13:
          this.ButtonLoadBackUP = (Button) target;
          this.ButtonLoadBackUP.Click += new RoutedEventHandler(this.ButtonLoadBackUP_Click);
          break;
        case 14:
          this.ButtonOverrideDevice = (Button) target;
          this.ButtonOverrideDevice.Click += new RoutedEventHandler(this.ButtonOverrideDevice_Click);
          break;
        case 15:
          this.TextBoxMeterID = (TextBox) target;
          break;
        case 16:
          this.ButtonCreatefromArmID = (Button) target;
          this.ButtonCreatefromArmID.Click += new RoutedEventHandler(this.ButtonCreatefromArmID_Click);
          break;
        case 17:
          this.StackPanalButtons = (StackPanel) target;
          break;
        case 18:
          this.LabelByteSize = (Label) target;
          break;
        case 19:
          this.TextBoxVerifyReadByteSize = (TextBox) target;
          break;
        case 20:
          this.LabelLoops = (Label) target;
          break;
        case 21:
          this.TextBoxVerifyLoops = (TextBox) target;
          break;
        case 22:
          this.ButtonFWConnect = (Button) target;
          this.ButtonFWConnect.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 23:
          this.ButtonFWReadARMID = (Button) target;
          this.ButtonFWReadARMID.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 24:
          this.ButtonFWLoadFromFile = (Button) target;
          this.ButtonFWLoadFromFile.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 25:
          this.ButtonFWLoadFromDB = (Button) target;
          this.ButtonFWLoadFromDB.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 26:
          this.ButtonFWDeleteOnDevice = (Button) target;
          this.ButtonFWDeleteOnDevice.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 27:
          this.ButtonFWWriteToDevice = (Button) target;
          this.ButtonFWWriteToDevice.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 28:
          this.ButtonFWVerifyOnDevice = (Button) target;
          this.ButtonFWVerifyOnDevice.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 29:
          this.ButtonFWReadFlashSize = (Button) target;
          this.ButtonFWReadFlashSize.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 30:
          this.ButtonFWReadVectorTable = (Button) target;
          this.ButtonFWReadVectorTable.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 31:
          this.ButtonFWWriteVectorTable = (Button) target;
          this.ButtonFWWriteVectorTable.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 32:
          this.ButtonGo = (Button) target;
          this.ButtonGo.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 33:
          this.ButtonFWReadMeterKey = (Button) target;
          this.ButtonFWReadMeterKey.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 34:
          this.LabelRange = (Label) target;
          break;
        case 35:
          this.TextBoxStartRange = (TextBox) target;
          break;
        case 36:
          this.TextBoxEndRange = (TextBox) target;
          break;
        case 37:
          this.ButtonBSLConnect = (Button) target;
          this.ButtonBSLConnect.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 38:
          this.ButtonBSLReadARMID = (Button) target;
          this.ButtonBSLReadARMID.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 39:
          this.ButtonBSLLoadFromFile = (Button) target;
          this.ButtonBSLLoadFromFile.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 40:
          this.ButtonBSLLoadFromDB = (Button) target;
          this.ButtonBSLLoadFromDB.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 41:
          this.ButtonBSLWriteToDevice = (Button) target;
          this.ButtonBSLWriteToDevice.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 42:
          this.ButtonBSLVerifyOnDevice = (Button) target;
          this.ButtonBSLVerifyOnDevice.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 43:
          this.ButtonBSLDeleteOnDevice = (Button) target;
          this.ButtonBSLDeleteOnDevice.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 44:
          this.ButtonBSLOverwriteOnDevice = (Button) target;
          this.ButtonBSLOverwriteOnDevice.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 45:
          this.ButtonBSLReadFlashSize = (Button) target;
          this.ButtonBSLReadFlashSize.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 46:
          this.ButtonBSLResetMeterKey = (Button) target;
          this.ButtonBSLResetMeterKey.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 47:
          this.ButtonBSLReadFirst8Byte = (Button) target;
          this.ButtonBSLReadFirst8Byte.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 48:
          this.ButtonBSLWriteFirst8Byte = (Button) target;
          this.ButtonBSLWriteFirst8Byte.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 49:
          this.ButtonDeviceReset = (Button) target;
          this.ButtonDeviceReset.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 50:
          this.CheckShowDetails = (CheckBox) target;
          break;
        case 51:
          this.CheckIgnoreError = (CheckBox) target;
          break;
        case 52:
          this.ButtonWriteBSLtoDB = (Button) target;
          this.ButtonWriteBSLtoDB.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 53:
          this.ButtonCheckFWworkWithBSL = (Button) target;
          this.ButtonCheckFWworkWithBSL.Click += new RoutedEventHandler(this.ButtonHandlerDoEvent_Click);
          break;
        case 54:
          this.ButtonClear = (Button) target;
          this.ButtonClear.Click += new RoutedEventHandler(this.ButtonClear_Click);
          break;
        case 55:
          this.ButtonBreak = (Button) target;
          this.ButtonBreak.Click += new RoutedEventHandler(this.ButtonBreak_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- FirmwareUpdateToolDeviceCommands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.FirmwareUpdateToolDeviceCommands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using NLog;
using System;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public abstract class FirmwareUpdateToolDeviceCommands
  {
    internal static Logger FirmwareUpdateTool_DeviceCommandsLogger = LogManager.GetLogger("FirmwareUpdateTool_DeviceCommands");
    private string messageNotImplemented = "Method not implemented for actual connection type!!!";
    public bool usingSubUnitCommands = false;

    public DeviceIdentification ConnectedDeviceVersion => this.GetDeviceVersionObject();

    protected abstract DeviceIdentification GetDeviceVersionObject();

    public bool IsDeviceIdentified => this.ConnectedDeviceVersion != null;

    public virtual async Task<byte[]> ReadMemoryAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      uint startAdress,
      uint size)
    {
      throw new Exception(this.messageNotImplemented);
    }

    public virtual async Task<byte[]> ReadMemoryAsync(
      ProgressHandler progress,
      CancellationToken token,
      uint address,
      uint count,
      byte maxBytesPerPacket)
    {
      throw new Exception(this.messageNotImplemented);
    }

    public virtual async Task WriteMemoryAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      uint startAdress,
      byte[] bytes)
    {
      throw new Exception(this.messageNotImplemented);
    }

    internal virtual void SetIdentificationLikeInFirmware(
      uint serialNumberBCD,
      ushort manufacturerCode,
      byte generation,
      byte mediumCode)
    {
      throw new Exception(this.messageNotImplemented);
    }

    internal virtual Task<byte[]> getVersion() => throw new Exception(this.messageNotImplemented);

    public virtual async Task<byte[]> getVersionAsync(
      ProgressHandler progress,
      CancellationToken token)
    {
      throw new Exception(this.messageNotImplemented);
    }

    public virtual async Task<DeviceIdentification> ReadVersionAsync(
      ProgressHandler progress,
      CancellationToken token)
    {
      throw new Exception(this.messageNotImplemented);
    }

    public virtual async Task<int> ReadDeviceAsync(
      ProgressHandler progress,
      CancellationToken token,
      ReadPartsSelection readPartsSelection)
    {
      throw new Exception(this.messageNotImplemented);
    }

    public virtual async Task ResetDeviceAsync(ProgressHandler progress, CancellationToken token)
    {
      throw new Exception(this.messageNotImplemented);
    }

    public virtual void SetBlockMode(bool modeOn = true, uint size = 512)
    {
      throw new Exception(this.messageNotImplemented);
    }

    public virtual void SetParameter(string parameterName, uint parameterValue)
    {
      throw new Exception(this.messageNotImplemented);
    }

    public virtual async Task<ushort> VerifyMemoryAsync(
      ProgressHandler progress,
      CancellationToken token,
      uint startAddress,
      uint endAddress)
    {
      throw new Exception(this.messageNotImplemented);
    }

    public virtual ushort VerifyMemory(uint startAddress, uint endAddress)
    {
      throw new Exception(this.messageNotImplemented);
    }
  }
}


--- FunctionDoesNotMakeSenseException.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.FunctionDoesNotMakeSenseException
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Runtime.Serialization;

#nullable disable
namespace HandlerLib
{
  public class FunctionDoesNotMakeSenseException : Exception
  {
    public FunctionDoesNotMakeSenseException()
    {
    }

    public FunctionDoesNotMakeSenseException(string message)
      : base(message)
    {
    }

    public FunctionDoesNotMakeSenseException(string message, Exception inner)
      : base(message, inner)
    {
    }

    protected FunctionDoesNotMakeSenseException(SerializationInfo info, StreamingContext context)
    {
    }
  }
}


--- GetCommandValues.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.GetCommandValues
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

#nullable disable
namespace HandlerLib
{
  public static class GetCommandValues
  {
    public static Dictionary<string, string> GetAllPrivateStaticFieldValuesForCommands(object obj)
    {
      return ((IEnumerable<FieldInfo>) obj.GetType().GetFields(BindingFlags.IgnoreCase | BindingFlags.Static | BindingFlags.NonPublic)).Where<FieldInfo>((Func<FieldInfo, bool>) (f => f.FieldType == typeof (string) && f.Name.Contains("CMD_"))).ToDictionary<FieldInfo, string, string>((Func<FieldInfo, string>) (f => f.Name), (Func<FieldInfo, string>) (f => (string) f.GetValue((object) null)));
    }
  }
}


--- HandlerFunctionsForProduction.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.HandlerFunctionsForProduction
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.Functions;
using GmmDbLib;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class HandlerFunctionsForProduction : IHandler, IReadoutConfig
  {
    public virtual bool MapCheckDisabled { get; set; }

    public DeviceMemory DeviceMemory { get; set; }

    public virtual void SetCommunicationPort(CommunicationPortFunctions myPort = null)
    {
      throw new NotImplementedException(nameof (SetCommunicationPort));
    }

    public virtual void Open() => throw new NotImplementedException(nameof (Open));

    public virtual void Close() => throw new NotImplementedException(nameof (Close));

    public virtual void SetReadoutConfiguration(ConfigList configList)
    {
      throw new NotImplementedException(nameof (SetReadoutConfiguration));
    }

    public virtual ConfigList GetReadoutConfiguration()
    {
      throw new NotImplementedException(nameof (GetReadoutConfiguration));
    }

    public virtual Task<int> ReadDeviceAsync(
      ProgressHandler progress,
      CancellationToken token,
      ReadPartsSelection readPartsSelection)
    {
      throw new NotImplementedException(nameof (ReadDeviceAsync));
    }

    public virtual Task WriteDeviceAsync(ProgressHandler progress, CancellationToken token)
    {
      throw new NotImplementedException(nameof (WriteDeviceAsync));
    }

    public virtual Task WriteDeviceOnlyAsync(ProgressHandler progress, CancellationToken token)
    {
      throw new NotImplementedException(nameof (WriteDeviceOnlyAsync));
    }

    public virtual DeviceIdentification GetDeviceIdentification()
    {
      return this.GetDeviceIdentification(0);
    }

    public virtual DeviceIdentification GetDeviceIdentification(int channel)
    {
      throw new NotImplementedException(nameof (GetDeviceIdentification));
    }

    public virtual SortedList<long, SortedList<DateTime, double>> GetValues(int subDevice = 0)
    {
      throw new NotImplementedException(nameof (GetValues));
    }

    public virtual SortedList<OverrideID, ConfigurationParameter> GetConfigurationParameters(
      int subDevice = 0)
    {
      throw new NotImplementedException(nameof (GetConfigurationParameters));
    }

    public virtual void SetConfigurationParameters(
      SortedList<OverrideID, ConfigurationParameter> parameter,
      int subDevice = 0)
    {
      throw new NotImplementedException(nameof (SetConfigurationParameters));
    }

    public virtual void SetDataToWorkMeter(uint Address, byte[] data)
    {
      throw new NotImplementedException(nameof (SetDataToWorkMeter));
    }

    public virtual void WriteConfigurationParameters(
      SortedList<OverrideID, ConfigurationParameter> parameter,
      int subDevice = 0)
    {
      throw new NotImplementedException(nameof (WriteConfigurationParameters));
    }

    public virtual BatteryEnergyManagement GetBatteryCalculations()
    {
      throw new NotImplementedException(nameof (GetBatteryCalculations));
    }

    public virtual async Task<NfcDeviceIdentification> GetMiConDeviceIdentification(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      throw new NotImplementedException(nameof (GetMiConDeviceIdentification));
    }

    public virtual async Task ProtectionResetByDb(
      ProgressHandler progress,
      CancellationToken cancelToken,
      BaseDbConnection dbCon)
    {
      throw new NotImplementedException(nameof (ProtectionResetByDb));
    }

    public virtual bool IsProtected() => throw new NotImplementedException(nameof (IsProtected));

    public virtual async Task<DeviceHistoryData> GetDeviceHistory(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      throw new NotImplementedException(nameof (GetDeviceHistory));
    }

    public virtual bool LoadLastBackup(int meterID)
    {
      throw new NotImplementedException(nameof (LoadLastBackup));
    }

    public virtual bool LoadBackup(int meterID, DateTime TimePoint)
    {
      throw new NotImplementedException(nameof (LoadBackup));
    }

    public virtual bool SetBackup(byte[] zippedBuffer)
    {
      throw new NotImplementedException("SetBackupToBackUPMeter");
    }

    public virtual bool SetConfigurationParameterFromBackup()
    {
      throw new NotImplementedException(nameof (SetConfigurationParameterFromBackup));
    }

    public virtual DateTime? SaveMeter() => throw new NotImplementedException(nameof (SaveMeter));

    public virtual void OpenType(int meterInfoID)
    {
      throw new NotImplementedException(nameof (OpenType));
    }

    public virtual void OpenType(string typeCreationString)
    {
      throw new NotImplementedException("OpenType by type TypeCreationString");
    }

    public virtual void OpenCompareType(int meterInfoID)
    {
      throw new NotImplementedException(nameof (OpenCompareType));
    }

    public virtual int SaveType(
      OpenTransaction openTransaction,
      string sapNumber,
      string description)
    {
      throw new NotImplementedException(nameof (SaveType));
    }

    public virtual int SaveType(
      OpenTransaction openTransaction,
      string sapNumber,
      string description,
      int meterhardwareid)
    {
      throw new NotImplementedException(nameof (SaveType));
    }

    public virtual void SaveTypeData(int meterInfoId)
    {
      throw new NotImplementedException(nameof (SaveTypeData));
    }

    public virtual void OverwriteFromType(CommonOverwriteGroups[] overwriteGroups)
    {
      throw new NotImplementedException(nameof (OverwriteFromType));
    }

    public virtual void OverwriteSrcToDest(
      HandlerMeterObjects sourceObject,
      HandlerMeterObjects destinationObject,
      CommonOverwriteGroups[] overwriteGroups)
    {
      throw new NotImplementedException("OverwriteFromType");
    }

    public virtual CommonOverwriteGroups[] GetAllOverwriteGroups() => new CommonOverwriteGroups[0];

    public virtual string GetOverwriteGroupInfo(CommonOverwriteGroups overwriteGroupe)
    {
      return "No overwrite group info prepared from handler.";
    }

    protected static CommonOverwriteGroups[] GetImplementedOverwriteGroups(string[] allNames)
    {
      if (allNames == null || allNames.Length == 0)
        return new CommonOverwriteGroups[0];
      CommonOverwriteGroups[] implementedOverwriteGroups = new CommonOverwriteGroups[allNames.Length];
      for (int index = 0; index < allNames.Length; ++index)
        implementedOverwriteGroups[index] = (CommonOverwriteGroups) Enum.Parse(typeof (CommonOverwriteGroups), allNames[index]);
      return implementedOverwriteGroups;
    }

    public virtual void SaveMeterObject(HandlerMeterObjects meterObject)
    {
      throw new NotImplementedException(nameof (SaveMeterObject));
    }

    public virtual async Task SetModeAsync(
      ProgressHandler progress,
      CancellationToken token,
      Enum mode)
    {
      await Task.Delay(0);
      throw new NotImplementedException(nameof (SetModeAsync));
    }

    public virtual async Task<byte> GetModeAsync(ProgressHandler progress, CancellationToken token)
    {
      await Task.Delay(0);
      throw new NotImplementedException(nameof (GetModeAsync));
    }

    public virtual async Task SetSystemTimeAsync(
      ProgressHandler progress,
      CancellationToken token,
      Common32BitCommands.SystemTime sysTime)
    {
      await Task.Delay(0);
      throw new NotImplementedException("SetModeAsync");
    }

    public virtual async Task ResetDeviceAsync(ProgressHandler progress, CancellationToken token)
    {
      await Task.Delay(0);
      throw new NotImplementedException(nameof (ResetDeviceAsync));
    }

    public virtual async Task ResetAccumulatedData(
      ProgressHandler progress,
      CancellationToken token)
    {
      await Task.Delay(0);
    }

    public virtual async Task ResetDiagnosticData(ProgressHandler progress, CancellationToken token)
    {
      await Task.Delay(0);
    }

    public virtual void Clear() => throw new NotImplementedException(nameof (Clear));

    public virtual async Task Calibrate_RTC(
      ProgressHandler progress,
      CancellationToken token,
      double calibrationValue)
    {
      throw new NotImplementedException(nameof (Calibrate_RTC));
    }

    public virtual async Task SetLcdTestStateAsync(
      ProgressHandler progress,
      CancellationToken token,
      byte lcdTestState)
    {
      await Task.Delay(0);
      throw new NotImplementedException(nameof (SetLcdTestStateAsync));
    }

    public virtual async Task ReInitMeasurementAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Delay(0);
      throw new NotImplementedException("ReInitMeasurement");
    }

    public virtual void AddEventHandler(EventHandler<GMM_EventArgs> TheEventHandlerArgs)
    {
      throw new NotImplementedException(nameof (AddEventHandler));
    }

    public virtual void RemoveEventHandler(EventHandler<GMM_EventArgs> TheEventHandlerArgs)
    {
      throw new NotImplementedException("AddEventHandler");
    }

    public virtual void SetCompatibleCommunicationStructure()
    {
      throw new NotImplementedException(nameof (SetCompatibleCommunicationStructure));
    }

    public virtual IEnumerable GetEvents() => throw new NotImplementedException(nameof (GetEvents));

    public enum CommonDeviceModes
    {
      OperationMode = 0,
      DeliveryMode = 1,
      StandbyCurrentMode = 2,
      TemperatureCalibrationMode = 3,
      RTC_CalibrationMode = 4,
      RTC_CalibrationVerifyMode = 5,
      DeliveryMode8 = 8,
      UltrasonicLevelTest = 9,
      LcdTest = 10, // 0x0000000A
      RadioTestTransmitUnmodulatedCarrier = 11, // 0x0000000B
      RadioTestTransmitModulatedCarrier = 12, // 0x0000000C
      RadioTestReceiveTestPacket = 13, // 0x0000000D
      RadioTestSendTestPacket = 14, // 0x0000000E
    }
  }
}


--- HandlerMessageException.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.HandlerMessageException
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Runtime.Serialization;

#nullable disable
namespace HandlerLib
{
  public class HandlerMessageException : Exception
  {
    public HandlerMessageException()
    {
    }

    public HandlerMessageException(string message)
      : base(message)
    {
    }

    public HandlerMessageException(string message, Exception inner)
      : base(message, inner)
    {
    }

    protected HandlerMessageException(SerializationInfo info, StreamingContext context)
    {
    }
  }
}


--- HandlerMeterObjects.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.HandlerMeterObjects
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum HandlerMeterObjects
  {
    WorkMeter,
    ConnectedMeter,
    TypeMeter,
    BackupMeter,
    SavedMeter,
    ConnectedDevice,
  }
}


--- HardwareTypeEditor.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.HardwareTypeEditor
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommonWPF;
using GmmDbLib;
using GmmDbLib.DataSets;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Data.Common;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class HardwareTypeEditor : Window, IComponentConnector
  {
    private HardwareTypeTables.HardwareOverviewDataTable HardwareOverviewTable;
    private HardwareTypeTables.ProgFilesDataTable ProgFilesTable;
    private SortedList<int, HardwareTypeTables.HardwareTypeRow> HardwareTypeRows;
    private SortedList<uint, List<HardwareTypeTables.HardwareTypeRow>> FirmwareVersionRows;
    private string[] HardwareNames;
    private uint? FirmwareVersionFromHandler;
    private uint? HardwareTypeFromHandler;
    private bool initFinished = false;
    private bool isChangeAllowed = false;
    private int? lastSelectedHardwareTypeID = new int?();
    private bool suppressTestChanged = false;
    private SortedList<int, HardwareTypeEditor.RowCompareState> CompareStates = new SortedList<int, HardwareTypeEditor.RowCompareState>();
    internal Menu menuMain;
    internal MenuItem MenuItemServiceFunctions;
    internal MenuItem MenuItemShowReleasedFirmwareForSapNumber;
    internal MenuItem MenuItemShowReleasedFirmwareForHardwareType;
    internal MenuItem MenuItemShowReleasedFirmwareForHardwareName;
    internal MenuItem MenuItemShowAllReleasedFirmwareForSapNumber;
    internal MenuItem MenuItemShowAllReleasedFirmwareForHardwareType;
    internal MenuItem MenuItemShowAllReleasedFirmwareForHardwareName;
    internal MenuItem MenuItemShowAllCompatibilities;
    internal StartupLib.GmmCorporateControl gmmCorporateControl1;
    internal StackPanel StackPanelButtons;
    internal Button ButtonShowCompatibleFirmwares;
    internal Button ButtonCreateHardwareType;
    internal Button ButtonChangeHardware;
    internal Button ButtonCompareSelected;
    internal Button ButtonCompareAll;
    internal Button ButtonCopySelected;
    internal TextBox TextBoxFirmwareFromHandlerHex;
    internal TextBox TextBoxFirmwareFromHandler;
    internal TextBox TextBoxHardwareVersionFromHandler;
    internal Button ButtonUseDataFromHandler;
    internal TextBox TextBoxInfo;
    internal ComboBox ComboBoxHardwareName;
    internal TextBox TextBoxFirmwareVersionHex;
    internal TextBox TextBoxFirmwareVersionStr;
    internal TextBox TextBoxFirmwareVersionDec;
    internal TextBox TextBoxHardwareVersion;
    internal TextBox TextBoxHardwareResource;
    internal TextBox TextBoxDescription;
    internal TextBox TextBoxTestinfo;
    internal TextBox TextBoxHardwareOptions;
    internal DataGrid DataGridOverview;
    private bool _contentLoaded;

    public HardwareTypeEditor(string hardwareName, uint? firmwareVersion = null, uint? hardwareType = null)
      : this(new string[1]{ hardwareName }, firmwareVersion, hardwareType)
    {
    }

    public HardwareTypeEditor(
      string[] HardwareNames,
      uint? firmwareVersion = null,
      uint? hardwareType = null,
      bool isChangingAllowed = false)
    {
      this.HardwareNames = HardwareNames;
      this.isChangeAllowed = isChangingAllowed;
      this.FirmwareVersionFromHandler = firmwareVersion;
      this.HardwareTypeFromHandler = hardwareType;
      if (firmwareVersion.HasValue && firmwareVersion.Value == 0U)
        this.FirmwareVersionFromHandler = new uint?();
      this.InitializeComponent();
      this.suppressTestChanged = true;
      this.ComboBoxHardwareName.ItemsSource = (IEnumerable) HardwareNames;
      this.ComboBoxHardwareName.SelectedIndex = 0;
      this.ButtonUseDataFromHandler.IsEnabled = false;
      uint num;
      if (this.FirmwareVersionFromHandler.HasValue)
      {
        this.TextBoxFirmwareFromHandler.Text = this.VersionString(this.FirmwareVersionFromHandler.Value);
        TextBox firmwareFromHandlerHex = this.TextBoxFirmwareFromHandlerHex;
        num = this.FirmwareVersionFromHandler.Value;
        string str = num.ToString("x08");
        firmwareFromHandlerHex.Text = str;
        this.TextBoxFirmwareVersionHex.Text = this.TextBoxFirmwareFromHandlerHex.Text;
        this.ButtonUseDataFromHandler.IsEnabled = true;
      }
      if (this.HardwareTypeFromHandler.HasValue)
      {
        TextBox versionFromHandler = this.TextBoxHardwareVersionFromHandler;
        num = this.HardwareTypeFromHandler.Value;
        string str = num.ToString("x08");
        versionFromHandler.Text = str;
        this.TextBoxHardwareVersion.Text = this.TextBoxHardwareVersionFromHandler.Text;
        this.ButtonUseDataFromHandler.IsEnabled = true;
      }
      this.suppressTestChanged = false;
    }

    private void Window_Loaded(object sender, RoutedEventArgs e)
    {
      this.LoadDataFromDatabase();
      if (this.FirmwareVersionFromHandler.HasValue && this.FirmwareVersionRows.ContainsKey(this.FirmwareVersionFromHandler.Value))
      {
        string str = this.VersionString(this.FirmwareVersionFromHandler.Value);
        foreach (object obj in (IEnumerable) this.DataGridOverview.Items)
        {
          if (obj is DataRowView && ((HardwareTypeTables.HardwareOverviewRow) ((DataRowView) obj).Row).FirmwareVersion == str)
          {
            this.DataGridOverview.SelectedItem = obj;
            break;
          }
        }
      }
      if (this.DataGridOverview.SelectedIndex < 0)
      {
        if (this.DataGridOverview.Items.Count > 0)
        {
          this.DataGridOverview.SelectedIndex = 0;
        }
        else
        {
          if (this.FirmwareVersionFromHandler.HasValue)
            this.TextBoxFirmwareVersionHex.Text = this.TextBoxFirmwareFromHandlerHex.Text;
          if (this.HardwareTypeFromHandler.HasValue)
            this.TextBoxHardwareVersion.Text = this.TextBoxHardwareVersionFromHandler.Text;
        }
      }
      this.UpdateStatus();
    }

    private void LoadDataFromDatabase()
    {
      this.TextBoxHardwareOptions.Clear();
      this.TextBoxInfo.Clear();
      this.TextBoxTestinfo.Clear();
      this.TextBoxDescription.Clear();
      this.TextBoxHardwareVersion.Clear();
      try
      {
        using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.Append("SELECT * FROM HardwareType ");
          if (this.HardwareNames != null && this.HardwareNames.Length != 0)
          {
            if (this.HardwareNames.Length == 1)
            {
              stringBuilder.Append(" WHERE HardwareName = '" + this.HardwareNames[0] + "'");
              if (this.HardwareNames[0].Contains<char>('_'))
                stringBuilder.Append(" OR HardwareName = '" + this.HardwareNames[0].Replace('_', ' ') + "'");
            }
            else
            {
              stringBuilder.Append(" WHERE (HardwareName = '" + this.HardwareNames[0] + "'");
              if (this.HardwareNames[0].Contains<char>('_'))
                stringBuilder.Append(" OR HardwareName = '" + this.HardwareNames[0].Replace('_', ' ') + "'");
              for (int index = 1; index < this.HardwareNames.Length; ++index)
              {
                stringBuilder.Append(" OR HardwareName = '" + this.HardwareNames[index] + "'");
                if (this.HardwareNames[index].Contains<char>('_'))
                  stringBuilder.Append(" OR HardwareName = '" + this.HardwareNames[index].Replace('_', ' ') + "'");
              }
              stringBuilder.Append(")");
            }
            stringBuilder.Append(" ORDER BY HardwareTypeID DESC");
          }
          DbDataAdapter dataAdapter1 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
          HardwareTypeTables.HardwareTypeDataTable hardwareTypeDataTable = new HardwareTypeTables.HardwareTypeDataTable();
          dataAdapter1.Fill((DataTable) hardwareTypeDataTable);
          this.HardwareOverviewTable = new HardwareTypeTables.HardwareOverviewDataTable();
          this.FirmwareVersionRows = new SortedList<uint, List<HardwareTypeTables.HardwareTypeRow>>();
          HashSet<int> source = new HashSet<int>();
          this.HardwareTypeRows = new SortedList<int, HardwareTypeTables.HardwareTypeRow>();
          if (hardwareTypeDataTable.Count > 0)
          {
            for (int index1 = 0; index1 < hardwareTypeDataTable.Count; ++index1)
            {
              this.HardwareTypeRows.Add(hardwareTypeDataTable[index1].HardwareTypeID, hardwareTypeDataTable[index1]);
              if (!source.Contains(hardwareTypeDataTable[index1].MapID))
                source.Add(hardwareTypeDataTable[index1].MapID);
              HardwareTypeTables.HardwareOverviewRow row = this.HardwareOverviewTable.NewHardwareOverviewRow();
              row.HardwareName = hardwareTypeDataTable[index1].HardwareName;
              row.FirmwareVersion = this.VersionString((uint) hardwareTypeDataTable[index1].FirmwareVersion);
              row.HardwareTypeID = hardwareTypeDataTable[index1].HardwareTypeID;
              row.MapID = hardwareTypeDataTable[index1].MapID;
              if (!hardwareTypeDataTable[index1].IsHardwareResourceNull())
                row.HardwareResource = hardwareTypeDataTable[index1].HardwareResource;
              if (!hardwareTypeDataTable[index1].IsHardwareVersionNull())
                row.HardwareVersion = hardwareTypeDataTable[index1].HardwareVersion.ToString("x04");
              if (!hardwareTypeDataTable[index1].IsDescriptionNull())
                row.Description = hardwareTypeDataTable[index1].Description;
              if (!hardwareTypeDataTable[index1].IsTestinfoNull())
                row.Testinfo = hardwareTypeDataTable[index1].Testinfo;
              if (!hardwareTypeDataTable[index1].IsHardwareOptionsNull())
                row.HardwareOptions = hardwareTypeDataTable[index1].HardwareOptions;
              this.HardwareOverviewTable.AddHardwareOverviewRow(row);
              int index2 = this.FirmwareVersionRows.IndexOfKey((uint) hardwareTypeDataTable[index1].FirmwareVersion);
              if (index2 >= 0)
                this.FirmwareVersionRows.Values[index2].Add(hardwareTypeDataTable[index1]);
              else
                this.FirmwareVersionRows.Add((uint) hardwareTypeDataTable[index1].FirmwareVersion, new List<HardwareTypeTables.HardwareTypeRow>()
                {
                  hardwareTypeDataTable[index1]
                });
            }
            if (source.Count > 0)
            {
              stringBuilder.Clear();
              stringBuilder.Append("SELECT MapID, HardwareTypeMapID, FirmwareVersion, HardwareName FROM ProgFiles");
              stringBuilder.Append(" WHERE ( HardwareTypeMapID = " + source.ElementAt<int>(0).ToString());
              for (int index = 1; index < source.Count; ++index)
                stringBuilder.Append(" OR HardwareTypeMapID = " + source.ElementAt<int>(index).ToString());
              stringBuilder.Append(" )");
              DbDataAdapter dataAdapter2 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
              this.ProgFilesTable = new HardwareTypeTables.ProgFilesDataTable();
              dataAdapter2.Fill((DataTable) this.ProgFilesTable);
              foreach (HardwareTypeTables.HardwareOverviewRow hardwareOverviewRow in (TypedTableBase<HardwareTypeTables.HardwareOverviewRow>) this.HardwareOverviewTable)
              {
                HardwareTypeTables.ProgFilesRow[] progFilesRowArray = (HardwareTypeTables.ProgFilesRow[]) this.ProgFilesTable.Select("HardwareTypeMapID = " + hardwareOverviewRow.MapID.ToString());
                hardwareOverviewRow.CompatibleFirmwares = progFilesRowArray.Length;
              }
            }
          }
          else
            this.TextBoxInfo.Text = "No required HardwareName rows in Database. Create completely new HardwareType!";
        }
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show(ex.ToString());
        return;
      }
      this.DataGridOverview.ItemsSource = (IEnumerable) this.HardwareOverviewTable;
      this.initFinished = true;
      if (!this.lastSelectedHardwareTypeID.HasValue)
        return;
      foreach (object obj in (IEnumerable) this.DataGridOverview.Items)
      {
        if (((HardwareTypeTables.HardwareOverviewRow) ((DataRowView) obj).Row).HardwareTypeID == this.lastSelectedHardwareTypeID.Value)
        {
          this.DataGridOverview.SelectedItem = obj;
          break;
        }
      }
    }

    private void UpdateStatus()
    {
      if (!this.initFinished)
        return;
      this.ButtonShowCompatibleFirmwares.IsEnabled = false;
      this.ButtonChangeHardware.IsEnabled = false;
      this.ButtonCreateHardwareType.IsEnabled = false;
      this.MenuItemShowReleasedFirmwareForHardwareName.IsEnabled = false;
      this.MenuItemShowReleasedFirmwareForHardwareType.IsEnabled = false;
      this.ButtonCompareSelected.IsEnabled = false;
      this.ButtonCompareAll.IsEnabled = false;
      this.ButtonCopySelected.IsEnabled = false;
      uint? usedFirmware = this.GetUsedFirmware();
      if (!usedFirmware.HasValue)
      {
        this.TextBoxInfo.Text = "Not a valied firmware version";
      }
      else
      {
        StringBuilder stringBuilder = new StringBuilder();
        HardwareTypeTables.HardwareTypeRow selectedHardwareTypeRow = this.GetSelectedHardwareTypeRow();
        if (selectedHardwareTypeRow == null)
        {
          HardwareTypeTables.ProgFilesRow[] progFilesRowArray = this.ProgFilesTable != null ? (HardwareTypeTables.ProgFilesRow[]) this.ProgFilesTable.Select("FirmwareVersion = " + usedFirmware.Value.ToString()) : (HardwareTypeTables.ProgFilesRow[]) null;
          if (progFilesRowArray != null && progFilesRowArray.Length != 0)
          {
            stringBuilder.AppendLine("This firmware version is used in a compatible type. HardwareType MapID: " + progFilesRowArray[0].HardwareTypeMapID.ToString());
          }
          else
          {
            stringBuilder.AppendLine("Create new HardwareType and MapID prepared");
            this.ButtonCreateHardwareType.IsEnabled = true;
            stringBuilder.AppendLine("By creating a new HardwareType a new MapID will be created.");
          }
        }
        else
        {
          if ((long) selectedHardwareTypeRow.FirmwareVersion != (long) usedFirmware.Value)
            throw new Exception("Internal error. FirmwareVersionTextBox != selected firmware version");
          this.ButtonShowCompatibleFirmwares.IsEnabled = true;
          this.ButtonChangeHardware.IsEnabled = true;
          this.ButtonCreateHardwareType.IsEnabled = true;
          this.ButtonCompareSelected.IsEnabled = true;
          this.ButtonCompareAll.IsEnabled = true;
          if (this.CompareStates.ContainsKey(selectedHardwareTypeRow.HardwareTypeID) && this.CompareStates[selectedHardwareTypeRow.HardwareTypeID] != HardwareTypeEditor.RowCompareState.equal)
            this.ButtonCopySelected.IsEnabled = true;
          if (selectedHardwareTypeRow.MapID > 0)
          {
            this.MenuItemShowReleasedFirmwareForHardwareName.IsEnabled = true;
            this.MenuItemShowReleasedFirmwareForHardwareType.IsEnabled = true;
          }
          stringBuilder.AppendLine("The selected firmware version is: " + this.VersionString((uint) selectedHardwareTypeRow.FirmwareVersion));
          stringBuilder.AppendLine("By creating a new HardwareType the selected MapID will be used");
        }
        int num = 0;
        int index = this.FirmwareVersionRows.IndexOfKey(usedFirmware.Value);
        if (index >= 0)
          num = this.FirmwareVersionRows.Values[index].Count;
        if (num == 1)
          stringBuilder.AppendLine("Only one type includes the selected firmware.");
        else
          stringBuilder.AppendLine("The selected firmware is used in " + num.ToString() + " types");
        this.TextBoxInfo.Text = stringBuilder.ToString();
      }
    }

    private string VersionString(uint firmwareVersion)
    {
      return new FirmwareVersion(firmwareVersion).ToString();
    }

    private void ButtonShowCompatibleFirmwares_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        HardwareTypeTables.HardwareTypeRow selectedHardwareTypeRow = this.GetSelectedHardwareTypeRow();
        int hardwareTypeId = selectedHardwareTypeRow.HardwareTypeID;
        new CompatibleFirmwareWindow(selectedHardwareTypeRow, this.FirmwareVersionFromHandler).ShowDialog();
        this.LoadDataFromDatabase();
        foreach (object obj in (IEnumerable) this.DataGridOverview.Items)
        {
          if (obj is DataRowView && ((HardwareTypeTables.HardwareOverviewRow) ((DataRowView) obj).Row).HardwareTypeID == hardwareTypeId)
          {
            this.DataGridOverview.SelectedItem = obj;
            break;
          }
        }
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonCreateHardwareType_Click(object sender, RoutedEventArgs e)
    {
      this.SaveHardwareType(false);
    }

    private void ButtonChangeHardware_Click(object sender, RoutedEventArgs e)
    {
      this.SaveHardwareType(true);
    }

    private HardwareTypeTables.HardwareTypeRow GetSelectedHardwareTypeRow()
    {
      return this.DataGridOverview.SelectedItem == null || !(this.DataGridOverview.SelectedItem is DataRowView) ? (HardwareTypeTables.HardwareTypeRow) null : this.HardwareTypeRows[((HardwareTypeTables.HardwareOverviewRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row).HardwareTypeID];
    }

    private void DataGridOverview_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      HardwareTypeTables.HardwareTypeRow selectedHardwareTypeRow = this.GetSelectedHardwareTypeRow();
      if (selectedHardwareTypeRow == null)
        return;
      if (this.ComboBoxHardwareName.SelectedItem.ToString() != selectedHardwareTypeRow.HardwareName)
      {
        for (int index = 0; index < this.ComboBoxHardwareName.Items.Count; ++index)
        {
          if (this.ComboBoxHardwareName.Items[index].ToString() == selectedHardwareTypeRow.HardwareName)
          {
            this.ComboBoxHardwareName.SelectedIndex = index;
            break;
          }
        }
      }
      this.TextBoxFirmwareVersionHex.Text = selectedHardwareTypeRow.FirmwareVersion.ToString("x08");
      if (!selectedHardwareTypeRow.IsHardwareVersionNull())
        this.TextBoxHardwareVersion.Text = selectedHardwareTypeRow.HardwareVersion.ToString("x08");
      else
        this.TextBoxHardwareVersion.Clear();
      if (!selectedHardwareTypeRow.IsHardwareResourceNull())
        this.TextBoxHardwareResource.Text = selectedHardwareTypeRow.HardwareResource;
      else
        this.TextBoxHardwareResource.Clear();
      if (!selectedHardwareTypeRow.IsDescriptionNull())
        this.TextBoxDescription.Text = selectedHardwareTypeRow.Description;
      else
        this.TextBoxDescription.Clear();
      if (!selectedHardwareTypeRow.IsTestinfoNull())
        this.TextBoxTestinfo.Text = selectedHardwareTypeRow.Testinfo;
      else
        this.TextBoxTestinfo.Clear();
      if (!selectedHardwareTypeRow.IsHardwareOptionsNull())
        this.TextBoxHardwareOptions.Text = selectedHardwareTypeRow.HardwareOptions;
      else
        this.TextBoxHardwareOptions.Clear();
      this.UpdateStatus();
    }

    private void TextBoxFirmwareVersion_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.suppressTestChanged)
        return;
      try
      {
        uint result;
        if (this.TextBoxFirmwareVersionHex.Text.Length == 8 && uint.TryParse(this.TextBoxFirmwareVersionHex.Text, NumberStyles.HexNumber, (IFormatProvider) null, out result))
        {
          this.TextBoxFirmwareVersionStr.Text = this.VersionString(result);
          this.TextBoxFirmwareVersionDec.Text = result.ToString();
          string str = this.VersionString(result);
          bool flag = true;
          HardwareTypeTables.HardwareOverviewRow[] hardwareOverviewRowArray1 = (HardwareTypeTables.HardwareOverviewRow[]) this.HardwareOverviewTable.Select("FirmwareVersion = '" + str + "'");
          if (hardwareOverviewRowArray1.Length != 0)
          {
            if (this.DataGridOverview.SelectedItem != null)
            {
              foreach (HardwareTypeTables.HardwareOverviewRow hardwareOverviewRow in hardwareOverviewRowArray1)
              {
                if (hardwareOverviewRow == ((DataRowView) this.DataGridOverview.SelectedItem).Row)
                {
                  flag = false;
                  break;
                }
              }
            }
            if (flag)
              this.SelectViewRow(hardwareOverviewRowArray1[0].HardwareTypeID);
          }
          else if (this.ProgFilesTable != null)
          {
            HardwareTypeTables.ProgFilesRow[] progFilesRowArray = (HardwareTypeTables.ProgFilesRow[]) this.ProgFilesTable.Select("FirmwareVersion = " + result.ToString());
            if (progFilesRowArray.Length != 0)
            {
              HardwareTypeTables.HardwareOverviewRow[] hardwareOverviewRowArray2 = (HardwareTypeTables.HardwareOverviewRow[]) this.HardwareOverviewTable.Select("MapID = " + progFilesRowArray[0].HardwareTypeMapID.ToString());
              if (hardwareOverviewRowArray2.Length != 0)
                this.SelectViewRow(hardwareOverviewRowArray2[0].HardwareTypeID);
              else
                this.DataGridOverview.SelectedItem = (object) null;
            }
            else
              this.DataGridOverview.SelectedItem = (object) null;
          }
        }
        else
        {
          this.TextBoxFirmwareVersionStr.Text = "?";
          this.TextBoxFirmwareVersionDec.Text = "?";
          this.DataGridOverview.SelectedItem = (object) null;
        }
        this.UpdateStatus();
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex, "FirmwareVersion error");
      }
    }

    private void SelectViewRow(int hardwareTypeID)
    {
      if (this.DataGridOverview.Items == null)
        return;
      foreach (DataRowView dataRowView in (IEnumerable) this.DataGridOverview.Items)
      {
        if (((HardwareTypeTables.HardwareOverviewRow) dataRowView.Row).HardwareTypeID == hardwareTypeID)
        {
          this.suppressTestChanged = true;
          this.DataGridOverview.SelectedItem = (object) dataRowView;
          this.suppressTestChanged = false;
          break;
        }
      }
    }

    private void SaveHardwareType(bool change)
    {
      DbBasis.PrimaryDB.BaseDbConnection.ExceptionIfNoSvnDatabase();
      this.CompareStates.Clear();
      HardwareTypeTables.HardwareTypeRow selectedHardwareTypeRow = this.GetSelectedHardwareTypeRow();
      StringBuilder stringBuilder = new StringBuilder();
      int num1;
      try
      {
        using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          newConnection.Open();
          DbTransaction theTransaction = newConnection.BeginTransaction();
          int index = this.FirmwareVersionRows.IndexOfKey((this.GetUsedFirmware() ?? throw new Exception("Illegal firmware")).Value);
          int mapID;
          if (index >= 0)
          {
            mapID = this.FirmwareVersionRows.Values[index][0].MapID;
          }
          else
          {
            mapID = DbBasis.PrimaryDB.BaseDbConnection.GetNewId("ProgFiles");
            stringBuilder.AppendLine("New MapID created: " + mapID.ToString());
          }
          if (!change)
          {
            num1 = this.CreateNewHardwareType(newConnection, theTransaction, mapID);
            stringBuilder.AppendLine("New Type created: " + num1.ToString());
          }
          else
          {
            num1 = selectedHardwareTypeRow.HardwareTypeID;
            this.ChangeHardwareType(newConnection, theTransaction, mapID);
            stringBuilder.AppendLine("Type changed: " + num1.ToString());
          }
          theTransaction.Commit();
          newConnection.Close();
        }
      }
      catch (Exception ex)
      {
        int num2 = (int) MessageBox.Show(ex.ToString());
        return;
      }
      int num3 = (int) MessageBox.Show(stringBuilder.ToString());
      this.LoadDataFromDatabase();
      foreach (object obj in (IEnumerable) this.DataGridOverview.Items)
      {
        if (obj is DataRowView && ((HardwareTypeTables.HardwareOverviewRow) ((DataRowView) obj).Row).HardwareTypeID == num1)
        {
          this.DataGridOverview.SelectedItem = obj;
          break;
        }
      }
      this.UpdateStatus();
    }

    private int CreateNewHardwareType(
      DbConnection theDbConnection,
      DbTransaction theTransaction,
      int mapID)
    {
      int newId = DbBasis.PrimaryDB.BaseDbConnection.GetNewId("HardwareType");
      string selectSql = "SELECT * FROM HardwareType WHERE HardwareTypeID = " + newId.ToString();
      DbDataAdapter dataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(selectSql, theDbConnection, theTransaction, out DbCommandBuilder _);
      HardwareTypeTables.HardwareTypeDataTable hardwareTypeDataTable = new HardwareTypeTables.HardwareTypeDataTable();
      dataAdapter.Fill((DataTable) hardwareTypeDataTable);
      HardwareTypeTables.HardwareTypeRow hardwareTypeRow = hardwareTypeDataTable.Count <= 0 ? hardwareTypeDataTable.NewHardwareTypeRow() : throw new Exception("HardwareTypeID error. New generated ID exists = " + newId.ToString());
      hardwareTypeRow.HardwareTypeID = newId;
      hardwareTypeRow.MapID = mapID;
      this.InsertHardwareTypeData(hardwareTypeRow);
      hardwareTypeDataTable.AddHardwareTypeRow(hardwareTypeRow);
      dataAdapter.Update((DataTable) hardwareTypeDataTable);
      return newId;
    }

    private void ChangeHardwareType(
      DbConnection theDbConnection,
      DbTransaction theTransaction,
      int mapID)
    {
      HardwareTypeTables.HardwareTypeRow selectedHardwareTypeRow = this.GetSelectedHardwareTypeRow();
      string selectSql = "SELECT * FROM HardwareType WHERE HardwareTypeID = " + selectedHardwareTypeRow.HardwareTypeID.ToString();
      DbDataAdapter dataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(selectSql, theDbConnection, theTransaction, out DbCommandBuilder _);
      HardwareTypeTables.HardwareTypeDataTable hardwareTypeDataTable = new HardwareTypeTables.HardwareTypeDataTable();
      dataAdapter.Fill((DataTable) hardwareTypeDataTable);
      if (hardwareTypeDataTable.Count != 1)
        throw new Exception("HardwareTypeID error. ID doesn't exists = " + selectedHardwareTypeRow.HardwareTypeID.ToString());
      this.InsertHardwareTypeData(hardwareTypeDataTable[0]);
      hardwareTypeDataTable[0].MapID = mapID;
      dataAdapter.Update((DataTable) hardwareTypeDataTable);
    }

    private uint? GetUsedFirmware()
    {
      if (this.TextBoxFirmwareVersionHex.Text.Length != 8)
        return new uint?();
      uint result;
      return uint.TryParse(this.TextBoxFirmwareVersionHex.Text, NumberStyles.HexNumber, (IFormatProvider) null, out result) ? new uint?(result) : new uint?();
    }

    private void InsertHardwareTypeData(
      HardwareTypeTables.HardwareTypeRow newHardwareTypeRow)
    {
      newHardwareTypeRow.FirmwareVersion = (int) (this.GetUsedFirmware() ?? throw new Exception("Illegal firmware")).Value;
      newHardwareTypeRow.HardwareName = this.HardwareNames[this.ComboBoxHardwareName.SelectedIndex];
      string s = this.TextBoxHardwareVersion.Text.Trim();
      if (s.Length > 0)
      {
        short result;
        if (!short.TryParse(s, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          throw new Exception("HardwareVersion has wrong format");
        newHardwareTypeRow.HardwareVersion = (int) result;
      }
      else
        newHardwareTypeRow.SetHardwareVersionNull();
      string str1 = this.TextBoxHardwareResource.Text.Trim();
      if (!string.IsNullOrEmpty(str1))
        newHardwareTypeRow.HardwareResource = str1;
      else
        newHardwareTypeRow.SetHardwareResourceNull();
      string str2 = this.TextBoxDescription.Text.Trim();
      if (!string.IsNullOrEmpty(str2))
        newHardwareTypeRow.Description = str2;
      else
        newHardwareTypeRow.SetDescriptionNull();
      string str3 = this.TextBoxHardwareOptions.Text.Trim();
      if (!string.IsNullOrEmpty(str3))
        newHardwareTypeRow.HardwareOptions = str3;
      else
        newHardwareTypeRow.SetHardwareOptionsNull();
      string str4 = this.TextBoxTestinfo.Text.Trim();
      if (!string.IsNullOrEmpty(str4))
        newHardwareTypeRow.Testinfo = str4;
      else
        newHardwareTypeRow.SetTestinfoNull();
    }

    private void MenuItemShowReleasedFirmwareForSapNumber_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        string oneValue = EnterOneValue.GetOneValue("Define SAP number", Environment.NewLine + "Type in the requiremd SAP number");
        if (string.IsNullOrEmpty(oneValue))
          return;
        this.ShowFirmwareData(HardwareTypeSupport.GetReleasedFirmwareDataForSapNumber(oneValue), "Released firmware for SAP number: " + oneValue);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void MenuItemShowReleasedFirmwareForHardwareType_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        HardwareTypeTables.HardwareTypeRow selectedHardwareTypeRow = this.GetSelectedHardwareTypeRow();
        this.ShowFirmwareData(HardwareTypeSupport.GetReleasedFirmwareDataForHardwareType(selectedHardwareTypeRow.HardwareTypeID), "Released firmware for HardwareTypeID: " + selectedHardwareTypeRow.HardwareTypeID.ToString());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void MenuItemShowReleasedFirmwareForHardwareName_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        HardwareTypeTables.HardwareTypeRow selectedHardwareTypeRow = this.GetSelectedHardwareTypeRow();
        this.ShowFirmwareData(HardwareTypeSupport.GetReleasedFirmwareDataForHardwareName(selectedHardwareTypeRow.HardwareName), "Released firmware for HardwareName: " + selectedHardwareTypeRow.HardwareName);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void MenuItemShowAllReleasedFirmwareForSapNumber_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        string oneValue = EnterOneValue.GetOneValue("Define SAP number", Environment.NewLine + "Type in the requiremd SAP number");
        if (string.IsNullOrEmpty(oneValue))
          return;
        this.ShowReleased(HardwareTypeSupport.GetAllReleasedFirmwareReleaseInfosForSapNumber(oneValue), "Released firmwares for SAP number: " + oneValue);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void MenuItemShowAllReleasedFirmwareForHardwareType_Click(
      object sender,
      RoutedEventArgs e)
    {
      try
      {
        HardwareTypeTables.HardwareTypeRow selectedHardwareTypeRow = this.GetSelectedHardwareTypeRow();
        this.ShowReleased(HardwareTypeSupport.GetAllReleasedFirmwareReleaseInfoForHardwareType(selectedHardwareTypeRow.HardwareTypeID), "Released firmwares for HardwareTypeID: " + selectedHardwareTypeRow.HardwareTypeID.ToString());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void MenuItemShowAllReleasedFirmwareForHardwareName_Click(
      object sender,
      RoutedEventArgs e)
    {
      try
      {
        HardwareTypeTables.HardwareTypeRow selectedHardwareTypeRow = this.GetSelectedHardwareTypeRow();
        this.ShowReleased(HardwareTypeSupport.GetAllReleasedFirmwareReleaseInfosForHardwareName(selectedHardwareTypeRow.HardwareName), "Released firmwares for HardwareName: " + selectedHardwareTypeRow.HardwareName);
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ShowReleased(List<FirmwareReleaseInfo> releaseInfo, string firstInfoLine)
    {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.AppendLine(firstInfoLine);
      stringBuilder.AppendLine();
      if (releaseInfo.Count == 0)
      {
        stringBuilder.AppendLine("No released firmware");
      }
      else
      {
        foreach (FirmwareReleaseInfo firmwareReleaseInfo in releaseInfo)
        {
          stringBuilder.AppendLine("MapID: " + firmwareReleaseInfo.MapID.ToString());
          stringBuilder.AppendLine("FirmwareVersion: " + firmwareReleaseInfo.FirmwareVersionString);
          stringBuilder.AppendLine("Release text: " + firmwareReleaseInfo.ReleaseText);
          if (firmwareReleaseInfo.ReleaseDescription != null)
            stringBuilder.AppendLine("Release description: " + firmwareReleaseInfo.ReleaseDescription);
          stringBuilder.AppendLine();
        }
      }
      GmmMessage.Show_Ok(stringBuilder.ToString());
    }

    private void ShowFirmwareData(FirmwareData firmwareData, string firstInfoLine)
    {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.AppendLine(firstInfoLine);
      stringBuilder.AppendLine();
      if (firmwareData == null)
        stringBuilder.AppendLine("No firmware found");
      else if (firmwareData.ProgrammerFileAsString == null)
      {
        stringBuilder.AppendLine("Firmware file not loaded to data base");
      }
      else
      {
        stringBuilder.AppendLine("Programmer file name: " + firmwareData.ProgFileName);
        stringBuilder.AppendLine("Programmer file bytes: " + firmwareData.ProgrammerFileAsString.Length.ToString());
      }
      GmmMessage.Show_Ok(stringBuilder.ToString());
    }

    private void MenuItemShowAllCompatibilities_Click(object sender, RoutedEventArgs e)
    {
      List<CompatibilityInfo> compatibilityInfos = HardwareTypeSupport.GetAllCompatibilityInfos();
      StringBuilder stringBuilder = new StringBuilder();
      int num = 0;
      for (int index = compatibilityInfos.Count - 1; index >= 0; --index)
      {
        CompatibilityInfo compatibilityInfo = compatibilityInfos[index];
        ++num;
        stringBuilder.AppendLine(num.ToString("d04") + ": " + compatibilityInfo.ToString());
      }
      GmmMessage.Show_Ok(stringBuilder.ToString(), "All compatibility infos");
    }

    private void ButtonCompareSelected_Click(object sender, RoutedEventArgs e)
    {
      StringBuilder message = new StringBuilder();
      try
      {
        if (this.DataGridOverview.SelectedItem == null)
          return;
        this.GuarantDatabasesAndGetInfo(message);
        message.AppendLine("*** Compare result ***");
        HardwareTypeTables.HardwareOverviewRow row = (HardwareTypeTables.HardwareOverviewRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
        using (DbConnection newConnection1 = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          using (DbConnection newConnection2 = DbBasis.SecondaryDB.BaseDbConnection.GetNewConnection())
            this.GetCompareData(row, newConnection1, newConnection2, message);
        }
        this.DataGridOverview.ItemsSource = (IEnumerable) null;
        this.DataGridOverview.ItemsSource = (IEnumerable) this.HardwareOverviewTable;
        this.SelectViewRow(row.HardwareTypeID);
        GmmMessage.Show_Ok(message.ToString());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonCompareAll_Click(object sender, RoutedEventArgs e)
    {
      StringBuilder message = new StringBuilder();
      try
      {
        HardwareTypeTables.HardwareOverviewRow hardwareOverviewRow = (HardwareTypeTables.HardwareOverviewRow) null;
        if (this.DataGridOverview.SelectedItem != null)
          hardwareOverviewRow = (HardwareTypeTables.HardwareOverviewRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
        this.GuarantDatabasesAndGetInfo(message);
        message.AppendLine("*** Compare result ***");
        using (DbConnection newConnection1 = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          using (DbConnection newConnection2 = DbBasis.SecondaryDB.BaseDbConnection.GetNewConnection())
          {
            foreach (DataRowView dataRowView in (IEnumerable) this.DataGridOverview.Items)
            {
              HardwareTypeTables.HardwareOverviewRow row = (HardwareTypeTables.HardwareOverviewRow) dataRowView.Row;
              message.AppendLine("HardwareTypeID: " + row.HardwareTypeID.ToString());
              this.GetCompareData(row, newConnection1, newConnection2, message);
              message.AppendLine();
            }
          }
        }
        this.DataGridOverview.ItemsSource = (IEnumerable) null;
        this.DataGridOverview.ItemsSource = (IEnumerable) this.HardwareOverviewTable;
        if (hardwareOverviewRow != null)
          this.SelectViewRow(hardwareOverviewRow.HardwareTypeID);
        GmmMessage.Show_Ok(message.ToString());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonCopySelected_Click(object sender, RoutedEventArgs e)
    {
      StringBuilder message = new StringBuilder();
      try
      {
        this.GuarantDatabasesAndGetInfo(message);
        HardwareTypeTables.HardwareOverviewRow row1 = (HardwareTypeTables.HardwareOverviewRow) ((DataRowView) this.DataGridOverview.SelectedItem).Row;
        using (DbConnection newConnection1 = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          using (DbConnection newConnection2 = DbBasis.SecondaryDB.BaseDbConnection.GetNewConnection())
          {
            string selectSql = "SELECT * FROM HardwareType WHERE HardwareTypeID = " + row1.HardwareTypeID.ToString();
            DbDataAdapter dataAdapter1 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(selectSql, newConnection1);
            HardwareTypeTables.HardwareTypeDataTable hardwareTypeDataTable1 = new HardwareTypeTables.HardwareTypeDataTable();
            dataAdapter1.Fill((DataTable) hardwareTypeDataTable1);
            DbDataAdapter dataAdapter2 = DbBasis.SecondaryDB.BaseDbConnection.GetDataAdapter(selectSql, newConnection2, out DbCommandBuilder _);
            HardwareTypeTables.HardwareTypeDataTable hardwareTypeDataTable2 = new HardwareTypeTables.HardwareTypeDataTable();
            dataAdapter2.Fill((DataTable) hardwareTypeDataTable2);
            HardwareTypeTables.HardwareTypeRow hardwareTypeRow = hardwareTypeDataTable1.Count == 1 ? hardwareTypeDataTable1[0] : throw new Exception("Could not load primary data");
            HardwareTypeTables.HardwareTypeRow row2;
            if (hardwareTypeDataTable2.Count == 1)
              row2 = hardwareTypeDataTable2[0];
            else
              row2 = hardwareTypeDataTable2.Count == 0 ? hardwareTypeDataTable2.NewHardwareTypeRow() : throw new Exception("Illegal nubers of secondary rows");
            foreach (DataColumn column in (InternalDataCollectionBase) hardwareTypeDataTable1.Columns)
              row2[column.ColumnName] = hardwareTypeRow[column.ColumnName];
            if (hardwareTypeDataTable2.Count == 0)
              hardwareTypeDataTable2.AddHardwareTypeRow(row2);
            dataAdapter2.Update((DataTable) hardwareTypeDataTable2);
            message.AppendLine("Copy done.");
          }
        }
        this.CompareStates[row1.HardwareTypeID] = HardwareTypeEditor.RowCompareState.equal;
        this.DataGridOverview.ItemsSource = (IEnumerable) null;
        this.DataGridOverview.ItemsSource = (IEnumerable) this.HardwareOverviewTable;
        this.SelectViewRow(row1.HardwareTypeID);
        GmmMessage.Show_Ok(message.ToString());
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void GuarantDatabasesAndGetInfo(StringBuilder message)
    {
      if (!PlugInLoader.InitSecundaryDatabase())
        throw new Exception("Error on loading secondary database");
      message.AppendLine("*** Primary database ***");
      message.AppendLine(DbBasis.PrimaryDB.BaseDbConnection.GetDatabaseInfo(">"));
      message.AppendLine("*** Secondary database ***");
      message.AppendLine(DbBasis.SecondaryDB.BaseDbConnection.GetDatabaseInfo(">"));
    }

    private void GetCompareData(
      HardwareTypeTables.HardwareOverviewRow hardwareOverviewRow,
      DbConnection primDbConnection,
      DbConnection secDbConnection,
      StringBuilder message)
    {
      if (!this.CompareStates.ContainsKey(hardwareOverviewRow.HardwareTypeID))
        this.CompareStates.Add(hardwareOverviewRow.HardwareTypeID, HardwareTypeEditor.RowCompareState.equal);
      else
        this.CompareStates[hardwareOverviewRow.HardwareTypeID] = HardwareTypeEditor.RowCompareState.equal;
      string selectSql = "SELECT * FROM HardwareType WHERE HardwareTypeID = " + hardwareOverviewRow.HardwareTypeID.ToString();
      DbDataAdapter dataAdapter1 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(selectSql, primDbConnection);
      HardwareTypeTables.HardwareTypeDataTable hardwareTypeDataTable1 = new HardwareTypeTables.HardwareTypeDataTable();
      dataAdapter1.Fill((DataTable) hardwareTypeDataTable1);
      DbDataAdapter dataAdapter2 = DbBasis.SecondaryDB.BaseDbConnection.GetDataAdapter(selectSql, secDbConnection);
      HardwareTypeTables.HardwareTypeDataTable hardwareTypeDataTable2 = new HardwareTypeTables.HardwareTypeDataTable();
      dataAdapter2.Fill((DataTable) hardwareTypeDataTable2);
      if (hardwareTypeDataTable1.Count != 1)
        throw new Exception("Could not load primary data");
      if (hardwareTypeDataTable2.Count != 1)
      {
        this.CompareStates[hardwareOverviewRow.HardwareTypeID] = HardwareTypeEditor.RowCompareState.notAvailable;
        message.AppendLine("Second data not available");
      }
      else
      {
        foreach (DataColumn column in (InternalDataCollectionBase) hardwareTypeDataTable1.Columns)
        {
          if (hardwareTypeDataTable1[0][column.ColumnName] == DBNull.Value)
          {
            if (hardwareTypeDataTable2[0][column.ColumnName] != DBNull.Value)
            {
              this.CompareStates[hardwareOverviewRow.HardwareTypeID] = HardwareTypeEditor.RowCompareState.different;
              message.AppendLine("Column: " + column.ColumnName + " -> PrimaryDB data not available");
            }
          }
          else if (hardwareTypeDataTable2[0][column.ColumnName] == DBNull.Value)
          {
            this.CompareStates[hardwareOverviewRow.HardwareTypeID] = HardwareTypeEditor.RowCompareState.different;
            message.AppendLine("Column: " + column.ColumnName + " -> SecondaryDB data not available");
          }
          else
          {
            string str1 = hardwareTypeDataTable1[0][column.ColumnName].ToString();
            string str2 = hardwareTypeDataTable2[0][column.ColumnName].ToString();
            if (str2 != str1)
            {
              this.CompareStates[hardwareOverviewRow.HardwareTypeID] = HardwareTypeEditor.RowCompareState.different;
              message.AppendLine("Column: " + column.ColumnName + " -> Data different.");
              if (str1.Length < 256 && str2.Length < 256)
              {
                message.AppendLine("   Primary: " + str1);
                message.AppendLine("   Secondary: " + str2);
              }
            }
          }
        }
      }
      if (this.CompareStates[hardwareOverviewRow.HardwareTypeID] != HardwareTypeEditor.RowCompareState.equal)
        return;
      message.AppendLine("Data are equal");
      this.CompareStates[hardwareOverviewRow.HardwareTypeID] = HardwareTypeEditor.RowCompareState.equal;
    }

    private void DataGridOverview_LoadingRow(object sender, DataGridRowEventArgs e)
    {
      HardwareTypeTables.HardwareOverviewRow row = (HardwareTypeTables.HardwareOverviewRow) ((DataRowView) e.Row.DataContext).Row;
      if (!this.CompareStates.ContainsKey(row.HardwareTypeID))
        return;
      switch (this.CompareStates[row.HardwareTypeID])
      {
        case HardwareTypeEditor.RowCompareState.checkError:
          e.Row.Background = (Brush) Brushes.Red;
          break;
        case HardwareTypeEditor.RowCompareState.equal:
          e.Row.Background = (Brush) Brushes.LightGreen;
          break;
        case HardwareTypeEditor.RowCompareState.different:
          e.Row.Background = (Brush) Brushes.Yellow;
          break;
        case HardwareTypeEditor.RowCompareState.notAvailable:
          e.Row.Background = (Brush) Brushes.Orange;
          break;
      }
    }

    private void ButtonUseDataFromHandler_Click(object sender, RoutedEventArgs e)
    {
      if (this.FirmwareVersionFromHandler.HasValue)
        this.TextBoxFirmwareVersionHex.Text = this.TextBoxFirmwareFromHandlerHex.Text;
      if (!this.HardwareTypeFromHandler.HasValue)
        return;
      this.TextBoxHardwareVersion.Text = this.TextBoxHardwareVersionFromHandler.Text;
    }

    private void DataGridOverview_MouseDoubleClick(object sender, MouseButtonEventArgs e)
    {
      this.ButtonShowCompatibleFirmwares_Click(sender, (RoutedEventArgs) null);
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/hardwaremanagement/hardwaretypeeditor.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          ((FrameworkElement) target).Loaded += new RoutedEventHandler(this.Window_Loaded);
          break;
        case 2:
          this.menuMain = (Menu) target;
          break;
        case 3:
          this.MenuItemServiceFunctions = (MenuItem) target;
          break;
        case 4:
          this.MenuItemShowReleasedFirmwareForSapNumber = (MenuItem) target;
          this.MenuItemShowReleasedFirmwareForSapNumber.Click += new RoutedEventHandler(this.MenuItemShowReleasedFirmwareForSapNumber_Click);
          break;
        case 5:
          this.MenuItemShowReleasedFirmwareForHardwareType = (MenuItem) target;
          this.MenuItemShowReleasedFirmwareForHardwareType.Click += new RoutedEventHandler(this.MenuItemShowReleasedFirmwareForHardwareType_Click);
          break;
        case 6:
          this.MenuItemShowReleasedFirmwareForHardwareName = (MenuItem) target;
          this.MenuItemShowReleasedFirmwareForHardwareName.Click += new RoutedEventHandler(this.MenuItemShowReleasedFirmwareForHardwareName_Click);
          break;
        case 7:
          this.MenuItemShowAllReleasedFirmwareForSapNumber = (MenuItem) target;
          this.MenuItemShowAllReleasedFirmwareForSapNumber.Click += new RoutedEventHandler(this.MenuItemShowAllReleasedFirmwareForSapNumber_Click);
          break;
        case 8:
          this.MenuItemShowAllReleasedFirmwareForHardwareType = (MenuItem) target;
          this.MenuItemShowAllReleasedFirmwareForHardwareType.Click += new RoutedEventHandler(this.MenuItemShowAllReleasedFirmwareForHardwareType_Click);
          break;
        case 9:
          this.MenuItemShowAllReleasedFirmwareForHardwareName = (MenuItem) target;
          this.MenuItemShowAllReleasedFirmwareForHardwareName.Click += new RoutedEventHandler(this.MenuItemShowAllReleasedFirmwareForHardwareName_Click);
          break;
        case 10:
          this.MenuItemShowAllCompatibilities = (MenuItem) target;
          this.MenuItemShowAllCompatibilities.Click += new RoutedEventHandler(this.MenuItemShowAllCompatibilities_Click);
          break;
        case 11:
          this.gmmCorporateControl1 = (StartupLib.GmmCorporateControl) target;
          break;
        case 12:
          this.StackPanelButtons = (StackPanel) target;
          break;
        case 13:
          this.ButtonShowCompatibleFirmwares = (Button) target;
          this.ButtonShowCompatibleFirmwares.Click += new RoutedEventHandler(this.ButtonShowCompatibleFirmwares_Click);
          break;
        case 14:
          this.ButtonCreateHardwareType = (Button) target;
          this.ButtonCreateHardwareType.Click += new RoutedEventHandler(this.ButtonCreateHardwareType_Click);
          break;
        case 15:
          this.ButtonChangeHardware = (Button) target;
          this.ButtonChangeHardware.Click += new RoutedEventHandler(this.ButtonChangeHardware_Click);
          break;
        case 16:
          this.ButtonCompareSelected = (Button) target;
          this.ButtonCompareSelected.Click += new RoutedEventHandler(this.ButtonCompareSelected_Click);
          break;
        case 17:
          this.ButtonCompareAll = (Button) target;
          this.ButtonCompareAll.Click += new RoutedEventHandler(this.ButtonCompareAll_Click);
          break;
        case 18:
          this.ButtonCopySelected = (Button) target;
          this.ButtonCopySelected.Click += new RoutedEventHandler(this.ButtonCopySelected_Click);
          break;
        case 19:
          this.TextBoxFirmwareFromHandlerHex = (TextBox) target;
          break;
        case 20:
          this.TextBoxFirmwareFromHandler = (TextBox) target;
          break;
        case 21:
          this.TextBoxHardwareVersionFromHandler = (TextBox) target;
          break;
        case 22:
          this.ButtonUseDataFromHandler = (Button) target;
          this.ButtonUseDataFromHandler.Click += new RoutedEventHandler(this.ButtonUseDataFromHandler_Click);
          break;
        case 23:
          this.TextBoxInfo = (TextBox) target;
          break;
        case 24:
          this.ComboBoxHardwareName = (ComboBox) target;
          break;
        case 25:
          this.TextBoxFirmwareVersionHex = (TextBox) target;
          this.TextBoxFirmwareVersionHex.TextChanged += new TextChangedEventHandler(this.TextBoxFirmwareVersion_TextChanged);
          break;
        case 26:
          this.TextBoxFirmwareVersionStr = (TextBox) target;
          break;
        case 27:
          this.TextBoxFirmwareVersionDec = (TextBox) target;
          break;
        case 28:
          this.TextBoxHardwareVersion = (TextBox) target;
          break;
        case 29:
          this.TextBoxHardwareResource = (TextBox) target;
          break;
        case 30:
          this.TextBoxDescription = (TextBox) target;
          break;
        case 31:
          this.TextBoxTestinfo = (TextBox) target;
          break;
        case 32:
          this.TextBoxHardwareOptions = (TextBox) target;
          break;
        case 33:
          this.DataGridOverview = (DataGrid) target;
          this.DataGridOverview.SelectionChanged += new SelectionChangedEventHandler(this.DataGridOverview_SelectionChanged);
          this.DataGridOverview.LoadingRow += new EventHandler<DataGridRowEventArgs>(this.DataGridOverview_LoadingRow);
          this.DataGridOverview.MouseDoubleClick += new MouseButtonEventHandler(this.DataGridOverview_MouseDoubleClick);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }

    private enum RowCompareState
    {
      checkError,
      equal,
      different,
      notAvailable,
    }
  }
}


--- HardwareTypeSupport.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.HardwareTypeSupport
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using GmmDbLib;
using GmmDbLib.DataSets;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.IO;
using System.Linq;
using System.Text;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;
using ZR_ClassLibrary.Schema_Access;

#nullable disable
namespace HandlerLib
{
  public class HardwareTypeSupport
  {
    internal const string LatestFirmwareVersionReleaseName = "Latest version";
    internal const string ReleasedFirmwareVersionReleaseName = "Released for production";
    private HardwareTypeTables.HardwareAndFirmwareInfoDataTable HardwareAndFirmwareInfoTable;
    private List<CompatibilityInfo> CompatibilityList;
    private static List<CompatibilityInfo> CachedCompatibilityInfo = (List<CompatibilityInfo>) null;
    private static string dummyForLock = "dfl";

    public HardwareTypeSupport(string[] hardwareNames)
    {
      if (hardwareNames == null || hardwareNames.Length == 0)
        throw new ArgumentException("hardwareNames not defined");
      try
      {
        using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.Append("SELECT");
          stringBuilder.Append(" HardwareType.HardwareTypeID as HardwareTypeID");
          stringBuilder.Append(",HardwareType.HardwareName as HardwareName");
          stringBuilder.Append(",HardwareType.HardwareVersion as HardwareVersion");
          stringBuilder.Append(",HardwareType.HardwareResource as HardwareResource");
          stringBuilder.Append(",HardwareType.Description as Description");
          stringBuilder.Append(",HardwareType.Testinfo as Testinfo");
          stringBuilder.Append(",HardwareType.HardwareOptions as HardwareOptions");
          stringBuilder.Append(",ProgFiles.MapID as MapID");
          stringBuilder.Append(",ProgFiles.Options as Options");
          stringBuilder.Append(",ProgFiles.SourceInfo as SourceInfo");
          stringBuilder.Append(",ProgFiles.FirmwareVersion as FirmwareVersion");
          stringBuilder.Append(",ProgFiles.ReleasedName as ReleasedName");
          stringBuilder.Append(",ProgFiles.CompatibleOverwriteGroups as CompatibleOverwriteGroups");
          stringBuilder.Append(",ProgFiles.ReleaseComments as ReleaseComments");
          stringBuilder.Append(" FROM HardwareType,ProgFiles");
          stringBuilder.Append(" WHERE (HardwareType.HardwareVersion > 0)");
          stringBuilder.Append(" AND (HardwareType.FirmwareVersion > 0)");
          bool flag = true;
          foreach (string hardwareName in hardwareNames)
          {
            if (flag)
            {
              stringBuilder.Append(" AND (HardwareType.HardwareName = '" + hardwareName + "'");
              flag = false;
            }
            else
              stringBuilder.Append(" OR HardwareType.HardwareName = '" + hardwareName + "'");
          }
          stringBuilder.Append(")");
          stringBuilder.Append(" AND (HardwareType.MapID = ProgFiles.HardwareTypeMapID)");
          this.HardwareAndFirmwareInfoTable = new HardwareTypeTables.HardwareAndFirmwareInfoDataTable();
          DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection).Fill((DataTable) this.HardwareAndFirmwareInfoTable);
        }
      }
      catch (Exception ex)
      {
        ZR_ClassLibMessages.AddErrorDescription(ZR_ClassLibMessages.LastErrors.InternalError, "Error on read data from table HardwareType");
        throw ex;
      }
    }

    public bool IsMapCompatibility(uint mapId, uint compatibleMapId, string overwriteGroup)
    {
      if ((int) mapId == (int) compatibleMapId)
        return true;
      CompatibilityInfo compatibilityInfos = this.GetMapCompatibilityInfos(mapId, compatibleMapId);
      return compatibilityInfos != null && (compatibilityInfos.IsFullCompatible || compatibilityInfos.CompatibleGroupShortcuts.Contains(overwriteGroup));
    }

    public CompatibilityInfo GetMapCompatibilityInfos(uint mapId, uint compatibleMapId)
    {
      lock (this)
      {
        if (this.CompatibilityList == null)
          this.CreateCompatibilityInfo();
        return this.CompatibilityList.FirstOrDefault<CompatibilityInfo>((System.Func<CompatibilityInfo, bool>) (x =>
        {
          if ((long) mapId == (long) x.MapID && (long) compatibleMapId == (long) x.CompatibleToMapID)
            return true;
          return (long) mapId == (long) x.CompatibleToMapID && (long) compatibleMapId == (long) x.MapID;
        }));
      }
    }

    private void CreateCompatibilityInfo()
    {
      List<CompatibilityInfo> compatibilityInfoList = new List<CompatibilityInfo>();
      foreach (HardwareTypeTables.HardwareAndFirmwareInfoRow andFirmwareInfoRow in (TypedTableBase<HardwareTypeTables.HardwareAndFirmwareInfoRow>) this.HardwareAndFirmwareInfoTable)
      {
        HardwareTypeTables.HardwareAndFirmwareInfoRow theRow = andFirmwareInfoRow;
        if (!theRow.IsCompatibleOverwriteGroupsNull())
        {
          string compatibleOverwriteGroups = theRow.CompatibleOverwriteGroups;
          char[] separator = new char[1]{ ';' };
          foreach (string str in compatibleOverwriteGroups.Split(separator, StringSplitOptions.RemoveEmptyEntries))
          {
            string[] strArray = str.Split(new char[1]{ ',' }, StringSplitOptions.RemoveEmptyEntries);
            int compatibleMapID;
            if (strArray.Length < 1 || !int.TryParse(strArray[0], out compatibleMapID))
              throw new Exception("CompatibleMapId setup error on MapID:" + theRow.MapID.ToString());
            if (theRow.MapID == compatibleMapID)
              throw new Exception("CompatibleMapId setup error. Illegal reference to own MapID:" + theRow.MapID.ToString());
            if (compatibilityInfoList.FirstOrDefault<CompatibilityInfo>((System.Func<CompatibilityInfo, bool>) (x => x.MapID == theRow.MapID && x.CompatibleToMapID == compatibleMapID)) == null)
            {
              CompatibilityInfo compatibilityInfo = new CompatibilityInfo();
              compatibilityInfo.Firmware = (uint) theRow.FirmwareVersion;
              compatibilityInfo.MapID = theRow.MapID;
              compatibilityInfo.CompatibleToMapID = compatibleMapID;
              HardwareTypeTables.HardwareAndFirmwareInfoRow[] andFirmwareInfoRowArray = (HardwareTypeTables.HardwareAndFirmwareInfoRow[]) this.HardwareAndFirmwareInfoTable.Select("MapID = " + compatibleMapID.ToString());
              if (andFirmwareInfoRowArray.Length == 0)
                throw new Exception("CompatibleMapId setup error. Illegal reference to not existing compatibleMapID:" + compatibleMapID.ToString());
              if (andFirmwareInfoRowArray.Length != 0)
                compatibilityInfo.CompatibleToFirmware = (uint) andFirmwareInfoRowArray[0].FirmwareVersion;
              if (strArray.Length == 1)
                compatibilityInfo.IsFullCompatible = true;
              else if (strArray.Length == 2 && strArray[1].Trim() == "full")
              {
                compatibilityInfo.IsFullCompatible = true;
              }
              else
              {
                compatibilityInfo.CompatibleGroupShortcuts = new List<string>();
                for (int index = 1; index < strArray.Length; ++index)
                  compatibilityInfo.CompatibleGroupShortcuts.Add(strArray[index]);
              }
              compatibilityInfoList.Add(compatibilityInfo);
            }
          }
        }
      }
      HardwareTypeSupport.AddMultiLevelCompatibilities(compatibilityInfoList);
      this.CompatibilityList = compatibilityInfoList;
    }

    public HardwareTypeTables.HardwareAndFirmwareInfoRow GetHardwareAndFirmwareInfo(
      int hardwareTypeID)
    {
      return this.HardwareAndFirmwareInfoTable.FirstOrDefault<HardwareTypeTables.HardwareAndFirmwareInfoRow>((System.Func<HardwareTypeTables.HardwareAndFirmwareInfoRow, bool>) (x => x.HardwareTypeID == hardwareTypeID));
    }

    public HardwareTypeTables.HardwareAndFirmwareInfoRow GetHardwareAndFirmwareInfo(
      int hardwareVersion,
      int firmwareVersion)
    {
      return this.HardwareAndFirmwareInfoTable.FirstOrDefault<HardwareTypeTables.HardwareAndFirmwareInfoRow>((System.Func<HardwareTypeTables.HardwareAndFirmwareInfoRow, bool>) (x => x.HardwareVersion == hardwareVersion && x.FirmwareVersion == firmwareVersion));
    }

    public HardwareTypeTables.HardwareAndFirmwareInfoRow GetExactOrNewestMapCompatibleHardwareAndFirmwareInfo(
      int hardwareVersion,
      int firmwareVersion)
    {
      HardwareTypeTables.HardwareAndFirmwareInfoRow hardwareAndFirmwareInfo = this.GetHardwareAndFirmwareInfo(hardwareVersion, firmwareVersion);
      if (hardwareAndFirmwareInfo != null)
        return hardwareAndFirmwareInfo;
      int compatibleFirmwareVersion = (int) ((long) firmwareVersion & 4294905855L);
      EnumerableRowCollection<HardwareTypeTables.HardwareAndFirmwareInfoRow> source = this.HardwareAndFirmwareInfoTable.Where<HardwareTypeTables.HardwareAndFirmwareInfoRow>((System.Func<HardwareTypeTables.HardwareAndFirmwareInfoRow, bool>) (x => x.HardwareVersion == hardwareVersion && ((long) x.FirmwareVersion & 4294905855L) == (long) compatibleFirmwareVersion));
      if (source == null)
        return (HardwareTypeTables.HardwareAndFirmwareInfoRow) null;
      List<HardwareTypeTables.HardwareAndFirmwareInfoRow> list = source.ToList<HardwareTypeTables.HardwareAndFirmwareInfoRow>();
      if (list.Count == 0)
        return (HardwareTypeTables.HardwareAndFirmwareInfoRow) null;
      list.Sort(new Comparison<HardwareTypeTables.HardwareAndFirmwareInfoRow>(this.CompareByVersion));
      return list[0];
    }

    public HardwareTypeTables.HardwareAndFirmwareInfoRow GetNewestFullCompatibleHardwareAndFirmwareInfo(
      HardwareTypeTables.HardwareAndFirmwareInfoRow baseInfo,
      int hardwareMask)
    {
      HardwareTypeTables.HardwareAndFirmwareInfoRow hardwareAndFirmwareInfo = (HardwareTypeTables.HardwareAndFirmwareInfoRow) null;
      foreach (HardwareTypeTables.HardwareAndFirmwareInfoRow testRow in (TypedTableBase<HardwareTypeTables.HardwareAndFirmwareInfoRow>) this.HardwareAndFirmwareInfoTable)
      {
        if (testRow.HardwareVersion == hardwareMask && this.IsHardwareCompatible(baseInfo, testRow) && (hardwareAndFirmwareInfo == null || hardwareAndFirmwareInfo.FirmwareVersion < testRow.FirmwareVersion))
          hardwareAndFirmwareInfo = testRow;
      }
      return hardwareAndFirmwareInfo;
    }

    public bool IsHardwareCompatible(
      HardwareTypeTables.HardwareAndFirmwareInfoRow baseRow,
      HardwareTypeTables.HardwareAndFirmwareInfoRow testRow)
    {
      if (baseRow == testRow)
        return true;
      string str = baseRow.HardwareTypeID.ToString();
      while (!testRow.IsHardwareOptionsNull())
      {
        string parameter = ParameterService.GetParameter(testRow.HardwareOptions, "CompatibleHwTypeId", '=', ';');
        if (parameter.Length == 0)
          return false;
        if (parameter == str)
          return true;
        testRow = (HardwareTypeTables.HardwareAndFirmwareInfoRow) null;
        foreach (HardwareTypeTables.HardwareAndFirmwareInfoRow andFirmwareInfoRow in (TypedTableBase<HardwareTypeTables.HardwareAndFirmwareInfoRow>) this.HardwareAndFirmwareInfoTable)
        {
          if (andFirmwareInfoRow.HardwareTypeID.ToString() == parameter)
          {
            testRow = andFirmwareInfoRow;
            break;
          }
        }
        if (testRow == null)
          return false;
      }
      return false;
    }

    private int CompareByVersion(
      HardwareTypeTables.HardwareAndFirmwareInfoRow a,
      HardwareTypeTables.HardwareAndFirmwareInfoRow b)
    {
      return b.FirmwareVersion.CompareTo(a.FirmwareVersion);
    }

    public static List<FirmwareReleaseInfo> GetAllReleasedFirmwareReleaseInfosForSapNumber(
      string SAP_Number)
    {
      List<FirmwareReleaseInfo> infosForSapNumber = new List<FirmwareReleaseInfo>();
      using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
      {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append(" SELECT");
        stringBuilder.Append(" ProgFiles.MapID as MapID,");
        stringBuilder.Append(" ProgFiles.ProgFileName as ProgFileName,");
        stringBuilder.Append(" ProgFiles.FirmwareVersion as FirmwareVersion,");
        stringBuilder.Append(" ProgFiles.ReleasedName as ReleasedName,");
        stringBuilder.Append(" ProgFiles.ReleaseComments as ReleaseComments");
        stringBuilder.Append(" FROM HardwareType, ProgFiles, MeterInfo");
        stringBuilder.Append(" WHERE MeterInfo.PPSArtikelNr = '" + SAP_Number + "'");
        stringBuilder.Append(" AND MeterInfo.HardwareTypeID = HardwareType.HardwareTypeID");
        stringBuilder.Append(" AND HardwareType.MapID = ProgFiles.HardwareTypeMapID");
        stringBuilder.Append(" AND NOT (ProgFiles.ReleasedName IS Null)");
        DbDataAdapter dataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
        HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
        dataAdapter.Fill((DataTable) progFilesDataTable);
        foreach (HardwareTypeTables.ProgFilesRow progFilesRow in (TypedTableBase<HardwareTypeTables.ProgFilesRow>) progFilesDataTable)
        {
          string str1 = new FirmwareVersion((uint) progFilesRow.FirmwareVersion).ToString();
          string str2 = (string) null;
          if (!progFilesRow.IsReleaseCommentsNull())
            str2 = progFilesRow.ReleaseComments;
          infosForSapNumber.Add(new FirmwareReleaseInfo()
          {
            MapID = progFilesRow.MapID,
            ProgFilName = progFilesRow.ProgFileName,
            ReleaseText = progFilesRow.ReleasedName,
            FirmwareVersion = progFilesRow.FirmwareVersion,
            FirmwareVersionString = str1,
            ReleaseDescription = str2
          });
        }
      }
      infosForSapNumber.Sort();
      return infosForSapNumber;
    }

    public static List<FirmwareReleaseInfo> GetAllReleasedFirmwareReleaseInfoForHardwareType(
      int HardwareTypeID)
    {
      List<FirmwareReleaseInfo> infoForHardwareType = new List<FirmwareReleaseInfo>();
      using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
      {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append(" SELECT");
        stringBuilder.Append(" ProgFiles.MapID as MapID,");
        stringBuilder.Append(" ProgFiles.ProgFileName as ProgFileName,");
        stringBuilder.Append(" ProgFiles.FirmwareVersion as FirmwareVersion,");
        stringBuilder.Append(" ProgFiles.ReleasedName as ReleasedName,");
        stringBuilder.Append(" ProgFiles.ReleaseComments as ReleaseComments");
        stringBuilder.Append(" FROM HardwareType, ProgFiles");
        stringBuilder.Append(" WHERE HardwareType.HardwareTypeID = " + HardwareTypeID.ToString());
        stringBuilder.Append(" AND HardwareType.MapID = ProgFiles.HardwareTypeMapID");
        stringBuilder.Append(" AND NOT (ReleasedName IS Null)");
        DbDataAdapter dataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
        HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
        dataAdapter.Fill((DataTable) progFilesDataTable);
        foreach (HardwareTypeTables.ProgFilesRow progFilesRow in (TypedTableBase<HardwareTypeTables.ProgFilesRow>) progFilesDataTable)
        {
          string str1 = new FirmwareVersion((uint) progFilesRow.FirmwareVersion).ToString();
          string str2 = (string) null;
          if (!progFilesRow.IsReleaseCommentsNull())
            str2 = progFilesRow.ReleaseComments;
          infoForHardwareType.Add(new FirmwareReleaseInfo()
          {
            MapID = progFilesRow.MapID,
            ProgFilName = progFilesRow.ProgFileName,
            ReleaseText = progFilesRow.ReleasedName,
            FirmwareVersion = progFilesRow.FirmwareVersion,
            FirmwareVersionString = str1,
            ReleaseDescription = str2
          });
        }
      }
      infoForHardwareType.Sort();
      return infoForHardwareType;
    }

    public static List<FirmwareReleaseInfo> GetAllReleasedFirmwareReleaseInfosForProgFileName(
      string FileName,
      string hardwareResource = null)
    {
      List<FirmwareReleaseInfo> infosForProgFileName = new List<FirmwareReleaseInfo>();
      using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
      {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append(" SELECT MapID,ProgFileName, FirmwareVersion, ReleasedName, ReleaseComments, Options FROM ProgFiles");
        stringBuilder.Append(" WHERE ProgFileName like '%" + FileName + "%'");
        stringBuilder.Append(" AND NOT (ReleasedName IS Null)");
        DbDataAdapter dataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
        HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
        dataAdapter.Fill((DataTable) progFilesDataTable);
        foreach (HardwareTypeTables.ProgFilesRow progFilesRow in (TypedTableBase<HardwareTypeTables.ProgFilesRow>) progFilesDataTable)
        {
          if (hardwareResource != null)
          {
            if (!progFilesRow.IsOptionsNull())
            {
              List<KeyValuePair<string, string>> keyValuePairList = DbUtil.KeyValueStringListToKeyValuePairList(progFilesRow.Options);
              int index = keyValuePairList.FindIndex((Predicate<KeyValuePair<string, string>>) (x => x.Key == "HardwareResource"));
              if (index >= 0)
              {
                if (((IEnumerable<string>) keyValuePairList[index].Value.Split(';')).FirstOrDefault<string>((System.Func<string, bool>) (x => x == hardwareResource)) == null)
                  continue;
              }
            }
            else
              continue;
          }
          string str1 = new FirmwareVersion((uint) progFilesRow.FirmwareVersion).ToString();
          string str2 = (string) null;
          if (!progFilesRow.IsReleaseCommentsNull())
            str2 = progFilesRow.ReleaseComments;
          FirmwareReleaseInfo firmwareReleaseInfo = new FirmwareReleaseInfo();
          firmwareReleaseInfo.MapID = progFilesRow.MapID;
          if (!progFilesRow.IsProgFileNameNull())
            firmwareReleaseInfo.ProgFilName = progFilesRow.ProgFileName;
          firmwareReleaseInfo.ReleaseText = progFilesRow.ReleasedName;
          firmwareReleaseInfo.FirmwareVersion = progFilesRow.FirmwareVersion;
          firmwareReleaseInfo.FirmwareVersionString = str1;
          firmwareReleaseInfo.ReleaseDescription = str2;
          infosForProgFileName.Add(firmwareReleaseInfo);
        }
      }
      infosForProgFileName.Sort();
      return infosForProgFileName;
    }

    public static List<FirmwareReleaseInfo> GetAllReleasedFirmwareReleaseInfosForHardwareName(
      string hardwareName,
      string hardwareResource = null)
    {
      List<FirmwareReleaseInfo> infosForHardwareName = new List<FirmwareReleaseInfo>();
      using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
      {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append(" SELECT MapID,ProgFileName, FirmwareVersion, ReleasedName, ReleaseComments, Options FROM ProgFiles");
        stringBuilder.Append(" WHERE HardwareName = '" + hardwareName + "'");
        stringBuilder.Append(" AND NOT (ReleasedName IS Null)");
        DbDataAdapter dataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
        HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
        dataAdapter.Fill((DataTable) progFilesDataTable);
        foreach (HardwareTypeTables.ProgFilesRow progFilesRow in (TypedTableBase<HardwareTypeTables.ProgFilesRow>) progFilesDataTable)
        {
          if (hardwareResource != null)
          {
            if (!progFilesRow.IsOptionsNull())
            {
              List<KeyValuePair<string, string>> keyValuePairList = DbUtil.KeyValueStringListToKeyValuePairList(progFilesRow.Options);
              int index = keyValuePairList.FindIndex((Predicate<KeyValuePair<string, string>>) (x => x.Key == "HardwareResource"));
              if (index >= 0)
              {
                if (((IEnumerable<string>) keyValuePairList[index].Value.Split(';')).FirstOrDefault<string>((System.Func<string, bool>) (x => x == hardwareResource)) == null)
                  continue;
              }
            }
            else
              continue;
          }
          string str1 = new FirmwareVersion((uint) progFilesRow.FirmwareVersion).ToString();
          string str2 = (string) null;
          if (!progFilesRow.IsReleaseCommentsNull())
            str2 = progFilesRow.ReleaseComments;
          FirmwareReleaseInfo firmwareReleaseInfo = new FirmwareReleaseInfo();
          firmwareReleaseInfo.MapID = progFilesRow.MapID;
          if (!progFilesRow.IsProgFileNameNull())
            firmwareReleaseInfo.ProgFilName = progFilesRow.ProgFileName;
          firmwareReleaseInfo.ReleaseText = progFilesRow.ReleasedName;
          firmwareReleaseInfo.FirmwareVersion = progFilesRow.FirmwareVersion;
          firmwareReleaseInfo.FirmwareVersionString = str1;
          firmwareReleaseInfo.ReleaseDescription = str2;
          infosForHardwareName.Add(firmwareReleaseInfo);
        }
      }
      infosForHardwareName.Sort();
      return infosForHardwareName;
    }

    public static List<FirmwareReleaseInfo> GetAllReleasedFirmwareReleaseInfosForHardwareNameAndSampleHardware(
      string hardwareName,
      string hardwareResource = null,
      bool sampleHardwareAllowed = false)
    {
      List<FirmwareReleaseInfo> andSampleHardware = new List<FirmwareReleaseInfo>();
      using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
      {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append(" SELECT MapID,ProgFileName, FirmwareVersion, ReleasedName, ReleaseComments, Options FROM ProgFiles");
        stringBuilder.Append(" WHERE HardwareName = '" + hardwareName + "'");
        stringBuilder.Append(" AND NOT (ReleasedName IS Null)");
        DbDataAdapter dataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
        HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
        dataAdapter.Fill((DataTable) progFilesDataTable);
        foreach (HardwareTypeTables.ProgFilesRow progFilesRow in (TypedTableBase<HardwareTypeTables.ProgFilesRow>) progFilesDataTable)
        {
          if (hardwareResource != null)
          {
            if (!progFilesRow.IsOptionsNull())
            {
              List<KeyValuePair<string, string>> keyValuePairList = DbUtil.KeyValueStringListToKeyValuePairList(progFilesRow.Options);
              int index1 = keyValuePairList.FindIndex((Predicate<KeyValuePair<string, string>>) (x => x.Key == "HardwareResource"));
              if (index1 >= 0)
              {
                KeyValuePair<string, string> keyValuePair = keyValuePairList[index1];
                if (((IEnumerable<string>) keyValuePair.Value.Split(',')).FirstOrDefault<string>((System.Func<string, bool>) (x => x == hardwareResource)) == null)
                {
                  if (sampleHardwareAllowed)
                  {
                    int index2 = keyValuePairList.FindIndex((Predicate<KeyValuePair<string, string>>) (x => x.Key == "SampleHardware"));
                    if (index2 >= 0)
                    {
                      keyValuePair = keyValuePairList[index2];
                      if (((IEnumerable<string>) keyValuePair.Value.Split(',')).FirstOrDefault<string>((System.Func<string, bool>) (x => x == hardwareResource)) == null)
                        continue;
                    }
                    else
                      continue;
                  }
                  else
                    continue;
                }
              }
              else
                continue;
            }
            else
              continue;
          }
          string str1 = new FirmwareVersion((uint) progFilesRow.FirmwareVersion).ToString();
          string str2 = (string) null;
          if (!progFilesRow.IsReleaseCommentsNull())
            str2 = progFilesRow.ReleaseComments;
          FirmwareReleaseInfo firmwareReleaseInfo = new FirmwareReleaseInfo();
          firmwareReleaseInfo.MapID = progFilesRow.MapID;
          if (!progFilesRow.IsProgFileNameNull())
            firmwareReleaseInfo.ProgFilName = progFilesRow.ProgFileName;
          firmwareReleaseInfo.ReleaseText = progFilesRow.ReleasedName;
          firmwareReleaseInfo.FirmwareVersion = progFilesRow.FirmwareVersion;
          firmwareReleaseInfo.FirmwareVersionString = str1;
          firmwareReleaseInfo.ReleaseDescription = str2;
          andSampleHardware.Add(firmwareReleaseInfo);
        }
      }
      andSampleHardware.Sort();
      return andSampleHardware;
    }

    public static List<FirmwareReleaseInfo> GetBslFirmwareReleaseInfosForFirmwareVersion(
      uint firmwareVersion)
    {
      List<FirmwareReleaseInfo> forFirmwareVersion = new List<FirmwareReleaseInfo>();
      using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
      {
        BaseDbConnection baseDbConnection = DbBasis.PrimaryDB.BaseDbConnection;
        if (baseDbConnection == null)
          throw new ArgumentNullException("Primary database");
        HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
        string empty = string.Empty;
        string selectSql = "SELECT p.MapID, p.ProgFileName, p.FirmwareVersion, p.ReleasedName, p.ReleaseComments FROM ProgFiles p WHERE p.hardwaretypemapid = 105 AND h.FirmwareDependencies like '%" + firmwareVersion.ToString().Trim() + "%' ORDER BY p.FirmwareVersion desc";
        baseDbConnection.GetDataAdapter(selectSql, newConnection).Fill((DataTable) progFilesDataTable);
        foreach (HardwareTypeTables.ProgFilesRow progFilesRow in (TypedTableBase<HardwareTypeTables.ProgFilesRow>) progFilesDataTable)
        {
          string str1 = new FirmwareVersion((uint) progFilesRow.FirmwareVersion).ToString();
          string str2 = (string) null;
          if (!progFilesRow.IsReleaseCommentsNull())
            str2 = progFilesRow.ReleaseComments;
          forFirmwareVersion.Add(new FirmwareReleaseInfo()
          {
            MapID = progFilesRow.MapID,
            ProgFilName = progFilesRow.ProgFileName,
            ReleaseText = progFilesRow.ReleasedName,
            FirmwareVersion = progFilesRow.FirmwareVersion,
            FirmwareVersionString = str1,
            ReleaseDescription = str2
          });
        }
      }
      forFirmwareVersion.Sort();
      return forFirmwareVersion;
    }

    public static List<FirmwareReleaseInfo> GetFirmwareReleaseInfosForHardwareTypeID(
      uint HardwareTypeID)
    {
      List<FirmwareReleaseInfo> forHardwareTypeId = new List<FirmwareReleaseInfo>();
      using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
      {
        BaseDbConnection baseDbConnection = DbBasis.PrimaryDB.BaseDbConnection;
        if (baseDbConnection == null)
          throw new ArgumentNullException("Primary database");
        HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
        string empty = string.Empty;
        string selectSql = "SELECT MapID, ProgFileName, FirmwareVersion, ReleasedName, ReleaseComments  FROM ProgFiles  WHERE HardwareTypeMapID = " + HardwareTypeID.ToString().Trim() + " ORDER BY FirmwareVersion desc";
        baseDbConnection.GetDataAdapter(selectSql, newConnection).Fill((DataTable) progFilesDataTable);
        foreach (HardwareTypeTables.ProgFilesRow progFilesRow in (TypedTableBase<HardwareTypeTables.ProgFilesRow>) progFilesDataTable)
        {
          string str1 = new FirmwareVersion((uint) progFilesRow.FirmwareVersion).ToString();
          string str2 = string.Empty;
          if (!progFilesRow.IsReleaseCommentsNull())
            str2 = progFilesRow.ReleaseComments;
          forHardwareTypeId.Add(new FirmwareReleaseInfo()
          {
            MapID = progFilesRow.MapID,
            FirmwareVersion = progFilesRow.FirmwareVersion,
            FirmwareVersionString = str1,
            ProgFilName = progFilesRow.ProgFileName,
            ReleaseDescription = progFilesRow.IsReleaseCommentsNull() ? string.Empty : str2,
            ReleaseText = progFilesRow.IsReleasedNameNull() ? string.Empty : progFilesRow.ReleasedName
          });
        }
      }
      forHardwareTypeId.Sort();
      return forHardwareTypeId;
    }

    public static FirmwareReleaseInfo GetReleasedFirmwareInfoForSapNumber(string SAP_Number)
    {
      return HardwareTypeSupport.GetReleasedFirmwareReleaseInfo(HardwareTypeSupport.GetAllReleasedFirmwareReleaseInfosForSapNumber(SAP_Number));
    }

    public static FirmwareReleaseInfo GetReleasedFirmwareInfoForHardwareType(int HardwareTypeID)
    {
      return HardwareTypeSupport.GetReleasedFirmwareReleaseInfo(HardwareTypeSupport.GetAllReleasedFirmwareReleaseInfoForHardwareType(HardwareTypeID));
    }

    public static FirmwareReleaseInfo GetReleasedFirmwareInfoForHardwareName(string hardwareName)
    {
      return HardwareTypeSupport.GetReleasedFirmwareReleaseInfo(HardwareTypeSupport.GetAllReleasedFirmwareReleaseInfosForHardwareName(hardwareName));
    }

    private static FirmwareReleaseInfo GetReleasedFirmwareReleaseInfo(
      List<FirmwareReleaseInfo> allReleased)
    {
      FirmwareReleaseInfo firmwareReleaseInfo = (FirmwareReleaseInfo) null;
      if (allReleased != null)
        firmwareReleaseInfo = allReleased.Count <= 1 ? allReleased[0] : throw new Exception("More then one released firmware version found.");
      return firmwareReleaseInfo;
    }

    public static FirmwareData GetReleasedFirmwareDataForSapNumber(string SAP_Number)
    {
      return HardwareTypeSupport.GetReleasedFirmwareData(HardwareTypeSupport.GetAllReleasedFirmwareReleaseInfosForSapNumber(SAP_Number));
    }

    public static FirmwareData GetReleasedFirmwareDataForHardwareType(int HardwareTypeID)
    {
      return HardwareTypeSupport.GetReleasedFirmwareData(HardwareTypeSupport.GetAllReleasedFirmwareReleaseInfoForHardwareType(HardwareTypeID));
    }

    public static FirmwareData GetReleasedFirmwareDataForHardwareName(string hardwareName)
    {
      return HardwareTypeSupport.GetReleasedFirmwareData(HardwareTypeSupport.GetAllReleasedFirmwareReleaseInfosForHardwareName(hardwareName));
    }

    private static FirmwareData GetReleasedFirmwareData(List<FirmwareReleaseInfo> allReleased)
    {
      FirmwareData releasedFirmwareData = (FirmwareData) null;
      FirmwareReleaseInfo firmwareReleaseInfo = HardwareTypeSupport.GetReleasedFirmwareReleaseInfo(allReleased);
      if (firmwareReleaseInfo != null)
        releasedFirmwareData = HardwareTypeSupport.GetFirmwareData((uint) firmwareReleaseInfo.MapID);
      return releasedFirmwareData;
    }

    public static FirmwareData GetFirmwareData(uint MapID)
    {
      FirmwareData firmwareData = new FirmwareData();
      try
      {
        using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          string selectSql = "SELECT * FROM ProgFiles WHERE MapID = " + MapID.ToString();
          DbDataAdapter dataAdapter = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(selectSql, newConnection, out DbCommandBuilder _);
          HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
          dataAdapter.Fill((DataTable) progFilesDataTable);
          if (progFilesDataTable.Count <= 0)
            return (FirmwareData) null;
          if (!progFilesDataTable[0].IsProgFileNameNull())
            firmwareData.ProgFileName = progFilesDataTable[0].ProgFileName;
          firmwareData.Options = !progFilesDataTable[0].IsOptionsNull() ? DbUtil.KeyValueStringListToKeyValuePairList(progFilesDataTable[0].Options) : new List<KeyValuePair<string, string>>();
          if (progFilesDataTable[0].IsSourceInfoNull())
            firmwareData.SourceInfo = progFilesDataTable[0].SourceInfo;
          if (!progFilesDataTable[0].IsHexTextNull())
          {
            firmwareData.ProgrammerFileAsString = progFilesDataTable[0].HexText;
            firmwareData.Options.Add(new KeyValuePair<string, string>(nameof (MapID), MapID.ToString()));
            int index = firmwareData.Options.FindIndex((Predicate<KeyValuePair<string, string>>) (x => x.Key == "Compression"));
            if (index >= 0)
            {
              if (firmwareData.Options[index].Value != "ZIP")
                throw new Exception("Unsupported compression formate: " + firmwareData.Options[index].Value);
              firmwareData.ProgrammerFileAsString = ZipUnzip.GetStringFromZipedString(firmwareData.ProgrammerFileAsString);
            }
          }
        }
      }
      catch (Exception ex)
      {
        throw new Exception("GetFirmwareData exception", ex);
      }
      return firmwareData;
    }

    [Obsolete]
    public static bool GetFirmwareProgramInformationsFromProgFilesTable(
      long MapID,
      out string FirmwareFileString,
      out string ProgFileName,
      out string ProgFileOptions,
      out string Fehlerstring)
    {
      FirmwareFileString = string.Empty;
      ProgFileName = string.Empty;
      ProgFileOptions = string.Empty;
      Fehlerstring = string.Empty;
      try
      {
        FirmwareData firmwareData = HardwareTypeSupport.GetFirmwareData((uint) MapID);
        FirmwareFileString = firmwareData.ProgrammerFileAsString;
        ProgFileName = firmwareData.ProgFileName;
        ProgFileOptions = DbUtil.KeyValuePairListToKeyValueStringList(firmwareData.Options);
        return true;
      }
      catch (Exception ex)
      {
        Fehlerstring = ex.ToString();
        return false;
      }
    }

    public static uint GetMapIDForHardwareTypeFromHardwareTypeTable(uint hardwareTypeID)
    {
      string empty = string.Empty;
      BaseDbConnection baseDbConnection = DbBasis.PrimaryDB.BaseDbConnection;
      if (baseDbConnection == null)
        throw new ArgumentNullException("Primary database");
      Schema.HardwareTypeDataTable hardwareTypeDataTable = new Schema.HardwareTypeDataTable();
      using (DbConnection newConnection = baseDbConnection.GetNewConnection())
      {
        string selectSql = "SELECT * FROM HardwareType WHERE HardwareTypeID = " + hardwareTypeID.ToString();
        baseDbConnection.GetDataAdapter(selectSql, newConnection).Fill((DataTable) hardwareTypeDataTable);
      }
      return hardwareTypeDataTable.Rows.Count == 0 ? 0U : (uint) hardwareTypeDataTable[0].MapID;
    }

    [Obsolete("Use FirmwareData.WriteToFile")]
    public static bool WriteFirmwareProgramIntoFile(
      string Dateiname,
      string FirmwareFileString,
      out string Fehlerstring)
    {
      Fehlerstring = string.Empty;
      try
      {
        FileStream fileStream = new FileStream(Dateiname, FileMode.Create, FileAccess.Write, FileShare.ReadWrite);
        StreamWriter streamWriter = new StreamWriter((Stream) fileStream, Encoding.ASCII);
        streamWriter.Write(FirmwareFileString);
        streamWriter.Close();
        fileStream.Close();
        return true;
      }
      catch (Exception ex)
      {
        Fehlerstring = ex.ToString();
        return false;
      }
    }

    public static FirmwareData GetNewestBSLFromProgFilesTable(
      uint actualFWVersion,
      uint newFWVersion)
    {
      FirmwareData fromProgFilesTable = new FirmwareData();
      int MapID = 0;
      string empty = string.Empty;
      BaseDbConnection baseDbConnection = DbBasis.PrimaryDB.BaseDbConnection;
      if (baseDbConnection == null)
        throw new ArgumentNullException("Primary database");
      HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
      using (DbConnection newConnection = baseDbConnection.GetNewConnection())
      {
        string selectSql = "SELECT * FROM Progfiles WHERE HardwareName like 'BootLoader' AND FirmwareDependencies like '%" + actualFWVersion.ToString("x8") + "%' " + (newFWVersion == 1U ? "" : "AND FirmwareDependencies like '%" + newFWVersion.ToString("x8") + "%' ") + "ORDER BY FirmwareVersion desc";
        baseDbConnection.GetDataAdapter(selectSql, newConnection).Fill((DataTable) progFilesDataTable);
      }
      if (progFilesDataTable.Rows.Count == 0)
      {
        fromProgFilesTable.SourceInfo = "No Bootloader found for this firmware version!";
        return fromProgFilesTable;
      }
      ushort num = (ushort) (actualFWVersion & 4095U);
      if (progFilesDataTable.Count > 1)
        fromProgFilesTable.SourceInfo = "More than one Bootloader found for this firmware version!\nCheck your database, this should not happen !!!";
      if (!progFilesDataTable[0].IsHardwareTypeMapIDNull())
        MapID = progFilesDataTable[0].MapID;
      if (MapID <= 0)
      {
        fromProgFilesTable.SourceInfo = "No Bootloader found for this firmware version!";
        return fromProgFilesTable;
      }
      FirmwareData firmwareData = HardwareTypeSupport.GetFirmwareData((uint) MapID);
      firmwareData.Options.Add(new KeyValuePair<string, string>("MapID", MapID.ToString()));
      return firmwareData;
    }

    private static void FindCompatible(
      List<CompatibilityInfo> fullCompatibleList,
      List<CompatibilityInfo> mapCompatibleList,
      int MapID)
    {
      foreach (CompatibilityInfo compatibilityInfo in fullCompatibleList.FindAll((Predicate<CompatibilityInfo>) (x => x.CompatibleToMapID == MapID)))
      {
        CompatibilityInfo ci = compatibilityInfo;
        if (mapCompatibleList.FindIndex((Predicate<CompatibilityInfo>) (x => x.MapID == ci.MapID && x.CompatibleToMapID == ci.CompatibleToMapID)) < 0)
        {
          mapCompatibleList.Add(ci);
          HardwareTypeSupport.FindCompatible(fullCompatibleList, mapCompatibleList, ci.MapID);
        }
      }
    }

    public static CompatibilityInfo GetCompatibilityInfos(
      uint firmwareVersion,
      uint compatibleFirmwareVersion)
    {
      List<CompatibilityInfo> compatibilityInfos = HardwareTypeSupport.GetAllCompatibilityInfos();
      return compatibleFirmwareVersion >= firmwareVersion ? compatibilityInfos.FirstOrDefault<CompatibilityInfo>((System.Func<CompatibilityInfo, bool>) (x => (int) compatibleFirmwareVersion == (int) x.Firmware && (int) firmwareVersion == (int) x.CompatibleToFirmware)) ?? compatibilityInfos.FirstOrDefault<CompatibilityInfo>((System.Func<CompatibilityInfo, bool>) (x => (int) firmwareVersion == (int) x.Firmware && (int) compatibleFirmwareVersion == (int) x.CompatibleToFirmware)) : compatibilityInfos.FirstOrDefault<CompatibilityInfo>((System.Func<CompatibilityInfo, bool>) (x => (int) firmwareVersion == (int) x.Firmware && (int) compatibleFirmwareVersion == (int) x.CompatibleToFirmware)) ?? compatibilityInfos.FirstOrDefault<CompatibilityInfo>((System.Func<CompatibilityInfo, bool>) (x => (int) compatibleFirmwareVersion == (int) x.Firmware && (int) firmwareVersion == (int) x.CompatibleToFirmware));
    }

    public static void ClearCache()
    {
      lock (HardwareTypeSupport.dummyForLock)
        HardwareTypeSupport.CachedCompatibilityInfo = (List<CompatibilityInfo>) null;
    }

    public static List<CompatibilityInfo> GetAllCompatibilityInfos()
    {
      lock (HardwareTypeSupport.dummyForLock)
      {
        if (HardwareTypeSupport.CachedCompatibilityInfo != null)
          return HardwareTypeSupport.CachedCompatibilityInfo;
        List<CompatibilityInfo> compatibilityList = new List<CompatibilityInfo>();
        using (DbConnection newConnection = DbBasis.PrimaryDB.BaseDbConnection.GetNewConnection())
        {
          StringBuilder stringBuilder = new StringBuilder();
          stringBuilder.Append("SELECT HardwareTypeID, MapID, FirmwareVersion, HardwareName ");
          stringBuilder.Append(" FROM HardwareType");
          DbDataAdapter dataAdapter1 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
          HardwareTypeTables.HardwareTypeDataTable hardwareTypeDataTable = new HardwareTypeTables.HardwareTypeDataTable();
          dataAdapter1.Fill((DataTable) hardwareTypeDataTable);
          stringBuilder.Clear();
          stringBuilder.Append(" SELECT MapID, Options, FirmwareVersion, CompatibleOverwriteGroups, HardwareTypeMapID, HardwareName FROM ProgFiles");
          stringBuilder.Append(" WHERE NOT (CompatibleOverwriteGroups IS NULL or HardwareName IS NULL)");
          DbDataAdapter dataAdapter2 = DbBasis.PrimaryDB.BaseDbConnection.GetDataAdapter(stringBuilder.ToString(), newConnection);
          HardwareTypeTables.ProgFilesDataTable progFilesDataTable = new HardwareTypeTables.ProgFilesDataTable();
          dataAdapter2.Fill((DataTable) progFilesDataTable);
          foreach (HardwareTypeTables.ProgFilesRow progFilesRow in (TypedTableBase<HardwareTypeTables.ProgFilesRow>) progFilesDataTable)
          {
            string compatibleOverwriteGroups = progFilesRow.CompatibleOverwriteGroups;
            char[] separator1 = new char[1]{ ';' };
            foreach (string str1 in compatibleOverwriteGroups.Split(separator1, StringSplitOptions.RemoveEmptyEntries))
            {
              char[] separator2 = new char[1]{ ',' };
              string[] strArray = str1.Split(separator2, StringSplitOptions.RemoveEmptyEntries);
              int result;
              if (strArray.Length < 1 || !int.TryParse(strArray[0], out result))
                throw new Exception("CompatibleMapId setup error on MapID:" + progFilesRow.MapID.ToString());
              string str2 = string.Empty;
              if (!progFilesRow.IsNull("HardwareName").Equals((object) DBNull.Value))
                str2 = " and HardwareName like '" + progFilesRow.HardwareName + "%' ";
              if (((HardwareTypeTables.HardwareTypeRow[]) hardwareTypeDataTable.Select("MapID = " + progFilesRow.HardwareTypeMapID.ToString() + str2)).Length != 0)
              {
                HardwareTypeTables.ProgFilesRow[] progFilesRowArray = (HardwareTypeTables.ProgFilesRow[]) null;
                HardwareTypeTables.HardwareTypeRow[] hardwareTypeRowArray = (HardwareTypeTables.HardwareTypeRow[]) hardwareTypeDataTable.Select("MapID = " + result.ToString() + str2);
                if (hardwareTypeRowArray.Length == 0)
                {
                  progFilesRowArray = (HardwareTypeTables.ProgFilesRow[]) progFilesDataTable.Select("MapID = " + result.ToString() + str2);
                  if (progFilesRowArray.Length == 0)
                    continue;
                }
                CompatibilityInfo compatibilityInfo = new CompatibilityInfo();
                compatibilityInfo.Firmware = (uint) progFilesRow.FirmwareVersion;
                compatibilityInfo.MapID = progFilesRow.MapID;
                compatibilityInfo.CompatibleToMapID = result;
                if (hardwareTypeRowArray.Length != 0)
                  compatibilityInfo.CompatibleToFirmware = (uint) hardwareTypeRowArray[0].FirmwareVersion;
                if (progFilesRowArray != null && progFilesRowArray.Length != 0)
                  compatibilityInfo.CompatibleToFirmware = (uint) progFilesRowArray[0].FirmwareVersion;
                if (strArray.Length == 1)
                  compatibilityInfo.IsFullCompatible = true;
                else if (strArray.Length == 2 && strArray[1].Trim().ToLower() == "full")
                {
                  compatibilityInfo.IsFullCompatible = true;
                }
                else
                {
                  compatibilityInfo.CompatibleGroupShortcuts = new List<string>();
                  for (int index = 1; index < strArray.Length; ++index)
                    compatibilityInfo.CompatibleGroupShortcuts.Add(strArray[index]);
                }
                compatibilityList.Add(compatibilityInfo);
              }
            }
          }
        }
        HardwareTypeSupport.AddMultiLevelCompatibilities(compatibilityList);
        HardwareTypeSupport.CachedCompatibilityInfo = compatibilityList;
        return compatibilityList;
      }
    }

    private static void AddMultiLevelCompatibilities(List<CompatibilityInfo> compatibilityList)
    {
      List<CompatibilityInfo> compatibilityInfoList1 = new List<CompatibilityInfo>();
      List<CompatibilityInfo> compatibilityInfoList2 = new List<CompatibilityInfo>();
      List<uint> uintList = new List<uint>();
      bool flag;
      do
      {
        uintList.Clear();
        flag = false;
        for (int index = 0; index < compatibilityList.Count; ++index)
        {
          CompatibilityInfo testInfo = compatibilityList[index];
          if (!uintList.Contains(testInfo.Firmware))
          {
            uintList.Add(testInfo.Firmware);
            List<CompatibilityInfo> all = compatibilityList.FindAll((Predicate<CompatibilityInfo>) (x => (int) x.Firmware == (int) testInfo.Firmware));
            compatibilityInfoList1.Clear();
            foreach (CompatibilityInfo compatibilityInfo1 in all)
            {
              CompatibilityInfo knownCompatibility = compatibilityInfo1;
              foreach (CompatibilityInfo compatibilityInfo2 in compatibilityList.FindAll((Predicate<CompatibilityInfo>) (x => (int) x.Firmware == (int) knownCompatibility.CompatibleToFirmware)))
              {
                CompatibilityInfo subObject = compatibilityInfo2;
                if ((int) subObject.CompatibleToFirmware != (int) testInfo.Firmware)
                {
                  CompatibilityInfo compatibilityInfo3 = all.FirstOrDefault<CompatibilityInfo>((System.Func<CompatibilityInfo, bool>) (x => (int) x.CompatibleToFirmware == (int) subObject.CompatibleToFirmware)) ?? compatibilityInfoList1.FirstOrDefault<CompatibilityInfo>((System.Func<CompatibilityInfo, bool>) (x => (int) x.CompatibleToFirmware == (int) subObject.CompatibleToFirmware));
                  if (compatibilityInfo3 == null)
                  {
                    CompatibilityInfo compatibilityInfo4 = new CompatibilityInfo();
                    compatibilityInfo4.MapID = knownCompatibility.MapID;
                    compatibilityInfo4.Firmware = knownCompatibility.Firmware;
                    compatibilityInfo4.CompatibleToMapID = subObject.CompatibleToMapID;
                    compatibilityInfo4.CompatibleToFirmware = subObject.CompatibleToFirmware;
                    if (knownCompatibility.IsFullCompatible && subObject.IsFullCompatible)
                      compatibilityInfo4.IsFullCompatible = true;
                    else if (knownCompatibility.IsFullCompatible)
                      compatibilityInfo4.CompatibleGroupShortcuts = subObject.CompatibleGroupShortcuts;
                    else if (subObject.IsFullCompatible)
                    {
                      compatibilityInfo4.CompatibleGroupShortcuts = knownCompatibility.CompatibleGroupShortcuts;
                    }
                    else
                    {
                      foreach (string compatibleGroupShortcut in knownCompatibility.CompatibleGroupShortcuts)
                      {
                        if (subObject.CompatibleGroupShortcuts.Contains(compatibleGroupShortcut))
                        {
                          if (compatibilityInfo4.CompatibleGroupShortcuts == null)
                            compatibilityInfo4.CompatibleGroupShortcuts = new List<string>();
                          compatibilityInfo4.CompatibleGroupShortcuts.Add(compatibleGroupShortcut);
                        }
                      }
                    }
                    if (compatibilityInfo4.IsFullCompatible || compatibilityInfo4.CompatibleGroupShortcuts != null)
                      compatibilityInfoList1.Add(compatibilityInfo4);
                  }
                  else if (!compatibilityInfo3.IsFullCompatible)
                  {
                    if (knownCompatibility.IsFullCompatible && subObject.IsFullCompatible)
                    {
                      compatibilityInfo3.IsFullCompatible = true;
                      flag = true;
                    }
                    else if (knownCompatibility.IsFullCompatible)
                    {
                      foreach (string compatibleGroupShortcut in subObject.CompatibleGroupShortcuts)
                      {
                        if (!compatibilityInfo3.CompatibleGroupShortcuts.Contains(compatibleGroupShortcut))
                        {
                          compatibilityInfo3.CompatibleGroupShortcuts.Add(compatibleGroupShortcut);
                          flag = true;
                        }
                      }
                    }
                    else if (subObject.IsFullCompatible)
                    {
                      foreach (string compatibleGroupShortcut in knownCompatibility.CompatibleGroupShortcuts)
                      {
                        if (!compatibilityInfo3.CompatibleGroupShortcuts.Contains(compatibleGroupShortcut))
                        {
                          compatibilityInfo3.CompatibleGroupShortcuts.Add(compatibleGroupShortcut);
                          flag = true;
                        }
                      }
                    }
                    else
                    {
                      foreach (string compatibleGroupShortcut in knownCompatibility.CompatibleGroupShortcuts)
                      {
                        if (subObject.CompatibleGroupShortcuts.Contains(compatibleGroupShortcut) && !compatibilityInfo3.CompatibleGroupShortcuts.Contains(compatibleGroupShortcut))
                        {
                          compatibilityInfo3.CompatibleGroupShortcuts.Add(compatibleGroupShortcut);
                          flag = true;
                        }
                      }
                    }
                  }
                }
              }
            }
            if (compatibilityInfoList1.Count > 0)
            {
              compatibilityList.AddRange((IEnumerable<CompatibilityInfo>) compatibilityInfoList1);
              flag = true;
            }
          }
        }
      }
      while (flag);
      compatibilityList.Sort();
    }

    public enum HardwareResources
    {
      IUWB,
      IUWR,
      IUWRR,
    }
  }
}


--- ICreateMeter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ICreateMeter
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public interface ICreateMeter
  {
    IMeter CreateMeter(byte[] zippedBuffer);
  }
}


--- IElectronicDeliveryNote.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.IElectronicDeliveryNote
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public interface IElectronicDeliveryNote
  {
    byte[] GetAesKey();
  }
}


--- IHandler.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.IHandler
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.Functions;
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public interface IHandler : IReadoutConfig
  {
    void Open();

    void Close();

    DateTime? SaveMeter();

    Task<int> ReadDeviceAsync(
      ProgressHandler progress,
      CancellationToken token,
      ReadPartsSelection readPartsSelection);

    Task WriteDeviceAsync(ProgressHandler progress, CancellationToken token);

    SortedList<OverrideID, ConfigurationParameter> GetConfigurationParameters(int subDevice = 0);

    void SetConfigurationParameters(
      SortedList<OverrideID, ConfigurationParameter> parameter,
      int subDevice = 0);

    SortedList<long, SortedList<DateTime, double>> GetValues(int subDevice = 0);

    void SetCommunicationPort(CommunicationPortFunctions myPort = null);
  }
}


--- ILoggerManager.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ILoggerManager
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System.Collections;
using System.Collections.ObjectModel;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public interface ILoggerManager
  {
    Task<ObservableCollection<LoggerListItem>> ReadLoggerListAsync(
      ProgressHandler progress,
      CancellationToken cancelToken);

    Task<IEnumerable> ReadLoggerDataAsync(
      string LoggerName,
      ProgressHandler progress,
      CancellationToken cancelToken);
  }
}


--- IMeter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.IMeter
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public interface IMeter
  {
    string GetInfo();
  }
}


--- IMeterAndFilter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.IMeterAndFilter
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public interface IMeterAndFilter : IMeter
  {
    bool IsParameterLikeRequired(string parameterName, string valueStartsWith = null);
  }
}


--- IMeterDataSpecial.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.IMeterDataSpecial
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using GmmDbLib.DataSets;

#nullable disable
namespace HandlerLib
{
  public interface IMeterDataSpecial
  {
    string Create(BaseTables.MeterDataRow meterData);
  }
}


--- InfoWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.InfoWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;

#nullable disable
namespace HandlerLib
{
  public class InfoWindow : Window, IComponentConnector
  {
    internal TextBox TextBoxApplicationInfo;
    private bool _contentLoaded;

    public InfoWindow() => this.InitializeComponent();

    public static void ShowDialog(Window owner, string[,] additionalInfo = null)
    {
      StringBuilder stringBuilder = new StringBuilder();
      try
      {
        string directoryName = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
        AssemblyName name = Assembly.GetCallingAssembly().GetName();
        string str1 = name.Name + ".dll";
        string str2 = File.Exists("HandlerLib.dll") ? FileVersionInfo.GetVersionInfo("HandlerLib.dll").ProductVersion : "n/a";
        string str3 = File.Exists("MBus_Handler.dll") ? FileVersionInfo.GetVersionInfo("MBus_Handler.dll").ProductVersion : "n/a";
        string str4 = File.Exists("MBusLib.dll") ? FileVersionInfo.GetVersionInfo("MBusLib.dll").ProductVersion : "n/a";
        string str5 = File.Exists("CommunicationPort.dll") ? FileVersionInfo.GetVersionInfo("CommunicationPort.dll").ProductVersion : "n/a";
        string str6 = File.Exists(str1) ? FileVersionInfo.GetVersionInfo(str1).FileVersion : "n/a";
        stringBuilder.AppendLine("Information about this handler and components");
        stringBuilder.AppendLine("------------------------------------------------------------------");
        stringBuilder.AppendLine("");
        stringBuilder.AppendLine("Application path: " + directoryName);
        stringBuilder.AppendLine("");
        stringBuilder.AppendLine("HandlerLib version: " + str2);
        stringBuilder.AppendLine("MBusHandler version: " + str3);
        stringBuilder.AppendLine("MBusLib version: " + str4);
        stringBuilder.AppendLine("CommunicationPort version: " + str5);
        stringBuilder.AppendLine(name.Name + " version: " + str6);
        stringBuilder.AppendLine("");
        stringBuilder.AppendLine("");
        if (!str2.Contains("n/a"))
        {
          stringBuilder.AppendLine("Info of implemented functions in HandlerLib.dll:");
          stringBuilder.AppendLine("ProtocolSpecification: " + LibraryInfo.MBusProtocolSpecification);
          stringBuilder.AppendLine("Protocol Date of implementation: " + LibraryInfo.MBusProtocolDateOfImplementation);
          stringBuilder.AppendLine("Implemented function codes: " + LibraryInfo.ImplementedFunctionCodes);
          stringBuilder.AppendLine("Implemented extended function codes: " + LibraryInfo.ImplementedExtendedFunctionCodes);
          stringBuilder.AppendLine("");
          stringBuilder.AppendLine("");
        }
        if (additionalInfo != null)
        {
          for (int index = 0; index < additionalInfo.GetLength(0); ++index)
          {
            if (!string.IsNullOrEmpty(additionalInfo[index, 0]))
              stringBuilder.AppendLine(additionalInfo[index, 0] + ": " + additionalInfo[index, 1]);
          }
        }
      }
      catch (Exception ex)
      {
        stringBuilder.AppendLine("\n\nCritical error occurred:");
        stringBuilder.AppendLine("Please check if the installation is OK.");
        stringBuilder.AppendLine("-> " + ex.Message);
      }
      InfoWindow infoWindow = new InfoWindow();
      infoWindow.Owner = owner;
      infoWindow.TextBoxApplicationInfo.Text = stringBuilder.ToString();
      if (infoWindow.ShowDialog().Value)
        ;
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/infowindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      if (connectionId == 1)
        this.TextBoxApplicationInfo = (TextBox) target;
      else
        this._contentLoaded = true;
    }
  }
}


--- InputWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.InputWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;

#nullable disable
namespace HandlerLib
{
  public class InputWindow : Window, IComponentConnector
  {
    internal TextBox InputText;
    internal Button OK_Button;
    private bool _contentLoaded;

    public InputWindow() => this.InitializeComponent();

    private void OkButton_Click(object sender, RoutedEventArgs e) => this.Close();

    public static string Show(string title, string defaultValue)
    {
      InputWindow inputWindow = new InputWindow();
      inputWindow.Title = title;
      inputWindow.InputText.Text = defaultValue;
      inputWindow.ShowDialog();
      return inputWindow.InputText.Text;
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/util/inputwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.InputText = (TextBox) target;
          break;
        case 2:
          this.OK_Button = (Button) target;
          this.OK_Button.Click += new RoutedEventHandler(this.OkButton_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- IZDebugInfo.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.IZDebugInfo
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public interface IZDebugInfo
  {
    void setDebugInfo(string txt);

    void setDebugInfo(string txt, bool clear, int clearRows);

    void setErrorInfo(string txt);

    bool? ignoreError();
  }
}


--- IZRCommand.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.IZRCommand
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  internal interface IZRCommand
  {
  }
}


--- LibraryInfo.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.LibraryInfo
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  public static class LibraryInfo
  {
    public static string MBusProtocolSpecification = "2.23";
    public static string MBusProtocolDateOfImplementation = "10/25/2017";
    public static string ImplementedFunctionCodes = "\n" + LibraryInfo.getAllImplementedFCsFromManufacturer();
    public static string ImplementedExtendedFunctionCodes = "\n Radio commands\n" + LibraryInfo.getAllImplementedRadioCMDs() + "\n MBus commands\n" + LibraryInfo.getAllImplementedMBusCMDs() + "\n LoRa commands\n" + LibraryInfo.getAllImplementedLoRaCMDs() + "\n Special commands\n" + LibraryInfo.getAllImplementedSpecialCMDs() + "\n";

    private static string getAllImplementedFCsFromManufacturer()
    {
      string str = string.Empty;
      foreach (byte num in Enum.GetValues(typeof (Manufacturer_FC)))
        str = str + ", 0x" + num.ToString("x2");
      return str.Substring(1);
    }

    private static string getAllImplementedLoRaCMDs()
    {
      string str = string.Empty;
      foreach (byte num in Enum.GetValues(typeof (CommonLoRaCommands_EFC)))
        str = str + ", 0x" + num.ToString("x2");
      return str.Substring(1);
    }

    private static string getAllImplementedMBusCMDs()
    {
      string str = string.Empty;
      foreach (byte num in Enum.GetValues(typeof (CommonMBusCommands_EFC)))
        str = str + ", 0x" + num.ToString("x2");
      return str.Substring(1);
    }

    private static string getAllImplementedRadioCMDs()
    {
      string str = string.Empty;
      foreach (byte num in Enum.GetValues(typeof (CommonRadioCommands_EFC)))
        str = str + ", 0x" + num.ToString("x2");
      return str.Substring(1);
    }

    private static string getAllImplementedSpecialCMDs()
    {
      string str = string.Empty;
      foreach (byte num in Enum.GetValues(typeof (SpecialCommands_EFC)))
        str = str + ", 0x" + num.ToString("x2");
      return str.Substring(1);
    }
  }
}


--- LoggerEventTypes.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.LoggerEventTypes
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum LoggerEventTypes : byte
  {
    NotDefined,
    Reset,
    Watchdog,
    OperationChanged,
    UltrasonicInit,
    EmptyTube,
    WaterFilled,
    ConfigChanged,
    UnitChanged,
    BackupReloaded,
    RAM_DataLost,
    BatteryLow,
    CRC_Error,
    SmartFunctionEvent,
  }
}


--- LoggerListItem.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.LoggerListItem
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public class LoggerListItem
  {
    public string LoggerName { get; set; }

    public ushort Entries { get; set; }

    public ushort MaxEntries { get; set; }

    public LoggerListItem(string loggerName, ushort entries, ushort maxEntries)
    {
      this.LoggerName = loggerName;
      this.Entries = entries;
      this.MaxEntries = maxEntries;
    }

    public LoggerListItem(byte[] data, ref int offset)
    {
      this.LoggerName = ByteArrayScanner.ScanString(data, ref offset);
      this.Entries = ByteArrayScanner.ScanUInt16(data, ref offset);
      this.MaxEntries = ByteArrayScanner.ScanUInt16(data, ref offset);
    }
  }
}


--- LoggerNames.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.LoggerNames
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum LoggerNames
  {
    Month,
    Event,
    DayVolumes,
    KeyDate,
    NearPast,
  }
}


--- LoggerTableRows.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.LoggerTableRows
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum LoggerTableRows
  {
    TimeStamp,
    Volume,
    FlowVolume,
    ReturnVolume,
    Unit,
    Event,
    EventCounter,
    EventParameter,
    VolumeUnit,
    Flow,
    FlowUnit,
  }
}


--- LoRaCheckJoinAccept.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.LoRaCheckJoinAccept
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  public sealed class LoRaCheckJoinAccept : ReturnValue
  {
    public DateTime Timestamp { get; set; }

    public byte[] NetID { get; set; }

    public uint DeviceAddress { get; set; }

    public byte DLSettings { get; set; }

    public byte RXDelay { get; set; }

    public byte[] CFList { get; set; }
  }
}


--- LoRaCommandWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.LoRaCommandWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZENNER.CommonLibrary.Exceptions;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class LoRaCommandWindow : Window, IComponentConnector
  {
    private CommonLoRaCommands myLoRaCommands;
    private List<string> Argument1_last_values;
    private List<string> Argument2_last_values;
    private List<string> Argument3_last_values;
    private List<string> Argument4_last_values;
    private List<string> Argument5_last_values;
    private ContextMenu Argument1ValuesMenu;
    private ContextMenu Argument2ValuesMenu;
    private ContextMenu Argument3ValuesMenu;
    private ContextMenu Argument4ValuesMenu;
    private ContextMenu Argument5ValuesMenu;
    private static string result = string.Empty;
    private static readonly string CMD_GetLoRaFCVersion = "Get LoRa FC version (0x00)";
    private static readonly string CMD_GetLoRaWANVersion = "Get LoRa WAN version (0x01)";
    private static readonly string CMD_SendJoinRequest = "Send join request (0x06)";
    private static readonly string CMD_CheckJoinRequest = "Check join accept (0x07)";
    private static readonly string CMD_SendUnconfirmedData = "Send unconfirmed data (0x08)";
    private static readonly string CMD_SendConfirmedData = "Send confirmed data (0x09)";
    private static readonly string CMD_SetNetID = "Set Net ID (0x20)";
    private static readonly string CMD_GetNetID = "Get Net ID (0x20)";
    private static readonly string CMD_SetAppEUI = "Set app EUI (0x21)";
    private static readonly string CMD_GetAppEUI = "Get app EUI (0x21)";
    private static readonly string CMD_SetNwkSKey = "Set network session key (0x22)";
    private static readonly string CMD_GetNwkSKey = "Get network session key (0x22)";
    private static readonly string CMD_SetAppSKey = "Set application session key (0x23)";
    private static readonly string CMD_GetAppSKey = "Get application session key (0x23)";
    private static readonly string CMD_SetOTAA_ABP = "Set OTAA-ABP (0x24)";
    private static readonly string CMD_GetOTAA_ABP = "Get OTAA_ABP (0x24)";
    private static readonly string CMD_SetDeviceEUI = "Set device EUI (0x25)";
    private static readonly string CMD_GetDeviceEUI = "Get device EUI (0x25)";
    private static readonly string CMD_SetAppKey = "Set application key (0x26)";
    private static readonly string CMD_GetAppKey = "Get application key (0x26)";
    private static readonly string CMD_SetDevAddr = "Set device address (0x27)";
    private static readonly string CMD_GetDevAddr = "Get device address (0x27)";
    private static readonly string CMD_SetTransmissionScenario = "Set transmission sceanrio (0x28)";
    private static readonly string CMD_GetTransmissionScenario = "Get transmission sceanrio (0x28)";
    private static readonly string CMD_SendConfigurationPaket = "Send configuration packet (0x29)";
    private static readonly string CMD_SetADR = "Set ADR (0x2a)";
    private static readonly string CMD_GetADR = "Get ADR (0x2a)";
    private static readonly string CMD_TriggerSystemDiagnostic = "TriggerSystemDiagnostic (0x2b)";
    private static readonly string CMD_SystemDiagnosticState = "SystemDiagnosticState (0x2b)";
    private Cursor defaultCursor;
    private CancellationTokenSource cancelTokenSource;
    private ProgressHandler progress;
    internal TextBlock TextBlockStatus;
    internal ProgressBar ProgressBar1;
    internal TextBox TextBoxUniversalCommandResult;
    internal StackPanel StackPanalButtons;
    internal ComboBox ComboCommand;
    internal CheckBox CheckBoxEncryption;
    internal Label EncryptionKey_Label;
    internal TextBox TextBoxEncryptionKey;
    internal Label ComboExtCommand_Label;
    internal ComboBox ComboExtCommand;
    internal Label ComboAddCommand_Label;
    internal ComboBox ComboAddCommand;
    internal Label ComboAddCommand2_Label;
    internal ComboBox ComboAddCommand2;
    internal Label ComboAddCommand3_Label;
    internal ComboBox ComboAddCommand3;
    internal Label TextArgument_1_Label;
    internal TextBox TextExtCommandArgument_1;
    internal Label TextArgument_2_Label;
    internal TextBox TextExtCommandArgument_2;
    internal Label TextArgument_3_Label;
    internal TextBox TextExtCommandArgument_3;
    internal Label TextArgument_4_Label;
    internal TextBox TextExtCommandArgument_4;
    internal Label TextArgument_5_Label;
    internal TextBox TextExtCommandArgument_5;
    internal StackPanel StackPanalButtons2;
    internal Button ButtonRunCommand;
    internal Button ButtonRunCommandPreview;
    internal Button ButtonBreak;
    private bool _contentLoaded;

    public ComboBox cmbBox
    {
      get => this.ComboExtCommand;
      set => this.ComboExtCommand.Items.Remove((object) value);
    }

    public LoRaCommandWindow(CommonLoRaCommands LoRaCMDs)
    {
      this.InitializeComponent();
      this.myLoRaCommands = LoRaCMDs;
      this.myLoRaCommands.setCryptValuesFromBaseClass();
      this.ButtonRunCommand.IsEnabled = false;
      this.SetArgumentFields((Dictionary<int, string>) null);
      this.setFunctionCodes();
      this.Argument1_last_values = new List<string>();
      this.Argument2_last_values = new List<string>();
      this.Argument3_last_values = new List<string>();
      this.Argument4_last_values = new List<string>();
      this.Argument5_last_values = new List<string>();
      this.Argument1ValuesMenu = new ContextMenu();
      this.Argument2ValuesMenu = new ContextMenu();
      this.Argument3ValuesMenu = new ContextMenu();
      this.Argument4ValuesMenu = new ContextMenu();
      this.Argument5ValuesMenu = new ContextMenu();
      this.SetStopState();
      this.setEncryptionState();
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
    }

    private void setEncryptionState()
    {
      this.CheckBoxEncryption.IsChecked = new bool?(this.myLoRaCommands.enDeCrypt);
      if (!this.myLoRaCommands.enDeCrypt)
        this.CheckBoxEncryption_UnChecked((object) null, (RoutedEventArgs) null);
      this.TextBoxEncryptionKey.Text = this.myLoRaCommands.AES_Key;
    }

    private void setFunctionCodes()
    {
      this.ComboExtCommand_Label.Visibility = Visibility.Hidden;
      this.ComboExtCommand.Visibility = Visibility.Hidden;
      this.ComboCommand.Items.Clear();
      this.ComboCommand.Items.Add((object) "LoRa Commands (0x35)");
      this.ComboCommand.SelectedIndex = 0;
    }

    private void setLoRaCommands()
    {
      Dictionary<string, string> valuesForCommands = GetCommandValues.GetAllPrivateStaticFieldValuesForCommands((object) this);
      this.ComboExtCommand.Items.Clear();
      foreach (KeyValuePair<string, string> keyValuePair in valuesForCommands)
        this.ComboExtCommand.Items.Add((object) keyValuePair.Value);
      this.ComboExtCommand.SelectedIndex = 0;
    }

    private void SetRunState()
    {
      this.cancelTokenSource = new CancellationTokenSource();
      this.progress.Reset();
      this.progress.Split(new double[2]{ 2.0, 98.0 });
      this.progress.Report("Run");
      this.ComboCommand.IsEnabled = false;
      this.ComboExtCommand.IsEnabled = false;
      this.TextBoxUniversalCommandResult.IsEnabled = false;
      this.TextExtCommandArgument_1.IsEnabled = false;
      this.TextExtCommandArgument_2.IsEnabled = false;
      this.TextExtCommandArgument_3.IsEnabled = false;
      this.ButtonRunCommand.IsEnabled = false;
      this.ButtonRunCommandPreview.IsEnabled = false;
      this.TextBoxEncryptionKey.IsEnabled = false;
      this.CheckBoxEncryption.IsEnabled = false;
      this.ButtonBreak.IsEnabled = true;
      this.defaultCursor = this.Cursor;
      this.Cursor = Cursors.Wait;
    }

    private void SetStopState()
    {
      this.ComboCommand.IsEnabled = true;
      this.ComboExtCommand.IsEnabled = true;
      this.TextBoxUniversalCommandResult.IsEnabled = true;
      this.TextExtCommandArgument_1.IsEnabled = true;
      this.TextExtCommandArgument_2.IsEnabled = true;
      this.TextExtCommandArgument_3.IsEnabled = true;
      this.ButtonRunCommand.IsEnabled = true;
      this.ButtonRunCommandPreview.IsEnabled = true;
      this.TextBoxEncryptionKey.IsEnabled = true;
      this.CheckBoxEncryption.IsEnabled = true;
      this.ButtonBreak.IsEnabled = false;
      this.Cursor = this.defaultCursor;
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.ProgressBar1.Value = obj.ProgressPercentage;
        this.TextBlockStatus.Text = obj.Message;
      }
    }

    private void ButtonBreak_Click(object sender, RoutedEventArgs e)
    {
      this.cancelTokenSource.Cancel();
    }

    private async Task RunCommandFrame()
    {
      this.SetRunState();
      try
      {
        await this.RunCommand();
      }
      catch (OperationCanceledException ex)
      {
      }
      catch (TimeoutException ex)
      {
        this.TextBoxUniversalCommandResult.Text = "Timeout";
      }
      catch (NACK_Exception ex)
      {
        this.TextBoxUniversalCommandResult.Text = "Device response is NACK: " + ex.Message;
      }
      catch (Exception ex)
      {
        bool isTimeout = false;
        if (ex is AggregateException)
        {
          AggregateException aex = ex as AggregateException;
          int num1;
          for (int i = 0; i < aex.InnerExceptions.Count; num1 = i++)
          {
            Exception theException = aex.InnerExceptions[i];
            if (theException is TimeoutException)
            {
              if (i == aex.InnerExceptions.Count - 1)
              {
                isTimeout = true;
                string newLine = Environment.NewLine;
                num1 = aex.InnerExceptions.Count;
                string str = num1.ToString();
                int num2 = (int) MessageBox.Show("**** Multiple timeouts ****" + newLine + "Timeout count: " + str);
              }
              theException = (Exception) null;
            }
            else
              break;
          }
          aex = (AggregateException) null;
        }
        if (!isTimeout)
        {
          int num = (int) MessageBox.Show(ex.ToString());
        }
      }
      this.SetStopState();
    }

    private async void ButtonRunCommand_Click(object sender, RoutedEventArgs e)
    {
      LoRaCommandWindow.result = string.Empty;
      await this.RunCommandFrame();
    }

    private async void ButtonRunCommandPreview_Click(object sender, RoutedEventArgs e)
    {
      LoRaCommandWindow.result = "Actual LoRa data of connected device:\n-------------------------------------------";
      Dictionary<int, string> args = new Dictionary<int, string>();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_GetLoRaFCVersion;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_GetLoRaWANVersion;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_GetNetID;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_GetAppEUI;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_GetNwkSKey;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_GetAppSKey;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_GetOTAA_ABP;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_GetDeviceEUI;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_GetAppKey;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_GetDevAddr;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_GetTransmissionScenario;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_GetADR;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) LoRaCommandWindow.CMD_SystemDiagnosticState;
      await this.RunCommandFrame();
      args = (Dictionary<int, string>) null;
    }

    private void ComboExtCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboExtCommand.SelectedItem != null)
      {
        object selectedItem = this.ComboExtCommand.SelectedItem;
        this.ComboAddCommand.Items.Clear();
        Dictionary<int, string> template = new Dictionary<int, string>();
        Dictionary<int, string> values = new Dictionary<int, string>();
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SendUnconfirmedData))
          template.Add(1, "Unconfirmed data:");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SendConfirmedData))
          template.Add(1, "Confirmed data:");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SetNetID))
          template.Add(1, "Net ID:");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SetAppEUI))
          template.Add(1, "Application EUI (8 Bytes):");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SetNwkSKey))
          template.Add(1, "Network session key (16 Bytes):");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SetAppSKey))
          template.Add(1, "Application session key:");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SetOTAA_ABP))
          template.Add(1, "Flag (0x01 OTAA) / (0x02 ABP):");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SetDeviceEUI))
          template.Add(1, "Device EUI (8 Bytes(reversed)):");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SetAppKey))
          template.Add(1, "Application Key (16 Bytes):");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SetDevAddr))
          template.Add(1, "Device address (4 Bytes):");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SetTransmissionScenario))
          template.Add(1, "Transmission scenario:");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SetADR))
          template.Add(1, "ADR:");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_SendConfigurationPaket))
          template.Add(1, "PacketType (hex):");
        if (selectedItem.ToString().Contains(LoRaCommandWindow.CMD_TriggerSystemDiagnostic))
        {
          template.Add(10, "DiagnosticInterval:");
          template.Add(11, "DiagnosticRepeat:");
          template.Add(1, "DailyStartTime (24h):");
          values.Add(1, "00:00");
          template.Add(2, "DailyEndTime (24h):");
          values.Add(2, "00:00");
        }
        this.SetArgumentFields(template);
        this.SetArgumentFieldsValues(values);
        this.ButtonRunCommand.IsEnabled = true;
      }
      else
        this.ButtonRunCommand.IsEnabled = false;
    }

    private void ComboCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboCommand.SelectedIndex < 0)
        return;
      Dictionary<int, string> dictionary = new Dictionary<int, string>();
      if (this.ComboCommand.SelectedItem.ToString().Contains("0x35"))
      {
        this.setLoRaCommands();
        this.ComboExtCommand_Label.Content = (object) "LoRa Commands (EFC):";
        this.ComboExtCommand_Label.Visibility = Visibility.Visible;
        this.ComboExtCommand.Visibility = Visibility.Visible;
      }
    }

    private void ComboAddCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboAddCommand.SelectedIndex < 0)
        return;
      object selectedItem = this.ComboAddCommand.SelectedItem;
    }

    private void ComboAddCommand2_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboAddCommand2.SelectedIndex < 0)
        return;
      object selectedItem = this.ComboAddCommand2.SelectedItem;
    }

    private void ComboAddCommand3_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboAddCommand3.SelectedIndex < 0)
        return;
      object selectedItem = this.ComboAddCommand3.SelectedItem;
    }

    private void SetArgumentFieldsValues(Dictionary<int, string> values)
    {
      if (values == null)
        return;
      foreach (KeyValuePair<int, string> keyValuePair in values)
      {
        if (keyValuePair.Key == 0)
          this.ComboAddCommand.SelectedItem = (object) keyValuePair.Value;
        if (keyValuePair.Key == 1)
          this.TextExtCommandArgument_1.Text = keyValuePair.Value;
        if (keyValuePair.Key == 2)
          this.TextExtCommandArgument_2.Text = keyValuePair.Value;
        if (keyValuePair.Key == 3)
          this.TextExtCommandArgument_3.Text = keyValuePair.Value;
        if (keyValuePair.Key == 4)
          this.TextExtCommandArgument_4.Text = keyValuePair.Value;
        if (keyValuePair.Key == 5)
          this.TextExtCommandArgument_5.Text = keyValuePair.Value;
        if (keyValuePair.Key == 10)
          this.ComboAddCommand2.SelectedItem = (object) keyValuePair.Value;
        if (keyValuePair.Key == 11)
          this.ComboAddCommand3.SelectedItem = (object) keyValuePair.Value;
      }
    }

    private void SetArgumentFields(Dictionary<int, string> template)
    {
      this.TextExtCommandArgument_1.Text = string.Empty;
      this.TextExtCommandArgument_2.Text = string.Empty;
      this.TextExtCommandArgument_3.Text = string.Empty;
      this.TextExtCommandArgument_4.Text = string.Empty;
      this.TextExtCommandArgument_5.Text = string.Empty;
      this.ComboAddCommand_Label.Visibility = Visibility.Collapsed;
      this.ComboAddCommand.Visibility = Visibility.Collapsed;
      this.ComboAddCommand2_Label.Visibility = Visibility.Collapsed;
      this.ComboAddCommand2.Visibility = Visibility.Collapsed;
      this.ComboAddCommand3_Label.Visibility = Visibility.Collapsed;
      this.ComboAddCommand3.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_1.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_2.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_3.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_4.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_5.Visibility = Visibility.Collapsed;
      this.TextArgument_1_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_2_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_3_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_4_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_5_Label.Visibility = Visibility.Collapsed;
      if (template == null)
        return;
      foreach (KeyValuePair<int, string> keyValuePair in template)
      {
        if (keyValuePair.Key == 0)
        {
          this.ComboAddCommand.Visibility = Visibility.Visible;
          this.ComboAddCommand.Items.Add((object) "FSK         (0x00)");
          this.ComboAddCommand.Items.Add((object) "GFSK        (0x01)");
          this.ComboAddCommand.Items.Add((object) "OOK         (0x02)");
          this.ComboAddCommand.Items.Add((object) "SIGFOX      (0x03)");
          this.ComboAddCommand.Items.Add((object) "LoRa SF7    (0x04)");
          this.ComboAddCommand.Items.Add((object) "LoRa SF8    (0x05)");
          this.ComboAddCommand.Items.Add((object) "LoRa SF9    (0x06)");
          this.ComboAddCommand.Items.Add((object) "LoRa SF10   (0x07)");
          this.ComboAddCommand.Items.Add((object) "LoRa SF11   (0x08)");
          this.ComboAddCommand.Items.Add((object) "LoRa SF12   (0x09)");
          this.ComboAddCommand_Label.Visibility = Visibility.Visible;
          this.ComboAddCommand_Label.Content = (object) keyValuePair.Value;
        }
        if (keyValuePair.Key == 1)
        {
          this.TextExtCommandArgument_1.Visibility = Visibility.Visible;
          this.TextArgument_1_Label.Visibility = Visibility.Visible;
          this.TextArgument_1_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_1.ContextMenu = this.Argument1ValuesMenu;
        }
        if (keyValuePair.Key == 2)
        {
          this.TextExtCommandArgument_2.Visibility = Visibility.Visible;
          this.TextArgument_2_Label.Visibility = Visibility.Visible;
          this.TextArgument_2_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_2.ContextMenu = this.Argument2ValuesMenu;
        }
        if (keyValuePair.Key == 3)
        {
          this.TextExtCommandArgument_3.Visibility = Visibility.Visible;
          this.TextArgument_3_Label.Visibility = Visibility.Visible;
          this.TextArgument_3_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_3.ContextMenu = this.Argument3ValuesMenu;
        }
        if (keyValuePair.Key == 4)
        {
          this.TextExtCommandArgument_4.Visibility = Visibility.Visible;
          this.TextArgument_4_Label.Visibility = Visibility.Visible;
          this.TextArgument_4_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_4.ContextMenu = this.Argument4ValuesMenu;
        }
        if (keyValuePair.Key == 5)
        {
          this.TextExtCommandArgument_5.Visibility = Visibility.Visible;
          this.TextArgument_5_Label.Visibility = Visibility.Visible;
          this.TextArgument_5_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_5.ContextMenu = this.Argument5ValuesMenu;
        }
        if (keyValuePair.Key == 10)
        {
          this.ComboAddCommand2.Visibility = Visibility.Visible;
          this.ComboAddCommand2.Items.Add((object) "Interval 0.25h  (0x00)");
          this.ComboAddCommand2.Items.Add((object) "Interval 0.50h  (0x01)");
          this.ComboAddCommand2.Items.Add((object) "Interval 1.00h  (0x02)");
          this.ComboAddCommand2.Items.Add((object) "Interval 2.00h  (0x03)");
          this.ComboAddCommand2.Items.Add((object) "Interval 3.00h  (0x04)");
          this.ComboAddCommand2.Items.Add((object) "Interval 6.00h  (0x05)");
          this.ComboAddCommand2.Items.Add((object) "Interval 12.00h  (0x06)");
          this.ComboAddCommand2.Items.Add((object) "Interval 24.00h  (0x07)");
          this.ComboAddCommand2_Label.Visibility = Visibility.Visible;
          this.ComboAddCommand2_Label.Content = (object) keyValuePair.Value;
        }
        if (keyValuePair.Key == 11)
        {
          this.ComboAddCommand3.Visibility = Visibility.Visible;
          this.ComboAddCommand3.Items.Add((object) "Repeats 5  (0x00)");
          this.ComboAddCommand3.Items.Add((object) "Repeats 10  (0x10)");
          this.ComboAddCommand3.Items.Add((object) "Repeats 20  (0x20)");
          this.ComboAddCommand3.Items.Add((object) "Repeats 50  (0x30)");
          this.ComboAddCommand3.Items.Add((object) "Repeats 100  (0x40)");
          this.ComboAddCommand3.Items.Add((object) "Repeats 200  (0x50)");
          this.ComboAddCommand3.Items.Add((object) "Repeats 500  (0x60)");
          this.ComboAddCommand3.Items.Add((object) "Repeats 1000  (0x70)");
          this.ComboAddCommand3_Label.Visibility = Visibility.Visible;
          this.ComboAddCommand3_Label.Content = (object) keyValuePair.Value;
        }
      }
    }

    private void mi_Click(object sender, RoutedEventArgs e)
    {
      ((TextBox) ((FrameworkElement) sender).Tag).Text = ((HeaderedItemsControl) sender).Header.ToString();
    }

    private async Task RunCommand()
    {
      string FC = this.ComboCommand.SelectedItem.ToString();
      string EFC = this.ComboExtCommand.SelectedItem.ToString();
      object addFC = this.ComboAddCommand.SelectedItem;
      string arg1 = string.IsNullOrEmpty(this.TextExtCommandArgument_1.Text) ? (string) null : this.TextExtCommandArgument_1.Text.Trim();
      string arg2 = string.IsNullOrEmpty(this.TextExtCommandArgument_2.Text) ? (string) null : this.TextExtCommandArgument_2.Text.Trim();
      string arg3 = string.IsNullOrEmpty(this.TextExtCommandArgument_3.Text) ? (string) null : this.TextExtCommandArgument_3.Text.Trim();
      string arg4 = string.IsNullOrEmpty(this.TextExtCommandArgument_4.Text) ? (string) null : this.TextExtCommandArgument_4.Text.Trim();
      string arg5 = string.IsNullOrEmpty(this.TextExtCommandArgument_5.Text) ? (string) null : this.TextExtCommandArgument_5.Text.Trim();
      CommonLoRaCommands loRaCommands = this.myLoRaCommands;
      bool? isChecked = this.CheckBoxEncryption.IsChecked;
      bool flag1 = true;
      int num1 = isChecked.GetValueOrDefault() == flag1 & isChecked.HasValue ? 1 : 0;
      loRaCommands.enDeCrypt = num1 != 0;
      this.myLoRaCommands.AES_Key = this.TextBoxEncryptionKey.Text.Trim();
      try
      {
        if (FC.Contains("0x35"))
        {
          if (EFC.Contains(LoRaCommandWindow.CMD_GetLoRaFCVersion))
          {
            LoRaFcVersion retVal = await this.myLoRaCommands.GetLoRaFC_VersionAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nLoRa FC Version: " + retVal.Version.ToString();
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nData: " + Util.ByteArrayToHexString(retVal.basedata);
            retVal = (LoRaFcVersion) null;
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_GetLoRaWANVersion))
          {
            LoRaWANVersion retVal = await this.myLoRaCommands.GetLoRaWAN_VersionAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nLoRa WAN Version: " + ((int) retVal.MainVersion).ToString() + "." + ((int) retVal.MinorVersion).ToString() + "." + ((int) retVal.ReleaseNr).ToString();
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nData: " + Util.ByteArrayToHexString(retVal.basedata);
            retVal = (LoRaWANVersion) null;
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SendJoinRequest))
          {
            await this.myLoRaCommands.SendJoinRequestAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result += "\nSend Join request succesfully send to device";
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_CheckJoinRequest))
          {
            LoRaCheckJoinAccept retVal = await this.myLoRaCommands.CheckJoinAcceptAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nCheck join request result was succesfully loaded. \nGet: " + Util.ByteArrayToHexString(retVal.basedata);
            if (retVal != null)
            {
              LoRaCommandWindow.result += "\n";
              LoRaCommandWindow.result = LoRaCommandWindow.result + "\n DateTime: " + retVal.Timestamp.ToString();
              LoRaCommandWindow.result = LoRaCommandWindow.result + "\n DeviceAdr.: " + retVal.DeviceAddress.ToString();
              LoRaCommandWindow.result = LoRaCommandWindow.result + "\n NetID: " + Util.ByteArrayToHexString(retVal.NetID);
              LoRaCommandWindow.result += "\n";
            }
            retVal = (LoRaCheckJoinAccept) null;
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SendUnconfirmedData))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              byte[] data = Util.HexStringToByteArray(arg1);
              if (data.Length <= 50)
              {
                await this.myLoRaCommands.SendUnconfirmedDataAsync(data, this.progress, this.cancelTokenSource.Token);
                LoRaCommandWindow.result += "\nUnconfirmed data succesfully sent to device.";
              }
              else
              {
                int num2 = (int) MessageBox.Show("To much bytes to send ... max. 50 Bytes.\nPlease check the lenght of your bytearray.");
              }
              data = (byte[]) null;
            }
            else
            {
              int num3 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SendConfirmedData))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              byte[] data = Util.HexStringToByteArray(arg1);
              if (data.Length <= 50)
              {
                await this.myLoRaCommands.SendConfirmedDataAsync(data, this.progress, this.cancelTokenSource.Token);
                LoRaCommandWindow.result += "\nConfirmed data succesfully sent to device.";
              }
              else
              {
                int num4 = (int) MessageBox.Show("To much bytes to send ... max. 50 Bytes.\nPlease check the lenght of your bytearray.");
              }
              data = (byte[]) null;
            }
            else
            {
              int num5 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SetNetID))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              byte[] data = Util.HexStringToByteArray(arg1);
              await this.myLoRaCommands.SetNetIDAsync(data, this.progress, this.cancelTokenSource.Token);
              LoRaCommandWindow.result += "\nNetID successfully sent to device.";
              data = (byte[]) null;
            }
            else
            {
              int num6 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_GetNetID))
          {
            byte[] retVal = await this.myLoRaCommands.GetNetIDAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nNetID: " + Util.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SetAppEUI))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              byte[] data = Util.HexStringToByteArray(arg1);
              await this.myLoRaCommands.SetAppEUIAsync(data, this.progress, this.cancelTokenSource.Token);
              LoRaCommandWindow.result += "\nData successfully sent to device.";
              data = (byte[]) null;
            }
            else
            {
              int num7 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_GetAppEUI))
          {
            byte[] retVal = await this.myLoRaCommands.GetAppEUIAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nAppEUI: " + Util.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SetNwkSKey))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              byte[] data = Util.HexStringToByteArray(arg1);
              await this.myLoRaCommands.SetNwkSKeyAsync(data, this.progress, this.cancelTokenSource.Token);
              LoRaCommandWindow.result += "\nNetwork session key successfully sent to device.";
              data = (byte[]) null;
            }
            else
            {
              int num8 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_GetNwkSKey))
          {
            byte[] retVal = await this.myLoRaCommands.GetNwkSKeyAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nNetwork session key: " + Util.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SetAppSKey))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              byte[] data = Util.HexStringToByteArray(arg1);
              await this.myLoRaCommands.SetAppSKeyAsync(data, this.progress, this.cancelTokenSource.Token);
              LoRaCommandWindow.result += "\nApplication session key successfully sent to device.";
              data = (byte[]) null;
            }
            else
            {
              int num9 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_GetAppSKey))
          {
            byte[] retVal = await this.myLoRaCommands.GetAppSKeyAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nApplication session key: " + Util.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SetOTAA_ABP))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              OTAA_ABP flag = (OTAA_ABP) byte.Parse(arg1);
              await this.myLoRaCommands.SetOTAA_ABPAsync(flag, this.progress, this.cancelTokenSource.Token);
              LoRaCommandWindow.result += "\nOTAA-ABP successfully sent to device.";
            }
            else
            {
              int num10 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_GetOTAA_ABP))
          {
            OTAA_ABP retVal = await this.myLoRaCommands.GetOTAA_ABPAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nActivation mode:  " + retVal.ToString();
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SetDeviceEUI))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              byte[] data = Util.HexStringToByteArray(arg1);
              await this.myLoRaCommands.SetDevEUIAsync(data, this.progress, this.cancelTokenSource.Token);
              LoRaCommandWindow.result += "\nDevice EUI successfully sent to device.";
              data = (byte[]) null;
            }
            else
            {
              int num11 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_GetDeviceEUI))
          {
            byte[] retVal = await this.myLoRaCommands.GetDevEUIAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nDevice EUI: " + Util.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SetAppKey))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              byte[] data = Util.HexStringToByteArray(arg1);
              await this.myLoRaCommands.SetAppKeyAsync(data, this.progress, this.cancelTokenSource.Token);
              LoRaCommandWindow.result += "\nApplikation key successfully sent to device.";
              data = (byte[]) null;
            }
            else
            {
              int num12 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_GetAppKey))
          {
            byte[] retVal = await this.myLoRaCommands.GetAppKeyAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nApplication Key: " + Util.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SetDevAddr))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              byte[] data = Util.HexStringToByteArray(arg1);
              await this.myLoRaCommands.SetDevAddrAsync(data, this.progress, this.cancelTokenSource.Token);
              LoRaCommandWindow.result += "\nDevice address successfully sent to device.";
              data = (byte[]) null;
            }
            else
            {
              int num13 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_GetDevAddr))
          {
            byte[] retVal = await this.myLoRaCommands.GetDevAddrAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nDevice address: " + Util.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SetTransmissionScenario))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              byte[] data = Util.HexStringToByteArray(arg1);
              await this.myLoRaCommands.SetTransmissionScenarioAsync(data, this.progress, this.cancelTokenSource.Token);
              LoRaCommandWindow.result += "\nTransmission scenario successfully set.";
              data = (byte[]) null;
            }
            else
            {
              int num14 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_GetTransmissionScenario))
          {
            byte retVal = await this.myLoRaCommands.GetTransmissionScenarioAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nTransmission scenario: " + retVal.ToString();
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SendConfigurationPaket))
          {
            if (!string.IsNullOrEmpty(arg1) && arg1.Length == 2)
            {
              byte[] data = Util.HexStringToByteArray(arg1);
              await this.myLoRaCommands.SendConfigurationPaketAsync(data, this.progress, this.cancelTokenSource.Token);
              LoRaCommandWindow.result += "\nConfiguration packet successfully set.";
              data = (byte[]) null;
            }
            else
            {
              int num15 = (int) MessageBox.Show("Wrong input string format found.\nInput string should be 2 characters!");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SetADR))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              byte data = byte.Parse(arg1);
              await this.myLoRaCommands.SetAdrAsync(data, this.progress, this.cancelTokenSource.Token);
              LoRaCommandWindow.result = LoRaCommandWindow.result + "\nADR set to: " + arg1;
            }
            else
            {
              int num16 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_GetADR))
          {
            byte retVal = await this.myLoRaCommands.GetAdrAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nADR: " + retVal.ToString();
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_TriggerSystemDiagnostic))
          {
            LoRaCommandWindow.result = "\nTriggerSystemDiagnostic";
            string selLow = this.ComboAddCommand2.SelectedItem.ToString();
            string selHigh = this.ComboAddCommand3.SelectedItem.ToString();
            selLow = selLow.Substring(selLow.IndexOf('(') + 1);
            selLow = selLow.Remove(selLow.IndexOf(')'));
            selHigh = selHigh.Substring(selHigh.IndexOf('(') + 1);
            selHigh = selHigh.Remove(selHigh.IndexOf(')'));
            ushort usLOW = Convert.ToUInt16(selLow, 16);
            ushort usHIGH = Convert.ToUInt16(selHigh, 16);
            byte diagConfig = (byte) ((uint) usLOW + (uint) usHIGH);
            ushort dailyStartTimeParam = LoRaSystemDiagnostic.getDailyTimeFromString(arg1);
            ushort dailyEndTimeParam = LoRaSystemDiagnostic.getDailyTimeFromString(arg2);
            LoRaSystemDiagnostic lsd = new LoRaSystemDiagnostic();
            lsd.DiagnosticConfig = diagConfig;
            lsd.DailyStartTime = (byte) dailyStartTimeParam;
            lsd.DailyEndTime = (byte) dailyEndTimeParam;
            await this.myLoRaCommands.TriggerSystemDiagnosticAsync(lsd, this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result += "\nTriggerSystemDiagnostic done";
            selLow = (string) null;
            selHigh = (string) null;
            lsd = (LoRaSystemDiagnostic) null;
          }
          if (EFC.Contains(LoRaCommandWindow.CMD_SystemDiagnosticState))
          {
            LoRaSystemDiagnostic lsd = await this.myLoRaCommands.SystemDiagnosticStateAsync(this.progress, this.cancelTokenSource.Token);
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nDiagnostigConfigInterval: " + lsd.getDiagnosticIntervalAsString();
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nDiagnostigConfigRepeat: " + lsd.getDiagnosticRepeatAsString();
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nDailyStartTime: " + lsd.getDailyStartEndTimeAsString() + " h";
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nDailyEndTime: " + lsd.getDailyStartEndTimeAsString(false) + " h";
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nRemainingActivity: " + lsd.RemainigActivity.ToString();
            LoRaCommandWindow.result = LoRaCommandWindow.result + "\nRemainingDiagnostic: " + lsd.RemainigDiagnostic.ToString();
            lsd = (LoRaSystemDiagnostic) null;
          }
        }
        if (string.IsNullOrEmpty(LoRaCommandWindow.result))
        {
          FC = (string) null;
          EFC = (string) null;
          addFC = (object) null;
          arg1 = (string) null;
          arg2 = (string) null;
          arg3 = (string) null;
          arg4 = (string) null;
          arg5 = (string) null;
        }
        else
        {
          this.TextBoxUniversalCommandResult.Text = LoRaCommandWindow.result;
          FC = (string) null;
          EFC = (string) null;
          addFC = (object) null;
          arg1 = (string) null;
          arg2 = (string) null;
          arg3 = (string) null;
          arg4 = (string) null;
          arg5 = (string) null;
        }
      }
      catch (Exception ex)
      {
        LoRaCommandWindow.result = LoRaCommandWindow.result + "\nERROR: " + ex.Message + "\nFunction (" + EFC + ")";
        this.TextBoxUniversalCommandResult.Text = LoRaCommandWindow.result;
        FC = (string) null;
        EFC = (string) null;
        addFC = (object) null;
        arg1 = (string) null;
        arg2 = (string) null;
        arg3 = (string) null;
        arg4 = (string) null;
        arg5 = (string) null;
      }
    }

    private void updateContextMenu1(string packet)
    {
      if (!this.Argument1_last_values.Contains(packet))
        this.Argument1_last_values.Add(packet);
      this.Argument1ValuesMenu.Items.Clear();
      if (this.Argument1_last_values.Count > 20)
        this.Argument1_last_values.RemoveRange(0, this.Argument1_last_values.Count - 20);
      foreach (string argument1LastValue in this.Argument1_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument1LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_1;
        this.Argument1ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu2(string packet)
    {
      if (!this.Argument2_last_values.Contains(packet))
        this.Argument2_last_values.Add(packet);
      this.Argument2ValuesMenu.Items.Clear();
      if (this.Argument2_last_values.Count > 20)
        this.Argument2_last_values.RemoveRange(0, this.Argument2_last_values.Count - 20);
      foreach (string argument2LastValue in this.Argument2_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument2LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_2;
        this.Argument2ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu3(string packet)
    {
      if (!this.Argument3_last_values.Contains(packet))
        this.Argument3_last_values.Add(packet);
      this.Argument3ValuesMenu.Items.Clear();
      if (this.Argument3_last_values.Count > 20)
        this.Argument3_last_values.RemoveRange(0, this.Argument3_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_3;
        this.Argument3ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu4(string packet)
    {
      if (!this.Argument4_last_values.Contains(packet))
        this.Argument4_last_values.Add(packet);
      this.Argument4ValuesMenu.Items.Clear();
      if (this.Argument4_last_values.Count > 20)
        this.Argument4_last_values.RemoveRange(0, this.Argument4_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_4;
        this.Argument4ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu5(string packet)
    {
      if (!this.Argument5_last_values.Contains(packet))
        this.Argument5_last_values.Add(packet);
      this.Argument5ValuesMenu.Items.Clear();
      if (this.Argument5_last_values.Count > 20)
        this.Argument5_last_values.RemoveRange(0, this.Argument5_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_5;
        this.Argument5ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void CheckBoxEncryption_Checked(object sender, RoutedEventArgs e)
    {
      this.myLoRaCommands.enDeCrypt = true;
      this.TextBoxEncryptionKey.Visibility = Visibility.Visible;
      this.EncryptionKey_Label.Visibility = Visibility.Visible;
    }

    private void CheckBoxEncryption_UnChecked(object sender, RoutedEventArgs e)
    {
      this.myLoRaCommands.enDeCrypt = false;
      this.TextBoxEncryptionKey.Visibility = Visibility.Collapsed;
      this.EncryptionKey_Label.Visibility = Visibility.Collapsed;
    }

    private void TextBoxEncryptionKey_TextChanged(object sender, TextChangedEventArgs e)
    {
      this.myLoRaCommands.AES_Key = this.TextBoxEncryptionKey.Text;
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/commandwindowlora.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.TextBlockStatus = (TextBlock) target;
          break;
        case 2:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        case 3:
          this.TextBoxUniversalCommandResult = (TextBox) target;
          break;
        case 4:
          this.StackPanalButtons = (StackPanel) target;
          break;
        case 5:
          this.ComboCommand = (ComboBox) target;
          this.ComboCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboCommand_SelectionChanged);
          break;
        case 6:
          this.CheckBoxEncryption = (CheckBox) target;
          this.CheckBoxEncryption.Checked += new RoutedEventHandler(this.CheckBoxEncryption_Checked);
          this.CheckBoxEncryption.Unchecked += new RoutedEventHandler(this.CheckBoxEncryption_UnChecked);
          break;
        case 7:
          this.EncryptionKey_Label = (Label) target;
          break;
        case 8:
          this.TextBoxEncryptionKey = (TextBox) target;
          this.TextBoxEncryptionKey.TextChanged += new TextChangedEventHandler(this.TextBoxEncryptionKey_TextChanged);
          break;
        case 9:
          this.ComboExtCommand_Label = (Label) target;
          break;
        case 10:
          this.ComboExtCommand = (ComboBox) target;
          this.ComboExtCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboExtCommand_SelectionChanged);
          break;
        case 11:
          this.ComboAddCommand_Label = (Label) target;
          break;
        case 12:
          this.ComboAddCommand = (ComboBox) target;
          this.ComboAddCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboAddCommand_SelectionChanged);
          break;
        case 13:
          this.ComboAddCommand2_Label = (Label) target;
          break;
        case 14:
          this.ComboAddCommand2 = (ComboBox) target;
          this.ComboAddCommand2.SelectionChanged += new SelectionChangedEventHandler(this.ComboAddCommand2_SelectionChanged);
          break;
        case 15:
          this.ComboAddCommand3_Label = (Label) target;
          break;
        case 16:
          this.ComboAddCommand3 = (ComboBox) target;
          this.ComboAddCommand3.SelectionChanged += new SelectionChangedEventHandler(this.ComboAddCommand3_SelectionChanged);
          break;
        case 17:
          this.TextArgument_1_Label = (Label) target;
          break;
        case 18:
          this.TextExtCommandArgument_1 = (TextBox) target;
          break;
        case 19:
          this.TextArgument_2_Label = (Label) target;
          break;
        case 20:
          this.TextExtCommandArgument_2 = (TextBox) target;
          break;
        case 21:
          this.TextArgument_3_Label = (Label) target;
          break;
        case 22:
          this.TextExtCommandArgument_3 = (TextBox) target;
          break;
        case 23:
          this.TextArgument_4_Label = (Label) target;
          break;
        case 24:
          this.TextExtCommandArgument_4 = (TextBox) target;
          break;
        case 25:
          this.TextArgument_5_Label = (Label) target;
          break;
        case 26:
          this.TextExtCommandArgument_5 = (TextBox) target;
          break;
        case 27:
          this.StackPanalButtons2 = (StackPanel) target;
          break;
        case 28:
          this.ButtonRunCommand = (Button) target;
          this.ButtonRunCommand.Click += new RoutedEventHandler(this.ButtonRunCommand_Click);
          break;
        case 29:
          this.ButtonRunCommandPreview = (Button) target;
          this.ButtonRunCommandPreview.Click += new RoutedEventHandler(this.ButtonRunCommandPreview_Click);
          break;
        case 30:
          this.ButtonBreak = (Button) target;
          this.ButtonBreak.Click += new RoutedEventHandler(this.ButtonBreak_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- LoRaFcVersion.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.LoRaFcVersion
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  public sealed class LoRaFcVersion : ReturnValue
  {
    public ushort Version { get; set; }

    public override string ToString()
    {
      byte[] bytes = BitConverter.GetBytes(this.Version);
      return bytes[1].ToString() + "." + bytes[0].ToString();
    }
  }
}


--- LoRaPackets.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.LoRaPackets
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum LoRaPackets
  {
    SP1 = 1,
    SP2 = 2,
    SP3 = 3,
    SP4 = 4,
    START_JOINING = 5,
    TEMPERATURE = 6,
    AP1 = 7,
    SP9 = 8,
    CMD = 9,
    IK = 10, // 0x0000000A
    SP0 = 11, // 0x0000000B
    SP5 = 12, // 0x0000000C
    SP6 = 13, // 0x0000000D
    SP7 = 14, // 0x0000000E
    SP8 = 15, // 0x0000000F
    ASYNC_TELEGRAM = 16, // 0x00000010
    SP12 = 17, // 0x00000011
    STRESS = 18, // 0x00000012
    FE = 254, // 0x000000FE
  }
}


--- LoRaSystemDiagnostic.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.LoRaSystemDiagnostic
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  public sealed class LoRaSystemDiagnostic : ReturnValue
  {
    public byte DiagnosticConfig { get; set; }

    public byte DailyStartTime { get; set; }

    public byte DailyEndTime { get; set; }

    public ushort RemainigActivity { get; set; }

    public uint RemainigDiagnostic { get; set; }

    public static ushort getDailyTimeFromString(string argument)
    {
      try
      {
        string[] strArray = argument.Split(':');
        ushort num1 = ushort.Parse(strArray[0]);
        ushort num2 = ushort.Parse(strArray[1]);
        if (num1 < (ushort) 0 || num1 > (ushort) 24 || num2 < (ushort) 0 || num2 > (ushort) 59)
          throw new Exception("Time is out of range");
        if (num1 == (ushort) 24)
          num1 = (ushort) 0;
        return (ushort) ((int) num1 * 6 + (int) num2 / 10);
      }
      catch (Exception ex)
      {
        throw new Exception("DailyTime is incorrect !!!", ex);
      }
    }

    public string getDiagnosticIntervalAsString()
    {
      string intervalAsString = "n/a";
      if (this.DiagnosticConfig == byte.MaxValue)
        return "Diagnostic stopped!";
      byte num1 = (byte) ((uint) this.DiagnosticConfig & 15U);
      byte num2 = (byte) (((int) this.DiagnosticConfig & 240) >> 4);
      switch (num1)
      {
        case 0:
          intervalAsString = "0.25 h";
          break;
        case 1:
          intervalAsString = "0.50 h";
          break;
        case 2:
          intervalAsString = "1.00 h";
          break;
        case 3:
          intervalAsString = "2.00 h";
          break;
        case 4:
          intervalAsString = "3.00 h";
          break;
        case 5:
          intervalAsString = "6.00 h";
          break;
        case 6:
          intervalAsString = "12.00 h";
          break;
        case 7:
          intervalAsString = "24.00 h";
          break;
      }
      return intervalAsString;
    }

    public string getDiagnosticRepeatAsString()
    {
      string diagnosticRepeatAsString = "n/a";
      if (this.DiagnosticConfig == byte.MaxValue)
        return "Diagnostic stopped!";
      byte num = (byte) ((uint) this.DiagnosticConfig & 15U);
      switch ((byte) (((int) this.DiagnosticConfig & 240) >> 4))
      {
        case 0:
          diagnosticRepeatAsString = "5";
          break;
        case 1:
          diagnosticRepeatAsString = "10";
          break;
        case 2:
          diagnosticRepeatAsString = "20";
          break;
        case 3:
          diagnosticRepeatAsString = "50";
          break;
        case 4:
          diagnosticRepeatAsString = "100";
          break;
        case 5:
          diagnosticRepeatAsString = "200";
          break;
        case 6:
          diagnosticRepeatAsString = "500";
          break;
        case 7:
          diagnosticRepeatAsString = "1000";
          break;
      }
      return diagnosticRepeatAsString;
    }

    public string getDailyStartEndTimeAsString(bool startTime = true)
    {
      ushort num1 = startTime ? (ushort) this.DailyStartTime : (ushort) this.DailyEndTime;
      int num2 = (int) num1 / 6;
      string str1 = num2.ToString("00");
      num2 = (int) num1 % 6 * 10;
      string str2 = num2.ToString("00");
      return str1 + ":" + str2;
    }
  }
}


--- LoRaWANVersion.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.LoRaWANVersion
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public sealed class LoRaWANVersion : ReturnValue
  {
    public byte MainVersion { get; set; }

    public byte MinorVersion { get; set; }

    public byte ReleaseNr { get; set; }

    public override string ToString()
    {
      return ((int) this.MainVersion).ToString() + "." + ((int) this.MinorVersion).ToString() + "." + ((int) this.ReleaseNr).ToString();
    }
  }
}


--- Manufacturer_FC.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.Manufacturer_FC
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum Manufacturer_FC : byte
  {
    GetVersion_0x06 = 6,
    CommonRadioCommands_0x2f = 47, // 0x2F
    CommonMBusCommands_0x34 = 52, // 0x34
    CommonLoRaCommands_0x35 = 53, // 0x35
    SpecialCommands_0x36 = 54, // 0x36
    CommonNBIoTCommands_0x37 = 55, // 0x37
    SendNfcCommand_0x38 = 56, // 0x38
    ResetDevice_0x80 = 128, // 0x80
    SetWriteProtection_0x81 = 129, // 0x81
    OpenWriteProtectionTemp_0x82 = 130, // 0x82
    GetSetMode_0x83 = 131, // 0x83
    ReadMemory_0x84 = 132, // 0x84
    WriteMemory_0x85 = 133, // 0x85
    RunBackup_0x86 = 134, // 0x86
    GetSetSystemTime_0x87 = 135, // 0x87
    GetSetKeyDate_0x88 = 136, // 0x88
    GetSetRadioOperation_0x89 = 137, // 0x89
    ClearGetResetCounter_0x8a = 138, // 0x8A
    SetLcdTestState_0x8b = 139, // 0x8B
    SwitchLoRaLED_0x8c = 140, // 0x8C
    ActivateDeactivateDisplay_0x8d = 141, // 0x8D
    TimeShift_0x8e = 142, // 0x8E
    ExecuteEvent_0x8f = 143, // 0x8F
    SetRTCCalibration_0x90 = 144, // 0x90
    GetCommunicationScenario_0x91 = 145, // 0x91
    SetCommunicationScenario_0x92 = 146, // 0x92
    GetPrintedSerialNumber_0x93 = 147, // 0x93
    GetLocalInterfaceEncryption_0x94 = 148, // 0x94
    SetLocalInterfaceEncryption_0x94 = 148, // 0x94
  }
}


--- MBusChannelAddress.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MBusChannelAddress
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public sealed class MBusChannelAddress : ReturnValue
  {
    public byte Channel { get; set; }

    public byte Address { get; set; }
  }
}


--- MBusChannelConfiguration.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MBusChannelConfiguration
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public sealed class MBusChannelConfiguration : ReturnValue
  {
    public byte Channel { get; set; }

    public byte[] Mantissa { get; set; }

    public sbyte Exponent { get; set; }

    public byte VIF { get; set; }
  }
}


--- MBusChannelIdentification.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MBusChannelIdentification
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public sealed class MBusChannelIdentification : ReturnValue
  {
    public byte Channel { get; set; }

    public long SerialNumber { get; set; }

    public string Manufacturer { get; set; }

    public byte Generation { get; set; }

    public string Medium { get; set; }
  }
}


--- MBusChannelLog.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MBusChannelLog
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace HandlerLib
{
  public sealed class MBusChannelLog : ReturnValue
  {
    public byte Channel { get; set; }

    public byte LogSelected { get; set; }

    public byte StartIndex { get; set; }

    public byte EndIndex { get; set; }

    public byte Lenght { get; set; }

    public byte Year { get; set; }

    public byte Month { get; set; }

    public byte Day { get; set; }

    public byte Hour { get; set; }

    public byte Minute { get; set; }

    public byte Second { get; set; }

    public byte[] LogValues { get; set; }

    public IReadOnlyDictionary<DateTime, int> GetValues()
    {
      if (this.LogValues == null)
        return (IReadOnlyDictionary<DateTime, int>) null;
      DateTime result;
      if (!DateTime.TryParse(((int) this.Year + 2000).ToString() + "-" + this.Month.ToString("D2") + "-" + this.Day.ToString("D2") + " " + this.Hour.ToString("D2") + ":" + this.Minute.ToString("D2") + ":" + this.Second.ToString("D2"), out result))
        return (IReadOnlyDictionary<DateTime, int>) null;
      int[] numArray = new int[(int) this.Lenght];
      int startIndex = 0;
      int index = 0;
      while (index < (int) this.Lenght)
      {
        numArray[index] = BitConverter.ToInt32(this.LogValues, startIndex);
        ++index;
        startIndex += 4;
      }
      Dictionary<DateTime, int> values = new Dictionary<DateTime, int>();
      foreach (int num in numArray)
      {
        values.Add(result, num);
        switch (this.LogSelected)
        {
          case 0:
            result = result.AddMinutes(-15.0);
            break;
          case 1:
            result = result.AddDays(-1.0);
            break;
          case 2:
          case 3:
            result = result.AddMonths(-1);
            break;
          case 4:
            result = result.AddYears(-1);
            break;
          default:
            throw new NotImplementedException(this.LogSelected.ToString());
        }
      }
      return (IReadOnlyDictionary<DateTime, int>) values;
    }
  }
}


--- MBusChannelOBIS.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MBusChannelOBIS
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public sealed class MBusChannelOBIS : ReturnValue
  {
    public byte Channel { get; set; }

    public byte OBIS_code { get; set; }
  }
}


--- MBusChannelSingleLogValue.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MBusChannelSingleLogValue
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  public sealed class MBusChannelSingleLogValue : ReturnValue
  {
    public byte Channel { get; set; }

    public byte[] Date { get; set; }

    public DateTime DateAndTime { get; set; }

    public uint Value { get; set; }
  }
}


--- MBusChannelValue.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MBusChannelValue
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public sealed class MBusChannelValue : ReturnValue
  {
    public byte Channel { get; set; }

    public uint Value { get; set; }
  }
}


--- MBusCommandWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MBusCommandWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using GmmDbLib;
using MBusLib;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZENNER.CommonLibrary.Exceptions;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class MBusCommandWindow : Window, IComponentConnector
  {
    private const string translaterBaseKey = "MBusCommandWindow";
    private CommonMBusCommands myMBusCommands;
    private List<string> Argument1_last_values;
    private List<string> Argument2_last_values;
    private List<string> Argument3_last_values;
    private List<string> Argument4_last_values;
    private List<string> Argument5_last_values;
    private ContextMenu Argument1ValuesMenu;
    private ContextMenu Argument2ValuesMenu;
    private ContextMenu Argument3ValuesMenu;
    private ContextMenu Argument4ValuesMenu;
    private ContextMenu Argument5ValuesMenu;
    private static string result = string.Empty;
    private static readonly string CMD_GetChannelMBusAddress = "Get channel MBus address (0x01)";
    private static readonly string CMD_SetChannelMBusAddress = "Set channel MBus address (0x01)";
    private static readonly string CMD_GetChannelIdentification = "Get channel identification (0x02)";
    private static readonly string CMD_SetChannelIdentification = "Set channel identification (0x02)";
    private static readonly string CMD_GetChannelOBISCode = "Get channel OBIS code (0x03)";
    private static readonly string CMD_SetChannelOBISCode = "Set channel OBIS code (0x03)";
    private static readonly string CMD_GetChannelConfiguration = "Get channel configuration (0x04)";
    private static readonly string CMD_SetChannelConfiguration = "Set channel configuration (0x04)";
    private static readonly string CMD_GetChannelValue = "Get channel value (0x05)";
    private static readonly string CMD_SetChannelValue = "Set channel value (0x05)";
    private static readonly string CMD_ReadChannelLOG = "Read channel log value (0x10)";
    private static readonly string CMD_ReadEventLOG = "Read event log (0x11)";
    private static readonly string CMD_ClearEventLOG = "Clear event log (0x12)";
    private static readonly string CMD_ReadSystemLOG = "Read system log (0x13)";
    private static readonly string CMD_ClearSystemLOG = "Clear system log (0x14)";
    private static readonly string CMD_ReadChannelSingleLogValue = "Read channel single log value (0x15)";
    private static readonly string CMD_GetRadioList = "Get radio list (0x16)";
    private static readonly string CMD_SetRadioList = "Set radio list (0x16)";
    private static readonly string CMD_GetTXTimings = "Get TX timings (0x17)";
    private static readonly string CMD_SetTXTimings = "Set TX timings (0x17)";
    private static readonly string CMD_GetMBusKey = "Get MBusKey (0x18)";
    private static readonly string CMD_SetMBusKey = "Set MBusKey (0x18)";
    private Cursor defaultCursor;
    private CancellationTokenSource cancelTokenSource;
    private ProgressHandler progress;
    internal TextBlock TextBlockStatus;
    internal ProgressBar ProgressBar1;
    internal TextBox TextBoxUniversalCommandResult;
    internal StackPanel StackPanalButtons;
    internal ComboBox ComboCommand;
    internal CheckBox CheckBoxEncryption;
    internal Label EncryptionKey_Label;
    internal TextBox TextBoxEncryptionKey;
    internal Label ComboExtCommand_Label;
    internal ComboBox ComboExtCommand;
    internal Label ComboAddCommand_Label;
    internal ComboBox ComboAddCommand;
    internal Label TextArgument_1_Label;
    internal TextBox TextExtCommandArgument_1;
    internal Label TextArgument_2_Label;
    internal TextBox TextExtCommandArgument_2;
    internal Label TextArgument_3_Label;
    internal TextBox TextExtCommandArgument_3;
    internal Label TextArgument_4_Label;
    internal TextBox TextExtCommandArgument_4;
    internal Label TextArgument_5_Label;
    internal TextBox TextExtCommandArgument_5;
    internal StackPanel StackPanalButtons2;
    internal Button ButtonRunCommand;
    internal Button ButtonRunCommandPreview;
    internal Button ButtonBreak;
    private bool _contentLoaded;

    public MBusCommandWindow(CommonMBusCommands MBusCMDs)
    {
      this.InitializeComponent();
      WpfTranslatorSupport.TranslateWindow(Tg.MBus_CommandWindow, (Window) this);
      this.myMBusCommands = MBusCMDs;
      this.myMBusCommands.setCryptValuesFromBaseClass();
      this.ButtonRunCommand.IsEnabled = false;
      this.SetArgumentFields((Dictionary<int, string>) null);
      this.setFunctionCodes();
      this.Argument1_last_values = new List<string>();
      this.Argument2_last_values = new List<string>();
      this.Argument3_last_values = new List<string>();
      this.Argument4_last_values = new List<string>();
      this.Argument5_last_values = new List<string>();
      this.Argument1ValuesMenu = new ContextMenu();
      this.Argument2ValuesMenu = new ContextMenu();
      this.Argument3ValuesMenu = new ContextMenu();
      this.Argument4ValuesMenu = new ContextMenu();
      this.Argument5ValuesMenu = new ContextMenu();
      this.setCryptState();
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
    }

    private void setCryptState()
    {
      this.CheckBoxEncryption.IsChecked = new bool?(this.myMBusCommands.enDeCrypt);
      if (!this.myMBusCommands.enDeCrypt)
        this.CheckBoxEncryption_UnChecked((object) null, (RoutedEventArgs) null);
      this.TextBoxEncryptionKey.Text = this.myMBusCommands.AES_Key;
    }

    private void setFunctionCodes()
    {
      this.ComboExtCommand_Label.Visibility = Visibility.Hidden;
      this.ComboExtCommand.Visibility = Visibility.Hidden;
      this.ComboCommand.Items.Clear();
      this.ComboCommand.Items.Add((object) "MBus Commands (0x34)");
      this.ComboCommand.SelectedIndex = 0;
    }

    private void setMBusCommands()
    {
      Dictionary<string, string> valuesForCommands = GetCommandValues.GetAllPrivateStaticFieldValuesForCommands((object) this);
      this.ComboExtCommand.Items.Clear();
      foreach (KeyValuePair<string, string> keyValuePair in valuesForCommands)
        this.ComboExtCommand.Items.Add((object) keyValuePair.Value);
      this.ComboExtCommand.SelectedIndex = 0;
    }

    private void SetRunState()
    {
      this.cancelTokenSource = new CancellationTokenSource();
      this.progress.Reset();
      this.progress.Split(new double[2]{ 2.0, 98.0 });
      this.progress.Report("Run");
      this.ComboCommand.IsEnabled = false;
      this.ComboExtCommand.IsEnabled = false;
      this.TextBoxUniversalCommandResult.IsEnabled = false;
      this.TextExtCommandArgument_1.IsEnabled = false;
      this.TextExtCommandArgument_2.IsEnabled = false;
      this.TextExtCommandArgument_3.IsEnabled = false;
      this.ButtonRunCommand.IsEnabled = false;
      this.ButtonRunCommandPreview.IsEnabled = false;
      this.ButtonBreak.IsEnabled = true;
      this.defaultCursor = this.Cursor;
      this.Cursor = Cursors.Wait;
    }

    private void SetStopState()
    {
      this.ComboCommand.IsEnabled = true;
      this.ComboExtCommand.IsEnabled = true;
      this.TextBoxUniversalCommandResult.IsEnabled = true;
      this.TextExtCommandArgument_1.IsEnabled = true;
      this.TextExtCommandArgument_2.IsEnabled = true;
      this.TextExtCommandArgument_3.IsEnabled = true;
      this.ButtonRunCommand.IsEnabled = true;
      this.ButtonRunCommandPreview.IsEnabled = true;
      this.ButtonBreak.IsEnabled = false;
      this.Cursor = this.defaultCursor;
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.ProgressBar1.Value = obj.ProgressPercentage;
        this.TextBlockStatus.Text = obj.Message;
      }
    }

    private void ButtonBreak_Click(object sender, RoutedEventArgs e)
    {
      this.cancelTokenSource.Cancel();
    }

    private async Task RunCommandFrame()
    {
      this.SetRunState();
      try
      {
        await this.RunCommand();
      }
      catch (OperationCanceledException ex)
      {
      }
      catch (TimeoutException ex)
      {
        this.TextBoxUniversalCommandResult.Text = "Timeout";
      }
      catch (NACK_Exception ex)
      {
        this.TextBoxUniversalCommandResult.Text = "Device response is NACK: " + ex.Message;
      }
      catch (Exception ex)
      {
        bool isTimeout = false;
        if (ex is AggregateException)
        {
          AggregateException aex = ex as AggregateException;
          int num1;
          for (int i = 0; i < aex.InnerExceptions.Count; num1 = i++)
          {
            Exception theException = aex.InnerExceptions[i];
            if (theException is TimeoutException)
            {
              if (i == aex.InnerExceptions.Count - 1)
              {
                isTimeout = true;
                string newLine = Environment.NewLine;
                num1 = aex.InnerExceptions.Count;
                string str = num1.ToString();
                int num2 = (int) MessageBox.Show("**** Multiple timeouts ****" + newLine + "Timeout count: " + str);
              }
              theException = (Exception) null;
            }
            else
              break;
          }
          aex = (AggregateException) null;
        }
        if (!isTimeout)
        {
          int num = (int) MessageBox.Show(ex.ToString());
        }
      }
      this.SetStopState();
    }

    private async void ButtonRunCommand_Click(object sender, RoutedEventArgs e)
    {
      MBusCommandWindow.result = string.Empty;
      await this.RunCommandFrame();
    }

    private async void ButtonRunCommandPreview_Click(object sender, RoutedEventArgs e)
    {
      MBusCommandWindow.result = "Actual MBus info data from connected device: \n-----------------------------------------------------";
      Dictionary<int, string> args = new Dictionary<int, string>();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetChannelMBusAddress;
      args.Clear();
      args.Add(1, "0");
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetChannelMBusAddress;
      args.Clear();
      args.Add(1, "1");
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetChannelConfiguration;
      args.Clear();
      args.Add(1, "0");
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetChannelConfiguration;
      args.Clear();
      args.Add(1, "1");
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetChannelIdentification;
      args.Clear();
      args.Add(1, "0");
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetChannelIdentification;
      args.Clear();
      args.Add(1, "1");
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetChannelOBISCode;
      args.Clear();
      args.Add(1, "0");
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetChannelOBISCode;
      args.Clear();
      args.Add(1, "1");
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetChannelValue;
      args.Clear();
      args.Add(1, "0");
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetChannelValue;
      args.Clear();
      args.Add(1, "1");
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetRadioList;
      args.Clear();
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetTXTimings;
      args.Clear();
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) MBusCommandWindow.CMD_GetMBusKey;
      args.Clear();
      this.SetArgumentFieldsValues(args);
      await this.RunCommandFrame();
      args = (Dictionary<int, string>) null;
    }

    private void ComboExtCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboExtCommand.SelectedItem != null)
      {
        object selectedItem = this.ComboExtCommand.SelectedItem;
        this.ComboAddCommand.Items.Clear();
        Dictionary<int, string> template = new Dictionary<int, string>();
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_SetChannelMBusAddress))
        {
          template.Add(1, "Channel:");
          template.Add(2, "Address:");
        }
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_GetChannelMBusAddress))
          template.Add(1, "Channel:");
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_SetChannelIdentification))
        {
          template.Add(1, "Channel:");
          template.Add(2, "Serialnumber:");
          template.Add(3, "Manufacturer:");
          template.Add(4, "Generation:");
          template.Add(5, "Medium:");
        }
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_GetChannelIdentification))
          template.Add(1, "Channel:");
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_SetChannelOBISCode))
        {
          template.Add(1, "Channel:");
          template.Add(2, "OBIS code:");
        }
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_GetChannelOBISCode))
          template.Add(1, "Channel:");
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_SetChannelConfiguration))
        {
          template.Add(1, "Channel:");
          template.Add(2, "Masntissa(2 bytes):");
          template.Add(3, "Exponent:");
          template.Add(4, "VIF:");
        }
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_GetChannelConfiguration))
          template.Add(1, "Channel:");
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_SetChannelValue))
        {
          template.Add(1, "Channel:");
          template.Add(2, "Value:");
        }
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_GetChannelValue))
          template.Add(1, "Channel:");
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_ReadChannelLOG))
        {
          template.Add(1, "Channel:");
          template.Add(2, "Log select:");
          template.Add(3, "Start index:");
          template.Add(4, "End index:");
        }
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_ReadEventLOG))
          template.Add(1, "Flow control:");
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_ReadSystemLOG))
          template.Add(1, "Flow control:");
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_ReadChannelSingleLogValue))
        {
          template.Add(1, "Channel:");
          template.Add(2, "Date:");
        }
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_SetRadioList))
          template.Add(1, "Radio list identifier:");
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_SetTXTimings))
        {
          template.Add(1, "Interval (sec.):");
          template.Add(2, "Nighttime start(hour):");
          template.Add(3, "Nighttime end(hour):");
          template.Add(4, "Radio suppression days:");
        }
        if (selectedItem.ToString().Contains(MBusCommandWindow.CMD_SetMBusKey))
          template.Add(1, "MBusKey:");
        this.SetArgumentFields(template);
        this.ButtonRunCommand.IsEnabled = true;
      }
      else
        this.ButtonRunCommand.IsEnabled = false;
    }

    private void ComboCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboCommand.SelectedIndex < 0)
        return;
      Dictionary<int, string> dictionary = new Dictionary<int, string>();
      if (this.ComboCommand.SelectedItem.ToString().Contains("0x34"))
      {
        this.setMBusCommands();
        this.ComboExtCommand_Label.Content = (object) "MBus Commands (EFC):";
        this.ComboExtCommand_Label.Visibility = Visibility.Visible;
        this.ComboExtCommand.Visibility = Visibility.Visible;
      }
    }

    private void ComboAddCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboAddCommand.SelectedIndex < 0)
        return;
      object selectedItem = this.ComboAddCommand.SelectedItem;
    }

    private void SetArgumentFieldsValues(Dictionary<int, string> values)
    {
      if (values == null)
        return;
      foreach (KeyValuePair<int, string> keyValuePair in values)
      {
        if (keyValuePair.Key == 0)
          this.ComboAddCommand.SelectedItem = (object) keyValuePair.Value;
        if (keyValuePair.Key == 1)
          this.TextExtCommandArgument_1.Text = keyValuePair.Value;
        if (keyValuePair.Key == 2)
          this.TextExtCommandArgument_2.Text = keyValuePair.Value;
        if (keyValuePair.Key == 3)
          this.TextExtCommandArgument_3.Text = keyValuePair.Value;
        if (keyValuePair.Key == 4)
          this.TextExtCommandArgument_4.Text = keyValuePair.Value;
        if (keyValuePair.Key == 5)
          this.TextExtCommandArgument_5.Text = keyValuePair.Value;
      }
    }

    private void SetArgumentFields(Dictionary<int, string> template)
    {
      this.TextExtCommandArgument_1.Text = string.Empty;
      this.TextExtCommandArgument_2.Text = string.Empty;
      this.TextExtCommandArgument_3.Text = string.Empty;
      this.TextExtCommandArgument_4.Text = string.Empty;
      this.TextExtCommandArgument_5.Text = string.Empty;
      this.ComboAddCommand_Label.Visibility = Visibility.Collapsed;
      this.ComboAddCommand.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_1.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_2.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_3.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_4.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_5.Visibility = Visibility.Collapsed;
      this.TextArgument_1_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_2_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_3_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_4_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_5_Label.Visibility = Visibility.Collapsed;
      if (template == null)
        return;
      foreach (KeyValuePair<int, string> keyValuePair in template)
      {
        if (keyValuePair.Key == 0)
        {
          this.ComboAddCommand.Visibility = Visibility.Visible;
          this.ComboAddCommand.Items.Add((object) "FSK         (0x00)");
          this.ComboAddCommand.Items.Add((object) "GFSK        (0x01)");
          this.ComboAddCommand.Items.Add((object) "OOK         (0x02)");
          this.ComboAddCommand.Items.Add((object) "SIGFOX      (0x03)");
          this.ComboAddCommand.Items.Add((object) "LoRa SF7    (0x04)");
          this.ComboAddCommand.Items.Add((object) "LoRa SF8    (0x05)");
          this.ComboAddCommand.Items.Add((object) "LoRa SF9    (0x06)");
          this.ComboAddCommand.Items.Add((object) "LoRa SF10   (0x07)");
          this.ComboAddCommand.Items.Add((object) "LoRa SF11   (0x08)");
          this.ComboAddCommand.Items.Add((object) "LoRa SF12   (0x09)");
          this.ComboAddCommand_Label.Visibility = Visibility.Visible;
          this.ComboAddCommand_Label.Content = (object) keyValuePair.Value;
        }
        if (keyValuePair.Key == 1)
        {
          this.TextExtCommandArgument_1.Visibility = Visibility.Visible;
          this.TextArgument_1_Label.Visibility = Visibility.Visible;
          this.TextArgument_1_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_1.ContextMenu = this.Argument1ValuesMenu;
        }
        if (keyValuePair.Key == 2)
        {
          this.TextExtCommandArgument_2.Visibility = Visibility.Visible;
          this.TextArgument_2_Label.Visibility = Visibility.Visible;
          this.TextArgument_2_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_2.ContextMenu = this.Argument2ValuesMenu;
        }
        if (keyValuePair.Key == 3)
        {
          this.TextExtCommandArgument_3.Visibility = Visibility.Visible;
          this.TextArgument_3_Label.Visibility = Visibility.Visible;
          this.TextArgument_3_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_3.ContextMenu = this.Argument3ValuesMenu;
        }
        if (keyValuePair.Key == 4)
        {
          this.TextExtCommandArgument_4.Visibility = Visibility.Visible;
          this.TextArgument_4_Label.Visibility = Visibility.Visible;
          this.TextArgument_4_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_4.ContextMenu = this.Argument4ValuesMenu;
        }
        if (keyValuePair.Key == 5)
        {
          this.TextExtCommandArgument_5.Visibility = Visibility.Visible;
          this.TextArgument_5_Label.Visibility = Visibility.Visible;
          this.TextArgument_5_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_5.ContextMenu = this.Argument5ValuesMenu;
        }
      }
    }

    private void mi_Click(object sender, RoutedEventArgs e)
    {
      ((TextBox) ((FrameworkElement) sender).Tag).Text = ((HeaderedItemsControl) sender).Header.ToString();
    }

    private async Task RunCommand()
    {
      string FC = this.ComboCommand.SelectedItem.ToString();
      string EFC = this.ComboExtCommand.SelectedItem.ToString();
      object addFC = this.ComboAddCommand.SelectedItem;
      string arg1 = string.IsNullOrEmpty(this.TextExtCommandArgument_1.Text) ? (string) null : this.TextExtCommandArgument_1.Text.Trim();
      string arg2 = string.IsNullOrEmpty(this.TextExtCommandArgument_2.Text) ? (string) null : this.TextExtCommandArgument_2.Text.Trim();
      string arg3 = string.IsNullOrEmpty(this.TextExtCommandArgument_3.Text) ? (string) null : this.TextExtCommandArgument_3.Text.Trim();
      string arg4 = string.IsNullOrEmpty(this.TextExtCommandArgument_4.Text) ? (string) null : this.TextExtCommandArgument_4.Text.Trim();
      string arg5 = string.IsNullOrEmpty(this.TextExtCommandArgument_5.Text) ? (string) null : this.TextExtCommandArgument_5.Text.Trim();
      try
      {
        if (FC.Contains("0x34"))
        {
          if (EFC.Contains(MBusCommandWindow.CMD_SetChannelMBusAddress))
          {
            if (!string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2))
            {
              await this.myMBusCommands.SetMBusChannelAddressAsync(byte.Parse(arg1), byte.Parse(arg2), this.progress, this.cancelTokenSource.Token);
              MBusCommandWindow.result = MBusCommandWindow.result + "\nChannel " + arg1 + " MBus address set to " + arg2;
            }
            else
            {
              int num1 = (int) MessageBox.Show("Channel or address was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(MBusCommandWindow.CMD_GetChannelMBusAddress))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              MBusChannelAddress ChannelAddress = await this.myMBusCommands.GetMBusChannelAddressAsync(byte.Parse(arg1), this.progress, this.cancelTokenSource.Token);
              MBusCommandWindow.result = MBusCommandWindow.result + "\nChannel " + ChannelAddress.Channel.ToString() + " has address " + ChannelAddress.Address.ToString();
              ChannelAddress = (MBusChannelAddress) null;
            }
            else
            {
              int num2 = (int) MessageBox.Show("Channel was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(MBusCommandWindow.CMD_SetChannelIdentification))
          {
            if (!string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2) && !string.IsNullOrEmpty(arg3) && !string.IsNullOrEmpty(arg4) && !string.IsNullOrEmpty(arg5))
            {
              MBusChannelIdentification mci = new MBusChannelIdentification()
              {
                Channel = byte.Parse(arg1),
                SerialNumber = (long) Util.ConvertUnt32ToBcdUInt32(uint.Parse(arg2)),
                Manufacturer = MBusUtil.GetManufacturer(ushort.Parse(arg3)),
                Generation = byte.Parse(arg4),
                Medium = MBusUtil.GetMedium(byte.Parse(arg5))
              };
              mci.Medium = string.IsNullOrEmpty(mci.Medium) ? MBusUtil.GetMedium((byte) 15) : mci.Medium;
              await this.myMBusCommands.SetChannelIdentificationAsync(mci, this.progress, this.cancelTokenSource.Token);
              MBusCommandWindow.result += "\nChannel identification was successfully set to device";
              mci = (MBusChannelIdentification) null;
            }
            else
            {
              int num3 = (int) MessageBox.Show("Channel, serialnumber, manufacturer, generation or medium was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(MBusCommandWindow.CMD_GetChannelIdentification) && !string.IsNullOrEmpty(arg1))
          {
            MBusChannelIdentification retVal = await this.myMBusCommands.GetChannelIdentificationAsync(byte.Parse(arg1), this.progress, this.cancelTokenSource.Token);
            MBusCommandWindow.result = MBusCommandWindow.result + "\nChannel: " + retVal.Channel.ToString() + "\nSerialnumber: " + retVal.SerialNumber.ToString() + "\nManufacturer: " + retVal.Manufacturer + "\nGeneration: " + retVal.Generation.ToString() + "\nMedium: " + retVal.Medium;
            retVal = (MBusChannelIdentification) null;
          }
          if (EFC.Contains(MBusCommandWindow.CMD_SetChannelOBISCode) && !string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2))
          {
            await this.myMBusCommands.SetChannelOBISCodeAsync(byte.Parse(arg1), byte.Parse(arg2), this.progress, this.cancelTokenSource.Token);
            MBusCommandWindow.result = MBusCommandWindow.result + "\nChannel " + arg1 + " set OBIS code to: " + arg2;
          }
          if (EFC.Contains(MBusCommandWindow.CMD_GetChannelOBISCode) && !string.IsNullOrEmpty(arg1))
          {
            MBusChannelOBIS retVal = await this.myMBusCommands.GetChannelOBISCodeAsync(byte.Parse(arg1), this.progress, this.cancelTokenSource.Token);
            MBusCommandWindow.result = MBusCommandWindow.result + "\nChannel: " + retVal.Channel.ToString() + " OBIS_Code: " + retVal.OBIS_code.ToString();
            retVal = (MBusChannelOBIS) null;
          }
          if (EFC.Contains(MBusCommandWindow.CMD_SetChannelConfiguration))
          {
            if (!string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2) && !string.IsNullOrEmpty(arg3) && !string.IsNullOrEmpty(arg4))
            {
              MBusChannelConfiguration mbChannelConfig = new MBusChannelConfiguration();
              mbChannelConfig.Channel = byte.Parse(arg1);
              mbChannelConfig.Mantissa = BitConverter.GetBytes(ushort.Parse(arg2));
              mbChannelConfig.Exponent = sbyte.Parse(arg3);
              mbChannelConfig.VIF = byte.Parse(arg4);
              await this.myMBusCommands.SetChannelConfigurationAsync(mbChannelConfig, this.progress, this.cancelTokenSource.Token);
              MBusCommandWindow.result += "\nChannel configuration was successfully set to device";
              mbChannelConfig = (MBusChannelConfiguration) null;
            }
            else
            {
              int num4 = (int) MessageBox.Show("Channel, mantissa, exponent or vif was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(MBusCommandWindow.CMD_GetChannelConfiguration) && !string.IsNullOrEmpty(arg1))
          {
            MBusChannelConfiguration retVal = await this.myMBusCommands.GetChannelConfigurationAsync(byte.Parse(arg1), this.progress, this.cancelTokenSource.Token);
            ushort Mantissa = BitConverter.ToUInt16(retVal.Mantissa, 0);
            MBusCommandWindow.result = MBusCommandWindow.result + "\nChannel: " + retVal.Channel.ToString() + "\nMantissa: " + Mantissa.ToString() + "\nExponent: " + retVal.Exponent.ToString() + "\nVIF: " + retVal.VIF.ToString();
            retVal = (MBusChannelConfiguration) null;
          }
          if (EFC.Contains(MBusCommandWindow.CMD_SetChannelValue))
          {
            if (!string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2))
            {
              await this.myMBusCommands.SetChannelValueAsync(byte.Parse(arg1), uint.Parse(arg2), this.progress, this.cancelTokenSource.Token);
              MBusCommandWindow.result += "\nChannel value was successfully set to device";
            }
            else
            {
              int num5 = (int) MessageBox.Show("Channel or value was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(MBusCommandWindow.CMD_GetChannelValue) && !string.IsNullOrEmpty(arg1))
          {
            uint retVal = await this.myMBusCommands.GetChannelValueAsync(byte.Parse(arg1), this.progress, this.cancelTokenSource.Token);
            MBusCommandWindow.result = MBusCommandWindow.result + "\nChannel: " + arg1 + "\nValue: " + retVal.ToString();
          }
          byte num6;
          if (EFC.Contains(MBusCommandWindow.CMD_ReadChannelLOG))
          {
            if (!string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2) && !string.IsNullOrEmpty(arg3) && !string.IsNullOrEmpty(arg4))
            {
              int channel = int.Parse(arg1);
              if (channel < 0 || channel > 4)
              {
                MBusCommandWindow.result += "\nChannel is not supported!";
              }
              else
              {
                MBusChannelLog retVal = await this.myMBusCommands.ReadChannelLogValueAsync(byte.Parse(arg1), byte.Parse(arg2), byte.Parse(arg3), byte.Parse(arg4), this.progress, this.cancelTokenSource.Token);
                if (retVal != null)
                {
                  MBusCommandWindow.result += "\nChannel log values read successfully from device.\n";
                  if (retVal.Year != byte.MaxValue)
                  {
                    string[] strArray = new string[13];
                    strArray[0] = MBusCommandWindow.result;
                    strArray[1] = "\nStartTime: 20";
                    strArray[2] = retVal.Year.ToString("D2");
                    strArray[3] = "-";
                    strArray[4] = retVal.Month.ToString("D2");
                    strArray[5] = "-";
                    num6 = retVal.Day;
                    strArray[6] = num6.ToString("D2");
                    strArray[7] = " ";
                    num6 = retVal.Hour;
                    strArray[8] = num6.ToString("D2");
                    strArray[9] = ":";
                    num6 = retVal.Minute;
                    strArray[10] = num6.ToString("D2");
                    strArray[11] = ":";
                    num6 = retVal.Second;
                    strArray[12] = num6.ToString("D2");
                    MBusCommandWindow.result = string.Concat(strArray);
                  }
                  else
                    MBusCommandWindow.result += "\nStartTime: N/A";
                  string[] strArray1 = new string[5]
                  {
                    MBusCommandWindow.result,
                    "\nChannel: (",
                    null,
                    null,
                    null
                  };
                  num6 = retVal.Channel;
                  strArray1[2] = num6.ToString();
                  strArray1[3] = ") - ";
                  strArray1[4] = (int) retVal.Channel == (int) byte.Parse(arg1) ? " OK." : "FALSE !!!";
                  MBusCommandWindow.result = string.Concat(strArray1);
                  string result = MBusCommandWindow.result;
                  num6 = retVal.LogSelected;
                  string str = num6.ToString();
                  MBusCommandWindow.result = result + "\nLog selected: " + str;
                  MBusCommandWindow.result += "\n------------------------";
                  int index = 0;
                  for (int i = 0; i < retVal.LogValues.Length / 4; ++i)
                  {
                    byte[] data = new byte[4];
                    Buffer.BlockCopy((Array) retVal.LogValues, index, (Array) data, 0, data.Length);
                    index += 4;
                    uint logVal = BitConverter.ToUInt32(data, 0);
                    MBusCommandWindow.result = MBusCommandWindow.result + "\nLogValues(" + (i + 1).ToString() + "): " + (logVal != uint.MaxValue ? logVal.ToString() : "N/A");
                    data = (byte[]) null;
                  }
                }
                else
                  MBusCommandWindow.result += "\nCould not read channel log from device!!!\n";
                retVal = (MBusChannelLog) null;
              }
            }
            else
            {
              int num7 = (int) MessageBox.Show("Channel, logSelect, StartIndex or EndIndex was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(MBusCommandWindow.CMD_ReadEventLOG) && !string.IsNullOrEmpty(arg1))
          {
            MBusEventLog retVal = await this.myMBusCommands.ReadEventLogAsync(byte.Parse(arg1), this.progress, this.cancelTokenSource.Token);
            if (retVal.FlowControl == (byte) 1)
            {
              string[] strArray = new string[17];
              strArray[0] = MBusCommandWindow.result;
              strArray[1] = "\nEvent log read successfully. \nSystemEventType: ";
              num6 = retVal.SystemEventType;
              strArray[2] = num6.ToString();
              strArray[3] = "\nEventTime: 20";
              strArray[4] = retVal.EventTime[0].ToString("D2");
              strArray[5] = "-";
              strArray[6] = retVal.EventTime[1].ToString("D2");
              strArray[7] = "-";
              strArray[8] = retVal.EventTime[2].ToString("D2");
              strArray[9] = " ";
              strArray[10] = retVal.EventTime[3].ToString("D2");
              strArray[11] = ":";
              strArray[12] = retVal.EventTime[4].ToString("D2");
              strArray[13] = "\nChannel0Value: ";
              strArray[14] = Util.ByteArrayToHexString(retVal.Channel0Value);
              strArray[15] = "\nChannel1Value: ";
              strArray[16] = Util.ByteArrayToHexString(retVal.Channel1Value);
              MBusCommandWindow.result = string.Concat(strArray);
            }
            else if (retVal.FlowControl == (byte) 0)
              MBusCommandWindow.result += "\nNo additional data";
            retVal = (MBusEventLog) null;
          }
          if (EFC.Contains(MBusCommandWindow.CMD_ClearEventLOG))
          {
            await this.myMBusCommands.ClearEventLogAsync(this.progress, this.cancelTokenSource.Token);
            MBusCommandWindow.result += "\nEvent log successfully cleared.";
          }
          if (EFC.Contains(MBusCommandWindow.CMD_ReadSystemLOG) && !string.IsNullOrEmpty(arg1))
          {
            MBusSystemLog retVal = await this.myMBusCommands.ReadSystemLogAsync(byte.Parse(arg1), this.progress, this.cancelTokenSource.Token);
            if (retVal.FlowControl == (byte) 1)
            {
              string[] strArray = new string[17];
              strArray[0] = MBusCommandWindow.result;
              strArray[1] = "\nSystem log read successfully. \nSystemEventType: ";
              num6 = retVal.SystemEventType;
              strArray[2] = num6.ToString();
              strArray[3] = "\nEventTime: 20";
              strArray[4] = retVal.EventTime[0].ToString("D2");
              strArray[5] = "-";
              strArray[6] = retVal.EventTime[1].ToString("D2");
              strArray[7] = "-";
              strArray[8] = retVal.EventTime[2].ToString("D2");
              strArray[9] = " ";
              strArray[10] = retVal.EventTime[3].ToString("D2");
              strArray[11] = ":";
              strArray[12] = retVal.EventTime[4].ToString("D2");
              strArray[13] = "\nChannel0Value: ";
              strArray[14] = Util.ByteArrayToHexString(retVal.Channel0Value);
              strArray[15] = "\nChannel1Value: ";
              strArray[16] = Util.ByteArrayToHexString(retVal.Channel1Value);
              MBusCommandWindow.result = string.Concat(strArray);
            }
            else if (retVal.FlowControl == (byte) 0)
              MBusCommandWindow.result += "\nNo additional data";
            retVal = (MBusSystemLog) null;
          }
          if (EFC.Contains(MBusCommandWindow.CMD_ClearSystemLOG))
          {
            await this.myMBusCommands.ClearSystemLogAsync(this.progress, this.cancelTokenSource.Token);
            MBusCommandWindow.result += "\nSystem log successfully cleared.";
          }
          if (EFC.Contains(MBusCommandWindow.CMD_ReadChannelSingleLogValue) && !string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2))
          {
            byte channel = byte.Parse(arg1);
            byte[] date = BitConverter.GetBytes(ushort.Parse(arg2));
            MBusChannelSingleLogValue retVal = await this.myMBusCommands.ReadChannelSingleLogValueAsync(channel, date, this.progress, this.cancelTokenSource.Token);
            if ((int) retVal.Channel == (int) channel)
            {
              string[] strArray = new string[7];
              strArray[0] = MBusCommandWindow.result;
              strArray[1] = "\nChannel log value read successfully. \nChannel: ";
              num6 = retVal.Channel;
              strArray[2] = num6.ToString();
              strArray[3] = "\nDate:";
              strArray[4] = retVal.DateAndTime.ToString();
              strArray[5] = "\nValue: ";
              strArray[6] = retVal.Value.ToString();
              MBusCommandWindow.result = string.Concat(strArray);
            }
            else
              MBusCommandWindow.result += "\nNo informational data";
            date = (byte[]) null;
            retVal = (MBusChannelSingleLogValue) null;
          }
          if (EFC.Contains(MBusCommandWindow.CMD_GetRadioList))
          {
            byte[] retVal = await this.myMBusCommands.GetRadioListAsync(this.progress, this.cancelTokenSource.Token);
            if (retVal != null && retVal.Length != 0)
            {
              if (retVal.Length > 1)
                throw new Exception("Not specified in documentation!");
              MBusCommandWindow.result = MBusCommandWindow.result + "\nRadio list identifier read successfully. \nIdentifier: " + retVal[0].ToString();
            }
            else
              MBusCommandWindow.result += "\nNo data received.";
            retVal = (byte[]) null;
          }
          if (EFC.Contains(MBusCommandWindow.CMD_SetRadioList) && !string.IsNullOrEmpty(arg1))
          {
            await this.myMBusCommands.SetRadioListAsync(byte.Parse(arg1), this.progress, this.cancelTokenSource.Token);
            MBusCommandWindow.result += "\nRadio list set.";
          }
          if (EFC.Contains(MBusCommandWindow.CMD_SetTXTimings) && !string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2) && !string.IsNullOrEmpty(arg3) && !string.IsNullOrEmpty(arg4))
          {
            MBusTXTimings values = new MBusTXTimings();
            values.Interval = ushort.Parse(arg1);
            values.NightTimeStart = byte.Parse(arg2);
            values.NightTimeEnd = byte.Parse(arg3);
            values.RadioSuppressionDays = byte.Parse(arg4);
            await this.myMBusCommands.SetTXTimingsAsync(values, this.progress, this.cancelTokenSource.Token);
            MBusCommandWindow.result += "\nTX timings successfully set.";
            values = (MBusTXTimings) null;
          }
          if (EFC.Contains(MBusCommandWindow.CMD_GetTXTimings))
          {
            MBusTXTimings retVal = await this.myMBusCommands.GetTXTimingsAsync(this.progress, this.cancelTokenSource.Token);
            if (retVal != null)
            {
              MBusCommandWindow.result = MBusCommandWindow.result + "\nInterval: " + retVal.Interval.ToString();
              string result1 = MBusCommandWindow.result;
              num6 = retVal.NightTimeStart;
              string str1 = num6.ToString();
              MBusCommandWindow.result = result1 + "\nNighttime Start: " + str1;
              string result2 = MBusCommandWindow.result;
              num6 = retVal.NightTimeEnd;
              string str2 = num6.ToString();
              MBusCommandWindow.result = result2 + "\nNighttime End: " + str2;
              string result3 = MBusCommandWindow.result;
              num6 = retVal.RadioSuppressionDays;
              string str3 = num6.ToString();
              MBusCommandWindow.result = result3 + "\nRadio suppression days: " + str3;
              if (retVal.Reserved != uint.MaxValue)
                MBusCommandWindow.result = MBusCommandWindow.result + "\nReserved: " + Util.ByteArrayToHexString(BitConverter.GetBytes(retVal.Reserved));
            }
            else
              MBusCommandWindow.result += "Timing settings not available ...";
            retVal = (MBusTXTimings) null;
          }
          if (EFC.Contains(MBusCommandWindow.CMD_SetMBusKey) && !string.IsNullOrEmpty(arg1))
          {
            byte[] values = Utility.HexStringToByteArray(arg1);
            await this.myMBusCommands.SetMBusKeyAsync(values, this.progress, this.cancelTokenSource.Token);
            MBusCommandWindow.result += "\nMBusKey successfully set.";
            values = (byte[]) null;
          }
          if (EFC.Contains(MBusCommandWindow.CMD_GetMBusKey))
          {
            byte[] retVal = await this.myMBusCommands.GetMBusKeyAsync(this.progress, this.cancelTokenSource.Token);
            MBusCommandWindow.result = retVal == null ? MBusCommandWindow.result + "MBusKey not available ..." : MBusCommandWindow.result + "\nMBusKey: " + Utility.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
        }
        if (string.IsNullOrEmpty(MBusCommandWindow.result))
        {
          FC = (string) null;
          EFC = (string) null;
          addFC = (object) null;
          arg1 = (string) null;
          arg2 = (string) null;
          arg3 = (string) null;
          arg4 = (string) null;
          arg5 = (string) null;
        }
        else
        {
          this.TextBoxUniversalCommandResult.Text = MBusCommandWindow.result;
          FC = (string) null;
          EFC = (string) null;
          addFC = (object) null;
          arg1 = (string) null;
          arg2 = (string) null;
          arg3 = (string) null;
          arg4 = (string) null;
          arg5 = (string) null;
        }
      }
      catch (Exception ex)
      {
        MBusCommandWindow.result = MBusCommandWindow.result + "\nFunction (" + EFC + ") - FAILED !!!\n --> ERROR: " + ex.Message;
        this.TextBoxUniversalCommandResult.Text = MBusCommandWindow.result;
        FC = (string) null;
        EFC = (string) null;
        addFC = (object) null;
        arg1 = (string) null;
        arg2 = (string) null;
        arg3 = (string) null;
        arg4 = (string) null;
        arg5 = (string) null;
      }
    }

    private void updateContextMenu1(string packet)
    {
      if (!this.Argument1_last_values.Contains(packet))
        this.Argument1_last_values.Add(packet);
      this.Argument1ValuesMenu.Items.Clear();
      if (this.Argument1_last_values.Count > 20)
        this.Argument1_last_values.RemoveRange(0, this.Argument1_last_values.Count - 20);
      foreach (string argument1LastValue in this.Argument1_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument1LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        this.Argument1ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu2(string packet)
    {
      if (!this.Argument2_last_values.Contains(packet))
        this.Argument2_last_values.Add(packet);
      this.Argument2ValuesMenu.Items.Clear();
      if (this.Argument2_last_values.Count > 20)
        this.Argument2_last_values.RemoveRange(0, this.Argument2_last_values.Count - 20);
      foreach (string argument2LastValue in this.Argument2_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument2LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        this.Argument2ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu3(string packet)
    {
      if (!this.Argument3_last_values.Contains(packet))
        this.Argument3_last_values.Add(packet);
      this.Argument3ValuesMenu.Items.Clear();
      if (this.Argument3_last_values.Count > 20)
        this.Argument3_last_values.RemoveRange(0, this.Argument3_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        this.Argument3ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu4(string packet)
    {
      if (!this.Argument4_last_values.Contains(packet))
        this.Argument4_last_values.Add(packet);
      this.Argument4ValuesMenu.Items.Clear();
      if (this.Argument4_last_values.Count > 20)
        this.Argument4_last_values.RemoveRange(0, this.Argument4_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        this.Argument4ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu5(string packet)
    {
      if (!this.Argument5_last_values.Contains(packet))
        this.Argument5_last_values.Add(packet);
      this.Argument5ValuesMenu.Items.Clear();
      if (this.Argument5_last_values.Count > 20)
        this.Argument5_last_values.RemoveRange(0, this.Argument5_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        this.Argument5ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void CheckBoxEncryption_Checked(object sender, RoutedEventArgs e)
    {
      this.myMBusCommands.enDeCrypt = true;
      this.TextBoxEncryptionKey.Visibility = Visibility.Visible;
      this.EncryptionKey_Label.Visibility = Visibility.Visible;
    }

    private void CheckBoxEncryption_UnChecked(object sender, RoutedEventArgs e)
    {
      this.myMBusCommands.enDeCrypt = false;
      this.TextBoxEncryptionKey.Visibility = Visibility.Collapsed;
      this.EncryptionKey_Label.Visibility = Visibility.Collapsed;
    }

    private void TextBoxEncryptionKey_TextChanged(object sender, TextChangedEventArgs e)
    {
      this.myMBusCommands.AES_Key = this.TextBoxEncryptionKey.Text;
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/commandwindowmbus.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.TextBlockStatus = (TextBlock) target;
          break;
        case 2:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        case 3:
          this.TextBoxUniversalCommandResult = (TextBox) target;
          break;
        case 4:
          this.StackPanalButtons = (StackPanel) target;
          break;
        case 5:
          this.ComboCommand = (ComboBox) target;
          this.ComboCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboCommand_SelectionChanged);
          break;
        case 6:
          this.CheckBoxEncryption = (CheckBox) target;
          this.CheckBoxEncryption.Checked += new RoutedEventHandler(this.CheckBoxEncryption_Checked);
          this.CheckBoxEncryption.Unchecked += new RoutedEventHandler(this.CheckBoxEncryption_UnChecked);
          break;
        case 7:
          this.EncryptionKey_Label = (Label) target;
          break;
        case 8:
          this.TextBoxEncryptionKey = (TextBox) target;
          this.TextBoxEncryptionKey.TextChanged += new TextChangedEventHandler(this.TextBoxEncryptionKey_TextChanged);
          break;
        case 9:
          this.ComboExtCommand_Label = (Label) target;
          break;
        case 10:
          this.ComboExtCommand = (ComboBox) target;
          this.ComboExtCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboExtCommand_SelectionChanged);
          break;
        case 11:
          this.ComboAddCommand_Label = (Label) target;
          break;
        case 12:
          this.ComboAddCommand = (ComboBox) target;
          this.ComboAddCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboAddCommand_SelectionChanged);
          break;
        case 13:
          this.TextArgument_1_Label = (Label) target;
          break;
        case 14:
          this.TextExtCommandArgument_1 = (TextBox) target;
          break;
        case 15:
          this.TextArgument_2_Label = (Label) target;
          break;
        case 16:
          this.TextExtCommandArgument_2 = (TextBox) target;
          break;
        case 17:
          this.TextArgument_3_Label = (Label) target;
          break;
        case 18:
          this.TextExtCommandArgument_3 = (TextBox) target;
          break;
        case 19:
          this.TextArgument_4_Label = (Label) target;
          break;
        case 20:
          this.TextExtCommandArgument_4 = (TextBox) target;
          break;
        case 21:
          this.TextArgument_5_Label = (Label) target;
          break;
        case 22:
          this.TextExtCommandArgument_5 = (TextBox) target;
          break;
        case 23:
          this.StackPanalButtons2 = (StackPanel) target;
          break;
        case 24:
          this.ButtonRunCommand = (Button) target;
          this.ButtonRunCommand.Click += new RoutedEventHandler(this.ButtonRunCommand_Click);
          break;
        case 25:
          this.ButtonRunCommandPreview = (Button) target;
          this.ButtonRunCommandPreview.Click += new RoutedEventHandler(this.ButtonRunCommandPreview_Click);
          break;
        case 26:
          this.ButtonBreak = (Button) target;
          this.ButtonBreak.Click += new RoutedEventHandler(this.ButtonBreak_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- MBusEventLog.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MBusEventLog
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public sealed class MBusEventLog : ReturnValue
  {
    public byte FlowControl { get; set; }

    public byte EntryFormat { get; set; }

    public byte SystemEventType { get; set; }

    public byte[] EventTime { get; set; }

    public byte[] Channel0Value { get; set; }

    public byte[] Channel1Value { get; set; }
  }
}


--- MBusSystemLog.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MBusSystemLog
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public sealed class MBusSystemLog : ReturnValue
  {
    public byte FlowControl { get; set; }

    public byte EntryFormat { get; set; }

    public byte SystemEventType { get; set; }

    public byte[] EventTime { get; set; }

    public byte[] Channel0Value { get; set; }

    public byte[] Channel1Value { get; set; }
  }
}


--- MBusTXTimings.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MBusTXTimings
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public sealed class MBusTXTimings : ReturnValue
  {
    public ushort Interval { get; set; }

    public byte NightTimeStart { get; set; }

    public byte NightTimeEnd { get; set; }

    public byte RadioSuppressionDays { get; set; }

    public uint Reserved { get; set; }
  }
}


--- Memory16BitWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.Memory16BitWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class Memory16BitWindow : Window, IComponentConnector
  {
    private bool isRunning;
    private CancellationTokenSource cancelToken;
    private ProgressHandler progress;
    private Common16BitCommands deviceCommands;
    internal Button ButtonReadMemory16bit;
    internal TextBox TextBoxAddress16bit;
    internal TextBox TextBoxCount16bit;
    internal Button ButtonWriteRam16bit;
    internal TextBox TextBoxMaxBytesPerPacket16bit;
    internal Button ButtonWriteFlash16bit;
    internal Button ButtonEraseFlash16bit;
    internal Button ButtonBackup16bit;
    internal ProgressBar ProgressBar1;
    internal TextBlock TextBlockMessage;
    internal Button ButtonStop;
    internal TextBox TextBlockOutput;
    internal Button ButtonReset16bit;
    private bool _contentLoaded;

    public Memory16BitWindow()
    {
      this.InitializeComponent();
      this.isRunning = false;
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.ProgressBar1.Value = obj.ProgressPercentage;
        this.TextBlockMessage.Text = obj.Message;
      }
    }

    private void Window_Closing(object sender, CancelEventArgs e)
    {
      if (this.cancelToken == null)
        return;
      this.cancelToken.Cancel();
    }

    public static void Show(Window owner, Common16BitCommands deviceCommands)
    {
      Memory16BitWindow memory16BitWindow = new Memory16BitWindow();
      memory16BitWindow.deviceCommands = deviceCommands;
      memory16BitWindow.Owner = owner;
      memory16BitWindow.ShowDialog();
    }

    private async void ButtonReadMemory16bit_Click(object sender, RoutedEventArgs e)
    {
      if (this.isRunning)
        return;
      this.isRunning = true;
      this.TextBlockOutput.Text = string.Empty;
      try
      {
        ushort address = Convert.ToUInt16(this.TextBoxAddress16bit.Text, 16);
        uint count = Convert.ToUInt32(this.TextBoxCount16bit.Text);
        byte max = Convert.ToByte(this.TextBoxMaxBytesPerPacket16bit.Text);
        this.cancelToken = new CancellationTokenSource();
        this.progress.Reset();
        byte[] memory = await this.deviceCommands.ReadMemoryAsync(this.progress, this.cancelToken.Token, address, count, max);
        this.TextBlockOutput.Text = Utility.ByteArrayToHexString(memory);
        memory = (byte[]) null;
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Read memory error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      finally
      {
        this.isRunning = false;
      }
    }

    private async void ButtonWriteRam16bit_Click(object sender, RoutedEventArgs e)
    {
      if (this.isRunning)
        return;
      this.isRunning = true;
      try
      {
        ushort address = Convert.ToUInt16(this.TextBoxAddress16bit.Text, 16);
        byte max = Convert.ToByte(this.TextBoxMaxBytesPerPacket16bit.Text);
        byte[] buffer = Utility.HexStringToByteArray(this.TextBlockOutput.Text);
        this.cancelToken = new CancellationTokenSource();
        this.progress.Reset();
        await this.deviceCommands.WriteRAMAsync(this.progress, this.cancelToken.Token, address, buffer, max);
        this.TextBlockOutput.Text = string.Empty;
        buffer = (byte[]) null;
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Write RAM error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      finally
      {
        this.isRunning = false;
      }
    }

    private async void ButtonWriteFlash16bit_Click(object sender, RoutedEventArgs e)
    {
      if (this.isRunning)
        return;
      this.isRunning = true;
      try
      {
        ushort address = Convert.ToUInt16(this.TextBoxAddress16bit.Text, 16);
        byte max = Convert.ToByte(this.TextBoxMaxBytesPerPacket16bit.Text);
        byte[] buffer = Utility.HexStringToByteArray(this.TextBlockOutput.Text);
        this.cancelToken = new CancellationTokenSource();
        this.progress.Reset();
        await this.deviceCommands.WriteFLASHAsync(this.progress, this.cancelToken.Token, address, buffer, max);
        this.TextBlockOutput.Text = string.Empty;
        buffer = (byte[]) null;
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Write FLASH error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      finally
      {
        this.isRunning = false;
      }
    }

    private async void ButtonEraseFlash16bit_Click(object sender, RoutedEventArgs e)
    {
      if (this.isRunning)
        return;
      this.isRunning = true;
      try
      {
        ushort address = Convert.ToUInt16(this.TextBoxAddress16bit.Text, 16);
        this.cancelToken = new CancellationTokenSource();
        this.progress.Reset();
        await this.deviceCommands.EraseFLASHAsync(this.progress, this.cancelToken.Token, address);
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Erase FLASH error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      finally
      {
        this.isRunning = false;
      }
    }

    private async void ButtonBackup16bit_Click(object sender, RoutedEventArgs e)
    {
      if (this.isRunning)
        return;
      this.isRunning = true;
      try
      {
        this.cancelToken = new CancellationTokenSource();
        this.progress.Reset();
        await this.deviceCommands.BackupDeviceAsync(this.progress, this.cancelToken.Token);
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Backup error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      finally
      {
        this.isRunning = false;
      }
    }

    private async void ButtonReset16bit_Click(object sender, RoutedEventArgs e)
    {
      if (this.isRunning)
        return;
      this.isRunning = true;
      try
      {
        this.cancelToken = new CancellationTokenSource();
        this.progress.Reset();
        await this.deviceCommands.ResetDeviceAsync(this.progress, this.cancelToken.Token);
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Reset error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      finally
      {
        this.isRunning = false;
      }
    }

    private void ButtonStop_Click(object sender, RoutedEventArgs e)
    {
      if (this.cancelToken == null)
        return;
      this.cancelToken.Cancel();
      this.isRunning = false;
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/memory16bitwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          ((Window) target).Closing += new CancelEventHandler(this.Window_Closing);
          break;
        case 2:
          this.ButtonReadMemory16bit = (Button) target;
          this.ButtonReadMemory16bit.Click += new RoutedEventHandler(this.ButtonReadMemory16bit_Click);
          break;
        case 3:
          this.TextBoxAddress16bit = (TextBox) target;
          break;
        case 4:
          this.TextBoxCount16bit = (TextBox) target;
          break;
        case 5:
          this.ButtonWriteRam16bit = (Button) target;
          this.ButtonWriteRam16bit.Click += new RoutedEventHandler(this.ButtonWriteRam16bit_Click);
          break;
        case 6:
          this.TextBoxMaxBytesPerPacket16bit = (TextBox) target;
          break;
        case 7:
          this.ButtonWriteFlash16bit = (Button) target;
          this.ButtonWriteFlash16bit.Click += new RoutedEventHandler(this.ButtonWriteFlash16bit_Click);
          break;
        case 8:
          this.ButtonEraseFlash16bit = (Button) target;
          this.ButtonEraseFlash16bit.Click += new RoutedEventHandler(this.ButtonEraseFlash16bit_Click);
          break;
        case 9:
          this.ButtonBackup16bit = (Button) target;
          this.ButtonBackup16bit.Click += new RoutedEventHandler(this.ButtonBackup16bit_Click);
          break;
        case 10:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        case 11:
          this.TextBlockMessage = (TextBlock) target;
          break;
        case 12:
          this.ButtonStop = (Button) target;
          this.ButtonStop.Click += new RoutedEventHandler(this.ButtonStop_Click);
          break;
        case 13:
          this.TextBlockOutput = (TextBox) target;
          break;
        case 14:
          this.ButtonReset16bit = (Button) target;
          this.ButtonReset16bit.Click += new RoutedEventHandler(this.ButtonReset16bit_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- Memory32BitWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.Memory32BitWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class Memory32BitWindow : Window, IComponentConnector
  {
    private bool isRunning;
    private CancellationTokenSource cancelToken;
    private ProgressHandler progress;
    private Common32BitCommands deviceCMD;
    internal TextBox TextBoxAddress16bit;
    internal TextBox TextBoxCount16bit;
    internal TextBox TextBoxMaxBytesPerPacket16bit;
    internal ProgressBar ProgressBar1;
    internal TextBlock TextBlockMessage;
    internal Button ButtonStop;
    internal TextBox TextBlockOutput;
    internal Button ButtonReadMemory;
    internal Button ButtonWriteMemory;
    internal Button ButtonBackup;
    internal Button ButtonReset;
    private bool _contentLoaded;

    public Memory32BitWindow()
    {
      this.InitializeComponent();
      this.isRunning = false;
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.ProgressBar1.Value = obj.ProgressPercentage;
        this.TextBlockMessage.Text = obj.Message;
      }
    }

    private void Window_Closing(object sender, CancelEventArgs e)
    {
      if (this.cancelToken == null)
        return;
      this.cancelToken.Cancel();
    }

    public static void Show(Window owner, Common32BitCommands deviceCMD)
    {
      Memory32BitWindow memory32BitWindow = new Memory32BitWindow();
      memory32BitWindow.deviceCMD = deviceCMD;
      memory32BitWindow.Owner = owner;
      memory32BitWindow.ShowDialog();
    }

    private async void ButtonReadMemory_Click(object sender, RoutedEventArgs e)
    {
      if (this.isRunning)
        return;
      this.isRunning = true;
      this.TextBlockOutput.Text = string.Empty;
      try
      {
        uint address = Convert.ToUInt32(this.TextBoxAddress16bit.Text, 16);
        uint count = Convert.ToUInt32(this.TextBoxCount16bit.Text);
        byte max = Convert.ToByte(this.TextBoxMaxBytesPerPacket16bit.Text);
        this.cancelToken = new CancellationTokenSource();
        this.progress.Reset();
        byte[] memory = await this.deviceCMD.ReadMemoryAsync(this.progress, this.cancelToken.Token, address, count, max);
        this.TextBlockOutput.Text = Utility.ByteArrayToHexString(memory);
        memory = (byte[]) null;
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Read memory error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      finally
      {
        this.isRunning = false;
      }
    }

    private async void ButtonWriteMemory_Click(object sender, RoutedEventArgs e)
    {
      if (this.isRunning)
        return;
      this.isRunning = true;
      try
      {
        uint address = Convert.ToUInt32(this.TextBoxAddress16bit.Text, 16);
        byte max = Convert.ToByte(this.TextBoxMaxBytesPerPacket16bit.Text);
        byte[] buffer = Utility.HexStringToByteArray(this.TextBlockOutput.Text);
        this.cancelToken = new CancellationTokenSource();
        this.progress.Reset();
        await this.deviceCMD.WriteMemoryAsync(this.progress, this.cancelToken.Token, address, buffer, max);
        this.TextBlockOutput.Text = string.Empty;
        buffer = (byte[]) null;
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Write Memory error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      finally
      {
        this.isRunning = false;
      }
    }

    private async void ButtonBackup_Click(object sender, RoutedEventArgs e)
    {
      if (this.isRunning)
        return;
      this.isRunning = true;
      try
      {
        this.cancelToken = new CancellationTokenSource();
        this.progress.Reset();
        await this.deviceCMD.BackupDeviceAsync(this.progress, this.cancelToken.Token);
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Backup error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      finally
      {
        this.isRunning = false;
      }
    }

    private async void ButtonReset_Click(object sender, RoutedEventArgs e)
    {
      if (this.isRunning)
        return;
      this.isRunning = true;
      try
      {
        this.cancelToken = new CancellationTokenSource();
        this.progress.Reset();
        await this.deviceCMD.ResetDeviceAsync(this.progress, this.cancelToken.Token);
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Reset error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      finally
      {
        this.isRunning = false;
      }
    }

    private void ButtonStop_Click(object sender, RoutedEventArgs e)
    {
      if (this.cancelToken == null)
        return;
      this.cancelToken.Cancel();
      this.isRunning = false;
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/memory32bitwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          ((Window) target).Closing += new CancelEventHandler(this.Window_Closing);
          break;
        case 2:
          this.TextBoxAddress16bit = (TextBox) target;
          break;
        case 3:
          this.TextBoxCount16bit = (TextBox) target;
          break;
        case 4:
          this.TextBoxMaxBytesPerPacket16bit = (TextBox) target;
          break;
        case 5:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        case 6:
          this.TextBlockMessage = (TextBlock) target;
          break;
        case 7:
          this.ButtonStop = (Button) target;
          this.ButtonStop.Click += new RoutedEventHandler(this.ButtonStop_Click);
          break;
        case 8:
          this.TextBlockOutput = (TextBox) target;
          break;
        case 9:
          this.ButtonReadMemory = (Button) target;
          this.ButtonReadMemory.Click += new RoutedEventHandler(this.ButtonReadMemory_Click);
          break;
        case 10:
          this.ButtonWriteMemory = (Button) target;
          this.ButtonWriteMemory.Click += new RoutedEventHandler(this.ButtonWriteMemory_Click);
          break;
        case 11:
          this.ButtonBackup = (Button) target;
          this.ButtonBackup.Click += new RoutedEventHandler(this.ButtonBackup_Click);
          break;
        case 12:
          this.ButtonReset = (Button) target;
          this.ButtonReset.Click += new RoutedEventHandler(this.ButtonReset_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- memoryRow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.memoryRow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class memoryRow : INotifyPropertyChanged
  {
    public bool overWriteValuesOnly = false;
    private string Byte_0;
    private string Byte_1;
    private string Byte_2;
    private string Byte_3;
    private string Byte_4;
    private string Byte_5;
    private string Byte_6;
    private string Byte_7;
    private string Byte_8;
    private string Byte_9;
    private string Byte_10;
    private string Byte_11;
    private string Byte_12;
    private string Byte_13;
    private string Byte_14;
    private string Byte_15;
    public bool[] dataChanged = new bool[16];
    private byte[] byteArray;
    private byte[] oldArray;

    public string Address { get; set; }

    public uint address { get; set; }

    public bool resetArray()
    {
      if (this.oldArray.Length == 0)
        return false;
      Array.Copy((Array) this.oldArray, (Array) this.byteArray, this.oldArray.Length);
      return true;
    }

    public event PropertyChangedEventHandler PropertyChanged;

    private void NotifyPropertyChanged([CallerMemberName] string propertyName = "")
    {
      if (this.PropertyChanged == null)
        return;
      this.PropertyChanged((object) this, new PropertyChangedEventArgs(propertyName));
    }

    public bool dataChanged_Byte_0
    {
      get => this.dataChanged[0];
      set
      {
        if (this.overWriteValuesOnly)
          return;
        this.dataChanged[0] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_0));
      }
    }

    public bool dataChanged_Byte_1
    {
      get => this.dataChanged[1];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[1] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_1));
      }
    }

    public bool dataChanged_Byte_2
    {
      get => this.dataChanged[2];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[2] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_2));
      }
    }

    public bool dataChanged_Byte_3
    {
      get => this.dataChanged[3];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[3] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_3));
      }
    }

    public bool dataChanged_Byte_4
    {
      get => this.dataChanged[4];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[4] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_4));
      }
    }

    public bool dataChanged_Byte_5
    {
      get => this.dataChanged[5];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[5] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_5));
      }
    }

    public bool dataChanged_Byte_6
    {
      get => this.dataChanged[6];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[6] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_6));
      }
    }

    public bool dataChanged_Byte_7
    {
      get => this.dataChanged[7];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[7] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_7));
      }
    }

    public bool dataChanged_Byte_8
    {
      get => this.dataChanged[8];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[8] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_8));
      }
    }

    public bool dataChanged_Byte_9
    {
      get => this.dataChanged[9];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[9] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_9));
      }
    }

    public bool dataChanged_Byte_10
    {
      get => this.dataChanged[10];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[10] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_10));
      }
    }

    public bool dataChanged_Byte_11
    {
      get => this.dataChanged[11];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[11] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_11));
      }
    }

    public bool dataChanged_Byte_12
    {
      get => this.dataChanged[12];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[12] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_12));
      }
    }

    public bool dataChanged_Byte_13
    {
      get => this.dataChanged[13];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[13] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_13));
      }
    }

    public bool dataChanged_Byte_14
    {
      get => this.dataChanged[14];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[14] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_14));
      }
    }

    public bool dataChanged_Byte_15
    {
      get => this.dataChanged[15];
      set
      {
        if (!this.overWriteValuesOnly)
          this.dataChanged[15] = value;
        this.NotifyPropertyChanged(nameof (dataChanged_Byte_15));
      }
    }

    public string byte_0
    {
      get => this.Byte_0;
      set
      {
        this.dataChanged_Byte_0 = !(this.Byte_0 == value);
        this.Byte_0 = value;
      }
    }

    public string byte_1
    {
      get => this.Byte_1;
      set
      {
        this.dataChanged_Byte_1 = !(this.Byte_1 == value);
        this.Byte_1 = value;
      }
    }

    public string byte_2
    {
      get => this.Byte_2;
      set
      {
        this.dataChanged_Byte_2 = !(this.Byte_2 == value);
        this.Byte_2 = value;
      }
    }

    public string byte_3
    {
      get => this.Byte_3;
      set
      {
        this.dataChanged_Byte_3 = !(this.Byte_3 == value);
        this.Byte_3 = value;
      }
    }

    public string byte_4
    {
      get => this.Byte_4;
      set
      {
        this.dataChanged_Byte_4 = !(this.Byte_4 == value);
        this.Byte_4 = value;
      }
    }

    public string byte_5
    {
      get => this.Byte_5;
      set
      {
        this.dataChanged_Byte_5 = !(this.Byte_5 == value);
        this.Byte_5 = value;
      }
    }

    public string byte_6
    {
      get => this.Byte_6;
      set
      {
        this.dataChanged_Byte_6 = !(this.Byte_6 == value);
        this.Byte_6 = value;
      }
    }

    public string byte_7
    {
      get => this.Byte_7;
      set
      {
        this.dataChanged_Byte_7 = !(this.Byte_7 == value);
        this.Byte_7 = value;
      }
    }

    public string byte_8
    {
      get => this.Byte_8;
      set
      {
        this.dataChanged_Byte_8 = !(this.Byte_8 == value);
        this.Byte_8 = value;
      }
    }

    public string byte_9
    {
      get => this.Byte_9;
      set
      {
        this.dataChanged_Byte_9 = !(this.Byte_9 == value);
        this.Byte_9 = value;
      }
    }

    public string byte_10
    {
      get => this.Byte_10;
      set
      {
        this.dataChanged_Byte_10 = !(this.Byte_10 == value);
        this.Byte_10 = value;
      }
    }

    public string byte_11
    {
      get => this.Byte_11;
      set
      {
        this.dataChanged_Byte_11 = !(this.Byte_11 == value);
        this.Byte_11 = value;
      }
    }

    public string byte_12
    {
      get => this.Byte_12;
      set
      {
        this.dataChanged_Byte_12 = !(this.Byte_12 == value);
        this.Byte_12 = value;
      }
    }

    public string byte_13
    {
      get => this.Byte_13;
      set
      {
        this.dataChanged_Byte_13 = !(this.Byte_13 == value);
        this.Byte_13 = value;
      }
    }

    public string byte_14
    {
      get => this.Byte_14;
      set
      {
        this.dataChanged_Byte_14 = !(this.Byte_14 == value);
        this.Byte_14 = value;
      }
    }

    public string byte_15
    {
      get => this.Byte_15;
      set
      {
        this.dataChanged_Byte_15 = !(this.Byte_15 == value);
        this.Byte_15 = value;
      }
    }

    public string data { get; set; }

    public bool IsChanged { get; set; }

    public uint row { get; set; }

    public void ClearDataChanged()
    {
      this.dataChanged_Byte_0 = false;
      this.dataChanged_Byte_1 = false;
      this.dataChanged_Byte_2 = false;
      this.dataChanged_Byte_3 = false;
      this.dataChanged_Byte_4 = false;
      this.dataChanged_Byte_5 = false;
      this.dataChanged_Byte_6 = false;
      this.dataChanged_Byte_7 = false;
      this.dataChanged_Byte_8 = false;
      this.dataChanged_Byte_9 = false;
      this.dataChanged_Byte_10 = false;
      this.dataChanged_Byte_11 = false;
      this.dataChanged_Byte_12 = false;
      this.dataChanged_Byte_13 = false;
      this.dataChanged_Byte_14 = false;
      this.dataChanged_Byte_15 = false;
    }

    public byte[] ByteArray
    {
      get
      {
        return new byte[16]
        {
          Convert.ToByte(this.byte_0, 16),
          Convert.ToByte(this.byte_1, 16),
          Convert.ToByte(this.byte_2, 16),
          Convert.ToByte(this.byte_3, 16),
          Convert.ToByte(this.byte_4, 16),
          Convert.ToByte(this.byte_5, 16),
          Convert.ToByte(this.byte_6, 16),
          Convert.ToByte(this.byte_7, 16),
          Convert.ToByte(this.byte_8, 16),
          Convert.ToByte(this.byte_9, 16),
          Convert.ToByte(this.byte_10, 16),
          Convert.ToByte(this.byte_11, 16),
          Convert.ToByte(this.byte_12, 16),
          Convert.ToByte(this.byte_13, 16),
          Convert.ToByte(this.byte_14, 16),
          Convert.ToByte(this.byte_15, 16)
        };
      }
      set
      {
        this.oldArray = this.byteArray;
        Array.Copy((Array) this.byteArray, (Array) this.oldArray, this.byteArray.Length);
        this.byteArray = value;
        if (value.Length != 16)
          return;
        string hexString = Util.ByteArrayToHexString(this.byteArray, 0);
        this.byte_0 = hexString.Substring(0, 2);
        this.byte_1 = hexString.Substring(2, 2);
        this.byte_2 = hexString.Substring(4, 2);
        this.byte_3 = hexString.Substring(6, 2);
        this.byte_4 = hexString.Substring(8, 2);
        this.byte_5 = hexString.Substring(10, 2);
        this.byte_6 = hexString.Substring(12, 2);
        this.byte_7 = hexString.Substring(14, 2);
        this.byte_8 = hexString.Substring(16, 2);
        this.byte_9 = hexString.Substring(18, 2);
        this.byte_10 = hexString.Substring(20, 2);
        this.byte_11 = hexString.Substring(22, 2);
        this.byte_12 = hexString.Substring(24, 2);
        this.byte_13 = hexString.Substring(26, 2);
        this.byte_14 = hexString.Substring(28, 2);
        this.byte_15 = hexString.Substring(30, 2);
      }
    }
  }
}


--- MemoryViewer.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MemoryViewer
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using Microsoft.Win32;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Input;
using System.Windows.Markup;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class MemoryViewer : Window, IComponentConnector
  {
    private DeviceMemory localDeviceMemory;
    private DeviceMemory localBackUpDeviceMemory;
    private BaseMemoryAccess memoryAccess;
    private CancellationTokenSource cancelTokenSource;
    private ProgressHandler progress;
    private ObservableCollection<memoryRow> localItems;
    private SortedList<uint, memoryRow> localItems_ALL;
    private string[] ba_actual;
    private uint actualStartAddress;
    private uint actualBytesToRead;
    private bool isDirty;
    private uint maxBytesAtOnce = 1024;
    internal GmmCorporateControl gmmCorporateControl1;
    internal DataGrid DataGridMemoryArray;
    internal Grid DataGridSettings;
    internal ProgressBar ProgressBar1;
    internal Label LabelProgress1;
    internal TextBox TextBoxAddressDevice;
    internal TextBox TextBoxSizeDevice;
    internal Button ButtonReadDataFromDevice;
    internal Button ButtonWriteDataToDevice;
    internal Button ButtonCopyValues;
    internal Button ButtonLoadDeviceMemory;
    internal Button ButtonUpdateDataGrid;
    internal Button ButtonPrev;
    internal Button ButtonNext;
    internal ComboBox ComboBoxAddress;
    internal TextBox TextBoxAddressMemory;
    internal Button ButtonGotoAddress;
    internal Button ButtonCancel;
    internal Button ButtonSaveDeviceMemoryToFile;
    internal TextBox TextBoxStopwatch;
    internal CheckBox CheckBoxShowHex;
    internal TextBox TextBoxSizeMemory;
    private bool _contentLoaded;

    public MemoryViewer(DeviceMemory meterMemory, BaseMemoryAccess memoryAccess)
    {
      this.InitializeComponent();
      this.memoryAccess = memoryAccess;
      this.localDeviceMemory = meterMemory;
      this.localBackUpDeviceMemory = new DeviceMemory(meterMemory);
      this.localItems = new ObservableCollection<memoryRow>();
      this.localItems_ALL = new SortedList<uint, memoryRow>();
      this.cancelTokenSource = new CancellationTokenSource();
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
      this.DataContext = (object) this;
      this.actualStartAddress = 2147483648U;
      this.actualBytesToRead = 256U;
      List<DeviceMemoryStorage> list = meterMemory.MemoryBlockList.Values.OrderByDescending<DeviceMemoryStorage, uint>((Func<DeviceMemoryStorage, uint>) (kp => kp.StartAddress)).ToList<DeviceMemoryStorage>();
      bool flag = true;
      foreach (DeviceMemoryStorage newItem in list)
      {
        if (flag)
        {
          this.actualStartAddress = newItem.StartAddress;
          flag = false;
        }
        this.ComboBoxAddress.Items.Add((object) newItem);
      }
      if (WindowsIdentity.GetCurrent().Name.Contains("StollMa"))
      {
        this.ButtonLoadDeviceMemory.Visibility = Visibility.Visible;
        this.ButtonSaveDeviceMemoryToFile.Visibility = Visibility.Visible;
        this.TextBoxStopwatch.Visibility = Visibility.Visible;
      }
      else
      {
        this.ButtonLoadDeviceMemory.Visibility = Visibility.Hidden;
        this.ButtonSaveDeviceMemoryToFile.Visibility = Visibility.Hidden;
        this.TextBoxStopwatch.Visibility = Visibility.Hidden;
      }
      this.CheckBoxShowHex.IsChecked = new bool?(true);
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.ProgressBar1.Value = obj.ProgressPercentage;
        this.LabelProgress1.Content = (object) obj.Message;
      }
    }

    private void Window_Loaded(object sender, RoutedEventArgs e) => this.setTextToAddressFields();

    private void setTextToAddressFields()
    {
      this.TextBoxAddressMemory.Text = !this.TextBoxAddressMemory.Text.Contains("0x") ? this.actualStartAddress.ToString("D") : "0x" + this.actualStartAddress.ToString("x8");
      if (this.TextBoxSizeMemory.Text.Contains("0x"))
        this.TextBoxSizeMemory.Text = "0x" + this.actualBytesToRead.ToString("x4");
      else
        this.TextBoxSizeMemory.Text = this.actualBytesToRead.ToString("D");
    }

    private void setActualAddresses(int step = 0, bool isReadFromDevice = false)
    {
      uint result1 = 0;
      uint result2 = this.actualBytesToRead;
      if (this.TextBoxAddressMemory.Text.Length > 2 && this.TextBoxAddressMemory.Text.Substring(0, 2).Equals("0x"))
        uint.TryParse(this.TextBoxAddressMemory.Text.Substring(2), NumberStyles.HexNumber, (IFormatProvider) null, out result1);
      else
        uint.TryParse(this.TextBoxAddressMemory.Text, out result1);
      if (this.TextBoxSizeMemory.Text.Length > 2 && this.TextBoxSizeMemory.Text.Substring(0, 2).Equals("0x"))
        uint.TryParse(this.TextBoxSizeMemory.Text.Substring(2), NumberStyles.HexNumber, (IFormatProvider) null, out result2);
      else
        uint.TryParse(this.TextBoxSizeMemory.Text, out result2);
      if (isReadFromDevice)
      {
        if (this.TextBoxAddressDevice.Text.Length > 2 && this.TextBoxAddressDevice.Text.Substring(0, 2).Equals("0x"))
          uint.TryParse(this.TextBoxAddressDevice.Text.Substring(2), NumberStyles.HexNumber, (IFormatProvider) null, out result1);
        else
          uint.TryParse(this.TextBoxAddressDevice.Text, out result1);
        if (this.TextBoxSizeDevice.Text.Length > 2 && this.TextBoxSizeDevice.Text.Substring(0, 2).Equals("0x"))
          uint.TryParse(this.TextBoxSizeDevice.Text.Substring(2), NumberStyles.HexNumber, (IFormatProvider) null, out result2);
        else
          uint.TryParse(this.TextBoxSizeDevice.Text, out result2);
      }
      this.actualStartAddress = (uint) ((ulong) result1 + (ulong) step);
      this.actualBytesToRead = result2;
    }

    private void copyLocalDataToOLD(ObservableCollection<memoryRow> oldMemRows)
    {
      foreach (memoryRow oldMemRow in (Collection<memoryRow>) oldMemRows)
      {
        if (this.localItems_ALL.ContainsKey(oldMemRow.address))
          this.localItems_ALL[oldMemRow.address] = oldMemRow;
        else
          this.localItems_ALL.Add(oldMemRow.address, oldMemRow);
      }
    }

    private void updateDataGrid(bool isNewData = false)
    {
      this.DataGridMemoryArray.ItemsSource = (IEnumerable) null;
      this.copyLocalDataToOLD(this.localItems);
      this.localItems.Clear();
      Stopwatch stopwatch = new Stopwatch();
      stopwatch.Start();
      int newParts = (int) this.actualBytesToRead / 16 + 1;
      uint actualStartAddress = this.actualStartAddress;
      uint length = this.actualBytesToRead > this.maxBytesAtOnce ? this.maxBytesAtOnce : this.actualBytesToRead;
      int num = (int) Math.Ceiling((double) this.actualBytesToRead / (double) length);
      this.ba_actual = new string[(long) length * (long) num];
      string[] strArray1 = new string[(long) length * (long) num];
      for (int index1 = 0; index1 < num; ++index1)
      {
        try
        {
          Array.Copy((Array) this.localDeviceMemory.GetDataAsHexStrings((uint) ((ulong) actualStartAddress + (ulong) index1 * (ulong) length), length), 0L, (Array) this.ba_actual, (long) index1 * (long) length, (long) length);
        }
        catch (Exception ex)
        {
          string[] strArray2 = new string[(int) length];
          for (int index2 = 0; (long) index2 < (long) length; ++index2)
            strArray2[index2] = "??";
        }
      }
      this.progress.Reset(newParts);
      do
      {
        for (int index = 0; index < newParts; ++index)
        {
          string[] strArray3 = new string[16];
          string[] strArray4 = new string[16];
          Array.Copy((Array) this.ba_actual, index * 16, (Array) strArray3, 0, this.ba_actual.Length - index * 16 < 16 ? this.ba_actual.Length - index * 16 : 16);
          memoryRow memoryRow = (memoryRow) null;
          if (this.localItems_ALL.ContainsKey(actualStartAddress))
            memoryRow = this.localItems_ALL[actualStartAddress];
          if (memoryRow == null)
          {
            memoryRow = new memoryRow();
            memoryRow.address = actualStartAddress;
            bool? isChecked = this.CheckBoxShowHex.IsChecked;
            bool flag = true;
            memoryRow.Address = !(isChecked.GetValueOrDefault() == flag & isChecked.HasValue) ? actualStartAddress.ToString() : actualStartAddress.ToString("x8");
            memoryRow.overWriteValuesOnly = false;
            memoryRow.byte_0 = strArray3[0];
            memoryRow.byte_1 = strArray3[1];
            memoryRow.byte_2 = strArray3[2];
            memoryRow.byte_3 = strArray3[3];
            memoryRow.byte_4 = strArray3[4];
            memoryRow.byte_5 = strArray3[5];
            memoryRow.byte_6 = strArray3[6];
            memoryRow.byte_7 = strArray3[7];
            memoryRow.byte_8 = strArray3[8];
            memoryRow.byte_9 = strArray3[9];
            memoryRow.byte_10 = strArray3[10];
            memoryRow.byte_11 = strArray3[11];
            memoryRow.byte_12 = strArray3[12];
            memoryRow.byte_13 = strArray3[13];
            memoryRow.byte_14 = strArray3[14];
            memoryRow.byte_15 = strArray3[15];
            memoryRow.IsChanged = false;
            memoryRow.ClearDataChanged();
          }
          else
          {
            memoryRow.overWriteValuesOnly = true;
            memoryRow.byte_0 = strArray3[0];
            memoryRow.byte_1 = strArray3[1];
            memoryRow.byte_2 = strArray3[2];
            memoryRow.byte_3 = strArray3[3];
            memoryRow.byte_4 = strArray3[4];
            memoryRow.byte_5 = strArray3[5];
            memoryRow.byte_6 = strArray3[6];
            memoryRow.byte_7 = strArray3[7];
            memoryRow.byte_8 = strArray3[8];
            memoryRow.byte_9 = strArray3[9];
            memoryRow.byte_10 = strArray3[10];
            memoryRow.byte_11 = strArray3[11];
            memoryRow.byte_12 = strArray3[12];
            memoryRow.byte_13 = strArray3[13];
            memoryRow.byte_14 = strArray3[14];
            memoryRow.byte_15 = strArray3[15];
            memoryRow.overWriteValuesOnly = false;
            if (isNewData)
            {
              memoryRow.IsChanged = false;
              memoryRow.ClearDataChanged();
            }
          }
          memoryRow.row = (uint) index;
          memoryRow.data = this.getReadAbleDataString(strArray3);
          this.localItems.Add(memoryRow);
          this.progress.Report("reading ... " + memoryRow.Address);
          actualStartAddress += 16U;
        }
      }
      while (false);
      stopwatch.Stop();
      this.TextBoxStopwatch.Text = stopwatch.ElapsedMilliseconds.ToString() + " ms.";
      this.DataGridMemoryArray.ItemsSource = (IEnumerable) this.localItems;
      this.progress.Report(" reading done! ");
    }

    private string getReadAbleDataString(byte[] bascii)
    {
      string readAbleDataString = string.Empty;
      foreach (byte num in bascii)
        readAbleDataString = num < (byte) 32 || num == (byte) 85 ? readAbleDataString + "." : readAbleDataString + ((char) num).ToString();
      return readAbleDataString;
    }

    private string getReadAbleDataString(string[] asciiViews)
    {
      StringBuilder stringBuilder = new StringBuilder();
      foreach (string asciiView in asciiViews)
      {
        int result;
        if (!int.TryParse(asciiView, NumberStyles.HexNumber, (IFormatProvider) null, out result))
          stringBuilder.Append('.');
        else if (char.IsLetterOrDigit((char) result))
          stringBuilder.Append((char) result);
        else
          stringBuilder.Append('.');
      }
      return stringBuilder.ToString();
    }

    private void ButtonReadDataFromDevice_Click(object sender, RoutedEventArgs e)
    {
      this.setActualAddresses(isReadFromDevice: true);
      this.readDataFromDevice();
    }

    private void ButtonWriteDataToDevice_Click(object sender, RoutedEventArgs e)
    {
      this.writeDataToDevice();
    }

    private void ButonUpdateGRID_Click(object sender, RoutedEventArgs e) => this.updateDataGrid();

    private void ButtonPrev_Memory_Click(object sender, RoutedEventArgs e)
    {
      this.setActualAddresses((int) this.actualBytesToRead * -1);
      this.setTextToAddressFields();
      this.updateDataGrid();
    }

    private void ButtonNext_Memory_Click(object sender, RoutedEventArgs e)
    {
      this.setActualAddresses((int) this.actualBytesToRead);
      this.setTextToAddressFields();
      this.updateDataGrid();
    }

    private void ButtonLoadDeviceMemory_Click(object sender, RoutedEventArgs e)
    {
      this.loadDeviceMemFromFile();
    }

    private void ButtonSaveDeviceMemoryToFile_Click(object sender, RoutedEventArgs e)
    {
      this.writeMemoryDataToFile();
    }

    private void writeMemoryDataToFile()
    {
      byte[] compressedData = this.localDeviceMemory.GetCompressedData();
      File.WriteAllBytes("U:\\Device_" + this.localDeviceMemory.FirmwareVersion.ToString() + ".device", compressedData);
    }

    private async void writeDataToDevice()
    {
      try
      {
        uint writeStartAddress = 0;
        uint writeEndAddress = 0;
        foreach (memoryRow mr in (IEnumerable<memoryRow>) this.localItems_ALL.Values)
        {
          for (int i = 0; i < mr.dataChanged.Length; ++i)
          {
            if (mr.dataChanged[i])
            {
              writeStartAddress = writeStartAddress == 0U ? (uint) ((ulong) mr.address + (ulong) i) : writeStartAddress;
              writeEndAddress = writeEndAddress < (uint) ((ulong) mr.address + (ulong) i) ? (uint) ((ulong) mr.address + (ulong) i) : writeEndAddress;
              if (writeStartAddress >= 0U && writeEndAddress > 0U)
              {
                AddressRange aRange = new AddressRange(writeStartAddress, writeEndAddress + 1U - writeStartAddress);
                this.localDeviceMemory.GarantMemoryAvailable(aRange);
                await this.memoryAccess.WriteMemoryAsync(aRange, this.localDeviceMemory, this.progress, this.cancelTokenSource.Token);
                writeStartAddress = 0U;
                writeEndAddress = 0U;
                mr.dataChanged[i] = false;
                aRange = (AddressRange) null;
              }
            }
          }
          mr.ClearDataChanged();
          mr.IsChanged = false;
        }
        this.isDirty = false;
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show("Error occoured: \n\n" + ex.Message);
      }
    }

    private async void readDataFromDevice()
    {
      this.progress.Reset();
      if (this.isDirty && MessageBoxResult.No == MessageBox.Show("There are changes,reading from device will maybe overwrite them.\nDo you want to continue without saving the changes?", "SAVE Changes?", MessageBoxButton.YesNo))
        return;
      try
      {
        AddressRange readRange = new AddressRange(this.actualStartAddress, this.actualBytesToRead);
        this.localDeviceMemory.GarantMemoryAvailable(readRange);
        await this.memoryAccess.ReadMemoryAsync(readRange, this.localDeviceMemory, this.progress, this.cancelTokenSource.Token);
        readRange = (AddressRange) null;
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show("Error occoured: \n\n" + ex.Message);
      }
      this.localBackUpDeviceMemory = (DeviceMemory) null;
      this.localBackUpDeviceMemory = new DeviceMemory(this.localDeviceMemory);
      this.updateDataGrid(true);
    }

    private void ButtonGoto_Memory_Address_Click(object sender, RoutedEventArgs e)
    {
      this.setActualAddresses();
      this.updateDataGrid();
    }

    private void DataGrid_CellEditEnding(object sender, DataGridCellEditEndingEventArgs e)
    {
      string text = (e.EditingElement as TextBox).Text;
      string str = e.Column.Header.ToString();
      memoryRow memoryRow = e.Row.Item as memoryRow;
      try
      {
        int int32 = Convert.ToInt32(str);
        string name = "byte_" + int32.ToString();
        PropertyInfo property = memoryRow.GetType().GetProperty(name);
        if ((PropertyInfo) null != property && property.CanWrite)
        {
          byte[] numArray = new byte[1];
          byte[] byteArray = ZR_ClassLibrary.Util.HexStringToByteArray(text);
          property.SetValue((object) memoryRow, (object) text, (object[]) null);
          uint num = memoryRow.address + (uint) int32;
          this.localDeviceMemory.GarantMemoryAvailable(new AddressRange(num, (uint) byteArray.Length));
          this.localDeviceMemory.SetData(num, byteArray);
          memoryRow.IsChanged = true;
          this.isDirty = true;
        }
        this.updateDataGrid();
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show("There is an error in byte arra.\n" + ex.Message);
      }
    }

    private void ButtonCancel_Click(object sender, RoutedEventArgs e)
    {
      if (this.isDirty)
      {
        if (MessageBox.Show("There are changes that are not written to a device.\nDo you really want to quit and discard the changes?", "Changes pending ...", MessageBoxButton.YesNo, MessageBoxImage.Exclamation, MessageBoxResult.No) != MessageBoxResult.Yes)
          return;
        this.isDirty = false;
        this.Close();
      }
      else
        this.Close();
    }

    private void Window_Closed(object sender, CancelEventArgs e)
    {
      if (!this.isDirty)
        return;
      if (MessageBox.Show("There are changes that are not written to a device.\nDo you really want to quit and discard the changes?", "Changes pending ...", MessageBoxButton.YesNo, MessageBoxImage.Exclamation, MessageBoxResult.No) == MessageBoxResult.Yes)
      {
        this.isDirty = false;
        e.Cancel = false;
      }
      else
        e.Cancel = true;
    }

    private void TextBoxes_KeyDown(object sender, KeyEventArgs e)
    {
      if (e.Key == Key.Return)
        this.ButtonGoto_Memory_Address_Click((object) null, (RoutedEventArgs) null);
      int num;
      if (e.Key != Key.D0 && e.Key != Key.D1 && e.Key != Key.D2 && e.Key != Key.D3 && e.Key != Key.D4 && e.Key != Key.D5 && e.Key != Key.D6 && e.Key != Key.D7 && e.Key != Key.D8 && e.Key != Key.D9)
      {
        bool? isChecked = this.CheckBoxShowHex.IsChecked;
        bool flag = true;
        num = !(isChecked.GetValueOrDefault() == flag & isChecked.HasValue) ? 0 : (e.Key != Key.X || e.Key != Key.A || e.Key != Key.B || e.Key != Key.C || e.Key != Key.D || e.Key != Key.E ? 1 : (e.Key != Key.F ? 1 : 0));
      }
      else
        num = 0;
      if (num == 0)
        ;
    }

    private void TextBoxes_GotFocus(object sender, RoutedEventArgs e)
    {
      ((TextBoxBase) sender).SelectAll();
    }

    private void ButtonSetValuesFromMemory_Click(object sender, RoutedEventArgs e)
    {
      this.TextBoxAddressDevice.Text = this.TextBoxAddressMemory.Text;
      this.TextBoxSizeDevice.Text = this.TextBoxSizeMemory.Text;
    }

    private void TextBoxes_LostFocus(object sender, RoutedEventArgs e) => this.setActualAddresses();

    private void CheckBoxShowHex_Click(object sender, RoutedEventArgs e)
    {
      this.setTextToAddressFields();
    }

    private void DataGridMemoryArray_KeyUp(object sender, KeyEventArgs e)
    {
    }

    private void DataGridMemoryArray_KeyDown(object sender, KeyEventArgs e)
    {
      if (this.isAnAllowedKey(e.Key))
        return;
      e.Handled = true;
    }

    private bool isAnAllowedKey(Key pressedOne)
    {
      return new List<Key>()
      {
        Key.D0,
        Key.D1,
        Key.D2,
        Key.D3,
        Key.D4,
        Key.D5,
        Key.D6,
        Key.D7,
        Key.D8,
        Key.D9,
        Key.A,
        Key.B,
        Key.C,
        Key.D,
        Key.E,
        Key.F,
        Key.Tab,
        Key.Back,
        Key.Up,
        Key.Down,
        Key.Left,
        Key.Right,
        Key.NumPad0,
        Key.NumPad1,
        Key.NumPad2,
        Key.NumPad3,
        Key.NumPad4,
        Key.NumPad5,
        Key.NumPad6,
        Key.NumPad7,
        Key.NumPad8,
        Key.NumPad9
      }.Contains<Key>(pressedOne);
    }

    private void DataGridMemoryArray_CurrentCellChanged(object sender, EventArgs e)
    {
    }

    private void ComboBoxAddress_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      DeviceMemoryStorage selectedItem = (DeviceMemoryStorage) this.ComboBoxAddress.SelectedItem;
      this.TextBoxAddressMemory.Text = "0x" + selectedItem.StartAddress.ToString("X8");
      this.TextBoxSizeMemory.Text = "0x" + selectedItem.ByteSize.ToString("X4");
      this.setActualAddresses();
      this.updateDataGrid();
    }

    private void loadDeviceMemFromFile()
    {
      this.progress.Reset(6);
      OpenFileDialog openFileDialog = new OpenFileDialog();
      openFileDialog.FileName = "";
      openFileDialog.DefaultExt = ".device";
      openFileDialog.Filter = "DeviceMeter image (.device)|*.device";
      bool? nullable1 = openFileDialog.ShowDialog();
      this.progress.Report();
      bool? nullable2 = nullable1;
      bool flag = true;
      if (nullable2.GetValueOrDefault() == flag & nullable2.HasValue)
      {
        this.progress.Report();
        string fileName = openFileDialog.FileName;
        this.progress.Report();
        byte[] compressedData = File.ReadAllBytes(fileName);
        this.progress.Report();
        this.localDeviceMemory = new DeviceMemory(compressedData);
        this.localBackUpDeviceMemory = new DeviceMemory(compressedData);
        this.progress.Report();
        this.updateDataGrid(true);
      }
      this.progress.Report();
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/memoryviewer.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          ((FrameworkElement) target).Loaded += new RoutedEventHandler(this.Window_Loaded);
          ((Window) target).Closing += new CancelEventHandler(this.Window_Closed);
          break;
        case 2:
          this.gmmCorporateControl1 = (GmmCorporateControl) target;
          break;
        case 3:
          this.DataGridMemoryArray = (DataGrid) target;
          this.DataGridMemoryArray.CellEditEnding += new EventHandler<DataGridCellEditEndingEventArgs>(this.DataGrid_CellEditEnding);
          this.DataGridMemoryArray.CurrentCellChanged += new EventHandler<EventArgs>(this.DataGridMemoryArray_CurrentCellChanged);
          break;
        case 4:
          this.DataGridSettings = (Grid) target;
          break;
        case 5:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        case 6:
          this.LabelProgress1 = (Label) target;
          break;
        case 7:
          this.TextBoxAddressDevice = (TextBox) target;
          this.TextBoxAddressDevice.KeyDown += new KeyEventHandler(this.TextBoxes_KeyDown);
          this.TextBoxAddressDevice.LostFocus += new RoutedEventHandler(this.TextBoxes_LostFocus);
          this.TextBoxAddressDevice.GotFocus += new RoutedEventHandler(this.TextBoxes_GotFocus);
          break;
        case 8:
          this.TextBoxSizeDevice = (TextBox) target;
          this.TextBoxSizeDevice.KeyDown += new KeyEventHandler(this.TextBoxes_KeyDown);
          this.TextBoxSizeDevice.LostFocus += new RoutedEventHandler(this.TextBoxes_LostFocus);
          this.TextBoxSizeDevice.GotFocus += new RoutedEventHandler(this.TextBoxes_GotFocus);
          break;
        case 9:
          this.ButtonReadDataFromDevice = (Button) target;
          this.ButtonReadDataFromDevice.Click += new RoutedEventHandler(this.ButtonReadDataFromDevice_Click);
          break;
        case 10:
          this.ButtonWriteDataToDevice = (Button) target;
          this.ButtonWriteDataToDevice.Click += new RoutedEventHandler(this.ButtonWriteDataToDevice_Click);
          break;
        case 11:
          this.ButtonCopyValues = (Button) target;
          this.ButtonCopyValues.Click += new RoutedEventHandler(this.ButtonSetValuesFromMemory_Click);
          break;
        case 12:
          this.ButtonLoadDeviceMemory = (Button) target;
          this.ButtonLoadDeviceMemory.Click += new RoutedEventHandler(this.ButtonLoadDeviceMemory_Click);
          break;
        case 13:
          this.ButtonUpdateDataGrid = (Button) target;
          this.ButtonUpdateDataGrid.Click += new RoutedEventHandler(this.ButonUpdateGRID_Click);
          break;
        case 14:
          this.ButtonPrev = (Button) target;
          this.ButtonPrev.Click += new RoutedEventHandler(this.ButtonPrev_Memory_Click);
          break;
        case 15:
          this.ButtonNext = (Button) target;
          this.ButtonNext.Click += new RoutedEventHandler(this.ButtonNext_Memory_Click);
          break;
        case 16:
          this.ComboBoxAddress = (ComboBox) target;
          this.ComboBoxAddress.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxAddress_SelectionChanged);
          break;
        case 17:
          this.TextBoxAddressMemory = (TextBox) target;
          this.TextBoxAddressMemory.KeyDown += new KeyEventHandler(this.TextBoxes_KeyDown);
          this.TextBoxAddressMemory.LostFocus += new RoutedEventHandler(this.TextBoxes_LostFocus);
          this.TextBoxAddressMemory.GotFocus += new RoutedEventHandler(this.TextBoxes_GotFocus);
          break;
        case 18:
          this.ButtonGotoAddress = (Button) target;
          this.ButtonGotoAddress.Click += new RoutedEventHandler(this.ButtonGoto_Memory_Address_Click);
          break;
        case 19:
          this.ButtonCancel = (Button) target;
          this.ButtonCancel.Click += new RoutedEventHandler(this.ButtonCancel_Click);
          break;
        case 20:
          this.ButtonSaveDeviceMemoryToFile = (Button) target;
          this.ButtonSaveDeviceMemoryToFile.Click += new RoutedEventHandler(this.ButtonSaveDeviceMemoryToFile_Click);
          break;
        case 21:
          this.TextBoxStopwatch = (TextBox) target;
          break;
        case 22:
          this.CheckBoxShowHex = (CheckBox) target;
          this.CheckBoxShowHex.Click += new RoutedEventHandler(this.CheckBoxShowHex_Click);
          break;
        case 23:
          this.TextBoxSizeMemory = (TextBox) target;
          this.TextBoxSizeMemory.KeyDown += new KeyEventHandler(this.TextBoxes_KeyDown);
          this.TextBoxSizeMemory.LostFocus += new RoutedEventHandler(this.TextBoxes_LostFocus);
          this.TextBoxSizeMemory.GotFocus += new RoutedEventHandler(this.TextBoxes_GotFocus);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- MeterKeyManager.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MeterKeyManager
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using GmmDbLib;
using GmmDbLib.DataSets;
using System;
using System.Data;
using System.Data.Common;
using System.Text;

#nullable disable
namespace HandlerLib
{
  public static class MeterKeyManager
  {
    public static uint GetMeterKey(BaseDbConnection db, uint MeterID)
    {
      using (DbConnection newConnection = db.GetNewConnection())
      {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append("SELECT * FROM MeterData");
        stringBuilder.Append(" WHERE MeterID = " + MeterID.ToString());
        stringBuilder.Append(" AND PValueId = " + 217.ToString());
        DbDataAdapter dataAdapter = db.GetDataAdapter(stringBuilder.ToString(), newConnection, out DbCommandBuilder _);
        BaseTables.MeterDataDataTable meterDataDataTable = new BaseTables.MeterDataDataTable();
        dataAdapter.Fill((DataTable) meterDataDataTable);
        if (meterDataDataTable.Count > 1)
          throw new Exception("More then one MeterKey available for MeterID:" + MeterID.ToString());
        if (meterDataDataTable.Count == 0)
          throw new Exception("MeterKey not available for MeterID:" + MeterID.ToString());
        if (meterDataDataTable[0].IsPValueNull())
          throw new Exception("MeterKey null found for MeterID:" + MeterID.ToString());
        uint result;
        if (!uint.TryParse(meterDataDataTable[0].PValue, out result))
          throw new Exception("MeterKey format error for MeterID:" + MeterID.ToString());
        if (result < (uint) byte.MaxValue || result > 4294967040U)
          throw new Exception("MeterKey value error for MeterID:" + MeterID.ToString());
        return result ^ MeterID;
      }
    }

    public static uint GetOrCreateMeterKey(BaseDbConnection db, uint MeterID)
    {
      if (MeterID == 0U)
        throw new Exception("MeterID == 0 not allowed for protection.");
      using (DbConnection newConnection = db.GetNewConnection())
      {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.Append("SELECT * FROM MeterData");
        stringBuilder.Append(" WHERE MeterID = " + MeterID.ToString());
        stringBuilder.Append(" AND PValueId = " + 217.ToString());
        DbDataAdapter dataAdapter = db.GetDataAdapter(stringBuilder.ToString(), newConnection, out DbCommandBuilder _);
        BaseTables.MeterDataDataTable meterDataDataTable = new BaseTables.MeterDataDataTable();
        dataAdapter.Fill((DataTable) meterDataDataTable);
        if (meterDataDataTable.Count > 1)
          throw new Exception("More than one MeterKey available for MeterID:" + MeterID.ToString());
        uint result;
        if (meterDataDataTable.Count == 1)
        {
          if (meterDataDataTable[0].IsPValueNull())
            throw new Exception("MeterKey null found for MeterID:" + MeterID.ToString());
          if (!uint.TryParse(meterDataDataTable[0].PValue, out result))
            throw new Exception("MeterKey format error for MeterID:" + MeterID.ToString());
          if (result < (uint) byte.MaxValue || result > 4294967040U)
            throw new Exception("MeterKey value error for MeterID:" + MeterID.ToString());
        }
        else
        {
          Random random = new Random(DateTime.Now.Millisecond);
          uint num;
          do
          {
            num = (uint) random.Next();
          }
          while (((int) num & 2130706432) == 0 || ((int) num & (int) byte.MaxValue) == 0);
          result = num & (uint) int.MaxValue;
          BaseTables.MeterDataRow row = meterDataDataTable.NewMeterDataRow();
          row.MeterID = (int) MeterID;
          row.PValueID = 217;
          row.TimePoint = DateTime.Now.ToUniversalTime();
          row.PValue = result.ToString();
          meterDataDataTable.AddMeterDataRow(row);
          dataAdapter.Update((DataTable) meterDataDataTable);
        }
        return result ^ MeterID;
      }
    }
  }
}


--- MeterTypeNAME.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MeterTypeNAME
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum MeterTypeNAME
  {
    CONNECTED,
    WORK,
    TYPE,
    BACKUP,
  }
}


--- MSP430.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MSP430
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Resources;
using System.Text;

#nullable disable
namespace HandlerLib
{
  public static class MSP430
  {
    public static List<Parameter> LoadParameter(ResourceManager resourceManager, uint version)
    {
      return MSP430.LoadParameter(resourceManager, version, (string[]) null, (string[]) null);
    }

    public static List<Parameter> LoadParameter(
      ResourceManager resourceManager,
      uint version,
      string[] ignoreSegments)
    {
      return MSP430.LoadParameter(resourceManager, version, ignoreSegments, (string[]) null);
    }

    public static List<Parameter> LoadParameter(
      ResourceManager resourceManager,
      uint version,
      string[] ignoreSegments,
      string[] ignorePrefixes)
    {
      if (resourceManager == null)
        throw new NullReferenceException(nameof (resourceManager));
      foreach (DictionaryEntry resource in resourceManager.GetResourceSet(CultureInfo.InvariantCulture, true, true))
      {
        string str = resource.Key.ToString();
        uint result;
        if (str.Length == 11 && str.StartsWith("_0x") && uint.TryParse(str.Substring(3), NumberStyles.HexNumber, (IFormatProvider) null, out result) && (int) result == (int) version)
          return MSP430.LoadParameter(Encoding.ASCII.GetString(resource.Value as byte[]), ignoreSegments, ignorePrefixes);
      }
      return (List<Parameter>) null;
    }

    public static List<Parameter> LoadParameter(string mapContent)
    {
      return MSP430.LoadParameter(mapContent, (string[]) null, (string[]) null);
    }

    public static List<Parameter> LoadParameter(string mapContent, string[] ignoreSegments)
    {
      return MSP430.LoadParameter(mapContent, ignoreSegments, (string[]) null);
    }

    public static List<Parameter> LoadParameter(
      string mapContent,
      string[] ignoreSegments,
      string[] ignorePrefixes)
    {
      string[] map = !string.IsNullOrEmpty(mapContent) ? mapContent.Split(new string[1]
      {
        Environment.NewLine
      }, StringSplitOptions.RemoveEmptyEntries) : throw new NullReferenceException(nameof (mapContent));
      List<Parameter> result = new List<Parameter>();
      List<string> stringList1 = new List<string>()
      {
        "DATA16_AN",
        "DATA16_AC",
        "DATA16_ID",
        "CSTART",
        "RESET",
        "?FILL",
        "CODE",
        "CHECKSUM"
      };
      List<string> stringList2 = new List<string>();
      if (ignoreSegments != null)
        stringList1.AddRange((IEnumerable<string>) ignoreSegments);
      if (ignorePrefixes != null)
        stringList2.AddRange((IEnumerable<string>) ignorePrefixes);
      for (int i = 0; i < map.Length; ++i)
      {
        string str1 = map[i];
        if (str1.Contains("Relative segment, address:"))
        {
          string segment = map[i - 1];
          if (!stringList1.Exists((Predicate<string>) (x => segment.Contains(x))))
          {
            string[] strArray1 = str1.Split(' ');
            if (strArray1.Length == 12)
            {
              ushort address = ushort.Parse(strArray1[5], NumberStyles.HexNumber);
              ushort num1 = ushort.Parse(strArray1[7], NumberStyles.HexNumber);
              string str2;
              do
              {
                str2 = map[++i];
                if (str2.Contains("*************************************************************************") || str2.Contains("-------------------------------------------------------------------------"))
                  goto label_27;
              }
              while (!str2.Contains("===== "));
              string str3 = MSP430.TrimSpaces(map[++i]);
              string[] strArray2 = str3.Split(' ');
              string name = strArray2[0];
              ushort num2 = 0;
              if (strArray2.Length >= 2)
                num2 = ushort.Parse(strArray2[1], NumberStyles.HexNumber);
              else if (strArray2.Length == 1)
              {
                str3 = MSP430.TrimSpaces(map[++i]);
                num2 = ushort.Parse(str3.Split(' ')[0], NumberStyles.HexNumber);
              }
              if ((int) num2 != (int) address)
                throw new Exception("Internal error while parse the map file! Wrong address detected. " + str3);
              if (result.Exists((Predicate<Parameter>) (x => x.Name == name)))
                throw new Exception("Internal error while parse the map file! The parameter already exists. " + str3);
              if (stringList2.Count <= 0 || !stringList2.Exists((Predicate<string>) (x => name.StartsWith(x))))
                result.Add(new Parameter(segment, name, address, (int) (ushort) ((int) num1 - (int) address + 1)));
            }
            else if (strArray1.Length != 8)
              throw new Exception("Internal error while parse the map file! Unknown line detected: " + str1);
          }
          else
            continue;
        }
        else if (str1.StartsWith("SEGMENT") && str1.Contains("START ADDRESS"))
          MSP430.ParseSegments(map, i, result);
label_27:;
      }
      return result;
    }

    private static void ParseSegments(string[] map, int i, List<Parameter> result)
    {
      string line;
      while (true)
      {
        do
        {
          line = map[++i];
        }
        while (line.StartsWith("=======") || line.StartsWith("DATA16_AN") || line.StartsWith(" "));
        if (!line.StartsWith("CSTART"))
        {
          string[] strArray = MSP430.TrimSpaces(line).Split(' ');
          if (strArray.Length == 1)
          {
            line += map[++i];
            strArray = MSP430.TrimSpaces(line).Split(' ');
          }
          string name = strArray[0];
          if (strArray.Length == 7)
          {
            ushort address = ushort.Parse(strArray[1], NumberStyles.HexNumber);
            ushort size = ushort.Parse(strArray[4], NumberStyles.HexNumber);
            if (name.StartsWith("?FILL"))
            {
              Parameter parameter = result[result.Count - 1];
              result.RemoveAt(result.Count - 1);
              result.Add(new Parameter("SEGMENT", parameter.Name, parameter.Address, parameter.Size + (int) size));
            }
            else if (!result.Exists((Predicate<Parameter>) (x => x.Name == name)))
              result.Add(new Parameter("SEGMENT", name, address, (int) size));
            else
              goto label_8;
          }
          else if (strArray.Length == 4)
          {
            ushort address = ushort.Parse(strArray[1], NumberStyles.HexNumber);
            if (!result.Exists((Predicate<Parameter>) (x => x.Name == name)))
              result.Add(new Parameter("SEGMENT", name, address, 0));
            else
              goto label_13;
          }
          else
            goto label_15;
        }
        else
          break;
      }
      return;
label_8:
      throw new Exception("Internal error while parse the map file! The parameter already exists. " + line);
label_13:
      throw new Exception("Internal error while parse the map file! The parameter already exists. " + line);
label_15:
      throw new Exception("Internal error while parse the map file! Unknown segment structure. " + line);
    }

    private static string TrimSpaces(string line)
    {
      StringBuilder stringBuilder = new StringBuilder();
      char[] charArray = line.ToCharArray();
      bool flag = false;
      foreach (char c in charArray)
      {
        if (char.IsWhiteSpace(c))
        {
          if (flag)
          {
            stringBuilder.Append(c);
            flag = false;
          }
        }
        else
        {
          stringBuilder.Append(c);
          flag = true;
        }
      }
      return stringBuilder.ToString().TrimEnd();
    }
  }
}


--- myDataRow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.myDataRow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.ComponentModel;
using System.Globalization;
using System.Runtime.CompilerServices;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class myDataRow : INotifyPropertyChanged
  {
    private object _origValue;
    private string _oValHex;
    private object _oValue;
    private bool IsCrossChange = false;
    public int savedColumns = 0;
    public ParameterWindow ParamWindow = (ParameterWindow) null;

    public void ResetOldValue() => this.OldOrigValue = (object) null;

    private object OldOrigValue { get; set; }

    public object OrigValue
    {
      get => this._origValue;
      set
      {
        if (value != null && this.OldOrigValue != null)
        {
          if (value.GetType() == typeof (byte[]))
          {
            bool flag = true;
            for (int index = 0; index < ((byte[]) value).Length; ++index)
            {
              byte num1 = ((byte[]) this.OldOrigValue)[index];
              byte num2 = ((byte[]) value)[index];
              flag &= (int) num2 == (int) num1;
            }
            this.IsChanged = flag && this.IsChanged || !flag && !this.IsChanged || !flag;
          }
          else if (value != this.OldOrigValue)
            this.IsChanged = true;
        }
        else if (value != null && this.OldOrigValue == null)
        {
          if (!this.IsReading)
            this.IsChanged = true;
        }
        else if (value == null && this.OldOrigValue != null)
          this.IsChanged = true;
        if (!this.IsChanged && !this.IsReading)
          return;
        this.OldOrigValue = this._origValue;
        this._origValue = value;
      }
    }

    public string Name { get; set; }

    public string Section { get; set; }

    public string MemoryArea { get; set; }

    private string _oType { get; set; }

    public string Typ
    {
      get => this._oType;
      set
      {
        this._oType = value;
        this.NotifyPropertyChanged(nameof (Typ));
      }
    }

    public string ValueHEXfull => this._oValHex;

    public string ValueHEX
    {
      get
      {
        uint num = uint.Parse(this.Bytes.Substring(2), NumberStyles.HexNumber);
        int length = (int) num * 2 > 40 ? 40 : (int) num * 2;
        string valueHex = this._oValHex;
        if (this._oValHex != null && this._oValHex.Length >= length)
          valueHex = this._oValHex.Substring(0, length) + (num > 40U ? "..." : "");
        return valueHex;
      }
      set
      {
        try
        {
          if (value == null)
            value = string.Empty;
          if (this._oValHex == null)
            this._oValHex = value;
          if (this._oValHex.Trim().ToLower().Equals(value.Trim().ToLower()))
            return;
          this._oValHex = value;
          if (!this.IsCrossChange)
          {
            this.IsChanged = true;
            this.NotifyPropertyChanged(nameof (ValueHEX));
            if (this.Value != null && !this.Value.ToString().Contains("[...]"))
            {
              this.IsCrossChange = true;
              this.Value = ParameterArrayAssistant.HEXtoObject(this.ValType, this.ValueHEX);
              this.IsCrossChange = false;
            }
            if (!this.IsReading)
              this.setValueToMemory();
          }
          else
            this.NotifyPropertyChanged(nameof (ValueHEX));
        }
        catch (Exception ex)
        {
          this.IsCrossChange = false;
        }
      }
    }

    public object Value
    {
      get => this._oValue;
      set
      {
        try
        {
          if (value == null || string.IsNullOrEmpty(value.ToString()) || value == this._oValue)
            return;
          if (this.checkValueOK(value))
          {
            this._oValue = value;
            if (!this.IsCrossChange)
            {
              if (!this._oValue.ToString().Contains("[...]"))
              {
                this.IsChanged = true;
                this.NotifyPropertyChanged(nameof (Value));
                this.IsCrossChange = true;
                this.ValueHEX = this.getHexStringForObject(this.Value.ToString(), this.ValType);
                this.OrigValue = this._oValue;
                this.IsCrossChange = false;
                if (!this.IsReading)
                  this.setValueToMemory();
              }
            }
            else
            {
              this.NotifyPropertyChanged(nameof (Value));
              if (!this._oValue.ToString().Contains("[...]"))
                this.OrigValue = this._oValue;
            }
          }
          else if (this.IsValueForced)
          {
            this._oValue = value;
            this.NotifyPropertyChanged(nameof (Value));
          }
        }
        catch (Exception ex)
        {
          this.IsCrossChange = false;
        }
      }
    }

    public string Bytes { get; set; }

    public string Address { get; set; }

    public Type ValType { get; set; }

    private bool _isChanged { get; set; }

    public bool IsChanged
    {
      get => this._isChanged;
      set
      {
        this._isChanged = value;
        this.NotifyPropertyChanged(nameof (IsChanged));
      }
    }

    public bool IsChangedInternal { get; set; }

    public bool IsTypeChanged { get; set; }

    public bool IsSavedTemp { get; set; }

    private bool _isInit { get; set; }

    public bool IsInit
    {
      get => this._isInit;
      set
      {
        this._isInit = value;
        this.NotifyPropertyChanged(nameof (IsInit));
      }
    }

    private bool _isMemoryAvail { get; set; }

    public bool IsMemoryAvail
    {
      get => this._isMemoryAvail;
      set
      {
        this._isMemoryAvail = value;
        this.NotifyPropertyChanged(nameof (IsMemoryAvail));
      }
    }

    public bool IsReading { get; set; }

    public bool IsValueForced { get; set; }

    public myDataRow()
    {
    }

    public myDataRow(
      bool isInit,
      ParameterWindow oPW,
      string name,
      string section,
      string memoryArea,
      string typ,
      string bytes,
      string address,
      string valuehex,
      object value,
      Type valTyp)
    {
      this.IsInit = isInit;
      this.IsReading = this.IsInit;
      this.ParamWindow = oPW;
      this.Name = name;
      this.Section = section;
      this.MemoryArea = memoryArea;
      this.Typ = typ;
      this.ValType = valTyp;
      this.Bytes = bytes;
      this.Address = address;
      this.ValueHEX = valuehex;
      if (value != null && value.ToString().Equals("[...]"))
      {
        this.IsValueForced = true;
        this.Value = (object) "[...]";
        this.IsValueForced = false;
      }
      else
        this.Value = value;
      this.IsChanged = false;
      this.IsTypeChanged = false;
      this.IsSavedTemp = false;
      this.IsMemoryAvail = false;
      this.IsValueForced = false;
    }

    public event PropertyChangedEventHandler PropertyChanged;

    private void NotifyPropertyChanged([CallerMemberName] string propertyName = "")
    {
      if (this.PropertyChanged == null)
        return;
      this.PropertyChanged((object) this, new PropertyChangedEventArgs(propertyName));
    }

    private bool checkValueOK(object value)
    {
      if (value.ToString().Equals("[...]"))
        return false;
      try
      {
        return this.getHexStringForObject(value.ToString(), this.ValType) != null;
      }
      catch
      {
        return false;
      }
    }

    private void setValueToMemory()
    {
      if (this.Value == null || !this.IsChanged)
        return;
      uint address = uint.Parse(this.Address.Substring(2), NumberStyles.HexNumber);
      uint byteSize = uint.Parse(this.Bytes.Substring(2), NumberStyles.HexNumber);
      if (!this.Value.ToString().Contains("[...]"))
      {
        if (this.Value.ToString().Length > 1 && this.Value.ToString().Contains("-") || !this.Value.ToString().Contains("-"))
          Parameter32bit.SetValue(this.ValType, this.Value, address, this.ParamWindow.saveDeviceMemory);
      }
      else if (!string.IsNullOrEmpty(this.ValueHEX))
        Parameter32bit.SetValue(Util.HexStringToByteArray(this.ValueHEX), address, this.ParamWindow.saveDeviceMemory);
      string message = string.Empty;
      DeviceMemoryStorage memoryTypeForData = this.ParamWindow.saveDeviceMemory.GetDeviceMemoryTypeForData(address, byteSize, out message);
      DeviceMemoryType deviceMemoryType1 = memoryTypeForData == null ? DeviceMemoryType.NotAvail : memoryTypeForData.MemoryType;
      DeviceMemoryType deviceMemoryType2 = memoryTypeForData == null ? DeviceMemoryType.NotAvail : memoryTypeForData.MemoryType;
      this.MemoryArea = deviceMemoryType2 == DeviceMemoryType.Unknown ? "" : deviceMemoryType2.ToString();
      this.IsMemoryAvail = string.IsNullOrEmpty(message);
    }

    private string getValueStringFromHex(Type myType, string value)
    {
      try
      {
        string empty = string.Empty;
        if (myType == typeof (double) || myType == typeof (float))
          return double.Parse(value, NumberStyles.HexNumber).ToString();
        if (myType == typeof (byte))
          return byte.Parse(value, NumberStyles.HexNumber).ToString();
        if (myType == typeof (sbyte))
          return sbyte.Parse(value, NumberStyles.HexNumber).ToString();
        if (myType == typeof (short))
          return short.Parse(value, NumberStyles.HexNumber).ToString();
        if (myType == typeof (ushort))
          return ushort.Parse(value, NumberStyles.HexNumber).ToString();
        if (myType == typeof (int))
          return int.Parse(value, NumberStyles.HexNumber).ToString();
        if (myType == typeof (uint))
          return uint.Parse(value, NumberStyles.HexNumber).ToString();
        return myType == typeof (Decimal) ? Decimal.Parse(value, NumberStyles.HexNumber).ToString() : empty;
      }
      catch (Exception ex)
      {
        throw new Exception("Error while converting from HEX-String!", ex);
      }
    }

    public string getHexStringForObject(string value, Type myType)
    {
      try
      {
        if (myType == typeof (byte))
          return byte.Parse(value).ToString("X2");
        if (myType == typeof (sbyte))
          return sbyte.Parse(value).ToString("X2");
        if (myType == typeof (short))
          return short.Parse(value).ToString("X4");
        if (myType == typeof (ushort))
          return ushort.Parse(value).ToString("X4");
        if (myType == typeof (int))
          return int.Parse(value).ToString("X8");
        if (myType == typeof (uint))
          return uint.Parse(value).ToString("X8");
        if (myType == typeof (float))
          return ParameterArrayAssistant.float2HEXString(float.Parse(value));
        if (myType == typeof (double))
          return ParameterArrayAssistant.double2HEXString(double.Parse(value));
        return myType == typeof (Decimal) ? Decimal.Parse(value).ToString("x8") : string.Empty;
      }
      catch (Exception ex)
      {
        throw new Exception("Conversion Type is not implemented!!!", ex);
      }
    }
  }
}


--- MySpecialParam.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.MySpecialParam
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System.ComponentModel;

#nullable disable
namespace HandlerLib
{
  public class MySpecialParam : INotifyPropertyChanged
  {
    private byte[] _internalData;

    public event PropertyChangedEventHandler PropertyChanged;

    public byte[] InternalData
    {
      get => this._internalData;
      set
      {
        if (this._internalData == value)
          return;
        this._internalData = value;
        if (this.PropertyChanged == null)
          return;
        this.PropertyChanged((object) this, new PropertyChangedEventArgs(nameof (InternalData)));
      }
    }

    internal uint TypeSize { get; set; }

    internal string Name { get; set; }

    internal uint Position { get; set; }
  }
}


--- NACK_Messages.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NACK_Messages
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum NACK_Messages : byte
  {
    Unknown_function = 0,
    Illegal_reduced_device_information = 1,
    Illegal_request_frame_lenght = 2,
    Parameter_error = 3,
    Not_classified_error = 4,
    Access_denied = 5,
    Wrong_activation_code = 6,
    Invalid_encryption_key = 7,
    Illegal_NACK_code = 255, // 0xFF
  }
}


--- NBIoTCommandWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NBIoTCommandWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZENNER.CommonLibrary.Exceptions;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class NBIoTCommandWindow : Window, IComponentConnector
  {
    private CommonNBIoTCommands myNBIotCommands;
    private List<string> Argument1_last_values;
    private List<string> Argument2_last_values;
    private List<string> Argument3_last_values;
    private List<string> Argument4_last_values;
    private List<string> Argument5_last_values;
    private ContextMenu Argument1ValuesMenu;
    private ContextMenu Argument2ValuesMenu;
    private ContextMenu Argument3ValuesMenu;
    private ContextMenu Argument4ValuesMenu;
    private ContextMenu Argument5ValuesMenu;
    private static string result = string.Empty;
    private static readonly string CMD_GetNBIoTModulePartNumber = "Get NBIoT Module Part Number (0x00)";
    private static readonly string CMD_GetNBIoTFirmwareVersion = "Get NBIoT Firmware Version (0x01)";
    private static readonly string CMD_GetNBIoTIMEI_NB = "Get NBIoT IMEI From NB (0x02)";
    private static readonly string CMD_GetSIMIMSI_NB = "Get SIM IMSI From NB (0x03)";
    private static readonly string CMD_GetProtocol = "Get Protocol (0x04)";
    private static readonly string CMD_SetProtocol = "Set Protocol (0x04)";
    private static readonly string CMD_GetBand = "Get Band (0x05)";
    private static readonly string CMD_SetBand = "Set Band (0x05)";
    private static readonly string CMD_GetRemoteIP = "Get Remote IP (0x06)";
    private static readonly string CMD_SetRemoteIP = "Set Remote IP (0x06)";
    private static readonly string CMD_GetRemotePort = "Get Remote Port (0x07)";
    private static readonly string CMD_SetRemotePort = "Set Remote Port (0x07)";
    private static readonly string CMD_SetOperator = "Set Operator (0x08)";
    private static readonly string CMD_GetOperator = "Get Operator (0x08)";
    private static readonly string CMD_SendConfirmedData = "Send Confirmed Data (0x09)";
    private static readonly string CMD_SendUnconfirmedData = "Send Unconfirmed Data (0x0A)";
    private static readonly string CMD_SendTestData = "Send Test Data (0x0B)";
    private static readonly string CMD_SendRadioFullFunctionOn = "Send Radio Full Function On (0x0C)";
    private static readonly string CMD_SendRadioFullFunctionOff = "Send Radio Full Function Off (0x0C)";
    private static readonly string CMD_SetNBIoTPowerOn = "Send NBIoT Power On (0x20)";
    private static readonly string CMD_SetNBIoTPowerOff = "Send NBIoT Power Off (0x20)";
    private static readonly string CMD_SendCommonCommand = "Send Common Command (0x21)";
    private static readonly string CMD_GetIMEI_IMSI_NBVER_RAM = "Get IMEI, IMSI and NBVer from RAM (0x22)";
    private static readonly string CMD_GetICCID_IMSI_RAM = "Get ICCID and IMSI from RAM (0x23)";
    private static readonly string CMD_SetTransmissionScenario = "Set transmission sceanrio (0x28)";
    private static readonly string CMD_GetTransmissionScenario = "Get transmission sceanrio (0x28)";
    private static readonly string CMD_SetDeviceEUI = "Set device EUI (0x25)";
    private static readonly string CMD_GetDeviceEUI = "Get device EUI (0x25)";
    private static readonly string CMD_SendActivePacket = "Send Actived Packet (0x31)";
    private static readonly string CMD_GetSIMICCID_NB = "Get SIM ICCID From NB (0x0D)";
    private static readonly string CMD_GetSecondaryBand = "Get Secondary Band (0x0E)";
    private static readonly string CMD_SetSecondaryBand = "Set Secondary Band (0x0E)";
    private static readonly string CMD_GetDNSName = "Get DNS Name (0x0F)";
    private static readonly string CMD_SetDNSName = "Set DNS Name (0x0F)";
    private static readonly string CMD_GetRadioSendingState = "Get Radio Sending State (0x10)";
    private static readonly string CMD_RestNBModem = "Reset NB modem (0x11)";
    private static readonly string CMD_SetNBModemAutoConnect = "Set NB modem auto connect (0x12)";
    private static readonly string CMD_SetNBModemManualConnect = "Set NB modem manual connect (0x12)";
    private static readonly string CMD_SetNBModemAPN = "Set NB modem APN (0x13)";
    private static readonly string CMD_GetNBModemAPN = "Get NB modem APN (0x13)";
    private static readonly string CMD_SetDNSServerIP = "Set DNS Server IP (0x14)";
    private static readonly string CMD_GetDNSServerIP = "Get DNS Server IP (0x14)";
    private static readonly string CMD_SetDNSEnableByte = "Set DNS Enable Byte (0x29)";
    private static readonly string CMD_GetDNSEnableByte = "Get DNS Enable Byte (0x29)";
    private static readonly string CMD_SetAPNEnableByte = "Set APN Enable Byte (0x30)";
    private static readonly string CMD_GetAPNEnableByte = "Get APN Enable Byte (0x30)";
    private Cursor defaultCursor;
    private CancellationTokenSource cancelTokenSource;
    private ProgressHandler progress;
    internal TextBlock TextBlockStatus;
    internal ProgressBar ProgressBar1;
    internal TextBox TextBoxUniversalCommandResult;
    internal StackPanel StackPanalButtons;
    internal ComboBox ComboCommand;
    internal CheckBox CheckBoxEncryption;
    internal Label EncryptionKey_Label;
    internal TextBox TextBoxEncryptionKey;
    internal Label ComboExtCommand_Label;
    internal ComboBox ComboExtCommand;
    internal Label ComboAddCommand_Label;
    internal ComboBox ComboAddCommand;
    internal Label TextArgument_1_Label;
    internal TextBox TextExtCommandArgument_1;
    internal Label TextArgument_2_Label;
    internal TextBox TextExtCommandArgument_2;
    internal Label TextArgument_3_Label;
    internal TextBox TextExtCommandArgument_3;
    internal Label TextArgument_4_Label;
    internal TextBox TextExtCommandArgument_4;
    internal Label TextArgument_5_Label;
    internal TextBox TextExtCommandArgument_5;
    internal StackPanel StackPanalButtons2;
    internal Button ButtonRunCommand;
    internal Button ButtonRunCommandPreview;
    internal Button ButtonBreak;
    private bool _contentLoaded;

    public ComboBox cmbBox
    {
      get => this.ComboExtCommand;
      set => this.ComboExtCommand.Items.Remove((object) value);
    }

    public NBIoTCommandWindow(CommonNBIoTCommands NBIotCMDs)
    {
      this.InitializeComponent();
      this.myNBIotCommands = NBIotCMDs;
      this.myNBIotCommands.setCryptValuesFromBaseClass();
      this.ButtonRunCommand.IsEnabled = false;
      this.SetArgumentFields((Dictionary<int, string>) null);
      this.setFunctionCodes();
      this.Argument1_last_values = new List<string>();
      this.Argument2_last_values = new List<string>();
      this.Argument3_last_values = new List<string>();
      this.Argument4_last_values = new List<string>();
      this.Argument5_last_values = new List<string>();
      this.Argument1ValuesMenu = new ContextMenu();
      this.Argument2ValuesMenu = new ContextMenu();
      this.Argument3ValuesMenu = new ContextMenu();
      this.Argument4ValuesMenu = new ContextMenu();
      this.Argument5ValuesMenu = new ContextMenu();
      this.setEncryptionState();
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
    }

    private void setEncryptionState()
    {
      this.CheckBoxEncryption.IsChecked = new bool?(this.myNBIotCommands.enDeCrypt);
      if (!this.myNBIotCommands.enDeCrypt)
        this.CheckBoxEncryption_UnChecked((object) null, (RoutedEventArgs) null);
      this.TextBoxEncryptionKey.Text = this.myNBIotCommands.AES_Key;
    }

    private void setFunctionCodes()
    {
      this.ComboExtCommand_Label.Visibility = Visibility.Hidden;
      this.ComboExtCommand.Visibility = Visibility.Hidden;
      this.ComboCommand.Items.Clear();
      this.ComboCommand.Items.Add((object) "NBIoT Commands (0x37)");
      this.ComboCommand.SelectedIndex = 0;
    }

    private void setNBIoTCommands()
    {
      Dictionary<string, string> valuesForCommands = GetCommandValues.GetAllPrivateStaticFieldValuesForCommands((object) this);
      this.ComboExtCommand.Items.Clear();
      foreach (KeyValuePair<string, string> keyValuePair in valuesForCommands)
        this.ComboExtCommand.Items.Add((object) keyValuePair.Value);
      this.ComboExtCommand.SelectedIndex = 0;
    }

    private void SetRunState()
    {
      this.cancelTokenSource = new CancellationTokenSource();
      this.progress.Reset();
      this.progress.Split(new double[2]{ 2.0, 98.0 });
      this.progress.Report("Run");
      this.ComboCommand.IsEnabled = false;
      this.ComboExtCommand.IsEnabled = false;
      this.TextBoxUniversalCommandResult.IsEnabled = false;
      this.TextExtCommandArgument_1.IsEnabled = false;
      this.TextExtCommandArgument_2.IsEnabled = false;
      this.TextExtCommandArgument_3.IsEnabled = false;
      this.ButtonRunCommand.IsEnabled = false;
      this.ButtonRunCommandPreview.IsEnabled = false;
      this.ButtonBreak.IsEnabled = true;
      this.defaultCursor = this.Cursor;
      this.Cursor = Cursors.Wait;
    }

    private void SetStopState()
    {
      this.ComboCommand.IsEnabled = true;
      this.ComboExtCommand.IsEnabled = true;
      this.TextBoxUniversalCommandResult.IsEnabled = true;
      this.TextExtCommandArgument_1.IsEnabled = true;
      this.TextExtCommandArgument_2.IsEnabled = true;
      this.TextExtCommandArgument_3.IsEnabled = true;
      this.ButtonRunCommand.IsEnabled = true;
      this.ButtonRunCommandPreview.IsEnabled = true;
      this.ButtonBreak.IsEnabled = false;
      this.Cursor = this.defaultCursor;
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.ProgressBar1.Value = obj.ProgressPercentage;
        this.TextBlockStatus.Text = obj.Message;
      }
    }

    private void ButtonBreak_Click(object sender, RoutedEventArgs e)
    {
      this.cancelTokenSource.Cancel();
    }

    private async Task RunCommandFrame()
    {
      this.SetRunState();
      try
      {
        await this.RunCommand();
      }
      catch (OperationCanceledException ex)
      {
      }
      catch (TimeoutException ex)
      {
        this.TextBoxUniversalCommandResult.Text = "Timeout";
      }
      catch (NACK_Exception ex)
      {
        this.TextBoxUniversalCommandResult.Text = "Device response is NACK: " + ex.Message;
      }
      catch (Exception ex)
      {
        bool isTimeout = false;
        if (ex is AggregateException)
        {
          AggregateException aex = ex as AggregateException;
          int num1;
          for (int i = 0; i < aex.InnerExceptions.Count; num1 = i++)
          {
            Exception theException = aex.InnerExceptions[i];
            if (theException is TimeoutException)
            {
              if (i == aex.InnerExceptions.Count - 1)
              {
                isTimeout = true;
                string newLine = Environment.NewLine;
                num1 = aex.InnerExceptions.Count;
                string str = num1.ToString();
                int num2 = (int) MessageBox.Show("**** Multiple timeouts ****" + newLine + "Timeout count: " + str);
              }
              theException = (Exception) null;
            }
            else
              break;
          }
          aex = (AggregateException) null;
        }
        if (!isTimeout)
        {
          int num = (int) MessageBox.Show(ex.ToString());
        }
      }
      this.SetStopState();
    }

    private async void ButtonRunCommand_Click(object sender, RoutedEventArgs e)
    {
      NBIoTCommandWindow.result = string.Empty;
      await this.RunCommandFrame();
    }

    private async void ButtonRunCommandPreview_Click(object sender, RoutedEventArgs e)
    {
      NBIoTCommandWindow.result = "Actual NBIoT data of connected device:\n-------------------------------------------";
      Dictionary<int, string> args = new Dictionary<int, string>();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetNBIoTModulePartNumber;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetNBIoTFirmwareVersion;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetNBIoTIMEI_NB;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetSIMIMSI_NB;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetProtocol;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetBand;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetSecondaryBand;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetRemoteIP;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetRemotePort;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetOperator;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetTransmissionScenario;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetDeviceEUI;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) NBIoTCommandWindow.CMD_GetSIMICCID_NB;
      await this.RunCommandFrame();
      args = (Dictionary<int, string>) null;
    }

    private void ComboExtCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboExtCommand.SelectedItem != null)
      {
        object selectedItem = this.ComboExtCommand.SelectedItem;
        this.ComboAddCommand.Items.Clear();
        Dictionary<int, string> template = new Dictionary<int, string>();
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SendUnconfirmedData))
          template.Add(1, "Unconfirmed data:");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SendConfirmedData))
          template.Add(1, "Confirmed data:");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetProtocol))
          template.Add(1, "Protocol (1 Byte):");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetBand))
          template.Add(1, "Band (1 Byte):");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetSecondaryBand))
          template.Add(1, "Band (1 Byte):");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetRemoteIP))
          template.Add(1, "Coap Remote IP (4 Bytes):");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetRemotePort))
          template.Add(1, "Coap Remote Port (2 Bytes):");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetOperator))
          template.Add(1, "Operator (2 Bytes):");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetTransmissionScenario))
          template.Add(1, "Transmission scenario:");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetDeviceEUI))
          template.Add(1, "Device EUI (8 Bytes(reversed)):");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SendCommonCommand))
          template.Add(1, "NBIoT Common Command:");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetDNSName))
          template.Add(1, "DNS Name:");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_RestNBModem))
          template.Add(1, "Data:");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetNBModemAPN))
          template.Add(1, "APN:");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetDNSServerIP))
        {
          template.Add(1, "Primary DNS ServerIP:");
          template.Add(2, "Secondary DNS ServerIP:");
        }
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetDNSEnableByte))
          template.Add(1, "Value(0-255):");
        if (selectedItem.ToString().Contains(NBIoTCommandWindow.CMD_SetAPNEnableByte))
          template.Add(1, "Value(0-1):");
        this.SetArgumentFields(template);
        this.ButtonRunCommand.IsEnabled = true;
      }
      else
        this.ButtonRunCommand.IsEnabled = false;
    }

    private void ComboCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboCommand.SelectedIndex < 0)
        return;
      Dictionary<int, string> dictionary = new Dictionary<int, string>();
      if (this.ComboCommand.SelectedItem.ToString().Contains("0x37"))
      {
        this.setNBIoTCommands();
        this.ComboExtCommand_Label.Content = (object) "NBIoT Commands (EFC):";
        this.ComboExtCommand_Label.Visibility = Visibility.Visible;
        this.ComboExtCommand.Visibility = Visibility.Visible;
      }
    }

    private void ComboAddCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboAddCommand.SelectedIndex < 0)
        return;
      object selectedItem = this.ComboAddCommand.SelectedItem;
    }

    private void SetArgumentFieldsValues(Dictionary<int, string> values)
    {
      if (values == null)
        return;
      foreach (KeyValuePair<int, string> keyValuePair in values)
      {
        if (keyValuePair.Key == 0)
          this.ComboAddCommand.SelectedItem = (object) keyValuePair.Value;
        if (keyValuePair.Key == 1)
          this.TextExtCommandArgument_1.Text = keyValuePair.Value;
        if (keyValuePair.Key == 2)
          this.TextExtCommandArgument_2.Text = keyValuePair.Value;
        if (keyValuePair.Key == 3)
          this.TextExtCommandArgument_3.Text = keyValuePair.Value;
        if (keyValuePair.Key == 4)
          this.TextExtCommandArgument_4.Text = keyValuePair.Value;
        if (keyValuePair.Key == 5)
          this.TextExtCommandArgument_5.Text = keyValuePair.Value;
      }
    }

    private void SetArgumentFields(Dictionary<int, string> template)
    {
      this.TextExtCommandArgument_1.Text = string.Empty;
      this.TextExtCommandArgument_2.Text = string.Empty;
      this.TextExtCommandArgument_3.Text = string.Empty;
      this.TextExtCommandArgument_4.Text = string.Empty;
      this.TextExtCommandArgument_5.Text = string.Empty;
      this.ComboAddCommand_Label.Visibility = Visibility.Collapsed;
      this.ComboAddCommand.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_1.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_2.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_3.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_4.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_5.Visibility = Visibility.Collapsed;
      this.TextArgument_1_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_2_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_3_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_4_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_5_Label.Visibility = Visibility.Collapsed;
      if (template == null)
        return;
      foreach (KeyValuePair<int, string> keyValuePair in template)
      {
        if (keyValuePair.Key == 1)
        {
          this.TextExtCommandArgument_1.Visibility = Visibility.Visible;
          this.TextArgument_1_Label.Visibility = Visibility.Visible;
          this.TextArgument_1_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_1.ContextMenu = this.Argument1ValuesMenu;
        }
        if (keyValuePair.Key == 2)
        {
          this.TextExtCommandArgument_2.Visibility = Visibility.Visible;
          this.TextArgument_2_Label.Visibility = Visibility.Visible;
          this.TextArgument_2_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_2.ContextMenu = this.Argument2ValuesMenu;
        }
        if (keyValuePair.Key == 3)
        {
          this.TextExtCommandArgument_3.Visibility = Visibility.Visible;
          this.TextArgument_3_Label.Visibility = Visibility.Visible;
          this.TextArgument_3_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_3.ContextMenu = this.Argument3ValuesMenu;
        }
        if (keyValuePair.Key == 4)
        {
          this.TextExtCommandArgument_4.Visibility = Visibility.Visible;
          this.TextArgument_4_Label.Visibility = Visibility.Visible;
          this.TextArgument_4_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_4.ContextMenu = this.Argument4ValuesMenu;
        }
        if (keyValuePair.Key == 5)
        {
          this.TextExtCommandArgument_5.Visibility = Visibility.Visible;
          this.TextArgument_5_Label.Visibility = Visibility.Visible;
          this.TextArgument_5_Label.Content = (object) keyValuePair.Value;
          this.TextExtCommandArgument_5.ContextMenu = this.Argument5ValuesMenu;
        }
      }
    }

    private void mi_Click(object sender, RoutedEventArgs e)
    {
      ((TextBox) ((FrameworkElement) sender).Tag).Text = ((HeaderedItemsControl) sender).Header.ToString();
    }

    private async Task RunCommand()
    {
      string FC = this.ComboCommand.SelectedItem.ToString();
      string EFC = this.ComboExtCommand.SelectedItem.ToString();
      object addFC = this.ComboAddCommand.SelectedItem;
      string arg1 = string.IsNullOrEmpty(this.TextExtCommandArgument_1.Text) ? (string) null : this.TextExtCommandArgument_1.Text.Trim();
      string arg2 = string.IsNullOrEmpty(this.TextExtCommandArgument_2.Text) ? (string) null : this.TextExtCommandArgument_2.Text.Trim();
      string arg3 = string.IsNullOrEmpty(this.TextExtCommandArgument_3.Text) ? (string) null : this.TextExtCommandArgument_3.Text.Trim();
      string arg4 = string.IsNullOrEmpty(this.TextExtCommandArgument_4.Text) ? (string) null : this.TextExtCommandArgument_4.Text.Trim();
      string arg5 = string.IsNullOrEmpty(this.TextExtCommandArgument_5.Text) ? (string) null : this.TextExtCommandArgument_5.Text.Trim();
      try
      {
        if (FC.Contains("0x37"))
        {
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetNBIoTModulePartNumber))
          {
            byte[] retVal = await this.myNBIotCommands.GetNBIoT_ModulePartNumberAsync(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nNBIoT Module Part Number: " + Util.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetNBIoTFirmwareVersion))
          {
            byte[] retVal = await this.myNBIotCommands.GetNBIoT_FirmwareVersionAsync(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nNBIoT Firmware Version (Hex): " + Util.ByteArrayToHexString(retVal);
            string retString = Encoding.Default.GetString(retVal);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nNBIoT Firmware Version (String): " + retString;
            string[] retCut = retString.Split(new string[1]
            {
              "\r\n"
            }, StringSplitOptions.RemoveEmptyEntries);
            string[] strArray = retCut;
            for (int index = 0; index < strArray.Length; ++index)
            {
              string item = strArray[index];
              if (item.ToLower().Contains("revision"))
              {
                string[] reversion = item.Split(':');
                NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nNBIoT Firmware Version (Cut): " + reversion[1];
                reversion = (string[]) null;
              }
              item = (string) null;
            }
            strArray = (string[]) null;
            retVal = (byte[]) null;
            retString = (string) null;
            retCut = (string[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetNBIoTIMEI_NB))
          {
            byte[] retVal = await this.myNBIotCommands.GetNBIoT_IMEI_NBAsync(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nNBIoT IMEI: (Dec): " + Encoding.Default.GetString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetSIMIMSI_NB))
          {
            byte[] retVal = await this.myNBIotCommands.Get_SIM_IMSI_NBAsync(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nSIM IMSI (Dec): " + Encoding.Default.GetString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetSIMICCID_NB))
          {
            byte[] retVal = await this.myNBIotCommands.GetSIM_ICCID_NBAsync(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nSIM ICCID (Dec): " + Encoding.Default.GetString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetIMEI_IMSI_NBVER_RAM))
          {
            byte[] retVal = await this.myNBIotCommands.GetNBIoT_IMEI_IMSI_NBVER_RAMAsync(this.progress, this.cancelTokenSource.Token);
            if (retVal.Length >= 16)
            {
              byte[] imei = new byte[8];
              Array.Copy((Array) retVal, 0, (Array) imei, 0, 8);
              Array.Reverse((Array) imei);
              NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nIMEI (Hex): " + Util.ByteArrayToHexString(imei);
              byte[] imsi = new byte[8];
              Array.Copy((Array) retVal, 8, (Array) imsi, 0, 8);
              Array.Reverse((Array) imsi);
              NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nIMSI (Hex): " + Util.ByteArrayToHexString(imsi);
              if (retVal.Length > 16)
              {
                byte[] nbver = new byte[retVal.Length - 16];
                Array.Copy((Array) retVal, 16, (Array) nbver, 0, retVal.Length - 16);
                Array.Reverse((Array) nbver);
                NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nNBVer (String): " + Encoding.Default.GetString(nbver);
                nbver = (byte[]) null;
              }
              imei = (byte[]) null;
              imsi = (byte[]) null;
            }
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetICCID_IMSI_RAM))
          {
            byte[] retVal = await this.myNBIotCommands.GetNBIoT_ICCID_IMSI_RAMAsync(this.progress, this.cancelTokenSource.Token);
            if (retVal.Length >= 18)
            {
              byte[] iccid = new byte[10];
              Array.Copy((Array) retVal, 0, (Array) iccid, 0, 10);
              Array.Reverse((Array) iccid);
              NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nICCID (Hex): " + Util.ByteArrayToHexString(iccid);
              byte[] imsi = new byte[8];
              Array.Copy((Array) retVal, 10, (Array) imsi, 0, 8);
              Array.Reverse((Array) imsi);
              NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nIMSI (Hex): " + Util.ByteArrayToHexString(imsi);
              iccid = (byte[]) null;
              imsi = (byte[]) null;
            }
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetProtocol))
          {
            byte[] retVal = await this.myNBIotCommands.GetNBIoT_Protocol(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nProtocol: " + Util.ByteArrayToHexString(retVal);
            if (retVal.Length == 1 && retVal[0] == (byte) 1)
              NBIoTCommandWindow.result += "\nProtocol: CoAP";
            else if (retVal.Length == 1 && retVal[0] == (byte) 2)
              NBIoTCommandWindow.result += "\nProtocol: UDP";
            else if (retVal.Length == 1 && retVal[0] == (byte) 3)
              NBIoTCommandWindow.result += "\nProtocol: TCP";
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetProtocol))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              byte[] data = Util.HexStringToByteArray(arg1);
              if (data.Length == 1)
              {
                await this.myNBIotCommands.SetNBIoT_Protocol(data, this.progress, this.cancelTokenSource.Token);
                NBIoTCommandWindow.result += "\nSet NBIoT Protocol data succesfully sent to device.";
              }
              else
              {
                int num = (int) MessageBox.Show("To much bytes to send ... max. 1 Byte.\nPlease check the lenght of your bytearray.");
              }
              data = (byte[]) null;
            }
            else
            {
              int num1 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetBand))
          {
            byte[] retVal = await this.myNBIotCommands.GetNBIoT_Band(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nBand: " + Util.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetBand))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              byte[] data = Util.HexStringToByteArray(arg1);
              if (data.Length == 1)
              {
                await this.myNBIotCommands.SetNBIoT_Band(data, this.progress, this.cancelTokenSource.Token);
                NBIoTCommandWindow.result += "\nSet NBIoT Band data succesfully sent to device.";
              }
              else
              {
                int num2 = (int) MessageBox.Show("To much bytes to send ... max. 1 Byte.\nPlease check the lenght of your bytearray.");
              }
              data = (byte[]) null;
            }
            else
            {
              int num3 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetSecondaryBand))
          {
            byte[] retVal = await this.myNBIotCommands.GetNBIoT_SecondaryBand(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nSecondaryBand: " + Util.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetSecondaryBand))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              byte[] data = Util.HexStringToByteArray(arg1);
              if (data.Length == 1)
              {
                await this.myNBIotCommands.SetNBIoT_SecondaryBand(data, this.progress, this.cancelTokenSource.Token);
                NBIoTCommandWindow.result += "\nSet NBIoT Secondary Band data succesfully sent to device.";
              }
              else
              {
                int num4 = (int) MessageBox.Show("To much bytes to send ... max. 1 Byte.\nPlease check the lenght of your bytearray.");
              }
              data = (byte[]) null;
            }
            else
            {
              int num5 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetRemoteIP))
          {
            byte[] retVal = await this.myNBIotCommands.GetNBIoT_RemoteIP(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nRemote IP (Hex): " + Util.ByteArrayToHexString(retVal);
            if (retVal.Length == 4)
              NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nRemote IP (Dec): " + retVal[0].ToString() + "." + retVal[1].ToString() + "." + retVal[2].ToString() + "." + retVal[3].ToString();
            else
              NBIoTCommandWindow.result += "\nRemote IP data length is wrong";
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetRemoteIP))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              string[] inputStr = arg1.Split('.');
              if (inputStr.Length == 4)
              {
                byte[] data = new byte[4]
                {
                  Convert.ToByte(inputStr[0]),
                  Convert.ToByte(inputStr[1]),
                  Convert.ToByte(inputStr[2]),
                  Convert.ToByte(inputStr[3])
                };
                if (data.Length == 4)
                {
                  await this.myNBIotCommands.SetNBIoT_RemoteIP(data, this.progress, this.cancelTokenSource.Token);
                  NBIoTCommandWindow.result += "\nSet NBIoT Remote IP data succesfully sent to device.";
                }
                else
                {
                  int num6 = (int) MessageBox.Show("To much bytes to send ... max. 1 Byte.\nPlease check the lenght of your bytearray.");
                }
                data = (byte[]) null;
              }
              else
              {
                int num7 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
              }
              inputStr = (string[]) null;
            }
            else
            {
              int num8 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetRemotePort))
          {
            byte[] retVal = await this.myNBIotCommands.GetNBIoT_RemotePort(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nRemote Port (Hex): " + Util.ByteArrayToHexString(retVal);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nRemote Port (Dec): " + ((int) retVal[1] * 256 + (int) retVal[0]).ToString();
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetRemotePort))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              ushort decInt16 = Convert.ToUInt16(arg1);
              byte[] data = new byte[2]
              {
                (byte) ((uint) decInt16 & (uint) byte.MaxValue),
                (byte) ((int) decInt16 >> 8 & (int) byte.MaxValue)
              };
              await this.myNBIotCommands.SetNBIoT_RemotePort(data, this.progress, this.cancelTokenSource.Token);
              NBIoTCommandWindow.result += "\nSet NBIoT Coap Remote Port data succesfully sent to device.";
              data = (byte[]) null;
            }
            else
            {
              int num9 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetOperator))
            NBIoTCommandWindow.result += "\nGet Operator Is Not Released";
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetOperator))
            NBIoTCommandWindow.result += "\nSet Operator Is Not Released";
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetNBIoTPowerOn))
          {
            await this.myNBIotCommands.SetNBIoT_PowerON(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result += "\nSet NBIoT Power On succesfully sent to device.";
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetNBIoTPowerOff))
          {
            await this.myNBIotCommands.SetNBIoT_PowerOFF(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result += "\nSet NBIoT Power Off succesfully sent to device.";
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SendCommonCommand))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              byte[] data = Encoding.Default.GetBytes(arg1);
              if (data.Length > 2 && (double) data[0] == 65.0 && (double) data[1] == 84.0)
              {
                byte[] theData = await this.myNBIotCommands.NBIoT_CommonCommand(data, this.progress, this.cancelTokenSource.Token);
                NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nInfo:" + Encoding.Default.GetString(theData);
                theData = (byte[]) null;
              }
              else
              {
                int num10 = (int) MessageBox.Show("Please check the data of your input string.");
              }
              data = (byte[]) null;
            }
            else
            {
              int num11 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SendConfirmedData))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              byte[] data = Util.HexStringToByteArray(arg1);
              if (data.Length <= 50)
              {
                await this.myNBIotCommands.SendConfirmedDataAsync(data, this.progress, this.cancelTokenSource.Token);
                NBIoTCommandWindow.result += "\nConfirmed data succesfully sent to device.";
              }
              else
              {
                int num12 = (int) MessageBox.Show("To much bytes to send ... max. 50 Bytes.\nPlease check the lenght of your bytearray.");
              }
              data = (byte[]) null;
            }
            else
            {
              int num13 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SendUnconfirmedData))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              byte[] data = Util.HexStringToByteArray(arg1);
              if (data.Length <= 50)
              {
                await this.myNBIotCommands.SendUnconfirmedDataAsync(data, this.progress, this.cancelTokenSource.Token);
                NBIoTCommandWindow.result += "\nUnconfirmed data succesfully sent to device.";
              }
              else
              {
                int num14 = (int) MessageBox.Show("To much bytes to send ... max. 50 Bytes.\nPlease check the lenght of your bytearray.");
              }
              data = (byte[]) null;
            }
            else
            {
              int num15 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetTransmissionScenario))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              byte[] data = Util.HexStringToByteArray(arg1);
              await this.myNBIotCommands.SetTransmissionScenarioAsync(data, this.progress, this.cancelTokenSource.Token);
              NBIoTCommandWindow.result += "\nTransmission scenario successfully set.";
              data = (byte[]) null;
            }
            else
            {
              int num16 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetTransmissionScenario))
          {
            byte retVal = await this.myNBIotCommands.GetTransmissionScenarioAsync(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nTransmission scenario: " + retVal.ToString();
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetDeviceEUI))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              byte[] data = Util.HexStringToByteArray(arg1);
              await this.myNBIotCommands.SetDevEUIAsync(data, this.progress, this.cancelTokenSource.Token);
              NBIoTCommandWindow.result += "\nDevice EUI successfully sent to device.";
              data = (byte[]) null;
            }
            else
            {
              int num17 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetDeviceEUI))
          {
            byte[] retVal = await this.myNBIotCommands.GetDevEUIAsync(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nDevice EUI: " + Util.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SendTestData))
          {
            byte[] retVal = await this.myNBIotCommands.NBIoT_SendTestData(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\n(Send Test Data)The back info: " + retVal?.ToString();
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SendRadioFullFunctionOn))
          {
            byte[] ReturnData = await this.myNBIotCommands.SetNBIoT_RadioFullFunctionOn(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nReturn:" + Encoding.Default.GetString(ReturnData);
            ReturnData = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SendRadioFullFunctionOff))
          {
            byte[] ReturnData = await this.myNBIotCommands.SetNBIoT_RadioFullFunctionOff(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nReturn:" + Encoding.Default.GetString(ReturnData);
            ReturnData = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SendActivePacket))
          {
            await this.myNBIotCommands.NBIoT_SendActivePacket(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result += "\nActive Packet succesfully sent to device.";
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetDNSName))
          {
            byte[] retVal = await this.myNBIotCommands.GetDNSNameAsync(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nDNS Name: " + Encoding.Default.GetString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetDNSName))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              this.updateContextMenu1(arg1);
              byte[] data = Encoding.Default.GetBytes(arg1);
              if (data.Length > 1)
              {
                await this.myNBIotCommands.SetDNSNameAsync(data, this.progress, this.cancelTokenSource.Token);
                NBIoTCommandWindow.result += "\nDNS Name successfully sent to device.";
              }
              else
              {
                int num18 = (int) MessageBox.Show("Please check the data of your input string.");
              }
              data = (byte[]) null;
            }
            else
            {
              int num19 = (int) MessageBox.Show("Wrong input string format found.\nPlease check your input string.");
            }
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetRadioSendingState))
          {
            byte[] retVal = await this.myNBIotCommands.GetRadioSendingState(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nRadioSendingState: " + Util.ByteArrayToHexString(retVal);
            retVal = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_RestNBModem))
          {
            byte Data = 0;
            if (!string.IsNullOrEmpty(arg1))
            {
              byte[] ConvertData = Util.HexStringToByteArray(arg1);
              if (ConvertData.Length > 1 || ConvertData.Length == 0)
              {
                int num20 = (int) MessageBox.Show("Wrong Argument");
                FC = (string) null;
                EFC = (string) null;
                addFC = (object) null;
                arg1 = (string) null;
                arg2 = (string) null;
                arg3 = (string) null;
                arg4 = (string) null;
                arg5 = (string) null;
                return;
              }
              Data = ConvertData[0];
              ConvertData = (byte[]) null;
            }
            byte[] ReturnData = await this.myNBIotCommands.ResetNBModem(this.progress, this.cancelTokenSource.Token, Data);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nRetrun:" + Encoding.Default.GetString(ReturnData);
            ReturnData = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetNBModemAutoConnect))
          {
            byte[] ReturnData = await this.myNBIotCommands.SetNBModemManualOrAutoConnect((byte) 0, this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nReturn:" + Encoding.Default.GetString(ReturnData);
            ReturnData = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetNBModemManualConnect))
          {
            byte[] ReturnData = await this.myNBIotCommands.SetNBModemManualOrAutoConnect((byte) 1, this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nReturn:" + Encoding.Default.GetString(ReturnData);
            ReturnData = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetNBModemAPN))
          {
            byte[] APN = new byte[0];
            if (!string.IsNullOrEmpty(arg1))
            {
              byte[] ConvertData = Encoding.Default.GetBytes(arg1);
              if (ConvertData.Length == 0)
              {
                int num21 = (int) MessageBox.Show("Wrong Argument");
                FC = (string) null;
                EFC = (string) null;
                addFC = (object) null;
                arg1 = (string) null;
                arg2 = (string) null;
                arg3 = (string) null;
                arg4 = (string) null;
                arg5 = (string) null;
                return;
              }
              APN = ConvertData;
              await this.myNBIotCommands.SetNBModemAPN(APN, this.progress, this.cancelTokenSource.Token);
              NBIoTCommandWindow.result += "\nSet NB modem APN: Success";
              ConvertData = (byte[]) null;
              APN = (byte[]) null;
            }
            else
            {
              int num22 = (int) MessageBox.Show("Wrong Argument");
              FC = (string) null;
              EFC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              arg4 = (string) null;
              arg5 = (string) null;
              return;
            }
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetNBModemAPN))
          {
            byte[] ReturnData = await this.myNBIotCommands.GetNBModemAPN(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nGet NB modem APN:" + Encoding.Default.GetString(ReturnData);
            ReturnData = (byte[]) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetDNSServerIP))
          {
            List<byte> ServerIPBytes = new List<byte>();
            string FailString = string.Empty;
            byte[] IP;
            if (!this.ConvertFromIPString(arg1, out IP, out FailString))
            {
              NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nSet DNS Server IP: Failed" + Environment.NewLine + FailString;
              FC = (string) null;
              EFC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              arg4 = (string) null;
              arg5 = (string) null;
              return;
            }
            ServerIPBytes.AddRange((IEnumerable<byte>) IP);
            if (!this.ConvertFromIPString(arg2, out IP, out FailString))
            {
              NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nSet DNS Server IP: Failed" + Environment.NewLine + FailString;
              FC = (string) null;
              EFC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              arg4 = (string) null;
              arg5 = (string) null;
              return;
            }
            ServerIPBytes.AddRange((IEnumerable<byte>) IP);
            await this.myNBIotCommands.SetDNSServerIP(ServerIPBytes.ToArray(), this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result += "\nSet DNS Server IP: Success";
            ServerIPBytes = (List<byte>) null;
            IP = (byte[]) null;
            FailString = (string) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetDNSServerIP))
          {
            byte[] ServerIPBytes = await this.myNBIotCommands.GetDNSServerIP(this.progress, this.cancelTokenSource.Token);
            string IPString;
            string FailString;
            if (!this.ConvertToIPString(((IEnumerable<byte>) ServerIPBytes).Take<byte>(4).ToArray<byte>(), out IPString, out FailString))
            {
              NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nGet DNS Server IP: Failed" + Environment.NewLine + FailString;
              FC = (string) null;
              EFC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              arg4 = (string) null;
              arg5 = (string) null;
              return;
            }
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nPrimary DNS Server IP: " + IPString;
            if (!this.ConvertToIPString(((IEnumerable<byte>) ServerIPBytes).Skip<byte>(4).Take<byte>(4).ToArray<byte>(), out IPString, out FailString))
            {
              NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nGet DNS Server IP: Failed" + Environment.NewLine + FailString;
              FC = (string) null;
              EFC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              arg4 = (string) null;
              arg5 = (string) null;
              return;
            }
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nSecondary DNS Server IP: " + IPString;
            ServerIPBytes = (byte[]) null;
            IPString = (string) null;
            FailString = (string) null;
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetDNSEnableByte))
          {
            byte b;
            if (!byte.TryParse(arg1, out b))
            {
              NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nSet DNS Enable Byte: Faled" + Environment.NewLine + "Can not convert to byte";
              FC = (string) null;
              EFC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              arg4 = (string) null;
              arg5 = (string) null;
              return;
            }
            await this.myNBIotCommands.SetDNSEnableByte(b, this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result += "\nSet DNS Enable Byte: Success";
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetDNSEnableByte))
          {
            byte b = await this.myNBIotCommands.GetDNSEnableByte(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nGet DNS Enable Byte: " + b.ToString();
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_SetAPNEnableByte))
          {
            byte b;
            if (!byte.TryParse(arg1, out b))
            {
              NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nSet APN Enable Byte: Faled" + Environment.NewLine + "Can not convert to byte";
              FC = (string) null;
              EFC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              arg4 = (string) null;
              arg5 = (string) null;
              return;
            }
            if (b != (byte) 0 && b != (byte) 1)
            {
              NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nSet APN Enable Byte: Faled" + Environment.NewLine + "Only 0 or 1 is permitted";
              FC = (string) null;
              EFC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              arg4 = (string) null;
              arg5 = (string) null;
              return;
            }
            await this.myNBIotCommands.SetAPNEanbleByte(b, this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result += "\nSet APN Enable Byte: Success";
          }
          if (EFC.Contains(NBIoTCommandWindow.CMD_GetAPNEnableByte))
          {
            byte b = await this.myNBIotCommands.GetAPNEnabledByte(this.progress, this.cancelTokenSource.Token);
            NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nGet APN Enable Byte: " + b.ToString();
            NBIoTCommandWindow.result += "\n(0 : Will set the APN)";
            NBIoTCommandWindow.result += "\n(1 : Will not set the APN during sending procedure)";
          }
        }
        if (string.IsNullOrEmpty(NBIoTCommandWindow.result))
        {
          FC = (string) null;
          EFC = (string) null;
          addFC = (object) null;
          arg1 = (string) null;
          arg2 = (string) null;
          arg3 = (string) null;
          arg4 = (string) null;
          arg5 = (string) null;
        }
        else
        {
          this.TextBoxUniversalCommandResult.Text = NBIoTCommandWindow.result;
          FC = (string) null;
          EFC = (string) null;
          addFC = (object) null;
          arg1 = (string) null;
          arg2 = (string) null;
          arg3 = (string) null;
          arg4 = (string) null;
          arg5 = (string) null;
        }
      }
      catch (Exception ex)
      {
        NBIoTCommandWindow.result = NBIoTCommandWindow.result + "\nFunction (" + EFC + ") \nERROR: " + ex.Message;
        this.TextBoxUniversalCommandResult.Text = NBIoTCommandWindow.result;
        FC = (string) null;
        EFC = (string) null;
        addFC = (object) null;
        arg1 = (string) null;
        arg2 = (string) null;
        arg3 = (string) null;
        arg4 = (string) null;
        arg5 = (string) null;
      }
    }

    private void updateContextMenu1(string packet)
    {
      if (!this.Argument1_last_values.Contains(packet))
        this.Argument1_last_values.Add(packet);
      this.Argument1ValuesMenu.Items.Clear();
      if (this.Argument1_last_values.Count > 20)
        this.Argument1_last_values.RemoveRange(0, this.Argument1_last_values.Count - 20);
      foreach (string argument1LastValue in this.Argument1_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument1LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_1;
        this.Argument1ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu2(string packet)
    {
      if (!this.Argument2_last_values.Contains(packet))
        this.Argument2_last_values.Add(packet);
      this.Argument2ValuesMenu.Items.Clear();
      if (this.Argument2_last_values.Count > 20)
        this.Argument2_last_values.RemoveRange(0, this.Argument2_last_values.Count - 20);
      foreach (string argument2LastValue in this.Argument2_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument2LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_2;
        this.Argument2ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu3(string packet)
    {
      if (!this.Argument3_last_values.Contains(packet))
        this.Argument3_last_values.Add(packet);
      this.Argument3ValuesMenu.Items.Clear();
      if (this.Argument3_last_values.Count > 20)
        this.Argument3_last_values.RemoveRange(0, this.Argument3_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_3;
        this.Argument3ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu4(string packet)
    {
      if (!this.Argument4_last_values.Contains(packet))
        this.Argument4_last_values.Add(packet);
      this.Argument4ValuesMenu.Items.Clear();
      if (this.Argument4_last_values.Count > 20)
        this.Argument4_last_values.RemoveRange(0, this.Argument4_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_4;
        this.Argument4ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu5(string packet)
    {
      if (!this.Argument5_last_values.Contains(packet))
        this.Argument5_last_values.Add(packet);
      this.Argument5ValuesMenu.Items.Clear();
      if (this.Argument5_last_values.Count > 20)
        this.Argument5_last_values.RemoveRange(0, this.Argument5_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_5;
        this.Argument5ValuesMenu.Items.Add((object) newItem);
      }
    }

    private bool ConvertFromIPString(string IPString, out byte[] IPBytes, out string FailString)
    {
      IPBytes = new byte[4];
      FailString = "IP Format Wrong";
      if (string.IsNullOrEmpty(IPString))
        return false;
      string[] strArray = IPString.Split(".".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
      if (strArray.Length != 4)
        return false;
      for (int index = 0; index < 4; ++index)
      {
        byte result = 0;
        if (!byte.TryParse(strArray[index], out result))
          return false;
        IPBytes[index] = result;
      }
      FailString = string.Empty;
      return true;
    }

    private bool ConvertToIPString(byte[] IPBytes, out string IPString, out string FailString)
    {
      IPString = string.Empty;
      FailString = string.Empty;
      if (IPBytes.Length != 4)
      {
        FailString = "IP Byte Array Wrong";
        return false;
      }
      for (int index = 0; index < 4; ++index)
      {
        if (index > 0)
          IPString += ".";
        IPString += IPBytes[index].ToString();
      }
      return true;
    }

    private void CheckBoxEncryption_Checked(object sender, RoutedEventArgs e)
    {
      this.myNBIotCommands.enDeCrypt = true;
      this.TextBoxEncryptionKey.Visibility = Visibility.Visible;
      this.EncryptionKey_Label.Visibility = Visibility.Visible;
    }

    private void CheckBoxEncryption_UnChecked(object sender, RoutedEventArgs e)
    {
      this.myNBIotCommands.enDeCrypt = false;
      this.TextBoxEncryptionKey.Visibility = Visibility.Collapsed;
      this.EncryptionKey_Label.Visibility = Visibility.Collapsed;
    }

    private void TextBoxEncryptionKey_TextChanged(object sender, TextChangedEventArgs e)
    {
      this.myNBIotCommands.AES_Key = this.TextBoxEncryptionKey.Text;
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/commandwindownbiot.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.TextBlockStatus = (TextBlock) target;
          break;
        case 2:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        case 3:
          this.TextBoxUniversalCommandResult = (TextBox) target;
          break;
        case 4:
          this.StackPanalButtons = (StackPanel) target;
          break;
        case 5:
          this.ComboCommand = (ComboBox) target;
          this.ComboCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboCommand_SelectionChanged);
          break;
        case 6:
          this.CheckBoxEncryption = (CheckBox) target;
          this.CheckBoxEncryption.Checked += new RoutedEventHandler(this.CheckBoxEncryption_Checked);
          this.CheckBoxEncryption.Unchecked += new RoutedEventHandler(this.CheckBoxEncryption_UnChecked);
          break;
        case 7:
          this.EncryptionKey_Label = (Label) target;
          break;
        case 8:
          this.TextBoxEncryptionKey = (TextBox) target;
          this.TextBoxEncryptionKey.TextChanged += new TextChangedEventHandler(this.TextBoxEncryptionKey_TextChanged);
          break;
        case 9:
          this.ComboExtCommand_Label = (Label) target;
          break;
        case 10:
          this.ComboExtCommand = (ComboBox) target;
          this.ComboExtCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboExtCommand_SelectionChanged);
          break;
        case 11:
          this.ComboAddCommand_Label = (Label) target;
          break;
        case 12:
          this.ComboAddCommand = (ComboBox) target;
          this.ComboAddCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboAddCommand_SelectionChanged);
          break;
        case 13:
          this.TextArgument_1_Label = (Label) target;
          break;
        case 14:
          this.TextExtCommandArgument_1 = (TextBox) target;
          break;
        case 15:
          this.TextArgument_2_Label = (Label) target;
          break;
        case 16:
          this.TextExtCommandArgument_2 = (TextBox) target;
          break;
        case 17:
          this.TextArgument_3_Label = (Label) target;
          break;
        case 18:
          this.TextExtCommandArgument_3 = (TextBox) target;
          break;
        case 19:
          this.TextArgument_4_Label = (Label) target;
          break;
        case 20:
          this.TextExtCommandArgument_4 = (TextBox) target;
          break;
        case 21:
          this.TextArgument_5_Label = (Label) target;
          break;
        case 22:
          this.TextExtCommandArgument_5 = (TextBox) target;
          break;
        case 23:
          this.StackPanalButtons2 = (StackPanel) target;
          break;
        case 24:
          this.ButtonRunCommand = (Button) target;
          this.ButtonRunCommand.Click += new RoutedEventHandler(this.ButtonRunCommand_Click);
          break;
        case 25:
          this.ButtonRunCommandPreview = (Button) target;
          this.ButtonRunCommandPreview.Click += new RoutedEventHandler(this.ButtonRunCommandPreview_Click);
          break;
        case 26:
          this.ButtonBreak = (Button) target;
          this.ButtonBreak.Click += new RoutedEventHandler(this.ButtonBreak_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- NFC_Test.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NFC_Test
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.Functions;
using HandlerLib.NFC;
using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class NFC_Test : Window, IComponentConnector
  {
    private ProgressHandler progress;
    private CancellationTokenSource cancelTokenSource;
    private NfcRepeater myNfcRepeater;
    private NfcDeviceCommands myCommands;
    private NfcSubunitCommands mySubunitCommands;
    private MiConConnector myMiConConnector;
    internal Button BtnCouplerEcho;
    internal Button BtnCouplerIdent;
    internal Button BtnCouplerRfOff;
    internal Button BtnResetDevice;
    internal Button BtnCouplerRfOn;
    internal Button BtnNDCUSBStartBootloader;
    internal Button BtnNfcAntiCol;
    internal Button BtnNfcGetTagIdent;
    internal Button BtnGetTagStatus;
    internal Button BtnSend;
    internal TextBox TxBxTxDataLen;
    internal TextBox TxBxTxData;
    internal TextBox TxBxCRCData;
    internal TextBox TxBxRxData;
    internal TextBox TxBxRxDataLen;
    internal TextBox TxBxRxCRCData;
    internal Button BtnToggleRf;
    internal CheckBox CheckLoop;
    internal TextBox TxtBxTimeRFOn;
    internal TextBox TxtBxTimeRFOff;
    internal TextBox TxBxResult;
    internal TextBox TxBxResult_HEX;
    private bool _contentLoaded;

    public NFC_Test(CommunicationPortFunctions myPort)
    {
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
      this.cancelTokenSource = new CancellationTokenSource();
      this.myNfcRepeater = new NfcRepeater(myPort);
      this.myCommands = new NfcDeviceCommands(myPort);
      this.mySubunitCommands = this.myCommands.mySubunitCommands;
      this.myMiConConnector = new MiConConnector(this.myCommands);
      this.InitializeComponent();
    }

    private void OnProgress(ProgressArg obj)
    {
      if (this.CheckAccess())
        return;
      this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
    }

    private void ButtonX_Click(object sender, RoutedEventArgs e) => this.Run_Button(sender);

    private async void Run_Button(object sender)
    {
      try
      {
        byte[] response;
        if (sender == this.BtnCouplerEcho)
        {
          string hex = await this.mySubunitCommands.GetEchoAsync(this.progress, this.cancelTokenSource.Token);
          response = Util.HexStringToByteArray(hex);
          hex = (string) null;
          this.Fill_TxtBx(response);
        }
        else if (sender == this.BtnCouplerIdent)
        {
          string hex = await this.mySubunitCommands.ReadIdentificationAsync(this.progress, this.cancelTokenSource.Token);
          response = Util.HexStringToByteArray(hex);
          hex = (string) null;
          this.Fill_TxtBx(response);
        }
        else if (sender == this.BtnCouplerRfOff)
        {
          response = await this.mySubunitCommands.SetRfOffAsync(this.progress, this.cancelTokenSource.Token);
          this.Fill_TxtBx(response);
        }
        else if (sender == this.BtnCouplerRfOn)
        {
          response = await this.mySubunitCommands.SetRfOnAsync(this.progress, this.cancelTokenSource.Token);
          this.Fill_TxtBx(response);
        }
        else if (sender == this.BtnNDCUSBStartBootloader)
        {
          response = await this.mySubunitCommands.NDC_USB_StartBootloader(this.progress, this.cancelTokenSource.Token);
          this.Fill_TxtBx(response);
        }
        else if (sender == this.BtnNfcAntiCol)
        {
          response = await this.mySubunitCommands.NFC_AnticollisionAsync(this.progress, this.cancelTokenSource.Token);
          this.Fill_TxtBx(response);
        }
        else if (sender == this.BtnNfcGetTagIdent)
        {
          response = await this.mySubunitCommands.NFC_GetTagIdentAsync(this.progress, this.cancelTokenSource.Token);
          this.Fill_TxtBx(response);
        }
        else if (sender == this.BtnGetTagStatus)
        {
          response = await this.mySubunitCommands.NFC_GetTagStatusAsync(this.progress, this.cancelTokenSource.Token);
          this.Fill_TxtBx(response);
        }
        else if (sender == this.BtnToggleRf)
        {
          this.BtnToggleRf.IsEnabled = false;
          int TimeOn = (int) Convert.ToInt16(this.TxtBxTimeRFOn.Text);
          int TimeOff = (int) Convert.ToInt16(this.TxtBxTimeRFOff.Text);
          ulong loops = 0;
          bool? isChecked;
          bool flag;
          do
          {
            byte[] numArray1 = await this.mySubunitCommands.SetRfOnAsync(this.progress, this.cancelTokenSource.Token);
            await Task.Delay(TimeOn);
            byte[] numArray2 = await this.mySubunitCommands.SetRfOffAsync(this.progress, this.cancelTokenSource.Token);
            await Task.Delay(TimeOff);
            ++loops;
            this.TxBxResult.Text = "Loops = " + loops.ToString();
            isChecked = this.CheckLoop.IsChecked;
            flag = true;
          }
          while (isChecked.GetValueOrDefault() == flag & isChecked.HasValue);
          this.BtnToggleRf.IsEnabled = true;
        }
        else if (sender == this.BtnResetDevice)
          await this.myMiConConnector.ResetDevice(this.progress, this.cancelTokenSource.Token);
        else if (sender == this.BtnSend)
        {
          byte[] locDATA = Util.HexStringToByteArray(this.TxBxTxDataLen.Text + this.TxBxTxData.Text + this.TxBxCRCData.Text);
          NfcFrame mylocNFCFrame = new NfcFrame(locDATA, this.myNfcRepeater.myConfig.ReadingChannelIdentification);
          await this.myNfcRepeater.GetResultFrameAsync(mylocNFCFrame, this.progress, this.cancelTokenSource.Token);
          this.Fill_TxtBx(mylocNFCFrame.NfcResponseFrame);
          locDATA = (byte[]) null;
          mylocNFCFrame = (NfcFrame) null;
        }
        response = (byte[]) null;
      }
      catch (NfcFrameException ex)
      {
        this.TxBxResult.Text = ex.Message;
      }
      catch (TimeoutException ex)
      {
        this.TxBxResult.Text = ex.Message;
      }
    }

    private void TxBxTxData_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (this.TxBxTxData.Text.Length % 2 != 0)
        return;
      this.TxBxTxDataLen.Text = (this.TxBxTxData.Text.Length / 2).ToString("X2");
      ushort crc = NfcFrame.createCRC(Util.HexStringToByteArray(this.TxBxTxDataLen.Text + this.TxBxTxData.Text + "0000"), new ushort?(ushort.MaxValue));
      TextBox txBxCrcData = this.TxBxCRCData;
      byte num = (byte) crc;
      string str1 = num.ToString("X2");
      num = (byte) ((uint) crc >> 8);
      string str2 = num.ToString("X2");
      string str3 = str1 + str2;
      txBxCrcData.Text = str3;
    }

    private void Fill_TxtBx(byte[] frame)
    {
      this.TxBxRxDataLen.Text = frame[0].ToString("X2");
      this.TxBxRxData.Text = Util.ByteArrayToHexString(frame, 1, frame.Length - 3);
      this.TxBxRxCRCData.Text = Util.ByteArrayToHexString(frame, frame.Length - 2, 2);
      this.TxBxResult.Text = Encoding.ASCII.GetString(frame);
      this.TxBxResult_HEX.Text = Util.ByteArrayToHexString(frame, 0, frame.Length);
    }

    private void TxBxTxData_KeyDown(object sender, KeyEventArgs e)
    {
      if (e.Key != Key.Return)
        return;
      this.Run_Button((object) this.BtnSend);
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/nfc_test.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.BtnCouplerEcho = (Button) target;
          this.BtnCouplerEcho.Click += new RoutedEventHandler(this.ButtonX_Click);
          break;
        case 2:
          this.BtnCouplerIdent = (Button) target;
          this.BtnCouplerIdent.Click += new RoutedEventHandler(this.ButtonX_Click);
          break;
        case 3:
          this.BtnCouplerRfOff = (Button) target;
          this.BtnCouplerRfOff.Click += new RoutedEventHandler(this.ButtonX_Click);
          break;
        case 4:
          this.BtnResetDevice = (Button) target;
          this.BtnResetDevice.Click += new RoutedEventHandler(this.ButtonX_Click);
          break;
        case 5:
          this.BtnCouplerRfOn = (Button) target;
          this.BtnCouplerRfOn.Click += new RoutedEventHandler(this.ButtonX_Click);
          break;
        case 6:
          this.BtnNDCUSBStartBootloader = (Button) target;
          this.BtnNDCUSBStartBootloader.Click += new RoutedEventHandler(this.ButtonX_Click);
          break;
        case 7:
          this.BtnNfcAntiCol = (Button) target;
          this.BtnNfcAntiCol.Click += new RoutedEventHandler(this.ButtonX_Click);
          break;
        case 8:
          this.BtnNfcGetTagIdent = (Button) target;
          this.BtnNfcGetTagIdent.Click += new RoutedEventHandler(this.ButtonX_Click);
          break;
        case 9:
          this.BtnGetTagStatus = (Button) target;
          this.BtnGetTagStatus.Click += new RoutedEventHandler(this.ButtonX_Click);
          break;
        case 10:
          this.BtnSend = (Button) target;
          this.BtnSend.Click += new RoutedEventHandler(this.ButtonX_Click);
          break;
        case 11:
          this.TxBxTxDataLen = (TextBox) target;
          break;
        case 12:
          this.TxBxTxData = (TextBox) target;
          this.TxBxTxData.TextChanged += new TextChangedEventHandler(this.TxBxTxData_TextChanged);
          this.TxBxTxData.KeyDown += new KeyEventHandler(this.TxBxTxData_KeyDown);
          break;
        case 13:
          this.TxBxCRCData = (TextBox) target;
          break;
        case 14:
          this.TxBxRxData = (TextBox) target;
          break;
        case 15:
          this.TxBxRxDataLen = (TextBox) target;
          break;
        case 16:
          this.TxBxRxCRCData = (TextBox) target;
          break;
        case 17:
          this.BtnToggleRf = (Button) target;
          this.BtnToggleRf.Click += new RoutedEventHandler(this.ButtonX_Click);
          break;
        case 18:
          this.CheckLoop = (CheckBox) target;
          break;
        case 19:
          this.TxtBxTimeRFOn = (TextBox) target;
          break;
        case 20:
          this.TxtBxTimeRFOff = (TextBox) target;
          break;
        case 21:
          this.TxBxResult = (TextBox) target;
          break;
        case 22:
          this.TxBxResult_HEX = (TextBox) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- NfcDeviceCommands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NfcDeviceCommands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.Functions;
using HandlerLib.NFC;
using NLog;
using StartupLib;
using System;
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class NfcDeviceCommands : IZRCommand
  {
    public static Logger Base_DeviceCommandsLogger = LogManager.GetLogger("DeviceCommandsNFC");
    public ChannelLogger DeviceCommandsLogger;
    private NfcDeviceIdentification connectedDeviceVersion;
    public static byte[] FillData = new byte[2]
    {
      (byte) 90,
      (byte) 165
    };
    private bool ReadOnly = false;
    public bool NFC_BlockMode = true;

    public CommunicationPortFunctions Port { get; private set; }

    public NfcRepeater myNfcRepeater { get; set; }

    public NfcFrame nfcFrame { get; set; }

    public NfcMemoryTransceiver myNfcMemoryTransceiver { get; set; }

    public NfcSubunitCommands mySubunitCommands { get; set; }

    public bool useSubUnitCommands { get; set; }

    public NfcDeviceIdentification ConnectedDeviceVersion
    {
      get => this.connectedDeviceVersion;
      set => this.connectedDeviceVersion = value;
    }

    public byte[] ConnectedReducedID { get; private set; }

    public bool IsDeviceIdentified => this.ConnectedDeviceVersion != null;

    public NfcDeviceCommands(CommunicationPortFunctions port)
    {
      if (port == null)
        throw new ArgumentNullException(nameof (port));
      this.useSubUnitCommands = false;
      this.Port = port;
      this.myNfcRepeater = new NfcRepeater(port);
      this.mySubunitCommands = new NfcSubunitCommands(port);
      this.myNfcMemoryTransceiver = new NfcMemoryTransceiver(this.myNfcRepeater);
      this.ReadOnly = UserManager.CheckPermission(UserManager.Right_ReadOnly);
      this.DeviceCommandsLogger = new ChannelLogger(NfcDeviceCommands.Base_DeviceCommandsLogger, this.myNfcRepeater.myConfig);
    }

    public void SetIdentificationLikeInFirmware(
      uint serialNumberBCD,
      ushort manufacturerCode,
      byte generation,
      byte mediumCode)
    {
      this.CheckReadOnly();
      this.DeviceCommandsLogger.Debug(nameof (SetIdentificationLikeInFirmware));
      this.ConnectedDeviceVersion = new NfcDeviceIdentification(serialNumberBCD, manufacturerCode, generation, mediumCode);
    }

    private void CheckReadOnly()
    {
      if (this.ReadOnly)
        throw new Exception("Right ReadOnly is set");
    }

    public async Task<DeviceIdentification> ReadVersionAsync(
      ProgressHandler progress,
      CancellationToken token)
    {
      this.DeviceCommandsLogger.Debug(nameof (ReadVersionAsync));
      NfcDeviceIdentification nfcDVI = new NfcDeviceIdentification();
      this.myNfcRepeater.ClearCrcInitValue();
      this.nfcFrame = new NfcFrame(NfcCommands.GetIdentification, this.myNfcRepeater.myConfig.ReadingChannelIdentification);
      await this.myNfcRepeater.GetResultFrameAsync(this.nfcFrame, progress, token);
      nfcDVI = new NfcDeviceIdentification(this.nfcFrame.NfcResponseFrame);
      this.myNfcRepeater.SetCrcInitValue(nfcDVI.MeterID.Value);
      this.ConnectedDeviceVersion = nfcDVI;
      this.myNfcMemoryTransceiver.MaxBufferSize = this.NFC_BlockMode && this.ConnectedDeviceVersion.FirmwareVersion.Value >= 17039366U ? (this.myNfcRepeater.IrDaCommands == null && this.myNfcRepeater.IrDaWrapper == 0 ? 512U : 220U) : 64U;
      DeviceIdentification deviceIdentification = (DeviceIdentification) nfcDVI;
      nfcDVI = (NfcDeviceIdentification) null;
      return deviceIdentification;
    }

    public async Task ReadMemoryAsync(
      AddressRange addressRange,
      DeviceMemory deviceMemory,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug("ReadMemoryAsync " + addressRange.ToString());
      byte[] readData = await this.myNfcMemoryTransceiver.ReadMemoryAsync(addressRange.StartAddress, addressRange.ByteSize, progress, cancelToken);
      deviceMemory.SetData(addressRange.StartAddress, readData);
      readData = (byte[]) null;
    }

    public async Task WriteMemoryAsync(
      AddressRange addressRange,
      DeviceMemory deviceMemory,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug("WriteMemoryAsync " + addressRange.ToString());
      this.CheckReadOnly();
      byte[] writeData = deviceMemory.GetData(addressRange);
      if (writeData == null)
        throw new Exception("Write data not complete for AddressRange: " + addressRange.ToString());
      byte[] numArray = await this.myNfcMemoryTransceiver.WriteMemoryAsync(addressRange.StartAddress, writeData, progress, cancelToken);
      writeData = (byte[]) null;
    }

    public async Task<byte[]> ReadMemoryAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      uint startAdress,
      uint size)
    {
      this.DeviceCommandsLogger.Debug(nameof (ReadMemoryAsync));
      if (!this.useSubUnitCommands)
      {
        byte[] numArray = await this.myNfcMemoryTransceiver.ReadMemoryAsync(startAdress, size, progress, cancelToken);
        return numArray;
      }
      byte[] numArray1 = await this.mySubunitCommands.ReadNdcMemory_Async(startAdress, size, progress, cancelToken);
      return numArray1;
    }

    public async Task WriteMemoryAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      uint startAdress,
      byte[] bytes)
    {
      this.DeviceCommandsLogger.Debug(nameof (WriteMemoryAsync));
      this.CheckReadOnly();
      if (bytes == null)
        throw new Exception("Write data not complete for AddressRange: " + startAdress.ToString());
      byte[] numArray = await this.myNfcMemoryTransceiver.WriteMemoryAsync(startAdress, bytes, progress, cancelToken);
    }

    public async Task ResetDeviceAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      bool loadBackup = false)
    {
      this.DeviceCommandsLogger.Debug(nameof (ResetDeviceAsync));
      NfcFrame nfcFrame;
      if (loadBackup)
        nfcFrame = new NfcFrame(NfcCommands.ResetDevice, new byte[1]
        {
          (byte) 1
        }, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      else
        nfcFrame = new NfcFrame(NfcCommands.ResetDevice, new byte[1], this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.TransmitFrameAsync(nfcFrame, progress, cancelToken);
      nfcFrame = (NfcFrame) null;
    }

    public async Task BackupDeviceAsync(ProgressHandler progress, CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug(nameof (BackupDeviceAsync));
      NfcFrame nfcFrame = new NfcFrame(NfcCommands.SaveBackup, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      nfcFrame = (NfcFrame) null;
    }

    public async Task UnlockDevice(
      uint key,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug(nameof (UnlockDevice));
      this.CheckReadOnly();
      byte[] data = BitConverter.GetBytes(key);
      NfcFrame nfcFrame = new NfcFrame(NfcCommands.UnlockDevice, data, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      data = (byte[]) null;
      nfcFrame = (NfcFrame) null;
    }

    public async Task LockDevice(uint key, ProgressHandler progress, CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug(nameof (LockDevice));
      this.CheckReadOnly();
      byte[] data = BitConverter.GetBytes(key);
      NfcFrame nfcFrame = new NfcFrame(NfcCommands.LockDevice, data, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      data = (byte[]) null;
      nfcFrame = (NfcFrame) null;
    }

    public async Task<byte[]> VerifyMemoryAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      uint startAddress,
      uint endAddress)
    {
      this.DeviceCommandsLogger.Debug("verifyMemory");
      List<byte> ldata = new List<byte>();
      ldata.Add((byte) 4);
      ldata.AddRange((IEnumerable<byte>) BitConverter.GetBytes(startAddress));
      ldata.AddRange((IEnumerable<byte>) BitConverter.GetBytes(endAddress));
      byte[] data = ldata.ToArray();
      NfcFrame nfcFrame = new NfcFrame(NfcCommands.ChecksumManagement, data, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      byte[] nfcResponseFrame = nfcFrame.NfcResponseFrame;
      ldata = (List<byte>) null;
      data = (byte[]) null;
      nfcFrame = (NfcFrame) null;
      return nfcResponseFrame;
    }

    public async Task<byte[]> StandardCommandAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      NfcCommands command,
      byte[] data)
    {
      this.DeviceCommandsLogger.Debug(nameof (StandardCommandAsync));
      NfcFrame nfcFrame = new NfcFrame(command, data, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      byte[] nfcResponseFrame = nfcFrame.NfcResponseFrame;
      nfcFrame = (NfcFrame) null;
      return nfcResponseFrame;
    }

    public async Task StandardCommandAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      NfcCommands command)
    {
      this.DeviceCommandsLogger.Debug(nameof (StandardCommandAsync));
      NfcFrame nfcFrame = new NfcFrame(command, NfcDeviceCommands.FillData, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      nfcFrame = (NfcFrame) null;
    }

    public byte[] StandardCommand(
      ProgressHandler progress,
      CancellationToken cancelToken,
      NfcCommands command,
      byte[] data)
    {
      this.DeviceCommandsLogger.Debug(nameof (StandardCommand));
      NfcFrame nfcFrame = new NfcFrame(command, data, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      this.myNfcRepeater.GetResultFrame(nfcFrame, progress, cancelToken);
      return nfcFrame.NfcResponseFrame;
    }

    public void StandardCommand(
      ProgressHandler progress,
      CancellationToken cancelToken,
      NfcCommands command)
    {
      this.DeviceCommandsLogger.Debug(nameof (StandardCommand));
      this.myNfcRepeater.GetResultFrame(new NfcFrame(command, NfcDeviceCommands.FillData, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue), progress, cancelToken);
    }

    public async Task<byte[]> SendCommandAndGetResultAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      NfcCommands command,
      byte[] data = null)
    {
      this.DeviceCommandsLogger.Debug(nameof (SendCommandAndGetResultAsync));
      NfcFrame nfcFrame = data != null ? new NfcFrame(command, data, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue) : new NfcFrame(command, NfcDeviceCommands.FillData, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      byte[] nfcResult = nfcFrame.NfcResponseFrame;
      int headerLength = nfcResult[0] >= byte.MaxValue ? 4 : 2;
      if ((NfcCommands) nfcResult[headerLength - 1] != command)
        throw new Exception("Received commend != command");
      byte[] resultDataOnly = new byte[nfcResult.Length - headerLength - 2];
      Buffer.BlockCopy((Array) nfcResult, headerLength, (Array) resultDataOnly, 0, resultDataOnly.Length);
      byte[] resultAsync = resultDataOnly;
      nfcFrame = (NfcFrame) null;
      nfcResult = (byte[]) null;
      resultDataOnly = (byte[]) null;
      return resultAsync;
    }

    public async Task<byte[]> SendIrCommandAndGetResultAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      Manufacturer_FC command,
      byte[] data = null)
    {
      this.DeviceCommandsLogger.Debug(nameof (SendIrCommandAndGetResultAsync));
      byte[] frameData;
      if (data == null)
      {
        frameData = new byte[1]{ (byte) command };
      }
      else
      {
        frameData = new byte[data.Length + 1];
        frameData[0] = (byte) command;
        data.CopyTo((Array) frameData, 1);
      }
      NfcFrame nfcFrame = new NfcFrame(NfcCommands.IrDa_Compatible_Command, frameData, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      byte[] nfcResult = nfcFrame.NfcResponseFrame;
      int headerLength = nfcResult[0] >= byte.MaxValue ? 4 : 2;
      if (nfcResult[headerLength - 1] != (byte) 32)
        throw new Exception("Received commend != IrDa_Compatible_Command");
      if ((Manufacturer_FC) nfcResult[headerLength] != command)
      {
        if (nfcResult[headerLength] != (byte) 254)
        {
          if (nfcResult[headerLength] != byte.MaxValue)
            throw new Exception("Received IrDa commend structure error. Response command byte != request command byte and != ACK and != NACK");
          if ((Manufacturer_FC) nfcResult[headerLength + 1] != command)
            throw new Exception("IrDa NACK received. Following IrDa command byte error. Received: 0x" + nfcResult[headerLength + 1].ToString("x02"));
          int nackMessageIndex;
          if (Enum.IsDefined(typeof (SubCommands_FC), (object) nfcResult[headerLength + 1]))
          {
            if (frameData.Length < 2)
              throw new Exception("IrDa NACK received. Extended command byte received but not expected.");
            if ((int) nfcResult[headerLength + 2] != (int) frameData[1])
              throw new Exception("IrDa NACK received. Illegal extended command byte. Received: 0x" + nfcResult[headerLength + 2].ToString("x02"));
            nackMessageIndex = headerLength + 3;
          }
          else
            nackMessageIndex = headerLength + 2;
          throw new Exception("IrDa NACK received. IrDa coded error from device: " + ((NACK_Messages) nfcResult[nackMessageIndex]).ToString());
        }
        if ((Manufacturer_FC) nfcResult[headerLength + 1] == command)
          return new byte[0];
        throw new Exception("Illegal IrDa ACK. Command byte error");
      }
      byte[] resultDataOnly = new byte[nfcResult.Length - headerLength - 3];
      Buffer.BlockCopy((Array) nfcResult, headerLength + 1, (Array) resultDataOnly, 0, resultDataOnly.Length);
      return resultDataOnly;
    }

    public async Task<DateTimeOffset> GetSystemDateTime(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug(nameof (GetSystemDateTime));
      NfcFrame nfcFrame = new NfcFrame(NfcCommands.GetSystemDateTime, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      int scanOffset = 2;
      DateTimeOffset systemDateTime = ByteArrayScanner.ScanDateTimeOffset(nfcFrame.NfcResponseFrame, ref scanOffset);
      nfcFrame = (NfcFrame) null;
      return systemDateTime;
    }

    public async Task<DateTimeOffset> SetSystemDateTime(
      DateTimeOffset dateTimeOffset,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug("SetSystemDateTime: " + dateTimeOffset.ToString());
      int scanOffset = 0;
      byte[] dateTimeBytes = new byte[7];
      ByteArrayScanner.ScanInDateTimeOffset(dateTimeBytes, dateTimeOffset, ref scanOffset);
      NfcFrame nfcFrame = new NfcFrame(NfcCommands.SetSystemDateTime, dateTimeBytes, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      DateTimeOffset dateTimeOffset1 = dateTimeOffset;
      dateTimeBytes = (byte[]) null;
      nfcFrame = (NfcFrame) null;
      return dateTimeOffset1;
    }

    public async Task SetRTCCalibrationValue(
      ushort clocks,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug(nameof (SetRTCCalibrationValue));
      byte[] bytes = BitConverter.GetBytes(clocks);
      NfcFrame frame = new NfcFrame(NfcCommands.SetRtcCalibrationValue, bytes, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.GetResultFrameAsync(frame, progress, cancelToken);
      bytes = (byte[]) null;
      frame = (NfcFrame) null;
    }

    public async Task ClearEventLogger(ProgressHandler progress, CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug(nameof (ClearEventLogger));
      await this.StandardCommandAsync(progress, cancelToken, NfcCommands.ClearEventLogger);
    }

    public async Task SetAccumulatedValues(
      ProgressHandler progress,
      CancellationToken cancelToken,
      List<double> values)
    {
      StringBuilder nlogInfo = new StringBuilder("SetAccumulatedValues ");
      if (values == null || values.Count < 1)
        throw new ArgumentException("Values not defined");
      byte[] commandData = values.Count <= 5 ? new byte[values.Count * 8] : throw new ArgumentException("Not supported number of values");
      for (int i = 0; i < values.Count; ++i)
      {
        if (double.IsNaN(values[i]))
          throw new ArgumentException("NaN not allowed");
        if (i > 0)
          nlogInfo.Append(';');
        nlogInfo.Append(values[i].ToString());
        Buffer.BlockCopy((Array) BitConverter.GetBytes(values[i]), 0, (Array) commandData, i * 8, 8);
      }
      this.DeviceCommandsLogger.Debug(nlogInfo.ToString());
      byte[] numArray = await this.StandardCommandAsync(progress, cancelToken, NfcCommands.ClearEventLogger, commandData);
      nlogInfo = (StringBuilder) null;
      commandData = (byte[]) null;
    }

    public async Task<NfcDeviceCommands.BatteryEndDateData> GetBatteryEndDateAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug(nameof (GetBatteryEndDateAsync));
      NfcDeviceCommands.BatteryEndDateData result = new NfcDeviceCommands.BatteryEndDateData();
      byte[] resultBytes = await this.SendCommandAndGetResultAsync(progress, cancelToken, NfcCommands.GetBatteryEndDate, NfcDeviceCommands.FillData);
      if (resultBytes.Length == 7)
        result.BatteryCapacity_mAh = new ushort?(BitConverter.ToUInt16(resultBytes, 5));
      if (resultBytes.Length == 5 || resultBytes.Length == 7)
      {
        result.BatteryDurabilityMonths = new byte?(resultBytes[3]);
        result.BatteryPreWaringMonths = new sbyte?((sbyte) resultBytes[4]);
      }
      else if (resultBytes.Length != 3)
        throw new Exception("Illegal result length");
      result.EndDate = new DateTime((int) resultBytes[0] + 2000, (int) resultBytes[1], (int) resultBytes[2]);
      NfcDeviceCommands.BatteryEndDateData batteryEndDateAsync = result;
      result = (NfcDeviceCommands.BatteryEndDateData) null;
      resultBytes = (byte[]) null;
      return batteryEndDateAsync;
    }

    public async Task SetBatteryEndDateAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      DateTime endDate,
      byte? batteryDurabilityMonth = null,
      sbyte? batteryPreWaringMonth = null,
      ushort? batteryCapacity = null)
    {
      byte[] commandData;
      if (!batteryDurabilityMonth.HasValue)
      {
        commandData = new byte[3];
      }
      else
      {
        if (!batteryCapacity.HasValue)
        {
          commandData = new byte[5];
        }
        else
        {
          commandData = new byte[7];
          BitConverter.GetBytes(batteryCapacity.Value).CopyTo((Array) commandData, 5);
        }
        commandData[3] = batteryDurabilityMonth.Value;
        commandData[4] = (byte) batteryPreWaringMonth.Value;
      }
      commandData[0] = (byte) (endDate.Year - 2000);
      commandData[1] = (byte) endDate.Month;
      commandData[2] = (byte) endDate.Day;
      byte[] resultAsync = await this.SendCommandAndGetResultAsync(progress, cancelToken, NfcCommands.SetBatteryEndDate, commandData);
      commandData = (byte[]) null;
    }

    public async Task<List<SmartFunctionIdentResultAndCalls>> GetSmartFunctionsList(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug(nameof (GetSmartFunctionsList));
      byte[] result = await this.SendCommandAndGetResultAsync(progress, cancelToken, NfcCommands.GetSmartFunctionsList);
      List<SmartFunctionIdentResultAndCalls> FunctionsInDevice = new List<SmartFunctionIdentResultAndCalls>();
      int scanOffset = 0;
      while (scanOffset < result.Length)
      {
        SmartFunctionIdentResultAndCalls func = new SmartFunctionIdentResultAndCalls(result, ref scanOffset);
        FunctionsInDevice.Add(func);
        func = (SmartFunctionIdentResultAndCalls) null;
      }
      List<SmartFunctionIdentResultAndCalls> smartFunctionsList = FunctionsInDevice;
      result = (byte[]) null;
      FunctionsInDevice = (List<SmartFunctionIdentResultAndCalls>) null;
      return smartFunctionsList;
    }

    public async Task<SmartFunctionResult> SetSmartFunctionActivationAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      string functionName,
      bool active)
    {
      byte[] byteData = new byte[50];
      int offset = 0;
      ByteArrayScanner.ScanInString(byteData, functionName, ref offset);
      byteData[offset] = !active ? (byte) 0 : (byte) 1;
      Array.Resize<byte>(ref byteData, offset + 1);
      byte[] result = await this.SendCommandAndGetResultAsync(progress, cancelToken, NfcCommands.SetSmartFunctionActivation, byteData);
      SmartFunctionResult smartFunctionResult = result.Length == 2 ? (SmartFunctionResult) BitConverter.ToUInt16(result, 0) : throw new Exception("Unexpected number of result bytes at SetSmartFunctionActivationAsync");
      byteData = (byte[]) null;
      result = (byte[]) null;
      return smartFunctionResult;
    }

    public async Task<S4_SystemState> GetDeviceStatesAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug(nameof (GetDeviceStatesAsync));
      NfcFrame nfcFrame = new NfcFrame(NfcCommands.GetSystemState, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
      await this.myNfcRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      S4_SystemState deviceState = new S4_SystemState(nfcFrame.NfcResponseFrame);
      S4_SystemState deviceStatesAsync = deviceState;
      nfcFrame = (NfcFrame) null;
      deviceState = (S4_SystemState) null;
      return deviceStatesAsync;
    }

    public async Task SetModeAsync(
      S4_DeviceModes mode,
      ProgressHandler progress,
      CancellationToken cancelToken,
      byte[] optionBytes = null)
    {
      NfcFrame nfcFrame = this.GetModeFrame(mode, optionBytes);
      await this.myNfcRepeater.GetResultFrameAsync(nfcFrame, progress, cancelToken);
      nfcFrame = (NfcFrame) null;
    }

    public void SetMode(
      S4_DeviceModes mode,
      ProgressHandler progress,
      CancellationToken cancelToken,
      byte[] optionBytes = null)
    {
      this.myNfcRepeater.GetResultFrame(this.GetModeFrame(mode, optionBytes), progress, cancelToken);
    }

    private NfcFrame GetModeFrame(S4_DeviceModes mode, byte[] optionBytes = null)
    {
      if (!Enum.IsDefined(typeof (S4_DeviceModes), (object) mode))
        throw new ArgumentException("undefined S4_SystemState.DeviceModes mode");
      this.DeviceCommandsLogger.Debug("SetModeAsync");
      string str = "SetModeAsync. Mode:" + mode.ToString();
      byte[] numArray;
      if (optionBytes != null)
      {
        numArray = new byte[1 + optionBytes.Length];
        numArray[0] = (byte) mode;
        Buffer.BlockCopy((Array) optionBytes, 0, (Array) numArray, 1, optionBytes.Length);
        this.DeviceCommandsLogger.Debug(str + "; 0x" + Util.ByteArrayToHexString(numArray));
      }
      else
      {
        numArray = new byte[1]{ (byte) mode };
        this.DeviceCommandsLogger.Debug(str + "; 0x" + numArray[0].ToString("x02"));
      }
      return new NfcFrame(NfcCommands.SetTestMode, numArray, this.myNfcRepeater.myConfig.ReadingChannelIdentification, this.myNfcRepeater.CrcInitValue);
    }

    public async Task<double> GetCenterFrequencyMHz(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] commandData = new byte[2]
      {
        (byte) 47,
        (byte) 6
      };
      byte[] result = await this.SendCommandAndGetResultAsync(progress, cancelToken, NfcCommands.IrDa_Compatible_Command, commandData);
      uint frequencyHz = result.Length == 6 ? BitConverter.ToUInt32(result, 2) : throw new Exception("Unexpected number of result bytes at GetCenterFrequency");
      double centerFrequencyMhz = (double) frequencyHz / 1000000.0;
      commandData = (byte[]) null;
      result = (byte[]) null;
      return centerFrequencyMhz;
    }

    public async Task SetCenterFrequencyMHz(
      ProgressHandler progress,
      CancellationToken cancelToken,
      double frequencyMHz)
    {
      byte[] commandData = new byte[6]
      {
        (byte) 47,
        (byte) 6,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 0
      };
      BitConverter.GetBytes((uint) (frequencyMHz * 1000000.0)).CopyTo((Array) commandData, 2);
      byte[] result = await this.SendCommandAndGetResultAsync(progress, cancelToken, NfcCommands.IrDa_Compatible_Command, commandData);
      if (result.Length != 3)
        throw new Exception("Unexpected number of result bytes at GetCenterFrequency");
      commandData = (byte[]) null;
      result = (byte[]) null;
    }

    public async Task DeleteAllModuleConfigurations(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] data = new byte[2]
      {
        byte.MaxValue,
        byte.MaxValue
      };
      byte[] resultAsync = await this.SendCommandAndGetResultAsync(progress, cancelToken, NfcCommands.SetModuleConfiguration, data);
      data = (byte[]) null;
    }

    public async Task ClearSysStateAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      uint sysStateAddress,
      byte[] buffer)
    {
      uint clearFlag = 4278190080;
      byte[] SysStateBuffer = await this.ReadMemoryAsync(progress, cancelToken, sysStateAddress, (uint) (byte) buffer.Length);
      uint sysState = BitConverter.ToUInt32(SysStateBuffer, 0);
      sysState &= clearFlag;
      await this.WriteMemoryAsync(progress, cancelToken, sysStateAddress, SysStateBuffer);
      SysStateBuffer = (byte[]) null;
    }

    public async Task<byte[]> CallTestFunctionAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      byte[] transmitData)
    {
      this.DeviceCommandsLogger.Debug("CallTestFunction");
      byte[] result = await this.SendCommandAndGetResultAsync(progress, cancelToken, NfcCommands.CallTestFunction, transmitData);
      byte[] numArray = result;
      result = (byte[]) null;
      return numArray;
    }

    public async Task<List<BusModuleInfo>> ReadBusModuleListAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      this.DeviceCommandsLogger.Debug("ReadBusModuleList");
      byte[] result = await this.SendCommandAndGetResultAsync(progress, cancelToken, NfcCommands.GetBusModuleList);
      List<BusModuleInfo> infoList = BusModuleInfo.GetBusModuleInfoList(result, 0);
      List<BusModuleInfo> busModuleInfoList = infoList;
      result = (byte[]) null;
      infoList = (List<BusModuleInfo>) null;
      return busModuleInfoList;
    }

    public async Task<byte[]> SendTransparentToModuleAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      BusModuleInfo moduleInfo,
      BusModuleCommand moduleCommand,
      byte[] transmitData = null)
    {
      this.DeviceCommandsLogger.Debug("SendTransparentToModule");
      byte[] sendData;
      if (transmitData == null)
      {
        sendData = new byte[7];
      }
      else
      {
        sendData = new byte[transmitData.Length + 7];
        transmitData.CopyTo((Array) sendData, 7);
      }
      BitConverter.GetBytes((ushort) moduleInfo.BusModuleType).CopyTo((Array) sendData, 0);
      BitConverter.GetBytes(moduleInfo.BusModuleSerialNumber).CopyTo((Array) sendData, 2);
      sendData[6] = (byte) moduleCommand;
      byte[] result = await this.SendCommandAndGetResultAsync(progress, cancelToken, NfcCommands.SendToBusModule, sendData);
      byte[] moduleAsync = result;
      sendData = (byte[]) null;
      result = (byte[]) null;
      return moduleAsync;
    }

    public class BatteryEndDateData
    {
      public DateTime EndDate;
      public byte? BatteryDurabilityMonths;
      public sbyte? BatteryPreWaringMonths;
      public ushort? BatteryCapacity_mAh;
    }
  }
}


--- NfcDeviceIdentification.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.NfcDeviceIdentification
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using HandlerLib.NFC;
using MBusLib;
using System;
using System.Text;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  [Serializable]
  public class NfcDeviceIdentification : DeviceIdentification, IPrintable
  {
    protected byte? nfcIdentFrameVersion;
    protected byte? nfcProtocolVersion;
    protected uint? compilerVersion;
    protected byte? numberOfAvailableParameterGroups;
    protected ushort? numberOfAvailableParameters;
    protected byte? numberOfSelectedParameterGroups;
    protected ushort? numberOfSelectedParameters;
    protected ushort? maximumRecordLength;

    public NfcDeviceIdentification()
    {
    }

    public NfcDeviceIdentification(
      uint serialNumberBCD,
      ushort manufacturerCode,
      byte generation,
      byte mediumCode)
    {
      this.iD_BCD = new uint?(serialNumberBCD);
      this.manufacturer = new ushort?(manufacturerCode);
      this.generation = new byte?(generation);
      this.medium = new byte?(mediumCode);
    }

    public NfcDeviceIdentification(NfcFrame deviceIdFrame)
    {
      if (deviceIdFrame == null)
        throw new Exception("No deviceIdFrame");
      if (deviceIdFrame.NfcResponseFrame.Length != 35)
        throw new Exception("Illegal deviceID response frame length");
      if (deviceIdFrame.NfcResponseFrame[1] != (byte) 1)
        throw new Exception("Illegal deviceID response command byte");
      this.setIdentification(deviceIdFrame.NfcResponseFrame);
    }

    public NfcDeviceIdentification(byte[] ResponseFrame)
    {
      if (ResponseFrame == null)
        throw new Exception("No response frame");
      if (ResponseFrame.Length < 35)
        throw new ArgumentException("Wrong length of response frame");
      this.setIdentification(ResponseFrame);
    }

    public NfcDeviceIdentification(
      byte[] NfcResponseFrame,
      uint offsetIdentStart = 0,
      uint frameLenght = 36)
    {
      if (NfcResponseFrame == null)
        throw new Exception("No deviceID response frame");
      if ((long) NfcResponseFrame.Length != (long) frameLenght)
        throw new Exception("Illegal deviceID response frame length");
      byte[] numArray = new byte[0];
      Buffer.BlockCopy((Array) NfcResponseFrame, (int) offsetIdentStart, (Array) numArray, 0, (int) ((long) NfcResponseFrame.Length - (long) offsetIdentStart));
      this.setIdentification(numArray);
    }

    private void setIdentification(byte[] ResponseFrame)
    {
      this.nfcIdentFrameVersion = new byte?(ResponseFrame[2]);
      byte? identFrameVersion = this.nfcIdentFrameVersion;
      if (identFrameVersion.HasValue)
      {
        switch (identFrameVersion.GetValueOrDefault())
        {
          case 0:
            this.setIdentificationVersion_0(ResponseFrame);
            return;
          case 1:
            this.setIdentificationVersion_1(ResponseFrame);
            return;
          case 2:
            this.setIdentificationVersion_2(ResponseFrame);
            return;
        }
      }
      throw new Exception("Unknown identification flame version: " + this.nfcIdentFrameVersion.ToString());
    }

    private void setIdentificationVersion_0(byte[] ResponseFrame)
    {
      this.nfcProtocolVersion = new byte?(ResponseFrame[3]);
      this.medium = new byte?(ResponseFrame[4]);
      this.obisMedium = new char?((char) ResponseFrame[5]);
      this.manufacturer = new ushort?(BitConverter.ToUInt16(ResponseFrame, 6));
      this.generation = new byte?(ResponseFrame[8]);
      this.iD_BCD = new uint?(BitConverter.ToUInt32(ResponseFrame, 9));
      this.hardwareID = new uint?((uint) BitConverter.ToUInt16(ResponseFrame, 13));
      this.firmwareVersion = new uint?(BitConverter.ToUInt32(ResponseFrame, 15));
      this.meterID = new uint?(BitConverter.ToUInt32(ResponseFrame, 19));
      this.hardwareTypeID = new uint?(BitConverter.ToUInt32(ResponseFrame, 23));
      this.numberOfAvailableParameterGroups = new byte?(ResponseFrame[27]);
      this.numberOfAvailableParameters = new ushort?(BitConverter.ToUInt16(ResponseFrame, 28));
      this.numberOfSelectedParameterGroups = new byte?(ResponseFrame[30]);
      this.numberOfSelectedParameters = new ushort?(BitConverter.ToUInt16(ResponseFrame, 31));
      this.maximumRecordLength = new ushort?((ushort) ResponseFrame[33]);
    }

    private void setIdentificationVersion_1(byte[] ResponseFrame)
    {
      this.nfcProtocolVersion = new byte?(ResponseFrame[3]);
      this.medium = new byte?(ResponseFrame[4]);
      this.obisMedium = new char?((char) ResponseFrame[5]);
      this.manufacturer = new ushort?(BitConverter.ToUInt16(ResponseFrame, 6));
      this.generation = new byte?(ResponseFrame[8]);
      this.iD_BCD = new uint?(BitConverter.ToUInt32(ResponseFrame, 9));
      this.hardwareID = new uint?((uint) BitConverter.ToUInt16(ResponseFrame, 13));
      this.deviceStatusFlags = new uint?((uint) BitConverter.ToUInt16(ResponseFrame, 15));
      this.firmwareVersion = new uint?(BitConverter.ToUInt32(ResponseFrame, 17));
      this.meterID = new uint?(BitConverter.ToUInt32(ResponseFrame, 21));
      this.svnRevision = new uint?(BitConverter.ToUInt32(ResponseFrame, 25));
      byte[] numArray = new byte[4];
      Buffer.BlockCopy((Array) ResponseFrame, 29, (Array) numArray, 0, 4);
      this.buildTime = MBusUtil.ConvertToDateTime_MBus_CP32_TypeF(numArray);
      this.compilerVersion = new uint?(BitConverter.ToUInt32(ResponseFrame, 33));
      this.signatur = new ushort?(BitConverter.ToUInt16(ResponseFrame, 37));
      this.numberOfAvailableParameterGroups = new byte?(ResponseFrame[39]);
      this.numberOfAvailableParameters = new ushort?(BitConverter.ToUInt16(ResponseFrame, 40));
      this.numberOfSelectedParameterGroups = new byte?(ResponseFrame[42]);
      this.numberOfSelectedParameters = new ushort?(BitConverter.ToUInt16(ResponseFrame, 43));
      this.maximumRecordLength = new ushort?((ushort) ResponseFrame[45]);
    }

    private void setIdentificationVersion_2(byte[] ResponseFrame)
    {
      this.nfcProtocolVersion = new byte?(ResponseFrame[3]);
      this.medium = new byte?(ResponseFrame[4]);
      this.obisMedium = new char?((char) ResponseFrame[5]);
      this.manufacturer = new ushort?(BitConverter.ToUInt16(ResponseFrame, 6));
      this.generation = new byte?(ResponseFrame[8]);
      this.iD_BCD = new uint?(BitConverter.ToUInt32(ResponseFrame, 9));
      this.hardwareID = new uint?((uint) BitConverter.ToUInt16(ResponseFrame, 13));
      this.deviceStatusFlags = new uint?(BitConverter.ToUInt32(ResponseFrame, 15));
      this.firmwareVersion = new uint?(BitConverter.ToUInt32(ResponseFrame, 19));
      this.meterID = new uint?(BitConverter.ToUInt32(ResponseFrame, 23));
      this.svnRevision = new uint?(BitConverter.ToUInt32(ResponseFrame, 27));
      byte[] numArray = new byte[4];
      Buffer.BlockCopy((Array) ResponseFrame, 31, (Array) numArray, 0, 4);
      this.buildTime = MBusUtil.ConvertToDateTime_MBus_CP32_TypeF(numArray);
      this.compilerVersion = new uint?(BitConverter.ToUInt32(ResponseFrame, 35));
      this.signatur = new ushort?(BitConverter.ToUInt16(ResponseFrame, 39));
      this.numberOfAvailableParameterGroups = new byte?(ResponseFrame[41]);
      this.numberOfAvailableParameters = new ushort?(BitConverter.ToUInt16(ResponseFrame, 42));
      this.numberOfSelectedParameterGroups = new byte?(ResponseFrame[44]);
      this.numberOfSelectedParameters = new ushort?(BitConverter.ToUInt16(ResponseFrame, 45));
      this.maximumRecordLength = new ushort?((ushort) ResponseFrame[47]);
    }

    public override string ToString()
    {
      StringBuilder stringBuilder1 = new StringBuilder();
      stringBuilder1.AppendLine("Serial number: " + this.FullSerialNumber);
      stringBuilder1.AppendLine("HardwareVersions: " + this.HardwareID.Value.ToString("x08"));
      stringBuilder1.AppendLine("FirmwareVersion: " + this.GetFirmwareVersionString());
      stringBuilder1.AppendLine("Medium: " + this.GetMediumAsText());
      StringBuilder stringBuilder2 = stringBuilder1;
      uint? nullable = this.MeterID;
      string str1 = nullable.ToString();
      nullable = this.hardwareTypeID;
      string str2 = nullable.ToString();
      string str3 = "MeterID: " + str1 + "; HardwareTypeID: " + str2;
      stringBuilder2.AppendLine(str3);
      return stringBuilder1.ToString();
    }

    public new string Print(int spaces = 0) => Utility.PrintObject((object) this);

    public override DeviceIdentification Clone()
    {
      return (DeviceIdentification) (this.MemberwiseClone() as NfcDeviceIdentification);
    }

    public virtual byte? NfcIdentFrameVersion
    {
      get => this.nfcIdentFrameVersion;
      set => throw new Exception("Write to NfcIdentFrameVersion not defined");
    }

    public virtual byte? NfcProtocolVersion
    {
      get => this.nfcProtocolVersion;
      set => throw new Exception("Write to NfcProtocolVersion not defined");
    }

    public virtual uint? CompilerVersion
    {
      get => this.compilerVersion;
      set => throw new Exception("Write to CompilerVersion not defined");
    }

    public virtual byte? NumberOfAvailableParameterGroups
    {
      get => this.numberOfAvailableParameterGroups;
      set => throw new Exception("Write to NumberOfAvailableParameterGroups not defined");
    }

    public virtual ushort? NumberOfAvailableParameters
    {
      get => this.numberOfAvailableParameters;
      set => throw new Exception("Write to NumberOfAvailableParameters not defined");
    }

    public virtual byte? NumberOfSelectedParameterGroups
    {
      get => this.numberOfSelectedParameterGroups;
      set => throw new Exception("Write to NumberOfSelectedParameterGroups not defined");
    }

    public virtual ushort? NumberOfSelectedParameters
    {
      get => this.numberOfSelectedParameters;
      set => throw new Exception("Write to NumberOfSelectedParameters not defined");
    }

    public virtual ushort? MaximumRecordLength
    {
      get => this.maximumRecordLength;
      set => throw new Exception("Write to MaximumRecordLength not defined");
    }
  }
}


--- OperationChanges.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.OperationChanges
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum OperationChanges : byte
  {
    NotDefined,
    WriteProtectionActivated,
    WriteProtectionCleard,
    SleepActivated,
    WakeupFromSleep,
  }
}


--- OTAA_ABP.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.OTAA_ABP
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum OTAA_ABP : byte
  {
    OTAA = 1,
    ABP = 2,
  }
}


--- OverwriteAndCompare.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.OverwriteAndCompare
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommonWPF;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class OverwriteAndCompare : Window, IComponentConnector
  {
    public bool restartWindow = false;
    private string HandlerName;
    private SortedList<HandlerMeterObjects, DeviceMemory> SourceMemories;
    private SortedList<HandlerMeterObjects, DeviceMemory> DestinationMemories;
    private HandlerFunctionsForProduction HandlerFunctions;
    private bool AddOverWriteDevice;
    internal StartupLib.GmmCorporateControl gmmCorporateControl1;
    internal ListBox ListBoxSource;
    internal ListBox ListBoxDestination;
    internal ListBox ListBoxOverwriteGroups;
    internal Button ButtonShowGroupInfo;
    internal Button ButtonOverwrite;
    internal CheckBox CheckBoxSuppressAddresses;
    internal CheckBox CheckBoxSuppressKnownDiffs;
    internal CheckBox CheckBoxOnlySelectedGroups;
    internal Button ButtonSourceMap;
    internal Button ButtonMapDiff;
    internal Button ButtonMemoryDiff;
    internal Button ButtonDataDiff;
    internal Button ButtonSaveSourceObject;
    internal Button ButtonOpenCompareFileFolder;
    private bool _contentLoaded;

    public OverwriteAndCompare(
      string handlerName,
      SortedList<HandlerMeterObjects, DeviceMemory> allMemories,
      HandlerFunctionsForProduction handlerFunctions,
      bool addOverWriteDevice = false)
    {
      this.HandlerName = handlerName;
      this.SourceMemories = allMemories;
      this.DestinationMemories = allMemories;
      this.HandlerFunctions = handlerFunctions;
      this.AddOverWriteDevice = addOverWriteDevice;
      this.InitializeComponent();
    }

    public OverwriteAndCompare(
      string handlerName,
      SortedList<HandlerMeterObjects, DeviceMemory> sourceMemories,
      SortedList<HandlerMeterObjects, DeviceMemory> destinationMemories,
      HandlerFunctionsForProduction handlerFunctions)
    {
      this.HandlerName = handlerName;
      this.SourceMemories = sourceMemories;
      this.DestinationMemories = destinationMemories;
      this.HandlerFunctions = handlerFunctions;
      this.InitializeComponent();
    }

    private void Window_Loaded(object sender, RoutedEventArgs e)
    {
      this.ListBoxSource.ItemsSource = (IEnumerable) this.SourceMemories.Keys.ToArray<HandlerMeterObjects>();
      if (!this.AddOverWriteDevice)
      {
        this.ListBoxDestination.ItemsSource = (IEnumerable) this.DestinationMemories.Keys.ToArray<HandlerMeterObjects>();
      }
      else
      {
        List<HandlerMeterObjects> list = this.DestinationMemories.Keys.ToList<HandlerMeterObjects>();
        if (list.Count == 0)
          list.Add(HandlerMeterObjects.ConnectedDevice);
        this.ListBoxDestination.ItemsSource = (IEnumerable) list;
      }
      bool flag = true;
      if (this.ListBoxSource.Items.Count > 0)
      {
        foreach (object obj in (IEnumerable) this.ListBoxSource.Items)
        {
          if (obj.ToString() == HandlerMeterObjects.TypeMeter.ToString())
          {
            this.ListBoxSource.SelectedItem = obj;
            break;
          }
        }
        if (this.ListBoxSource.SelectedIndex < 0)
        {
          foreach (object obj in (IEnumerable) this.ListBoxSource.Items)
          {
            if (obj.ToString() == HandlerMeterObjects.ConnectedMeter.ToString())
            {
              this.ListBoxSource.SelectedItem = obj;
              break;
            }
          }
        }
        if (this.ListBoxSource.SelectedIndex < 0)
          this.ListBoxSource.SelectedIndex = 0;
      }
      else
        flag = false;
      if (this.ListBoxDestination.Items.Count > 0)
      {
        foreach (object obj in (IEnumerable) this.ListBoxDestination.Items)
        {
          if (obj.ToString() == HandlerMeterObjects.WorkMeter.ToString())
          {
            this.ListBoxDestination.SelectedItem = obj;
            break;
          }
        }
        if (this.ListBoxDestination.SelectedIndex < 0)
          this.ListBoxDestination.SelectedIndex = 0;
      }
      else
        flag = false;
      if (!flag)
      {
        this.ButtonDataDiff.IsEnabled = false;
        this.ButtonMemoryDiff.IsEnabled = false;
      }
      this.ListBoxOverwriteGroups.ItemsSource = (IEnumerable) this.HandlerFunctions.GetAllOverwriteGroups();
    }

    private void ListBoxOverwriteGroups_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ListBoxOverwriteGroups.SelectedItems.Count > 0)
        this.ButtonOverwrite.IsEnabled = true;
      else
        this.ButtonOverwrite.IsEnabled = false;
      if (this.ListBoxOverwriteGroups.SelectedItems.Count == 1)
        this.ButtonShowGroupInfo.IsEnabled = true;
      else
        this.ButtonShowGroupInfo.IsEnabled = false;
    }

    private void ButtonOverwrite_Click(object sender, RoutedEventArgs e)
    {
      if (this.ListBoxSource.SelectedItem == null)
        return;
      try
      {
        HandlerMeterObjects sourceObject = (HandlerMeterObjects) Enum.Parse(typeof (HandlerMeterObjects), this.ListBoxSource.SelectedItem.ToString());
        HandlerMeterObjects destinationObject = (HandlerMeterObjects) Enum.Parse(typeof (HandlerMeterObjects), this.ListBoxDestination.SelectedItem.ToString());
        CommonOverwriteGroups[] overwriteGroups = new CommonOverwriteGroups[this.ListBoxOverwriteGroups.SelectedItems.Count];
        for (int index = 0; index < overwriteGroups.Length; ++index)
        {
          string str = this.ListBoxOverwriteGroups.SelectedItems[index].ToString();
          overwriteGroups[index] = (CommonOverwriteGroups) Enum.Parse(typeof (CommonOverwriteGroups), str);
        }
        this.HandlerFunctions.OverwriteSrcToDest(sourceObject, destinationObject, overwriteGroups);
        int num = (int) MessageBox.Show("Overwrite done");
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    private void ButtonMemoryDiff_Click(object sender, RoutedEventArgs e)
    {
      DeviceMemory deviceMemory1 = this.SourceMemories.Values[this.ListBoxSource.SelectedIndex];
      DeviceMemory deviceMemory2 = this.DestinationMemories.Values[this.ListBoxDestination.SelectedIndex];
      DeviceMemory deviceMemory3 = deviceMemory1;
      string handlerName = this.HandlerName;
      HandlerMeterObjects key = this.SourceMemories.Keys[this.ListBoxSource.SelectedIndex];
      string originalTag = key.ToString();
      key = this.DestinationMemories.Keys[this.ListBoxDestination.SelectedIndex];
      string compareTag = key.ToString();
      DeviceMemory compareMemory = deviceMemory2;
      deviceMemory3.CompareMemoryInfo(handlerName, originalTag, compareTag, compareMemory);
    }

    private void ButtonSourceMap_Click(object sender, RoutedEventArgs e)
    {
      DeviceMemory deviceMemory = this.SourceMemories.Values[this.ListBoxSource.SelectedIndex];
      string handlerName = this.HandlerName;
      string originalTag = this.SourceMemories.Keys[this.ListBoxSource.SelectedIndex].ToString();
      bool? isChecked = this.CheckBoxSuppressAddresses.IsChecked;
      int num1 = isChecked.Value ? 1 : 0;
      isChecked = this.CheckBoxSuppressKnownDiffs.IsChecked;
      int num2 = isChecked.Value ? 1 : 0;
      CommonOverwriteGroups[] selectedOverwriteGroups = this.GetSelectedOverwriteGroups();
      deviceMemory.ShowParameterInfo(handlerName, originalTag, num1 != 0, num2 != 0, selectedOverwriteGroups);
    }

    private void ButtonMapDiff_Click(object sender, RoutedEventArgs e)
    {
      DeviceMemory deviceMemory1 = this.SourceMemories.Values[this.ListBoxSource.SelectedIndex];
      DeviceMemory deviceMemory2 = this.DestinationMemories.Values[this.ListBoxDestination.SelectedIndex];
      DeviceMemory deviceMemory3 = deviceMemory1;
      string handlerName = this.HandlerName;
      HandlerMeterObjects key = this.SourceMemories.Keys[this.ListBoxSource.SelectedIndex];
      string originalTag = key.ToString();
      key = this.DestinationMemories.Keys[this.ListBoxDestination.SelectedIndex];
      string compareTag = key.ToString();
      DeviceMemory compareMemory = deviceMemory2;
      bool? isChecked = this.CheckBoxSuppressAddresses.IsChecked;
      int num1 = isChecked.Value ? 1 : 0;
      isChecked = this.CheckBoxSuppressKnownDiffs.IsChecked;
      int num2 = isChecked.Value ? 1 : 0;
      CommonOverwriteGroups[] selectedOverwriteGroups = this.GetSelectedOverwriteGroups();
      deviceMemory3.CompareParameterInfo(handlerName, originalTag, compareTag, compareMemory, num1 != 0, num2 != 0, selectedOverwriteGroups);
    }

    private CommonOverwriteGroups[] GetSelectedOverwriteGroups()
    {
      CommonOverwriteGroups[] selectedOverwriteGroups = (CommonOverwriteGroups[]) null;
      if (this.CheckBoxOnlySelectedGroups.IsChecked.Value)
      {
        if (this.ListBoxOverwriteGroups.SelectedItems != null && this.ListBoxOverwriteGroups.SelectedItems.Count > 0)
        {
          try
          {
            selectedOverwriteGroups = new CommonOverwriteGroups[this.ListBoxOverwriteGroups.SelectedItems.Count];
            for (int index = 0; index < selectedOverwriteGroups.Length; ++index)
            {
              string str = this.ListBoxOverwriteGroups.SelectedItems[index].ToString();
              selectedOverwriteGroups[index] = (CommonOverwriteGroups) Enum.Parse(typeof (CommonOverwriteGroups), str);
            }
          }
          catch
          {
            selectedOverwriteGroups = (CommonOverwriteGroups[]) null;
          }
        }
      }
      return selectedOverwriteGroups;
    }

    private void ButtonDataDiff_Click(object sender, RoutedEventArgs e)
    {
      DeviceMemory deviceMemory1 = this.SourceMemories.Values[this.ListBoxSource.SelectedIndex];
      DeviceMemory deviceMemory2 = this.DestinationMemories.Values[this.ListBoxDestination.SelectedIndex];
      DeviceMemory deviceMemory3 = deviceMemory1;
      string handlerName = this.HandlerName;
      HandlerMeterObjects key = this.SourceMemories.Keys[this.ListBoxSource.SelectedIndex];
      string originalTag = key.ToString();
      key = this.DestinationMemories.Keys[this.ListBoxDestination.SelectedIndex];
      string compareTag = key.ToString();
      DeviceMemory compareMemory = deviceMemory2;
      deviceMemory3.CompareSortedParameterInfo(handlerName, originalTag, compareTag, compareMemory);
    }

    private void ButtonSaveSourceObject_Click(object sender, RoutedEventArgs e)
    {
      if (this.ListBoxSource.SelectedItem == null)
        return;
      try
      {
        this.HandlerFunctions.SaveMeterObject((HandlerMeterObjects) Enum.Parse(typeof (HandlerMeterObjects), this.ListBoxSource.SelectedItem.ToString()));
        this.restartWindow = true;
        this.Close();
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show(ex.Message);
      }
    }

    private void ListBoxSourceOrDestination_SelectionChanged(
      object sender,
      SelectionChangedEventArgs e)
    {
      if (this.ListBoxSource.SelectedItem == null || this.ListBoxDestination.SelectedItem == null)
      {
        this.ButtonDataDiff.IsEnabled = false;
        this.ButtonMemoryDiff.IsEnabled = false;
        this.ButtonOverwrite.IsEnabled = false;
      }
      else if (this.SourceMemories[(HandlerMeterObjects) this.ListBoxSource.SelectedItem] == null || this.SourceMemories[(HandlerMeterObjects) this.ListBoxSource.SelectedItem] == null)
      {
        this.ButtonDataDiff.IsEnabled = false;
        this.ButtonMemoryDiff.IsEnabled = false;
      }
      else
      {
        this.ButtonDataDiff.IsEnabled = true;
        this.ButtonMemoryDiff.IsEnabled = true;
      }
    }

    private void ButtonShowGroupInfo_Click(object sender, RoutedEventArgs e)
    {
      CommonOverwriteGroups overwriteGroupe = (CommonOverwriteGroups) Enum.Parse(typeof (CommonOverwriteGroups), this.ListBoxOverwriteGroups.SelectedItem.ToString());
      int num = (int) MessageBox.Show(this.HandlerFunctions.GetOverwriteGroupInfo(overwriteGroupe), overwriteGroupe.ToString() + " group infos");
    }

    private void ButtonOpenCompareFileFolder_Click(object sender, RoutedEventArgs e)
    {
      new Process()
      {
        StartInfo = {
          FileName = "explorer",
          Arguments = SystemValues.LoggDataPath
        }
      }.Start();
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/overwriteandcompare.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          ((FrameworkElement) target).Loaded += new RoutedEventHandler(this.Window_Loaded);
          break;
        case 2:
          this.gmmCorporateControl1 = (StartupLib.GmmCorporateControl) target;
          break;
        case 3:
          this.ListBoxSource = (ListBox) target;
          this.ListBoxSource.SelectionChanged += new SelectionChangedEventHandler(this.ListBoxSourceOrDestination_SelectionChanged);
          break;
        case 4:
          this.ListBoxDestination = (ListBox) target;
          this.ListBoxDestination.SelectionChanged += new SelectionChangedEventHandler(this.ListBoxSourceOrDestination_SelectionChanged);
          break;
        case 5:
          this.ListBoxOverwriteGroups = (ListBox) target;
          this.ListBoxOverwriteGroups.SelectionChanged += new SelectionChangedEventHandler(this.ListBoxOverwriteGroups_SelectionChanged);
          break;
        case 6:
          this.ButtonShowGroupInfo = (Button) target;
          this.ButtonShowGroupInfo.Click += new RoutedEventHandler(this.ButtonShowGroupInfo_Click);
          break;
        case 7:
          this.ButtonOverwrite = (Button) target;
          this.ButtonOverwrite.Click += new RoutedEventHandler(this.ButtonOverwrite_Click);
          break;
        case 8:
          this.CheckBoxSuppressAddresses = (CheckBox) target;
          break;
        case 9:
          this.CheckBoxSuppressKnownDiffs = (CheckBox) target;
          break;
        case 10:
          this.CheckBoxOnlySelectedGroups = (CheckBox) target;
          break;
        case 11:
          this.ButtonSourceMap = (Button) target;
          this.ButtonSourceMap.Click += new RoutedEventHandler(this.ButtonSourceMap_Click);
          break;
        case 12:
          this.ButtonMapDiff = (Button) target;
          this.ButtonMapDiff.Click += new RoutedEventHandler(this.ButtonMapDiff_Click);
          break;
        case 13:
          this.ButtonMemoryDiff = (Button) target;
          this.ButtonMemoryDiff.Click += new RoutedEventHandler(this.ButtonMemoryDiff_Click);
          break;
        case 14:
          this.ButtonDataDiff = (Button) target;
          this.ButtonDataDiff.Click += new RoutedEventHandler(this.ButtonDataDiff_Click);
          break;
        case 15:
          this.ButtonSaveSourceObject = (Button) target;
          this.ButtonSaveSourceObject.Click += new RoutedEventHandler(this.ButtonSaveSourceObject_Click);
          break;
        case 16:
          this.ButtonOpenCompareFileFolder = (Button) target;
          this.ButtonOpenCompareFileFolder.Click += new RoutedEventHandler(this.ButtonOpenCompareFileFolder_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- OverwriteConditions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.OverwriteConditions
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum OverwriteConditions
  {
    None,
    LO,
  }
}


--- OverwriteSupport.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.OverwriteSupport
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace HandlerLib
{
  public static class OverwriteSupport
  {
    public static SortedList<string, CommonOverwriteGroups> OverwriteGroupProperties = new SortedList<string, CommonOverwriteGroups>();

    static OverwriteSupport()
    {
      OverwriteSupport.OverwriteGroupProperties.Add("ID", CommonOverwriteGroups.IdentData);
      OverwriteSupport.OverwriteGroupProperties.Add("TI", CommonOverwriteGroups.TypeIdentification);
      OverwriteSupport.OverwriteGroupProperties.Add("UC", CommonOverwriteGroups.UltrasonicCalibration);
      OverwriteSupport.OverwriteGroupProperties.Add("UH", CommonOverwriteGroups.UltrasonicHydraulicTestSetup);
      OverwriteSupport.OverwriteGroupProperties.Add("UL", CommonOverwriteGroups.UltrasonicLimits);
      OverwriteSupport.OverwriteGroupProperties.Add("UT", CommonOverwriteGroups.UltrasonicTempSensorCurve);
      OverwriteSupport.OverwriteGroupProperties.Add("MD", CommonOverwriteGroups.MenuDefinition);
      OverwriteSupport.OverwriteGroupProperties.Add("RD", CommonOverwriteGroups.RamData);
      OverwriteSupport.OverwriteGroupProperties.Add("BC", CommonOverwriteGroups.BasicConfiguration);
      OverwriteSupport.OverwriteGroupProperties.Add("TS", CommonOverwriteGroups.TemperatureSettings);
      OverwriteSupport.OverwriteGroupProperties.Add("TL", CommonOverwriteGroups.TemperatureLimits);
      OverwriteSupport.OverwriteGroupProperties.Add("DP", CommonOverwriteGroups.DeviceProtection);
      OverwriteSupport.OverwriteGroupProperties.Add("RC", CommonOverwriteGroups.RTC_Calibration);
      OverwriteSupport.OverwriteGroupProperties.Add("CP", CommonOverwriteGroups.ConfigurationParameters);
      OverwriteSupport.OverwriteGroupProperties.Add("CC", CommonOverwriteGroups.CarrierFrequencyCalibration);
      OverwriteSupport.OverwriteGroupProperties.Add("ZC", CommonOverwriteGroups.ZeroFlowCalibration);
    }

    public static CommonOverwriteGroups GetOverwriteGroupFromShortcat(string shortcut)
    {
      return OverwriteSupport.OverwriteGroupProperties.ContainsKey(shortcut) ? OverwriteSupport.OverwriteGroupProperties[shortcut] : throw new ArgumentException("Unknown overwrite shortcut:" + shortcut);
    }

    public static string GetShortcatFromOverwriteGroup(CommonOverwriteGroups theGroup)
    {
      int index = OverwriteSupport.OverwriteGroupProperties.IndexOfValue(theGroup);
      if (index < 0)
        throw new ArgumentException("Unknown overwrite group:" + theGroup.ToString());
      return OverwriteSupport.OverwriteGroupProperties.Keys[index];
    }

    public static CommonOverwriteGroups[] GetIncludingOverwriteGroups(CommonOverwriteGroups theGroup)
    {
      switch (theGroup)
      {
        case CommonOverwriteGroups.UltrasonicLimits:
          return new CommonOverwriteGroups[1]
          {
            CommonOverwriteGroups.UltrasonicCalibration
          };
        case CommonOverwriteGroups.UltrasonicTempSensorCurve:
          return new CommonOverwriteGroups[1]
          {
            CommonOverwriteGroups.UltrasonicCalibration
          };
        default:
          return new CommonOverwriteGroups[0];
      }
    }

    public static List<TypeOverwriteData> PrepareOverwriteData(string overwriteString)
    {
      if (string.IsNullOrEmpty(overwriteString))
        throw new ArgumentException("illegal overwriteString");
      List<TypeOverwriteData> typeOverwriteDataList = new List<TypeOverwriteData>();
      string[] strArray1 = overwriteString.Split(new char[1]
      {
        '|'
      }, StringSplitOptions.RemoveEmptyEntries);
      if (strArray1.Length < 1)
        throw new ArgumentException("illegal overwriteString");
      bool flag = true;
      foreach (string str1 in strArray1)
      {
        TypeOverwriteData typeOverwriteData = new TypeOverwriteData();
        string[] strArray2 = str1.Split(new char[1]{ ':' }, StringSplitOptions.RemoveEmptyEntries);
        string str2;
        if (strArray2.Length == 1)
        {
          str2 = strArray2[0];
        }
        else
        {
          if (strArray2.Length != 2)
            throw new ArgumentException("illegal conditions");
          if (flag)
            throw new ArgumentException("Basetype can not have a condition");
          OverwriteConditions result;
          if (!Enum.TryParse<OverwriteConditions>(strArray2[0], out result))
            throw new ArgumentException("unknown condition");
          typeOverwriteData.Condition = result;
          str2 = strArray2[1];
        }
        string[] strArray3 = str2.Split(new char[1]{ '=' }, StringSplitOptions.RemoveEmptyEntries);
        if (strArray3.Length < 1 || strArray3.Length > 2)
          throw new ArgumentException("illegal group definition");
        int result1;
        if (!int.TryParse(strArray3[0], out result1))
          throw new ArgumentException("illegal MeterInfoID");
        typeOverwriteData.MeterInfoID = result1;
        if (strArray3.Length == 2)
        {
          if (flag)
            throw new ArgumentException("Basetype can not have groups");
          string[] strArray4 = strArray3[1].Split(new char[1]
          {
            ','
          }, StringSplitOptions.RemoveEmptyEntries);
          List<CommonOverwriteGroups> commonOverwriteGroupsList = new List<CommonOverwriteGroups>();
          foreach (string shortcut in strArray4)
            commonOverwriteGroupsList.Add(OverwriteSupport.GetOverwriteGroupFromShortcat(shortcut));
          typeOverwriteData.OverwriteGroups = commonOverwriteGroupsList.ToArray();
        }
        typeOverwriteDataList.Add(typeOverwriteData);
        flag = false;
      }
      return typeOverwriteDataList;
    }

    public static void CheckAllGroupsCompatible(
      CommonOverwriteGroups[] overwriteGroups,
      CompatibilityInfo compatibilityInfo)
    {
      string str = "";
      if (compatibilityInfo == null)
        throw new Exception("Try to overwrite but no compatibility information is available.");
      if (!compatibilityInfo.IsFullCompatible)
      {
        foreach (CommonOverwriteGroups overwriteGroup in overwriteGroups)
        {
          if (compatibilityInfo.CompatibleGroupShortcuts.IndexOf(OverwriteSupport.GetShortcatFromOverwriteGroup(overwriteGroup)) < 0)
          {
            foreach (CommonOverwriteGroups includingOverwriteGroup in OverwriteSupport.GetIncludingOverwriteGroups(overwriteGroup))
            {
              if (compatibilityInfo.CompatibleGroupShortcuts.IndexOf(OverwriteSupport.GetShortcatFromOverwriteGroup(includingOverwriteGroup)) >= 0)
                goto label_13;
            }
            if (str.Length > 0)
              str += ";";
            str += overwriteGroup.ToString();
label_13:;
          }
        }
      }
      if (str.Length > 0)
        throw new Exception("Try to overwrite not compatible groups: " + str);
    }
  }
}


--- Parameter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.Parameter
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  [Serializable]
  public sealed class Parameter
  {
    public string Segment { get; private set; }

    public string Name { get; private set; }

    public ushort Address { get; private set; }

    public int Size { get; private set; }

    public Parameter(string segment, string name, ushort address, int size)
    {
      this.Segment = segment;
      this.Name = name;
      this.Address = address;
      this.Size = size;
    }

    public override string ToString()
    {
      return this.Name + ", 0x" + this.Address.ToString("X4") + ", " + this.Size.ToString() + " bytes, " + this.Segment;
    }
  }
}


--- Parameter32bit.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.Parameter32bit
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Runtime.InteropServices;
using System.Text;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class Parameter32bit : IComparable<Parameter32bit>
  {
    public string Section { get; private set; }

    public string Name { get; private set; }

    public Type SystemType { get; private set; }

    public string Typ { get; private set; }

    public uint Address { get; private set; }

    public uint Size { get; private set; }

    public uint EndAddress => (uint) ((int) this.Address + (int) this.Size - 1);

    public AddressRange AddressRange => new AddressRange(this.Address, this.Size);

    public Parameter32bit(string section, string name, uint address, uint size, string typ = "")
    {
      this.Section = section;
      this.Name = name;
      this.Address = address;
      this.Size = size;
      this.Typ = typ;
    }

    public T GetValue<T>(DeviceMemory deviceMemory)
    {
      return (T) Parameter32bit.GetValue(typeof (T), this.Address, deviceMemory);
    }

    public static T GetValue<T>(uint address, DeviceMemory deviceMemory, bool toHEX = false)
    {
      return (T) Parameter32bit.GetValue(typeof (T), address, deviceMemory, toHEX);
    }

    public static object GetValue(Type type, uint address, DeviceMemory deviceMemory, bool toHEX = false)
    {
      if (!deviceMemory.AreDataAvailable(address, (uint) Marshal.SizeOf(type)))
        throw new Exception("No data available!");
      if (toHEX)
      {
        uint sizeOfType = Parameter32bit.GetSizeOfType(type);
        byte[] data = deviceMemory.GetData(address, sizeOfType);
        byte[] buffer = new byte[data.Length];
        for (int index = 0; index < data.Length; ++index)
          buffer[data.Length - 1 - index] = data[index];
        return (object) Utility.ByteArrayToHexString(buffer);
      }
      if (type == typeof (sbyte))
        return (object) Parameter32bit.GetValueSByte(address, deviceMemory);
      if (type == typeof (byte))
        return (object) Parameter32bit.GetValueByte(address, deviceMemory);
      if (type == typeof (short))
        return (object) Parameter32bit.GetValueShort(address, deviceMemory);
      if (type == typeof (ushort))
        return (object) Parameter32bit.GetValueUShort(address, deviceMemory);
      if (type == typeof (int))
        return (object) Parameter32bit.GetValueInt(address, deviceMemory);
      if (type == typeof (uint))
        return (object) Parameter32bit.GetValueUInt(address, deviceMemory);
      if (type == typeof (float))
        return (object) Parameter32bit.GetValueFloat(address, deviceMemory);
      if (type == typeof (double))
        return (object) Parameter32bit.GetValueDouble(address, deviceMemory);
      if (type == typeof (ulong))
        return (object) BitConverter.ToUInt64(deviceMemory.GetData(address, 8U), 0);
      if (type == typeof (long))
        return (object) BitConverter.ToInt64(deviceMemory.GetData(address, 8U), 0);
      if (type == typeof (byte[]))
        throw new Exception("use static method GetValueByteArray() instead !!!");
      throw new Exception("unsupported type");
    }

    public static void SetType(Type type, Parameter32bit param)
    {
      param.SystemType = type == typeof (sbyte) || type == typeof (byte) || type == typeof (short) || type == typeof (ushort) || type == typeof (int) || type == typeof (uint) || type == typeof (float) || type == typeof (double) || type == typeof (byte[]) || type == typeof (ushort) || type == typeof (short) || type == typeof (uint) || type == typeof (int) || type == typeof (ulong) || type == typeof (long) || type == typeof (short) || type == typeof (float) || type == typeof (double) || type == typeof (byte) || type == typeof (sbyte) ? type : throw new Exception("unsupported type");
      param.Typ = type.ToString();
    }

    public static byte GetValueByte(uint address, DeviceMemory deviceMemory)
    {
      return deviceMemory.GetData(address, 1U)[0];
    }

    public static sbyte GetValueSByte(uint address, DeviceMemory deviceMemory)
    {
      return (sbyte) deviceMemory.GetData(address, 1U)[0];
    }

    public static short GetValueShort(uint address, DeviceMemory deviceMemory)
    {
      return BitConverter.ToInt16(deviceMemory.GetData(address, 2U), 0);
    }

    public static ushort GetValueUShort(uint address, DeviceMemory deviceMemory)
    {
      return BitConverter.ToUInt16(deviceMemory.GetData(address, 2U), 0);
    }

    public static int GetValueInt(uint address, DeviceMemory deviceMemory)
    {
      return BitConverter.ToInt32(deviceMemory.GetData(address, 4U), 0);
    }

    public static uint GetValueUInt(uint address, DeviceMemory deviceMemory)
    {
      return BitConverter.ToUInt32(deviceMemory.GetData(address, 4U), 0);
    }

    public static float GetValueFloat(uint address, DeviceMemory deviceMemory)
    {
      return BitConverter.ToSingle(deviceMemory.GetData(address, 4U), 0);
    }

    public static double GetValueDouble(uint address, DeviceMemory deviceMemory)
    {
      return BitConverter.ToDouble(deviceMemory.GetData(address, 8U), 0);
    }

    public static byte[] GetValueByteArray(uint address, uint byteSize, DeviceMemory deviceMemory)
    {
      return deviceMemory.GetData(address, byteSize);
    }

    public void SetValue<T>(T theValue, DeviceMemory deviceMemory)
    {
      Parameter32bit.SetValue<T>(theValue, this.Address, deviceMemory);
    }

    public static void SetValue(Type T, object theValue, uint address, DeviceMemory deviceMemory)
    {
      if (T == typeof (byte))
        Parameter32bit.SetValue<byte>(Convert.ToByte(theValue), address, deviceMemory);
      else if (T == typeof (sbyte))
        Parameter32bit.SetValue<sbyte>(Convert.ToSByte(theValue), address, deviceMemory);
      else if (T == typeof (short))
        Parameter32bit.SetValue<short>(Convert.ToInt16(theValue), address, deviceMemory);
      else if (T == typeof (ushort))
        Parameter32bit.SetValue<ushort>(Convert.ToUInt16(theValue), address, deviceMemory);
      else if (T == typeof (int))
        Parameter32bit.SetValue<int>(Convert.ToInt32(theValue), address, deviceMemory);
      else if (T == typeof (uint))
        Parameter32bit.SetValue<uint>(Convert.ToUInt32(theValue), address, deviceMemory);
      else if (T == typeof (long))
        Parameter32bit.SetValue<long>(Convert.ToInt64(theValue), address, deviceMemory);
      else if (T == typeof (float))
      {
        Parameter32bit.SetValue<float>(Convert.ToSingle(theValue), address, deviceMemory);
      }
      else
      {
        if (!(T == typeof (double)))
          throw new Exception("unsupported type");
        Parameter32bit.SetValue<double>(Convert.ToDouble(theValue), address, deviceMemory);
      }
    }

    public static void SetValue<T>(T theValue, uint address, DeviceMemory deviceMemory)
    {
      if (typeof (T) == typeof (byte))
        Parameter32bit.SetValue((byte) (object) theValue, address, deviceMemory);
      else if (typeof (T) == typeof (sbyte))
        Parameter32bit.SetValue((sbyte) (object) theValue, address, deviceMemory);
      else if (typeof (T) == typeof (short))
        Parameter32bit.SetValue((short) (object) theValue, address, deviceMemory);
      else if (typeof (T) == typeof (ushort))
        Parameter32bit.SetValue((ushort) (object) theValue, address, deviceMemory);
      else if (typeof (T) == typeof (int))
        Parameter32bit.SetValue((int) (object) theValue, address, deviceMemory);
      else if (typeof (T) == typeof (uint))
        Parameter32bit.SetValue((uint) (object) theValue, address, deviceMemory);
      else if (typeof (T) == typeof (ulong))
        Parameter32bit.SetValue((ulong) (object) theValue, address, deviceMemory);
      else if (typeof (T) == typeof (long))
        Parameter32bit.SetValue((long) (object) theValue, address, deviceMemory);
      else if (typeof (T) == typeof (float))
        Parameter32bit.SetValue((float) (object) theValue, address, deviceMemory);
      else if (typeof (T) == typeof (double))
      {
        Parameter32bit.SetValue((double) (object) theValue, address, deviceMemory);
      }
      else
      {
        if (!(typeof (T) == typeof (byte[])))
          throw new Exception("unsupported type");
        Parameter32bit.SetValue((byte[]) (object) theValue, address, deviceMemory);
      }
    }

    public static void SetValue(byte theValue, uint address, DeviceMemory deviceMemory)
    {
      deviceMemory.SetData(address, new byte[1]{ theValue });
    }

    public static void SetValue(sbyte theValue, uint address, DeviceMemory deviceMemory)
    {
      deviceMemory.SetData(address, new byte[1]
      {
        (byte) theValue
      });
    }

    public static void SetValue(short theValue, uint address, DeviceMemory deviceMemory)
    {
      deviceMemory.SetData(address, BitConverter.GetBytes(theValue));
    }

    public static void SetValue(ushort theValue, uint address, DeviceMemory deviceMemory)
    {
      deviceMemory.SetData(address, BitConverter.GetBytes(theValue));
    }

    public static void SetValue(int theValue, uint address, DeviceMemory deviceMemory)
    {
      deviceMemory.SetData(address, BitConverter.GetBytes(theValue));
    }

    public static void SetValue(uint theValue, uint address, DeviceMemory deviceMemory)
    {
      deviceMemory.SetData(address, BitConverter.GetBytes(theValue));
    }

    public static void SetValue(ulong theValue, uint address, DeviceMemory deviceMemory)
    {
      deviceMemory.SetData(address, BitConverter.GetBytes(theValue));
    }

    public static void SetValue(long theValue, uint address, DeviceMemory deviceMemory)
    {
      deviceMemory.SetData(address, BitConverter.GetBytes(theValue));
    }

    public static void SetValue(float theValue, uint address, DeviceMemory deviceMemory)
    {
      deviceMemory.SetData(address, BitConverter.GetBytes(theValue));
    }

    public static void SetValue(double theValue, uint address, DeviceMemory deviceMemory)
    {
      deviceMemory.SetData(address, BitConverter.GetBytes(theValue));
    }

    public static void SetValue(byte[] theValue, uint address, DeviceMemory deviceMemory)
    {
      deviceMemory.SetData(address, theValue);
    }

    public static void CheckValueType(Type T, object theValue)
    {
      object obj;
      if (T == typeof (byte))
        obj = (object) Convert.ToByte(theValue);
      else if (T == typeof (sbyte))
        obj = (object) Convert.ToSByte(theValue);
      else if (T == typeof (short))
        obj = (object) Convert.ToInt16(theValue);
      else if (T == typeof (ushort))
        obj = (object) Convert.ToUInt16(theValue);
      else if (T == typeof (int))
        obj = (object) Convert.ToInt32(theValue);
      else if (T == typeof (uint))
        obj = (object) Convert.ToUInt32(theValue);
      else if (T == typeof (long))
        obj = (object) Convert.ToInt64(theValue);
      else if (T == typeof (float))
      {
        obj = (object) Convert.ToSingle(theValue);
      }
      else
      {
        if (!(T == typeof (double)))
          throw new Exception("unsupported type");
        obj = (object) Convert.ToDouble(theValue);
      }
    }

    public static uint GetSizeOfType(Type T)
    {
      return !(T == typeof (byte)) && !(T == typeof (byte)) && !(T == typeof (sbyte)) && !(T == typeof (sbyte)) && !(T == typeof (bool)) && !(T == typeof (bool)) ? (!(T == typeof (short)) && !(T == typeof (short)) && !(T == typeof (ushort)) && !(T == typeof (ushort)) && !(T == typeof (char)) && !(T == typeof (char)) ? (!(T == typeof (int)) && !(T == typeof (int)) && !(T == typeof (uint)) && !(T == typeof (uint)) && !(T == typeof (float)) && !(T == typeof (float)) ? (!(T == typeof (double)) && !(T == typeof (double)) && !(T == typeof (ulong)) && !(T == typeof (long)) ? (!(T == typeof (Decimal)) && !(T == typeof (Decimal)) ? 0U : 16U) : 8U) : 4U) : 2U) : 1U;
    }

    public override string ToString()
    {
      return string.Format("{0} 0x{1:X8}, {2} byte(s)", (object) this.Name, (object) this.Address, (object) this.Size);
    }

    public void AppandValueStrings(
      DeviceMemory deviceMemory,
      StringBuilder result,
      string leftSpaceString = "")
    {
      if (!deviceMemory.AreDataAvailable(this.Address, this.Size))
      {
        result.Append(" Data not available");
      }
      else
      {
        byte[] data = deviceMemory.GetData(this.AddressRange);
        if (this.SystemType != (Type) null)
        {
          uint sizeOfType = Parameter32bit.GetSizeOfType(this.SystemType);
          if (sizeOfType > 0U)
          {
            double num1 = (double) this.Size / (double) sizeOfType;
            uint num2 = (uint) num1;
            if ((double) num2 != num1)
            {
              result.Append("Byte array count don't fit to type array count");
            }
            else
            {
              if (num2 == 1U)
              {
                result.Append(" Value: ");
                result.Append(Parameter32bit.GetValue(this.SystemType, this.Address, deviceMemory));
                result.Append(" = 0x");
                result.Append(Parameter32bit.GetValue(this.SystemType, this.Address, deviceMemory, true));
                result.Append(" Data.Bytes: ");
                result.Append(Utility.ByteArrayToHexStringFormated(data, (string) null, 32));
                return;
              }
              result.Append(" Array.Count=" + num2.ToString());
              result.Append(" Array.Values: ");
              uint address = this.Address;
              for (int index = 0; (long) index < (long) num2; ++index)
              {
                result.AppendLine();
                result.Append(leftSpaceString);
                result.Append("[" + index.ToString("d03") + "] ");
                result.Append(Parameter32bit.GetValue(this.SystemType, address, deviceMemory));
                result.Append(" = 0x");
                result.Append(Parameter32bit.GetValue(this.SystemType, address, deviceMemory, true));
                address += sizeOfType;
              }
            }
          }
        }
        result.AppendLine();
        result.Append(leftSpaceString + "Data.Bytes: ");
        if (this.Size <= 32U)
        {
          result.Append(Utility.ByteArrayToHexStringFormated(data, (string) null, 32));
        }
        else
        {
          result.AppendLine();
          result.Append(Utility.ByteArrayToHexStringFormated(data, leftSpaceString, 32, new uint?(this.Address)));
        }
      }
    }

    public int CompareTo(Parameter32bit compareObject)
    {
      return this.Address.CompareTo(compareObject.Address);
    }
  }
}


--- ParameterArrayAssistant.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ParameterArrayAssistant
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using System.Windows.Media;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class ParameterArrayAssistant : Window, IComponentConnector
  {
    private myDataRow Data;
    private Dictionary<string, MySpecialParam> mySParamList;
    private uint TypeSize = 0;
    private uint CellWidth = 25;
    private uint CellHeight = 23;
    private uint CharWidth = 9;
    private uint Cells = 0;
    private uint MinWindowHeight = 300;
    private uint MinWindowWidth = 600;
    internal bool isCanceled = false;
    private static string showDataInHex = string.Empty;
    internal GmmCorporateControl gmmCorporateControl1;
    internal TextBox txtColumnCount;
    internal Button btnCancel;
    internal Button btnSave;
    internal Button btnCopyToClipboard;
    internal Canvas myTableCanvas;
    internal Label lblParameterName;
    internal CheckBox chkBoxShowDataInHEX;
    private bool _contentLoaded;

    public ObservableCollection<MySpecialParam> mySParams { get; set; }

    public ParameterArrayAssistant(myDataRow Parameter)
    {
      this.InitializeComponent();
      this.Data = Parameter;
      this.DataContext = (object) this;
      this.Title = "Change data for " + Parameter.Name;
      this.lblParameterName.Content = (object) Parameter.Name;
      ParameterArrayAssistant.showDataInHex = Parameter.Name + "_showDataInHex";
      string fromUserSettings = FirmwareParameterManager.getStringFromUserSettings(ParameterArrayAssistant.showDataInHex);
      if (!string.IsNullOrEmpty(fromUserSettings))
        this.chkBoxShowDataInHEX.IsChecked = new bool?(fromUserSettings.Contains("true"));
      else
        this.chkBoxShowDataInHEX.IsChecked = new bool?(false);
      if (Parameter.ValType != (Type) null && Parameter.ValType != typeof (byte[]))
      {
        uint num = uint.Parse(this.Data.Bytes.Substring(2), NumberStyles.HexNumber);
        this.TypeSize = Parameter32bit.GetSizeOfType(Parameter.ValType);
        this.txtColumnCount.Text = this.Data.savedColumns != 0 ? this.Data.savedColumns.ToString() : Math.Ceiling((double) (num / this.TypeSize * this.CellHeight) / 140.0).ToString();
        this.txtColumnCount.TextChanged += new TextChangedEventHandler(this.txtColumnCount_TextChanged);
      }
      else
      {
        this.TypeSize = uint.Parse(this.Data.Bytes.Substring(2), NumberStyles.HexNumber);
        this.txtColumnCount.Text = this.Data.savedColumns != 0 ? this.Data.savedColumns.ToString() : "1";
        this.txtColumnCount.IsEnabled = false;
      }
      this.mySParamList = new Dictionary<string, MySpecialParam>();
      this.mySParams = new ObservableCollection<MySpecialParam>();
      this.Width = this.MinWidth = (double) this.MinWindowWidth;
      this.Height = this.MinHeight = (double) this.MinWindowHeight;
      this.buildGRID();
    }

    private void txtColumnCount_TextChanged(object sender, TextChangedEventArgs e)
    {
      if (string.IsNullOrEmpty(this.txtColumnCount.Text))
        return;
      this.Data.savedColumns = int.Parse(this.txtColumnCount.Text);
      this.buildGRID();
    }

    private void buildGRID()
    {
      try
      {
        this.myTableCanvas.Children.Clear();
        if (this.myTableCanvas.Children.Count != 0)
          this.myTableCanvas.Children.Clear();
        uint length = uint.Parse(this.Data.Bytes.Substring(2), NumberStyles.HexNumber);
        byte[] destinationArray = new byte[(int) length];
        if (this.Data.OrigValue != null)
          Array.Copy((Array) this.Data.OrigValue, (Array) destinationArray, (long) ((byte[]) this.Data.OrigValue).Length);
        else
          destinationArray = new byte[1];
        int int32 = Convert.ToInt32(this.txtColumnCount.Text);
        int num1 = (int) ((long) (length / this.TypeSize) / (long) int32);
        this.Cells = length / this.TypeSize;
        this.CellWidth = this.CharWidth * (this.TypeSize * 2U);
        if (int32 == 1 && num1 == 1)
          this.CellWidth = this.CharWidth * (this.TypeSize * 2U);
        int num2 = 0;
        for (int index1 = 0; index1 <= num1; ++index1)
        {
          for (int index2 = 0; index2 < int32; ++index2)
          {
            TextBox element = new TextBox();
            byte[] numArray = new byte[(int) this.TypeSize];
            for (int index3 = 0; (long) index3 < (long) this.TypeSize; ++index3)
              numArray[index3] = !(this.Data.ValType != (Type) null) ? (destinationArray.Length > index3 ? destinationArray[index3] : Convert.ToByte(0)) : ((long) destinationArray.Length > (long) num2 + (long) this.TypeSize ? destinationArray[(long) num2 * (long) this.TypeSize + (long) index3] : Convert.ToByte(0));
            element.Name = "Cell_" + num2.ToString();
            if (num2 == 0)
              element.Focus();
            if (!this.mySParamList.ContainsKey(element.Name))
            {
              MySpecialParam mySpecialParam = new MySpecialParam();
              mySpecialParam.InternalData = numArray;
              mySpecialParam.Position = (uint) num2;
              mySpecialParam.Name = element.Name;
              this.mySParamList.Add(mySpecialParam.Name, mySpecialParam);
              element.Tag = (object) mySpecialParam;
            }
            else
            {
              MySpecialParam sparam = this.mySParamList[element.Name];
              element.Tag = (object) sparam;
              element.Text = Util.ByteArrayToHexString(sparam.InternalData);
            }
            bool? isChecked;
            if (this.Data.ValType != (Type) null)
            {
              TextBox textBox = element;
              Type valType = this.Data.ValType;
              byte[] bArray = numArray;
              isChecked = this.chkBoxShowDataInHEX.IsChecked;
              int num3 = isChecked.Value ? 1 : 0;
              string str = ParameterArrayAssistant.ByteArrayToType(valType, bArray, num3 != 0).ToString();
              textBox.Text = str;
            }
            else
            {
              isChecked = this.chkBoxShowDataInHEX.IsChecked;
              element.Text = !isChecked.Value ? Util.ByteArrayToString(numArray) : Util.ByteArrayToHexString(numArray);
            }
            element.TextChanged += new TextChangedEventHandler(this.tbx_TextChanged);
            element.GotFocus += new RoutedEventHandler(this.tbx_GotFocus);
            element.LostFocus += new RoutedEventHandler(this.tbx_LostFocus);
            element.ToolTip = (object) ("Position: " + ((MySpecialParam) element.Tag).Position.ToString());
            if (num1 == 1 && length > 100U)
            {
              element.TextWrapping = TextWrapping.Wrap;
              this.CellWidth = 720U;
              this.CellHeight *= length / 65U + 1U;
              element.Height = (double) this.CellHeight;
              element.Width = (double) this.CellWidth;
              element.VerticalAlignment = VerticalAlignment.Top;
              element.HorizontalAlignment = HorizontalAlignment.Left;
            }
            else
            {
              element.Height = (double) this.CellHeight;
              element.Width = (double) this.CellWidth;
            }
            element.TextAlignment = TextAlignment.Left;
            element.Margin = new Thickness(5.0, 10.0, 0.0, 0.0);
            this.myTableCanvas.Children.Add((UIElement) element);
            Canvas.SetLeft((UIElement) element, (double) ((long) this.CellWidth * (long) index2));
            Canvas.SetTop((UIElement) element, (double) ((long) this.CellHeight * (long) index1));
            ++num2;
            if ((long) num2 >= (long) this.Cells)
              break;
          }
          if ((long) num2 >= (long) this.Cells)
            break;
        }
        if ((double) ((long) this.CellWidth * (long) int32 + 55L) >= this.MinWidth)
          this.Width = (double) ((long) this.CellWidth * (long) int32 + 55L);
        else
          this.Width = this.MinWidth;
        if ((double) ((long) this.CellHeight * (long) num1 + 205L) >= this.MinHeight)
          this.Height = (double) ((long) this.CellHeight * (long) num1 + 205L);
        else
          this.Height = this.MinHeight;
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show("ERROR:\n\n" + ex.Message);
      }
    }

    private void ToLittleIndian(ref byte[] cellContent) => Array.Reverse((Array) cellContent);

    private void tbx_LostFocus(object sender, RoutedEventArgs e)
    {
      (sender as TextBox).Select(0, 0);
    }

    private void tbx_GotFocus(object sender, RoutedEventArgs e) => (sender as TextBox).SelectAll();

    private void tbx_TextChanged(object sender, TextChangedEventArgs e)
    {
      TextBox textBox = sender as TextBox;
      MySpecialParam tag = textBox.Tag as MySpecialParam;
      string str = textBox.Text;
      try
      {
        textBox.Background = (Brush) Brushes.White;
        textBox.Foreground = (Brush) Brushes.Black;
        textBox.BorderBrush = (Brush) Brushes.Black;
        textBox.BorderThickness = new Thickness(1.0, 1.0, 1.0, 1.0);
        bool flag1 = true;
        this.Data.ValType = this.Data.ValType == (Type) null ? typeof (string) : this.Data.ValType;
        if (this.Data.ValType == typeof (string))
        {
          bool? isChecked = this.chkBoxShowDataInHEX.IsChecked;
          bool flag2 = true;
          if (!(isChecked.GetValueOrDefault() == flag2 & isChecked.HasValue))
            str = Util.ByteArrayToHexString(Util.StringToByteArray(str));
          string valueHeXfull = this.Data.ValueHEXfull;
          if (valueHeXfull.Length != str.Length)
            textBox.Background = (Brush) Brushes.LightGoldenrodYellow;
          if (valueHeXfull.Length < str.Length)
          {
            textBox.BorderBrush = (Brush) Brushes.Red;
            textBox.BorderThickness = new Thickness(1.0, 3.0, 1.0, 3.0);
          }
          if (!valueHeXfull.Equals(str))
            textBox.Foreground = (Brush) Brushes.Red;
          tag.InternalData = ParameterArrayAssistant.TypeToByteArray(this.Data.ValType, (object) str);
        }
        else
        {
          bool? isChecked = this.chkBoxShowDataInHEX.IsChecked;
          bool flag3 = true;
          if (isChecked.GetValueOrDefault() == flag3 & isChecked.HasValue)
            str = ParameterArrayAssistant.HEXtoObject(this.Data.ValType, str).ToString();
          byte[] byteArray1 = ParameterArrayAssistant.TypeToByteArray(this.Data.ValType, (object) str);
          byte[] byteArray2 = ParameterArrayAssistant.TypeToByteArray(this.Data.ValType, (object) str);
          if (this.Data.OrigValue != null)
            Array.Copy((Array) this.Data.OrigValue, (long) (tag.Position * this.TypeSize), (Array) byteArray2, 0L, (long) this.TypeSize);
          else if (this.Data.ValType == typeof (byte[]))
            this.Data.OrigValue = (object) ParameterArrayAssistant.TypeToByteArray(this.Data.ValType, (object) string.Empty.PadLeft((int) this.TypeSize, '0'));
          if (tag.InternalData.Length != byteArray1.Length)
            throw new Exception("wrong lenght...");
          for (int index = 0; index < byteArray1.Length; index = index + 1 + 1)
            flag1 &= (int) byteArray2[index] == (int) byteArray1[index];
          tag.InternalData = byteArray1;
          if (!flag1)
            textBox.Foreground = (Brush) Brushes.Red;
          else
            textBox.Foreground = (Brush) Brushes.Black;
        }
      }
      catch (Exception ex)
      {
        textBox.Background = (Brush) Brushes.LightSalmon;
      }
    }

    private void setBytesToOriginalByteArray()
    {
      byte[] numArray = new byte[(int) this.Cells * (int) this.TypeSize];
      if (this.Data.OrigValue != null)
        numArray = (byte[]) this.Data.OrigValue;
      foreach (MySpecialParam mySpecialParam in this.mySParamList.Values)
      {
        for (int index = 0; (long) index < (long) this.TypeSize; ++index)
          numArray[(long) (mySpecialParam.Position * this.TypeSize) + (long) index] = mySpecialParam.InternalData[index];
      }
      this.Data.OrigValue = (object) numArray;
    }

    private void btnSave_Click(object sender, RoutedEventArgs e)
    {
      this.setBytesToOriginalByteArray();
      this.isCanceled = false;
      this.Close();
    }

    private void btnCancel_Click(object sender, RoutedEventArgs e) => this.isCanceled = true;

    private void btnCopy2Clipboard_Click(object sender, RoutedEventArgs e)
    {
      string data = string.Empty;
      bool toHEX = this.chkBoxShowDataInHEX.IsChecked.Value;
      foreach (MySpecialParam mySpecialParam in this.mySParamList.Values)
      {
        data = !(this.Data.ValType != (Type) null) ? (!this.chkBoxShowDataInHEX.IsChecked.Value ? data + Util.ByteArrayToString(mySpecialParam.InternalData) : data + Util.ByteArrayToHexString(mySpecialParam.InternalData)) : data + ParameterArrayAssistant.ByteArrayToType(this.Data.ValType, mySpecialParam.InternalData, toHEX).ToString();
        data += ";";
      }
      Clipboard.SetDataObject((object) data);
    }

    public static object ByteArrayToType(Type localType, byte[] bArray, bool toHEX = true)
    {
      localType.GetType();
      object type;
      if (localType == typeof (int))
        type = toHEX ? (object) Util.ByteArrayToHexString(((IEnumerable<byte>) bArray).Reverse<byte>().ToArray<byte>()) : (object) BitConverter.ToInt32(bArray, 0).ToString();
      else if (localType == typeof (short))
        type = toHEX ? (object) Util.ByteArrayToHexString(((IEnumerable<byte>) bArray).Reverse<byte>().ToArray<byte>()) : (object) BitConverter.ToInt16(bArray, 0).ToString();
      else if (localType == typeof (bool))
        type = toHEX ? (BitConverter.ToBoolean(bArray, 0) ? (object) "1" : (object) "0") : (object) BitConverter.ToBoolean(bArray, 0).ToString();
      else if (localType == typeof (byte))
        type = toHEX ? (object) bArray[0].ToString("x") : (object) bArray[0].ToString();
      else if (localType == typeof (sbyte))
        type = toHEX ? (object) bArray[0].ToString("x") : (object) bArray[0].ToString();
      else if (localType == typeof (float))
        type = toHEX ? (object) ParameterArrayAssistant.float2HEXString(BitConverter.ToSingle(bArray, 0)) : (object) BitConverter.ToSingle(bArray, 0).ToString();
      else if (localType == typeof (float))
        type = toHEX ? (object) ParameterArrayAssistant.float2HEXString(BitConverter.ToSingle(bArray, 0)) : (object) BitConverter.ToSingle(bArray, 0).ToString();
      else if (localType == typeof (double))
        type = toHEX ? (object) Util.ByteArrayToHexString(((IEnumerable<byte>) bArray).Reverse<byte>().ToArray<byte>()) : (object) BitConverter.ToDouble(bArray, 0).ToString();
      else if (localType == typeof (string))
        type = toHEX ? (object) Util.ByteArrayToHexString(((IEnumerable<byte>) bArray).Reverse<byte>().ToArray<byte>()) : (object) Util.ByteArrayToString(((IEnumerable<byte>) bArray).Reverse<byte>().ToArray<byte>());
      else if (localType == typeof (uint))
      {
        type = toHEX ? (object) Util.ByteArrayToHexString(((IEnumerable<byte>) bArray).Reverse<byte>().ToArray<byte>()) : (object) BitConverter.ToUInt32(bArray, 0).ToString();
      }
      else
      {
        if (!(localType == typeof (ushort)))
          throw new InvalidCastException("Unsupported type" + localType.ToString());
        type = toHEX ? (object) Util.ByteArrayToHexString(((IEnumerable<byte>) bArray).Reverse<byte>().ToArray<byte>()) : (object) BitConverter.ToUInt16(bArray, 0).ToString();
      }
      return type;
    }

    public static string float2HEXString(float val)
    {
      return BitConverter.DoubleToInt64Bits((double) val).ToString("x");
    }

    public static float HEXStringToFloat(string val)
    {
      return (float) BitConverter.Int64BitsToDouble(Convert.ToInt64(val, 16));
    }

    public static string double2HEXString(double val)
    {
      return new Double2ulong() { d = val }.ul.ToString("x");
    }

    public static double HEXStringToDouble(string val)
    {
      ulong num = ulong.Parse(val, NumberStyles.AllowHexSpecifier);
      return new Double2ulong() { ul = num }.d;
    }

    public static byte[] TypeToByteArray(Type localType, object localValue)
    {
      byte[] byteArray;
      if (localType == typeof (int))
        byteArray = BitConverter.GetBytes(Convert.ToInt32(localValue));
      else if (localType == typeof (short))
        byteArray = BitConverter.GetBytes(Convert.ToInt16(localValue));
      else if (localType == typeof (bool))
        byteArray = BitConverter.GetBytes(Convert.ToBoolean(localValue));
      else if (localType == typeof (byte))
        byteArray = new byte[1]
        {
          Convert.ToByte(localValue)
        };
      else if (localType == typeof (sbyte))
        byteArray = new byte[1]
        {
          (byte) Convert.ToSByte(localValue)
        };
      else if (localType == typeof (float))
        byteArray = BitConverter.GetBytes(Convert.ToSingle(localValue));
      else if (localType == typeof (double))
        byteArray = BitConverter.GetBytes(Convert.ToDouble(localValue));
      else if (localType == typeof (uint))
        byteArray = BitConverter.GetBytes(Convert.ToUInt32(localValue));
      else if (localType == typeof (ulong))
        byteArray = BitConverter.GetBytes(Convert.ToUInt64(localValue));
      else if (localType == typeof (long))
        byteArray = BitConverter.GetBytes(Convert.ToInt64(localValue));
      else if (localType == typeof (ushort))
      {
        byteArray = BitConverter.GetBytes(Convert.ToUInt16(localValue));
      }
      else
      {
        if (!(localType == typeof (string)))
          throw new InvalidCastException("Unsupported type" + localType.ToString());
        byteArray = Util.HexStringToByteArray(localValue.ToString());
      }
      return byteArray;
    }

    public static object HEXtoObject(Type localType, string localValue)
    {
      object obj;
      if (localType == typeof (int))
        obj = (object) Convert.ToInt32(localValue, 16);
      else if (localType == typeof (short))
        obj = (object) Convert.ToInt16(localValue, 16);
      else if (localType == typeof (bool))
        obj = (object) Convert.ToBoolean(localValue);
      else if (localType == typeof (byte))
        obj = (object) Convert.ToByte(localValue, 16);
      else if (localType == typeof (sbyte))
        obj = (object) Convert.ToSByte(localValue, 16);
      else if (localType == typeof (float))
        obj = (object) ParameterArrayAssistant.HEXStringToFloat(localValue);
      else if (localType == typeof (double))
        obj = (object) ParameterArrayAssistant.HEXStringToDouble(localValue);
      else if (localType == typeof (uint))
        obj = (object) Convert.ToUInt32(localValue, 16);
      else if (localType == typeof (ulong))
        obj = (object) Convert.ToUInt64(localValue, 16);
      else if (localType == typeof (long))
        obj = (object) Convert.ToInt64(localValue, 16);
      else if (localType == typeof (ushort))
      {
        obj = (object) Convert.ToUInt16(localValue, 16);
      }
      else
      {
        if (!(localType == typeof (string)))
          throw new InvalidCastException("Unsupported type" + localType.ToString());
        if (localValue.Length % 2 != 0)
          localValue = "0" + localValue;
        obj = (object) Util.ByteArrayToHexString(Util.HexStringToByteArray(localValue));
      }
      return obj;
    }

    private void chkBoxShowDataInHEX_Checked(object sender, RoutedEventArgs e)
    {
      FirmwareParameterManager.setStringToUserSettings(ParameterArrayAssistant.showDataInHex, this.chkBoxShowDataInHEX.IsChecked.ToString());
      this.buildGRID();
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/parameterarrayassistant.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.gmmCorporateControl1 = (GmmCorporateControl) target;
          break;
        case 2:
          this.txtColumnCount = (TextBox) target;
          break;
        case 3:
          this.btnCancel = (Button) target;
          this.btnCancel.Click += new RoutedEventHandler(this.btnCancel_Click);
          break;
        case 4:
          this.btnSave = (Button) target;
          this.btnSave.Click += new RoutedEventHandler(this.btnSave_Click);
          break;
        case 5:
          this.btnCopyToClipboard = (Button) target;
          this.btnCopyToClipboard.Click += new RoutedEventHandler(this.btnCopy2Clipboard_Click);
          break;
        case 6:
          this.myTableCanvas = (Canvas) target;
          break;
        case 7:
          this.lblParameterName = (Label) target;
          break;
        case 8:
          this.chkBoxShowDataInHEX = (CheckBox) target;
          this.chkBoxShowDataInHEX.Click += new RoutedEventHandler(this.chkBoxShowDataInHEX_Checked);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- ParameterItem.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ParameterItem
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public class ParameterItem
  {
    public string Key { get; set; }

    public bool IsReadOnly { get; set; }

    public string Value { get; set; }

    public override string ToString() => this.Key + " = " + this.Value;
  }
}


--- ParameterListInfo.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ParameterListInfo
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;

#nullable disable
namespace HandlerLib
{
  public sealed class ParameterListInfo
  {
    public ParameterListInfo.ParameterDevice S3_Device { get; set; }

    public ParameterListInfo.ParameterDevice Radio { get; set; }

    public ParameterListInfo()
    {
      this.S3_Device = new ParameterListInfo.ParameterDevice();
      this.Radio = new ParameterListInfo.ParameterDevice();
    }

    public static ParameterListInfo Parse(byte[] buffer)
    {
      if (buffer == null)
        throw new ArgumentNullException(nameof (buffer));
      ParameterListInfo parameterListInfo = new ParameterListInfo();
      parameterListInfo.S3_Device.MaxList = (int) buffer[0];
      parameterListInfo.S3_Device.SelectedList = (int) buffer[1];
      parameterListInfo.S3_Device.Sublists = (int) buffer[2];
      parameterListInfo.Radio.MaxList = (int) buffer[3];
      if (parameterListInfo.Radio.MaxList != (int) byte.MaxValue)
      {
        parameterListInfo.Radio.SelectedList = (int) buffer[4];
        if (parameterListInfo.Radio.SelectedList >= parameterListInfo.Radio.MaxList)
          throw new ArgumentException("selected lis > max list");
      }
      if (buffer.Length >= 8)
      {
        parameterListInfo.Radio.AES_EncMode = (AES_ENCRYPTION_MODE) ((int) buffer[5] & 15);
        if (!Enum.IsDefined(typeof (AES_ENCRYPTION_MODE), (object) parameterListInfo.Radio.AES_EncMode))
          throw new Exception("Undefined EncryptionMode received");
        parameterListInfo.Radio.RadioMode = new RADIO_MODE?((RADIO_MODE) (((int) buffer[5] & 240) >> 4));
        if (!Enum.IsDefined(typeof (RADIO_MODE), (object) parameterListInfo.Radio.RadioMode))
          throw new Exception("Undefined RadioMode received");
        parameterListInfo.Radio.Cycletime = new int?((int) buffer[7] << 8 | (int) buffer[6]);
      }
      return parameterListInfo;
    }

    public static byte[] GetCommandPayload(ushort list, bool isRadio)
    {
      List<byte> byteList = new List<byte>();
      byte num1 = 0;
      if (isRadio)
        num1 = (byte) 1;
      byte num2 = (byte) ((int) num1 << 4 | 8);
      if (((uint) list & 1U) > 0U)
        num2 |= (byte) 64;
      list >>= 1;
      if (list > (ushort) 0)
        num2 |= (byte) 128;
      byteList.Add(num2);
      while (((int) num2 & 128) == 128)
      {
        num2 = (byte) ((uint) list & 15U);
        list >>= 4;
        if (list > (ushort) 0)
          num2 |= (byte) 128;
        byteList.Add(num2);
      }
      return byteList.ToArray();
    }

    public static byte[] GetCommandPayload(ushort list, bool isRadio, ushort enc_mode)
    {
      List<byte> byteList = new List<byte>();
      byte num1 = 0;
      if (isRadio)
        num1 = (byte) 1;
      byte num2 = (byte) ((int) num1 << 4 | 8);
      if (((uint) list & 1U) > 0U)
        num2 |= (byte) 64;
      list >>= 1;
      if (list > (ushort) 0 || enc_mode > (ushort) 0)
        num2 |= (byte) 128;
      byteList.Add(num2);
      while (((int) num2 & 128) == 128)
      {
        num2 = (byte) ((int) list & 15 | ((int) enc_mode & 3) << 4);
        list >>= 4;
        enc_mode >>= 2;
        if (list > (ushort) 0 || enc_mode > (ushort) 0)
          num2 |= (byte) 128;
        byteList.Add(num2);
      }
      return byteList.ToArray();
    }

    public class ParameterDevice
    {
      public int MaxList { get; set; }

      public int SelectedList { get; set; }

      public int Sublists { get; set; }

      public AES_ENCRYPTION_MODE AES_EncMode { get; set; }

      public RADIO_MODE? RadioMode { get; set; }

      public int? Cycletime { get; set; }
    }
  }
}


--- ParameterType.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ParameterType
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System.Xml.Serialization;

#nullable disable
namespace HandlerLib
{
  public class ParameterType
  {
    [XmlElement("ParameterTypeSaved")]
    public string ParameterTypeSaved { get; set; }

    [XmlElement("ParameterTypeColPreset")]
    public int ParameterTypeColPreset { get; set; }
  }
}


--- ParameterWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ParameterWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommonWPF;
using HandlerLib.MapManagement;
using Microsoft.Win32;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class ParameterWindow : Window, IComponentConnector
  {
    private DeviceMemory actualDeviceMemory;
    private List<myDataRow> localDataSourceBACKUP;
    private List<myDataRow> localDataSourceSELECT;
    private SortedList<string, Parameter32bit> FirmwareParameter;
    private BaseMemoryAccess memoryAccess;
    private CancellationTokenSource cancelTokenSource;
    private ProgressHandler progress;
    private bool FirstInitData;
    private bool doSelection;
    private bool saveAllDataToDevice;
    private bool isDataSaved = false;
    private bool CancelButtonPressed;
    internal StartupLib.GmmCorporateControl gmmCorporateControl1;
    internal DataGrid DataGridParameterView;
    internal ContextMenu contextM1;
    internal MenuItem miReadValue;
    internal MenuItem miWriteValue;
    internal MenuItem miNone1;
    internal MenuItem miInt32;
    internal MenuItem miUInt32;
    internal MenuItem miInt16;
    internal MenuItem miUInt16;
    internal MenuItem miSByte;
    internal MenuItem miByte;
    internal MenuItem miBool;
    internal MenuItem miFloat;
    internal MenuItem miDouble;
    internal MenuItem miNone2;
    internal MenuItem miUpdatePTF;
    internal Button ButtonCancel;
    internal TextBox TextBoxSearchParameter;
    internal Button ButtonSearchForParameter;
    internal ProgressBar ProgressBar1;
    internal Button ButtonPrint;
    internal Button ButtonOK;
    internal Label labelParameterInfoAvail;
    internal Grid Walter;
    internal Canvas Sign1;
    internal Button ButtonLoadPrintFile;
    private bool _contentLoaded;

    public DeviceMemory saveDeviceMemory { get; set; }

    private ObservableCollection<myDataRow> localDataSource { get; set; }

    private FirmwareParameterManager FWParamMgr { get; set; }

    private Assembly HandlerAssembly { get; set; }

    private bool InitData { get; set; }

    private bool IsParameterFileAvail { get; set; }

    private bool IsParameterFileDeveloper { get; set; }

    private bool IsDeviceConnected { get; set; }

    private bool bWriteToDevice { get; set; }

    private myDataRow actualMDR { get; set; }

    public ParameterWindow(
      DeviceMemory deviceMemory,
      BaseMemoryAccess memoryAccess,
      Assembly handlerAssembly,
      bool isDeviceConnected = true,
      bool writeToDevice = true)
    {
      this.actualDeviceMemory = deviceMemory;
      this.saveDeviceMemory = new DeviceMemory(deviceMemory);
      this.memoryAccess = memoryAccess;
      this.localDataSource = new ObservableCollection<myDataRow>();
      this.localDataSourceBACKUP = new List<myDataRow>();
      this.localDataSourceSELECT = new List<myDataRow>();
      this.cancelTokenSource = new CancellationTokenSource();
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
      this.FirmwareParameter = new SortedList<string, Parameter32bit>();
      this.FirmwareParameter = this.actualDeviceMemory.MapDef.GetAllParametersList();
      this.doSelection = false;
      this.saveAllDataToDevice = false;
      this.IsParameterFileAvail = false;
      this.HandlerAssembly = handlerAssembly;
      this.IsDeviceConnected = isDeviceConnected;
      this.bWriteToDevice = writeToDevice;
      this.InitData = true;
      this.FirstInitData = true;
      this.InitializeComponent();
      this.LoadFirmwareParameterInformation();
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      else
        this.ProgressBar1.Value = obj.ProgressPercentage;
    }

    private void Window_Loaded(object sender, RoutedEventArgs e)
    {
      this.DataGridParameterView.DataContext = (object) this.localDataSource;
      this.DataGridParameterView.ItemsSource = (IEnumerable) this.localDataSource;
    }

    public void LoadFirmwareParameterInformation()
    {
      if (this.HandlerAssembly == (Assembly) null)
        throw new Exception("Assembly Name not plausible, check DeviceMemory call.");
      if (this.FWParamMgr == null)
        this.FWParamMgr = new FirmwareParameterManager(this.HandlerAssembly);
      this.FWParamMgr.ParameterInfos = FirmwareParameterManager.LoadParameterInfos();
    }

    private void DataGrid_Loaded(object sender, RoutedEventArgs e)
    {
      if (sender == null)
        this.InitData = true;
      this.localDataSource.Clear();
      DataGrid gridParameterView = this.DataGridParameterView;
      if (this.FWParamMgr != null && this.FWParamMgr.ParameterInfos != null)
      {
        this.IsParameterFileAvail = true;
        this.labelParameterInfoAvail.Content = (object) ("Definition file location: " + FirmwareParameterManager.FileNameWithPath);
      }
      else
      {
        this.IsParameterFileAvail = false;
        this.labelParameterInfoAvail.Content = (object) "Info --- <Bold>ParameterTypeInfo file not avail.</Bold> --- All changes to TYPES will not be saved.";
      }
      this.IsParameterFileDeveloper = this.FWParamMgr != null && this.FWParamMgr.isDeveloperVersion;
      this.labelParameterInfoAvail.Visibility = Visibility.Visible;
      foreach (MenuItem menuItem in (IEnumerable) this.contextM1.Items)
      {
        if (menuItem.Name.Equals("miUpdatePTF"))
          menuItem.Visibility = this.IsParameterFileDeveloper ? Visibility.Visible : Visibility.Collapsed;
        if (menuItem.Name.Equals("miReadValue"))
          menuItem.IsEnabled = this.IsDeviceConnected;
        if (menuItem.Name.Equals("miWriteValue"))
          menuItem.IsEnabled = this.IsDeviceConnected;
      }
      foreach (Parameter32bit parameter32bit in (IEnumerable<Parameter32bit>) this.FirmwareParameter.Values)
      {
        Parameter32bit p32Bit = parameter32bit;
        this.progress.Reset(this.FirmwareParameter.Values.Count);
        int num1 = 0;
        bool flag = this.localDataSourceSELECT.Count<myDataRow>((Func<myDataRow, bool>) (x => x.Name.Contains(p32Bit.Name))) > 0;
        if (!this.doSelection || flag)
        {
          uint[] source = new uint[3]{ 1U, 2U, 4U };
          Type type = MapReader.ConvertToRealType(p32Bit.Typ);
          if (this.IsParameterFileAvail)
          {
            FirmwareParameterInfo firmwareParameterInfo = this.FWParamMgr.ParameterInfos.SingleOrDefault<FirmwareParameterInfo>((Func<FirmwareParameterInfo, bool>) (kvp => kvp.ParameterName == p32Bit.Name));
            if (firmwareParameterInfo != null && p32Bit.Typ != firmwareParameterInfo.ParameterType.ParameterTypeSaved)
            {
              Type realType = MapReader.ConvertToRealType(firmwareParameterInfo.ParameterType.ParameterTypeSaved);
              num1 = firmwareParameterInfo.ParameterType.ParameterTypeColPreset;
              if (realType != (Type) null)
              {
                Parameter32bit.SetType(realType, p32Bit);
                type = MapReader.ConvertToRealType(p32Bit.Typ);
              }
              else if (type != (Type) null)
                Parameter32bit.SetType(type, p32Bit);
            }
            else if (firmwareParameterInfo == null)
              this.GenerateParameterTypeInfo();
          }
          if (p32Bit.Typ.Contains("UNKNOWN") && ((IEnumerable<uint>) source).Contains<uint>(p32Bit.Size))
          {
            type = MapReader.getDefaultTypeForSize(p32Bit.Size);
            Parameter32bit.SetType(type, p32Bit);
          }
          uint sizeOfType = Parameter32bit.GetSizeOfType(type);
          object localValue = (object) null;
          string str1 = "";
          byte[] numArray = new byte[0];
          if (this.saveDeviceMemory.AreDataAvailable(p32Bit.Address, p32Bit.Size))
          {
            if (type == (Type) null || sizeOfType < p32Bit.Size)
            {
              localValue = (object) Parameter32bit.GetValueByteArray(p32Bit.Address, p32Bit.Size, this.saveDeviceMemory);
            }
            else
            {
              localValue = Parameter32bit.GetValue(type, p32Bit.Address, this.saveDeviceMemory);
              str1 = Parameter32bit.GetValue(type, p32Bit.Address, this.saveDeviceMemory, true).ToString();
              if (localValue != null)
                numArray = ParameterArrayAssistant.TypeToByteArray(type, localValue);
            }
          }
          object obj1 = (int) p32Bit.Size == (int) sizeOfType ? localValue : (object) "[...]";
          DeviceMemoryType deviceMemoryType = DeviceMemoryType.DataRAM;
          string message = string.Empty;
          DeviceMemoryStorage memoryTypeForData = this.saveDeviceMemory.GetDeviceMemoryTypeForData(p32Bit.Address, p32Bit.Size, out message);
          deviceMemoryType = memoryTypeForData == null ? DeviceMemoryType.NotAvail : memoryTypeForData.MemoryType;
          string str2 = deviceMemoryType.Equals((object) DeviceMemoryType.NotAvail) || deviceMemoryType.Equals((object) DeviceMemoryType.Unknown) ? "" : deviceMemoryType.ToString();
          string section1 = p32Bit.Section.ToUpper().Contains("UNKNOWN") ? "" : p32Bit.Section;
          string name = p32Bit.Name;
          string section2 = section1;
          string memoryArea = str2;
          string typ = type == (Type) null ? "" : this.OriginTypeName(type);
          uint num2 = p32Bit.Size;
          string bytes = "0x" + num2.ToString("x4");
          num2 = p32Bit.Address;
          string address = "0x" + num2.ToString("x8");
          string valuehex = str1;
          object obj2 = obj1;
          Type valTyp = type;
          myDataRow myDataRow = new myDataRow(true, this, name, section2, memoryArea, typ, bytes, address, valuehex, obj2, valTyp)
          {
            OrigValue = localValue
          };
          myDataRow.IsMemoryAvail = myDataRow.IsMemoryAvail = string.IsNullOrEmpty(message);
          if (this.InitData)
          {
            myDataRow.IsChanged = false;
            int num3 = myDataRow.ValueHEX == null ? 0 : (!string.IsNullOrEmpty(myDataRow.ValueHEX) ? 1 : 0);
            myDataRow.IsInit = num3 != 0;
          }
          myDataRow.IsReading = false;
          myDataRow.savedColumns = num1;
          this.localDataSource.Add(myDataRow);
          if (this.FirstInitData)
            this.localDataSourceBACKUP.Add(myDataRow);
          this.progress.Report();
        }
      }
      try
      {
        gridParameterView.Items.Refresh();
      }
      catch (Exception ex)
      {
      }
      this.InitData = false;
      this.FirstInitData = false;
    }

    private void DataGrid_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
    }

    private void DataGridParameterView_PreparingCellForEdit(
      object sender,
      DataGridPreparingCellForEditEventArgs e)
    {
      TextBox editingElement = e.EditingElement as TextBox;
      myDataRow myDataRow = e.Row.Item as myDataRow;
      if (editingElement.Text.Contains("[...]"))
      {
        MessageBoxResult messageBoxResult = MessageBoxResult.Yes;
        if (myDataRow.OrigValue == null)
          messageBoxResult = MessageBox.Show("No initial data avail for this parameter, please read data from device first.\nIf you continue without reading data you could damage your device.\nDo you want to continue? ", "WARNING - DAMAGE !!!", MessageBoxButton.YesNo, MessageBoxImage.Exclamation, MessageBoxResult.No);
        if (messageBoxResult == MessageBoxResult.Yes)
          this.DataGridParameterView_MouseDoubleClick(this.DataGridParameterView);
        ((DataGrid) sender).CancelEdit();
      }
      else
      {
        if (myDataRow.OrigValue != null)
          return;
        int num = (int) MessageBox.Show("No data for this parameter read from device, please read first.\nRight-Mouse click for context menu.");
        ((DataGrid) sender).CancelEdit();
      }
    }

    private void DataGridParameterView_MouseDoubleClick(DataGrid grid)
    {
      if (grid.CurrentItem == null)
        return;
      grid.Items.IndexOf(grid.CurrentItem);
      grid.CurrentCell.Column.Header.ToString();
      myDataRow mdr = grid.CurrentItem as myDataRow;
      try
      {
        if (mdr.Value == null || !mdr.Value.ToString().Contains("..."))
          return;
        Type valType = mdr.ValType;
        ParameterArrayAssistant parameterArrayAssistant = new ParameterArrayAssistant(mdr);
        parameterArrayAssistant.ShowDialog();
        if (mdr.IsChanged && !parameterArrayAssistant.isCanceled)
        {
          uint address = uint.Parse(mdr.Address.Substring(2), NumberStyles.HexNumber);
          if (mdr.OrigValue != null)
            Parameter32bit.SetValue<byte[]>((byte[]) mdr.OrigValue, address, this.saveDeviceMemory);
          mdr.ValType = valType;
          string hexString = ZR_ClassLibrary.Util.ByteArrayToHexString((byte[]) mdr.OrigValue);
          mdr.ValueHEX = hexString;
        }
        if (this.IsParameterFileAvail)
        {
          this.FWParamMgr.ParameterInfos.Single<FirmwareParameterInfo>((Func<FirmwareParameterInfo, bool>) (x => x.ParameterName == mdr.Name)).ParameterType.ParameterTypeColPreset = mdr.savedColumns;
          FirmwareParameterManager.SaveParameterInfos(this.FWParamMgr.ParameterInfos);
        }
      }
      catch (Exception ex)
      {
        throw new Exception("ERROR: \n\n" + ex.Message);
      }
      finally
      {
      }
    }

    private async void DataGridReadValue_MouseClick(object sender, RoutedEventArgs e)
    {
      this.progress.Report("reading...");
      DataGrid grid = this.DataGridParameterView;
      try
      {
        if (grid == null || grid.SelectedItems == null || grid.SelectedItems.Count <= 0)
        {
          grid = (DataGrid) null;
        }
        else
        {
          IEnumerable<myDataRow> items = grid.SelectedItems.OfType<myDataRow>();
          this.progress.Reset(items.Count<myDataRow>());
          foreach (myDataRow mdr in items)
          {
            uint address = uint.Parse(mdr.Address.Substring(2), NumberStyles.HexNumber);
            uint bytes = uint.Parse(mdr.Bytes.Substring(2), NumberStyles.HexNumber);
            this.saveDeviceMemory.GarantMemoryAvailable(new AddressRange(address, bytes));
            await this.memoryAccess.ReadMemoryAsync(new AddressRange(address, bytes), this.saveDeviceMemory, this.progress, this.cancelTokenSource.Token);
            Type myType = MapReader.ConvertToRealType(mdr.Typ);
            uint TypeSize = Parameter32bit.GetSizeOfType(mdr.ValType);
            if ((int) bytes == (int) TypeSize)
            {
              mdr.IsInit = true;
              mdr.IsReading = true;
              object oldOrigValue = mdr.OrigValue;
              object result = Parameter32bit.GetValue(myType, address, this.saveDeviceMemory);
              mdr.OrigValue = result;
              mdr.Value = myType != (Type) null ? result : (object) "[...]";
              mdr.ValueHEX = this.getHexStringForObject(result.ToString(), myType);
              if (!mdr.IsMemoryAvail && !string.IsNullOrEmpty(mdr.MemoryArea))
              {
                mdr.IsMemoryAvail = true;
                mdr.MemoryArea = mdr.MemoryArea.Substring(0, mdr.MemoryArea.Contains("-") ? mdr.MemoryArea.IndexOf('-') : mdr.MemoryArea.Length).Trim();
              }
              mdr.IsChanged = false;
              mdr.IsReading = false;
              oldOrigValue = (object) null;
              result = (object) null;
            }
            else
            {
              mdr.IsInit = true;
              mdr.IsReading = true;
              string message = string.Empty;
              byte[] result = Parameter32bit.GetValueByteArray(address, bytes, this.saveDeviceMemory);
              this.saveDeviceMemory.GetDeviceMemoryTypeForData(address, bytes, out message);
              mdr.MemoryArea = mdr.MemoryArea.Substring(0, mdr.MemoryArea.Contains("-") ? mdr.MemoryArea.IndexOf('-') : mdr.MemoryArea.Length).Trim();
              mdr.IsMemoryAvail = true;
              mdr.OrigValue = (object) result;
              mdr.IsValueForced = true;
              mdr.Value = (object) "[...]";
              mdr.IsValueForced = false;
              string hexString = ZR_ClassLibrary.Util.ByteArrayToHexString(result);
              mdr.ValueHEX = hexString;
              mdr.IsChanged = false;
              mdr.IsReading = false;
              message = (string) null;
              result = (byte[]) null;
              hexString = (string) null;
            }
            this.progress.Report("Read 0x" + mdr.Address + " " + mdr.Bytes + " byte(s)");
            myType = (Type) null;
          }
          items = (IEnumerable<myDataRow>) null;
          grid = (DataGrid) null;
        }
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex, "Error occurred:\n\nDataGridReadValueFromDevice Error...");
        grid = (DataGrid) null;
      }
    }

    private async void DataGridWriteValue_MouseClick(object sender, RoutedEventArgs e)
    {
      DataGrid grid;
      if (!this.bWriteToDevice)
      {
        int num = (int) MessageBox.Show("Write to device is disabled!");
        grid = (DataGrid) null;
      }
      else
      {
        grid = this.DataGridParameterView;
        try
        {
          if (grid == null || grid.SelectedItems == null || grid.SelectedItems.Count <= 0)
          {
            grid = (DataGrid) null;
          }
          else
          {
            IEnumerable<myDataRow> items = grid.SelectedItems.OfType<myDataRow>();
            this.progress.Reset(items.Count<myDataRow>());
            foreach (myDataRow mdr in grid.SelectedItems.OfType<myDataRow>())
            {
              this.progress.Report("Write 0x" + mdr.Address + " " + mdr.Bytes + " byte(s)");
              uint address = uint.Parse(mdr.Address.Substring(2), NumberStyles.HexNumber);
              uint size = uint.Parse(mdr.Bytes.Substring(2), NumberStyles.HexNumber);
              this.saveDeviceMemory.GarantMemoryAvailable(new AddressRange(address, size));
              await this.memoryAccess.WriteMemoryAsync(new AddressRange(address, size), this.saveDeviceMemory, this.progress, this.cancelTokenSource.Token);
              mdr.IsInit = true;
              mdr.IsChanged = false;
            }
            items = (IEnumerable<myDataRow>) null;
            grid = (DataGrid) null;
          }
        }
        catch (Exception ex)
        {
          int num = (int) MessageBox.Show("Error occurred:\n\n" + ex.Message, "WriteValueToDeviceError ...");
          grid = (DataGrid) null;
        }
      }
    }

    private void WriteDataToMemoryOnly(DeviceMemory memory = null)
    {
      try
      {
        if (memory == null)
          memory = this.saveDeviceMemory;
        this.progress.Reset(this.DataGridParameterView.Items.Count);
        foreach (myDataRow myDataRow in this.DataGridParameterView.Items.OfType<myDataRow>())
        {
          if (myDataRow.IsChanged || myDataRow.IsSavedTemp || this.saveAllDataToDevice)
          {
            uint num = uint.Parse(myDataRow.Address.Substring(2), NumberStyles.HexNumber);
            uint length = uint.Parse(myDataRow.Bytes.Substring(2), NumberStyles.HexNumber);
            byte[] numArray = new byte[(int) length];
            byte[] data = !(myDataRow.ValType == (Type) null) && !(myDataRow.ValType == typeof (byte[])) && (!(myDataRow.ValType != typeof (double)) || length <= 4U) ? ParameterArrayAssistant.TypeToByteArray(myDataRow.ValType, myDataRow.OrigValue) : (byte[]) myDataRow.OrigValue;
            AddressRange setRange = new AddressRange(num, (uint) data.Length);
            memory.GarantMemoryAvailable(setRange);
            memory.SetData(num, data);
            this.isDataSaved = true;
            myDataRow.IsSavedTemp = true;
            if (myDataRow.IsChanged)
              myDataRow.IsChanged = false;
          }
          this.ProgressBar1.UpdateLayout();
        }
      }
      catch (Exception ex)
      {
        throw new Exception("An error occurred while writing data to memory.\nMessage:" + ex.Message);
      }
    }

    private void ButtonCancel_Click(object sender, RoutedEventArgs e)
    {
      this.CancelButtonPressed = true;
      this.Close();
    }

    private void ButtonOK_Click(object sender, RoutedEventArgs e)
    {
      this.CancelButtonPressed = false;
      this.WriteDataToMemoryOnly(this.actualDeviceMemory);
      this.Close();
    }

    protected override void OnClosing(CancelEventArgs e)
    {
      foreach (myDataRow myDataRow in this.DataGridParameterView.Items.OfType<myDataRow>())
      {
        if (myDataRow.IsChanged)
        {
          if (MessageBox.Show("There are changes in the Parameters.\nDo you want to discard the changes ? ", "Discard changes ?", MessageBoxButton.YesNo, MessageBoxImage.Exclamation, MessageBoxResult.No) == MessageBoxResult.No)
          {
            e.Cancel = true;
            break;
          }
          break;
        }
      }
      if (!this.CancelButtonPressed && !e.Cancel && this.isDataSaved)
        this.WriteDataToMemoryOnly(this.actualDeviceMemory);
      this.CancelButtonPressed = false;
      base.OnClosing(e);
    }

    private void ButtonSearchForParameter_Click(object sender, RoutedEventArgs e)
    {
      string lower = this.TextBoxSearchParameter.Text.ToLower();
      this.localDataSourceSELECT.Clear();
      if (!string.IsNullOrEmpty(lower))
      {
        this.doSelection = true;
        foreach (myDataRow myDataRow in this.localDataSourceBACKUP)
        {
          if (((((((((myDataRow.Name.ToLower().Contains(lower) ? 1 : 0) | (myDataRow.Value != null ? (myDataRow.Value.ToString().ToLower().Contains(lower) ? 1 : 0) : 0)) != 0 ? 1 : 0) | (myDataRow.ValueHEX != null ? (myDataRow.ValueHEX.ToLower().Contains(lower) ? 1 : 0) : 0)) != 0 | myDataRow.Typ.ToLower().Contains(lower) ? 1 : 0) | (myDataRow.Section != null ? (myDataRow.Section.ToLower().Contains(lower) ? 1 : 0) : 0)) != 0 | myDataRow.Address.ToLower().Contains(lower) | myDataRow.Bytes.ToLower().Contains(lower) ? 1 : 0) | (myDataRow.MemoryArea != null ? (myDataRow.MemoryArea.ToLower().Contains(lower) ? 1 : 0) : 0)) != 0)
            this.localDataSourceSELECT.Add(myDataRow);
        }
      }
      else
        this.doSelection = false;
      this.DataGrid_Loaded((object) null, (RoutedEventArgs) null);
    }

    private void DataGridSetNewType(Type myType)
    {
      try
      {
        if (this.IsParameterFileDeveloper && !this.IsParameterFileAvail)
          this.GenerateParameterTypeInfo();
        bool flag = false;
        DataGrid gridParameterView = this.DataGridParameterView;
        if (gridParameterView == null || gridParameterView.SelectedItems == null || gridParameterView.SelectedItems.Count <= 0)
          return;
        gridParameterView.SelectedItems.OfType<myDataRow>();
        foreach (myDataRow myDataRow in gridParameterView.SelectedItems.OfType<myDataRow>())
        {
          myDataRow mdr = myDataRow;
          uint address = uint.Parse(mdr.Address.Substring(2), NumberStyles.HexNumber);
          uint byteSize = uint.Parse(mdr.Bytes.Substring(2), NumberStyles.HexNumber);
          uint sizeOfType = Parameter32bit.GetSizeOfType(myType);
          if ((int) byteSize == (int) sizeOfType)
          {
            mdr.ValType = myType;
            mdr.Typ = this.OriginTypeName(myType);
            object origValue = mdr.OrigValue;
            if (mdr.OrigValue != null)
            {
              mdr.IsInit = true;
              mdr.IsReading = true;
              object obj = Parameter32bit.GetValue(myType, address, this.saveDeviceMemory);
              mdr.OrigValue = obj;
              mdr.Value = myType != (Type) null ? obj : (object) "[...]";
              mdr.ValueHEX = this.getHexStringForObject(obj.ToString(), myType);
              if (!mdr.IsMemoryAvail && !string.IsNullOrEmpty(mdr.MemoryArea))
              {
                mdr.IsMemoryAvail = true;
                mdr.MemoryArea = mdr.MemoryArea.Substring(0, mdr.MemoryArea.Contains("-") ? mdr.MemoryArea.IndexOf('-') : mdr.MemoryArea.Length).Trim();
              }
            }
            else if (!string.IsNullOrEmpty(mdr.Value.ToString()) && mdr.Value.ToString().Contains("[...]"))
            {
              mdr.IsValueForced = true;
              mdr.Value = (object) null;
              mdr.IsValueForced = false;
            }
            mdr.IsChanged = false;
            mdr.IsReading = false;
          }
          else if (byteSize > sizeOfType)
          {
            mdr.ValType = myType;
            mdr.Typ = this.OriginTypeName(myType);
            if (mdr.OrigValue != null)
            {
              mdr.IsInit = true;
              mdr.IsReading = true;
              string message = string.Empty;
              byte[] valueByteArray = Parameter32bit.GetValueByteArray(address, byteSize, this.saveDeviceMemory);
              this.saveDeviceMemory.GetDeviceMemoryTypeForData(address, byteSize, out message);
              mdr.MemoryArea = mdr.MemoryArea.Substring(0, mdr.MemoryArea.Contains("-") ? mdr.MemoryArea.IndexOf('-') : mdr.MemoryArea.Length).Trim();
              mdr.IsMemoryAvail = !string.IsNullOrEmpty(message) || !message.Contains("not avail");
              mdr.ResetOldValue();
              mdr.OrigValue = (object) valueByteArray;
              string hexString = ZR_ClassLibrary.Util.ByteArrayToHexString(valueByteArray);
              mdr.ValueHEX = hexString;
            }
            mdr.IsValueForced = true;
            mdr.Value = (object) "[...]";
            mdr.IsValueForced = false;
            mdr.IsChanged = false;
            mdr.IsReading = false;
          }
          else if (byteSize < sizeOfType)
            return;
          if (this.IsParameterFileAvail)
          {
            FirmwareParameterInfo firmwareParameterInfo = this.FWParamMgr.ParameterInfos.Single<FirmwareParameterInfo>((Func<FirmwareParameterInfo, bool>) (x => x.ParameterName == mdr.Name));
            firmwareParameterInfo.ParameterType.ParameterTypeSaved = myType.Name;
            firmwareParameterInfo.ParameterType.ParameterTypeColPreset = mdr.savedColumns;
            flag = true;
            mdr.IsTypeChanged = true;
          }
        }
        if (flag && this.IsParameterFileAvail)
          FirmwareParameterManager.SaveParameterInfos(this.FWParamMgr.ParameterInfos);
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show("ERROR:\n" + ex.Message);
      }
    }

    private void GenerateParameterTypeInfo()
    {
      if (this.FWParamMgr == null)
        return;
      FirmwareParameterManager fwParamMgr = this.FWParamMgr;
      FirmwareParameterManager.GenerateParameterInfo(this.actualDeviceMemory.MapDef, ref fwParamMgr);
      FirmwareParameterManager.SaveParameterInfos(this.FWParamMgr.ParameterInfos);
    }

    private string getValueStringFromHex(Type myType, string value)
    {
      string empty = string.Empty;
      if (myType == typeof (double) || myType == typeof (float))
        return double.Parse(value, NumberStyles.HexNumber).ToString();
      if (myType == typeof (byte))
        return byte.Parse(value, NumberStyles.HexNumber).ToString();
      if (myType == typeof (sbyte))
        return sbyte.Parse(value, NumberStyles.HexNumber).ToString();
      if (myType == typeof (short))
        return short.Parse(value, NumberStyles.HexNumber).ToString();
      if (myType == typeof (ushort))
        return ushort.Parse(value, NumberStyles.HexNumber).ToString();
      if (myType == typeof (int))
        return int.Parse(value, NumberStyles.HexNumber).ToString();
      if (myType == typeof (uint))
        return uint.Parse(value, NumberStyles.HexNumber).ToString();
      return myType == typeof (Decimal) ? Decimal.Parse(value, NumberStyles.HexNumber).ToString() : empty;
    }

    private void DataGridSetType_MouseClick(object sender, RoutedEventArgs e)
    {
      MenuItem menuItem = (MenuItem) sender;
      if (menuItem.Header.Equals((object) "uint"))
        this.DataGridSetNewType(typeof (uint));
      else if (menuItem.Header.Equals((object) "ushort"))
        this.DataGridSetNewType(typeof (ushort));
      else if (menuItem.Header.Equals((object) "double"))
        this.DataGridSetNewType(typeof (double));
      else if (menuItem.Header.Equals((object) "float"))
        this.DataGridSetNewType(typeof (float));
      else if (menuItem.Header.Equals((object) "byte"))
        this.DataGridSetNewType(typeof (byte));
      else if (menuItem.Header.Equals((object) "sbyte"))
        this.DataGridSetNewType(typeof (sbyte));
      else if (menuItem.Header.Equals((object) "int"))
        this.DataGridSetNewType(typeof (int));
      else if (menuItem.Header.Equals((object) "short"))
        this.DataGridSetNewType(typeof (short));
      else if (menuItem.Header.Equals((object) "Bool"))
        this.DataGridSetNewType(typeof (bool));
      else if (menuItem.Header.Equals((object) "byte[]"))
      {
        this.DataGridSetNewType(typeof (byte[]));
      }
      else
      {
        if (!menuItem.Header.Equals((object) "-none-"))
          return;
        this.DataGridSetNewType((Type) null);
      }
    }

    private string OriginTypeName(Type myType)
    {
      if (myType == typeof (uint))
        return "uint";
      if (myType == typeof (ushort))
        return "ushort";
      if (myType == typeof (int))
        return "int";
      if (myType == typeof (short))
        return "short";
      if (myType == typeof (sbyte))
        return "sbyte";
      if (myType == typeof (byte))
        return "byte";
      if (myType == typeof (float))
        return "float";
      if (myType == typeof (double))
        return "double";
      if (myType == typeof (byte[]))
        return "byte[]";
      if (myType == typeof (sbyte[]))
        return "sbyte[]";
      return myType == typeof (bool) ? "bool" : string.Empty;
    }

    private void DataGridUpdatePTF_MouseClick(object sender, RoutedEventArgs e)
    {
      this.GenerateParameterTypeInfo();
    }

    private string getHexStringForObject(string value, Type myType)
    {
      if (myType == typeof (byte))
        return byte.Parse(value).ToString("X2");
      if (myType == typeof (sbyte))
        return sbyte.Parse(value).ToString("X2");
      if (myType == typeof (short))
        return short.Parse(value).ToString("X4");
      if (myType == typeof (ushort))
        return ushort.Parse(value).ToString("X4");
      if (myType == typeof (int))
        return int.Parse(value).ToString("X8");
      if (myType == typeof (uint))
        return uint.Parse(value).ToString("X8");
      if (myType == typeof (float))
        return ParameterArrayAssistant.float2HEXString(float.Parse(value));
      if (myType == typeof (double))
        return ParameterArrayAssistant.double2HEXString(double.Parse(value));
      return myType == typeof (Decimal) ? Decimal.Parse(value).ToString("x8") : string.Empty;
    }

    private void ButtonPrint_Click(object sender, RoutedEventArgs e)
    {
      if (this.actualDeviceMemory == null)
        return;
      string title = new FirmwareVersion(this.actualDeviceMemory.FirmwareVersion).ToString() + " (" + DateTime.Now.ToString("dd.MM.yyyy HH:mm:ss") + ")";
      string parameterInfo = this.actualDeviceMemory.GetParameterInfo();
      if (string.IsNullOrEmpty(parameterInfo))
        return;
      NotepadHelper.ShowMessage(parameterInfo, title);
    }

    private void ButtonLoadPrintFile_Click(object sender, RoutedEventArgs e)
    {
      if (this.actualDeviceMemory == null)
        return;
      OpenFileDialog openFileDialog = new OpenFileDialog();
      openFileDialog.DefaultExt = ".txt";
      openFileDialog.Filter = "Backup file (*.txt)|*.txt";
      bool? nullable = openFileDialog.ShowDialog();
      bool flag = true;
      if (!(nullable.GetValueOrDefault() == flag & nullable.HasValue))
        return;
      try
      {
        string[] strArray = File.ReadAllText(openFileDialog.FileName).Split(new string[1]
        {
          Environment.NewLine
        }, StringSplitOptions.None);
        for (int index = 4; index < strArray.Length; ++index)
        {
          List<string> list = ((IEnumerable<string>) Regex.Split(strArray[index], "\\s+")).Where<string>((Func<string, bool>) (s => s != string.Empty)).Select<string, string>((Func<string, string>) (p => p.Trim())).ToList<string>();
          if (list.Count<string>() > 4)
            this.actualDeviceMemory.SetData(Convert.ToUInt32(list[0], 16), ZR_ClassLibrary.Util.HexStringToByteArray(list[4]));
        }
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/parameterwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          ((FrameworkElement) target).Loaded += new RoutedEventHandler(this.Window_Loaded);
          break;
        case 2:
          this.gmmCorporateControl1 = (StartupLib.GmmCorporateControl) target;
          break;
        case 3:
          this.DataGridParameterView = (DataGrid) target;
          this.DataGridParameterView.Loaded += new RoutedEventHandler(this.DataGrid_Loaded);
          this.DataGridParameterView.PreparingCellForEdit += new EventHandler<DataGridPreparingCellForEditEventArgs>(this.DataGridParameterView_PreparingCellForEdit);
          this.DataGridParameterView.SelectionChanged += new SelectionChangedEventHandler(this.DataGrid_SelectionChanged);
          break;
        case 4:
          this.contextM1 = (ContextMenu) target;
          break;
        case 5:
          this.miReadValue = (MenuItem) target;
          this.miReadValue.Click += new RoutedEventHandler(this.DataGridReadValue_MouseClick);
          break;
        case 6:
          this.miWriteValue = (MenuItem) target;
          this.miWriteValue.Click += new RoutedEventHandler(this.DataGridWriteValue_MouseClick);
          break;
        case 7:
          this.miNone1 = (MenuItem) target;
          break;
        case 8:
          this.miInt32 = (MenuItem) target;
          this.miInt32.Click += new RoutedEventHandler(this.DataGridSetType_MouseClick);
          break;
        case 9:
          this.miUInt32 = (MenuItem) target;
          this.miUInt32.Click += new RoutedEventHandler(this.DataGridSetType_MouseClick);
          break;
        case 10:
          this.miInt16 = (MenuItem) target;
          this.miInt16.Click += new RoutedEventHandler(this.DataGridSetType_MouseClick);
          break;
        case 11:
          this.miUInt16 = (MenuItem) target;
          this.miUInt16.Click += new RoutedEventHandler(this.DataGridSetType_MouseClick);
          break;
        case 12:
          this.miSByte = (MenuItem) target;
          this.miSByte.Click += new RoutedEventHandler(this.DataGridSetType_MouseClick);
          break;
        case 13:
          this.miByte = (MenuItem) target;
          this.miByte.Click += new RoutedEventHandler(this.DataGridSetType_MouseClick);
          break;
        case 14:
          this.miBool = (MenuItem) target;
          this.miBool.Click += new RoutedEventHandler(this.DataGridSetType_MouseClick);
          break;
        case 15:
          this.miFloat = (MenuItem) target;
          this.miFloat.Click += new RoutedEventHandler(this.DataGridSetType_MouseClick);
          break;
        case 16:
          this.miDouble = (MenuItem) target;
          this.miDouble.Click += new RoutedEventHandler(this.DataGridSetType_MouseClick);
          break;
        case 17:
          this.miNone2 = (MenuItem) target;
          break;
        case 18:
          this.miUpdatePTF = (MenuItem) target;
          this.miUpdatePTF.Click += new RoutedEventHandler(this.DataGridUpdatePTF_MouseClick);
          break;
        case 19:
          this.ButtonCancel = (Button) target;
          this.ButtonCancel.Click += new RoutedEventHandler(this.ButtonCancel_Click);
          break;
        case 20:
          this.TextBoxSearchParameter = (TextBox) target;
          break;
        case 21:
          this.ButtonSearchForParameter = (Button) target;
          this.ButtonSearchForParameter.Click += new RoutedEventHandler(this.ButtonSearchForParameter_Click);
          break;
        case 22:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        case 23:
          this.ButtonPrint = (Button) target;
          this.ButtonPrint.Click += new RoutedEventHandler(this.ButtonPrint_Click);
          break;
        case 24:
          this.ButtonOK = (Button) target;
          this.ButtonOK.Click += new RoutedEventHandler(this.ButtonOK_Click);
          break;
        case 25:
          this.labelParameterInfoAvail = (Label) target;
          break;
        case 26:
          this.Walter = (Grid) target;
          break;
        case 27:
          this.Sign1 = (Canvas) target;
          break;
        case 28:
          this.ButtonLoadPrintFile = (Button) target;
          this.ButtonLoadPrintFile.Click += new RoutedEventHandler(this.ButtonLoadPrintFile_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- PropertyEditorWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.PropertyEditorWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Reflection;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class PropertyEditorWindow : Window, IComponentConnector
  {
    private object obj;
    internal Button ButtonSave;
    private bool _contentLoaded;

    public List<ParameterItem> Propertys { get; set; }

    public PropertyEditorWindow(Window owner, object obj)
    {
      this.InitializeComponent();
      this.Owner = owner;
      this.obj = obj;
      this.Propertys = new List<ParameterItem>();
      foreach (PropertyDescriptor property in TypeDescriptor.GetProperties(obj))
      {
        string name = property.Name;
        bool flag = property.Attributes.Contains((Attribute) ReadOnlyAttribute.Yes);
        object buffer = property.GetValue(obj);
        string str = string.Empty;
        if (buffer != null)
        {
          Type type = buffer.GetType();
          if (type == typeof (byte[]))
            str = Utility.ByteArrayToHexString((byte[]) buffer);
          else if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof (Dictionary<,>))
          {
            Type genericArgument1 = type.GetGenericArguments()[0];
            Type genericArgument2 = type.GetGenericArguments()[1];
            IDictionary dictionary = buffer as IDictionary;
            IEnumerator enumerator = dictionary.Keys.GetEnumerator();
            try
            {
              while (enumerator.MoveNext())
              {
                object current = enumerator.Current;
                this.Propertys.Add(new ParameterItem()
                {
                  Key = current.ToString(),
                  Value = dictionary[current] != null ? dictionary[current].ToString() : "",
                  IsReadOnly = flag
                });
              }
              continue;
            }
            finally
            {
              if (enumerator is IDisposable disposable)
                disposable.Dispose();
            }
          }
          else
            str = buffer.ToString();
        }
        this.Propertys.Add(new ParameterItem()
        {
          Key = name,
          Value = str,
          IsReadOnly = flag
        });
      }
      this.DataContext = (object) this;
    }

    private void ButtonSave_Click(object sender, RoutedEventArgs e)
    {
      foreach (ParameterItem property1 in this.Propertys)
      {
        if (!property1.IsReadOnly)
        {
          PropertyInfo property2 = this.obj.GetType().GetProperty(property1.Key);
          property2.SetValue(this.obj, Convert.ChangeType((object) property1.Value, property2.PropertyType), (object[]) null);
        }
      }
      this.DialogResult = new bool?(true);
      this.Close();
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/propertyeditorwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      if (connectionId == 1)
      {
        this.ButtonSave = (Button) target;
        this.ButtonSave.Click += new RoutedEventHandler(this.ButtonSave_Click);
      }
      else
        this._contentLoaded = true;
    }
  }
}


--- ProtectionWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ProtectionWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class ProtectionWindow : Window, IComponentConnector
  {
    private bool isWriteProtection;
    private CancellationTokenSource cancelToken;
    private ProgressHandler progress;
    private DeviceCommandsMBus deviceCommands;
    private Common32BitCommands deviceCommonCMD;
    private Cursor defaultCursor;
    internal TextBox TextProtectionKey;
    internal Button ButtonSetProtectionKey;
    internal Button ButtonCheckProtectionKey;
    internal TextBox TextSeriesKey;
    internal Button ButtonSetSeriesKey;
    internal Button ButtonDelSeriesKey;
    internal Button ButtonSaveSeriesKey;
    internal TextBlock TextBlock_Status;
    internal Button ButtonCancel;
    internal Button ButtonOpenWriteProtectionTemporarily;
    private bool _contentLoaded;

    public ProtectionWindow()
    {
      this.InitializeComponent();
      this.isWriteProtection = false;
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
    }

    private void StartUp()
    {
      if (this.deviceCommands == null || this.deviceCommands.SeriesKey <= 0U)
        return;
      this.TextSeriesKey.Text = "0x" + this.deviceCommands.SeriesKey.ToString("x4");
    }

    private void SetRunState()
    {
      this.cancelToken = new CancellationTokenSource();
      this.ButtonCheckProtectionKey.IsEnabled = false;
      this.ButtonSetProtectionKey.IsEnabled = false;
      this.ButtonDelSeriesKey.IsEnabled = false;
      this.ButtonSaveSeriesKey.IsEnabled = false;
      this.ButtonSetSeriesKey.IsEnabled = false;
      this.ButtonSetProtectionKey.IsEnabled = false;
      this.ButtonCancel.IsEnabled = true;
      this.defaultCursor = this.Cursor;
      this.Cursor = Cursors.Wait;
    }

    private void SetStopState()
    {
      this.ButtonCheckProtectionKey.IsEnabled = true;
      this.ButtonSetProtectionKey.IsEnabled = true;
      this.ButtonDelSeriesKey.IsEnabled = true;
      this.ButtonSaveSeriesKey.IsEnabled = true;
      this.ButtonSetSeriesKey.IsEnabled = true;
      this.ButtonSetProtectionKey.IsEnabled = true;
      this.ButtonCancel.IsEnabled = false;
      this.Cursor = this.defaultCursor;
    }

    private void OnProgress(ProgressArg obj)
    {
      if (this.CheckAccess())
        return;
      this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
    }

    public static void Show(
      Window owner,
      DeviceCommandsMBus deviceCommands,
      Common32BitCommands commonCMDs)
    {
      ProtectionWindow protectionWindow1 = new ProtectionWindow();
      protectionWindow1.deviceCommands = deviceCommands;
      protectionWindow1.Owner = owner;
      protectionWindow1.deviceCommonCMD = commonCMDs;
      ProtectionWindow protectionWindow2 = protectionWindow1;
      protectionWindow2.StartUp();
      protectionWindow2.ShowDialog();
    }

    private async void SetWriteProtectionAsync_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.SetRunState();
        this.progress.Reset();
        this.TextBlock_Status.Text = "Status:";
        string text = this.TextProtectionKey.Text;
        byte[] data = text.Length == 8 ? Util.HexStringToByteArray(text.Replace("0x", "")) : throw new Exception("Key not in a valid format. (4 Bytes)");
        await this.deviceCommonCMD.SetWriteProtectionAsync(data, this.progress, this.cancelToken.Token);
        this.TextBlock_Status.Text = "Status: Write protection key successfully set.";
        text = (string) null;
        data = (byte[]) null;
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "SetWriteProtection error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      finally
      {
        this.SetStopState();
      }
    }

    private async void CheckWriteProtectionAsync_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.SetRunState();
        this.TextBlock_Status.Text = "Status:";
        this.progress.Reset();
        byte[] key = new byte[4];
        await this.deviceCommonCMD.OpenWriteProtectionTemporarilyAsync(key, this.progress, this.cancelToken.Token);
        this.isWriteProtection = true;
        this.TextBlock_Status.Text = "Status: Write protection key is set.";
        key = (byte[]) null;
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        this.TextBlock_Status.Text = "Status: " + ex.Message;
        this.isWriteProtection = false;
      }
      finally
      {
        this.SetStopState();
      }
    }

    private async void OpenWriteProtectionAsync_Click(object sender, RoutedEventArgs e)
    {
      bool oldWRProtection = this.isWriteProtection;
      try
      {
        this.SetRunState();
        this.TextBlock_Status.Text = "Status:";
        this.progress.Reset();
        string text = this.TextProtectionKey.Text;
        byte[] key = text.Length == 8 ? Util.HexStringToByteArray(text.Replace("0x", "")) : throw new Exception("Key not in a valid format. (4 Bytes)");
        await this.deviceCommonCMD.OpenWriteProtectionTemporarilyAsync(key, this.progress, this.cancelToken.Token);
        this.isWriteProtection = false;
        this.TextBlock_Status.Text = "Status: Write protection temporarily disabled !!!";
        text = (string) null;
        key = (byte[]) null;
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        this.TextBlock_Status.Text = "Status: " + ex.Message;
        this.isWriteProtection = oldWRProtection;
      }
      finally
      {
        this.SetStopState();
      }
    }

    private async void SaveSeriesKeyAsync_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.SetRunState();
        this.TextBlock_Status.Text = "Status:";
        this.progress.Reset();
        string text = this.TextSeriesKey.Text;
        if (text.Length != 8 && text.Length != 10)
          throw new Exception("Key not in a valid format. (4 Bytes)");
        uint uintkey = 0;
        uintkey = !text.Substring(0, 2).Equals("0x") ? uint.Parse(text) : uint.Parse(text.Substring(2), NumberStyles.HexNumber);
        await Task.Run((Action) (() => this.deviceCommands.SaveSeriesKey(uintkey)));
        this.TextBlock_Status.Text = "Status: Series Key saved.";
        text = (string) null;
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        this.TextBlock_Status.Text = "Status: " + ex.Message;
      }
      finally
      {
        this.SetStopState();
      }
    }

    private async void UseSeriesKeyAsync_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.SetRunState();
        this.TextBlock_Status.Text = "Status:";
        this.progress.Reset();
        string text = this.TextSeriesKey.Text;
        if (text.Length != 8 && text.Length != 10)
          throw new Exception("Key not in a valid format. (4 Bytes)");
        uint uintkey = 0;
        uintkey = !text.Substring(0, 2).Equals("0x") ? uint.Parse(text) : uint.Parse(text.Substring(2), NumberStyles.HexNumber);
        await Task.Run((Action) (() => this.deviceCommands.SetProtectedIdentification(uintkey)));
        this.TextBlock_Status.Text = "Status: Series Key is in usage now.";
        text = (string) null;
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        this.TextBlock_Status.Text = "Status: " + ex.Message;
      }
      finally
      {
        this.SetStopState();
      }
    }

    private async void DeleteSeriesKeyAsync_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.SetRunState();
        this.TextBlock_Status.Text = "Status:";
        this.progress.Reset();
        await Task.Run((Action) (() => this.deviceCommands.ClearProtectedIdentification()));
        this.TextBlock_Status.Text = "Status: Series Key deleted. ProtectionIdentification cleared.";
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        this.TextBlock_Status.Text = "Status: " + ex.Message;
      }
      finally
      {
        this.SetStopState();
      }
    }

    private void Cancel_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.TextBlock_Status.Text = "Status:";
        this.cancelToken.Cancel();
        this.TextBlock_Status.Text = "Status: operation cancelled by user.";
        this.SetStopState();
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        this.TextBlock_Status.Text = "Status: " + ex.Message;
      }
      finally
      {
        this.SetStopState();
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/protectionwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.TextProtectionKey = (TextBox) target;
          break;
        case 2:
          this.ButtonSetProtectionKey = (Button) target;
          this.ButtonSetProtectionKey.Click += new RoutedEventHandler(this.SetWriteProtectionAsync_Click);
          break;
        case 3:
          this.ButtonCheckProtectionKey = (Button) target;
          this.ButtonCheckProtectionKey.Click += new RoutedEventHandler(this.CheckWriteProtectionAsync_Click);
          break;
        case 4:
          this.TextSeriesKey = (TextBox) target;
          break;
        case 5:
          this.ButtonSetSeriesKey = (Button) target;
          this.ButtonSetSeriesKey.Click += new RoutedEventHandler(this.UseSeriesKeyAsync_Click);
          break;
        case 6:
          this.ButtonDelSeriesKey = (Button) target;
          this.ButtonDelSeriesKey.Click += new RoutedEventHandler(this.DeleteSeriesKeyAsync_Click);
          break;
        case 7:
          this.ButtonSaveSeriesKey = (Button) target;
          this.ButtonSaveSeriesKey.Click += new RoutedEventHandler(this.SaveSeriesKeyAsync_Click);
          break;
        case 8:
          this.TextBlock_Status = (TextBlock) target;
          break;
        case 9:
          this.ButtonCancel = (Button) target;
          this.ButtonCancel.Click += new RoutedEventHandler(this.SaveSeriesKeyAsync_Click);
          break;
        case 10:
          this.ButtonOpenWriteProtectionTemporarily = (Button) target;
          this.ButtonOpenWriteProtectionTemporarily.Click += new RoutedEventHandler(this.CheckWriteProtectionAsync_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- RADIO_MODE.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.RADIO_MODE
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum RADIO_MODE : ushort
  {
    Radio3_Sz0,
    Radio3,
    Radio3_Sz5,
    wMBusS1,
    wMBusS2,
    wMBusT1,
    wMBusT2Met,
    wMBusT2Oth,
    wMBusC1,
    wMBusC1B,
    Off,
  }
}


--- RadioCommandWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.RadioCommandWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZENNER.CommonLibrary.Exceptions;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class RadioCommandWindow : Window, IComponentConnector
  {
    private CommonRadioCommands myRadioCommands;
    private IPort myPort;
    private List<string> Argument1_last_values;
    private List<string> Argument2_last_values;
    private List<string> Argument3_last_values;
    private List<string> Argument4_last_values;
    private List<string> Argument5_last_values;
    private List<string> Argument6_last_values;
    private ContextMenu Argument1ValuesMenu;
    private ContextMenu Argument2ValuesMenu;
    private ContextMenu Argument3ValuesMenu;
    private ContextMenu Argument4ValuesMenu;
    private ContextMenu Argument5ValuesMenu;
    private ContextMenu Argument6ValuesMenu;
    private static string result = "";
    private static readonly string CMD_GetRadioVersion = "Get radio version (0x00)";
    private static readonly string CMD_SetTransmitPower = "Set transmit power (0x05)";
    private static readonly string CMD_GetTransmitPower = "Get transmit power (0x05)";
    private static readonly string CMD_SetCenterFrequency = "Set center frequency (0x06)";
    private static readonly string CMD_GetCenterFrequency = "Get center frequency (0x06)";
    private static readonly string CMD_SetFrequencyIncrement = "Set frequency increment (0x07)";
    private static readonly string CMD_GetFrequencyIncrement = "Get frequency increment (0x07)";
    private static readonly string CMD_SetCarrierMode = "Set carrier Mode (0x08)";
    private static readonly string CMD_GetCarrierMode = "Get carrier Mode (0x08)";
    private static readonly string CMD_SetFrequencyDeviation = "Set TX frequency deviation (0x09)";
    private static readonly string CMD_GetFrequencyDeviation = "Get TX frequency deviation (0x09)";
    private static readonly string CMD_SetBandwidth = "Set RX bandwidth (0x0a)";
    private static readonly string CMD_GetBandwidth = "Get RX bandwidth (0x0a)";
    private static readonly string CMD_SetTxDataRate = "Set Tx data rate (0x0b)";
    private static readonly string CMD_GetTxDataRate = "Get Tx data rate (0x0b)";
    private static readonly string CMD_SetRxDataRate = "Set Rx data rate (0x0c)";
    private static readonly string CMD_GetRxDataRate = "Get Rx data rate (0x0c)";
    private static readonly string CMD_StopRadioTest = "Stop radio tests (0x20)";
    private static readonly string CMD_TransmitUnModulatedCarrier = "Transmit unmodulated carrier (0x21)";
    private static readonly string CMD_TransmitModulatedCarrier = "Transmit modulated carrier (0x22)";
    private static readonly string CMD_SendTestPacket = "Send test packet (0x23)";
    private static readonly string CMD_ReceiveRadio3TelegramViaRadio = "Receive radio3 scenario 3 telegram via radio (0x24)";
    private static readonly string CMD_ReceiveAndStreamRadio3Telegrams = "Receive and stream radio3 scenario 3 telegrams (0x25)";
    private static readonly string CMD_MonitorRadio = "Monitor radio  (0x26)";
    private static readonly string CMD_EchoRadio = "Echo radio3 telegram via radio (0x27)";
    private static readonly string CMD_SetTxBandwidth = "Set TX bandwidth (0x28)";
    private static readonly string CMD_GetTxBandwidth = "Get TX bandwidth (0x28)";
    private static readonly string CMD_StartTransmissionCycle = "StartTransmissionCycle (0x29)";
    private static readonly string CMD_SetNFCField = "Set NFC Field (0x2a)";
    private Cursor defaultCursor;
    private CancellationTokenSource cancelTokenSource;
    private ProgressHandler progress;
    internal TextBlock TextBlockStatus;
    internal ProgressBar ProgressBar1;
    internal TextBox TextBoxUniversalCommandResult;
    internal StackPanel StackPanalButtons;
    internal ComboBox ComboCommand;
    internal CheckBox CheckBoxEncryption;
    internal Label EncryptionKey_Label;
    internal TextBox TextBoxEncryptionKey;
    internal Label ComboExtCommand_Label;
    internal ComboBox ComboExtCommand;
    internal Label ComboAddCommand_Label;
    internal ComboBox ComboAddCommand;
    internal Label TextArgument_1_Label;
    internal TextBox TextExtCommandArgument_1;
    internal Label TextArgument_2_Label;
    internal TextBox TextExtCommandArgument_2;
    internal Label TextArgument_3_Label;
    internal TextBox TextExtCommandArgument_3;
    internal Label TextArgument_4_Label;
    internal TextBox TextExtCommandArgument_4;
    internal Label TextArgument_5_Label;
    internal TextBox TextExtCommandArgument_5;
    internal Label TextArgument_6_Label;
    internal TextBox TextExtCommandArgument_6;
    internal StackPanel StackPanalButtons2;
    internal Button ButtonRunCommand;
    internal Button ButtonRunCommandPreview;
    internal Button ButtonBreak;
    private bool _contentLoaded;

    public RadioCommandWindow(CommonRadioCommands RadioCMDs, IPort Port)
    {
      this.InitializeComponent();
      this.myRadioCommands = RadioCMDs;
      this.myRadioCommands.setCryptValuesFromBaseClass();
      this.myPort = Port;
      this.ButtonRunCommand.IsEnabled = false;
      this.SetArgumentFields((Dictionary<int, string>) null);
      this.setFunctionCodes();
      this.Argument1_last_values = new List<string>();
      this.Argument2_last_values = new List<string>();
      this.Argument3_last_values = new List<string>();
      this.Argument4_last_values = new List<string>();
      this.Argument5_last_values = new List<string>();
      this.Argument6_last_values = new List<string>();
      this.Argument1ValuesMenu = new ContextMenu();
      this.Argument2ValuesMenu = new ContextMenu();
      this.Argument3ValuesMenu = new ContextMenu();
      this.Argument4ValuesMenu = new ContextMenu();
      this.Argument5ValuesMenu = new ContextMenu();
      this.Argument6ValuesMenu = new ContextMenu();
      this.setEncryptionState();
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
    }

    private void setEncryptionState()
    {
      this.CheckBoxEncryption.IsChecked = new bool?(this.myRadioCommands.enDeCrypt);
      if (!this.myRadioCommands.enDeCrypt)
        this.CheckBoxEncryption_UnChecked((object) null, (RoutedEventArgs) null);
      this.TextBoxEncryptionKey.Text = this.myRadioCommands.AES_Key;
    }

    private void setFunctionCodes()
    {
      this.ComboExtCommand_Label.Visibility = Visibility.Hidden;
      this.ComboExtCommand.Visibility = Visibility.Hidden;
      this.ComboCommand.Items.Clear();
      this.ComboCommand.Items.Add((object) "Radio Test Commands (0x2f)");
      this.ComboCommand.SelectedIndex = 0;
    }

    private void setRadioCommands()
    {
      Dictionary<string, string> valuesForCommands = GetCommandValues.GetAllPrivateStaticFieldValuesForCommands((object) this);
      this.ComboExtCommand.Items.Clear();
      foreach (KeyValuePair<string, string> keyValuePair in valuesForCommands)
        this.ComboExtCommand.Items.Add((object) keyValuePair.Value);
      this.ComboExtCommand.SelectedIndex = 0;
    }

    private void SetRunState()
    {
      this.cancelTokenSource = new CancellationTokenSource();
      this.progress.Reset();
      this.progress.Split(new double[2]{ 2.0, 98.0 });
      this.progress.Report("Run");
      this.ComboCommand.IsEnabled = false;
      this.ComboExtCommand.IsEnabled = false;
      this.TextBoxUniversalCommandResult.IsEnabled = false;
      this.TextExtCommandArgument_1.IsEnabled = false;
      this.TextExtCommandArgument_2.IsEnabled = false;
      this.TextExtCommandArgument_3.IsEnabled = false;
      this.ButtonRunCommand.IsEnabled = false;
      this.ButtonRunCommandPreview.IsEnabled = false;
      this.ButtonBreak.IsEnabled = true;
      this.defaultCursor = this.Cursor;
      this.Cursor = Cursors.Wait;
    }

    private void SetStopState()
    {
      this.ComboCommand.IsEnabled = true;
      this.ComboExtCommand.IsEnabled = true;
      this.TextBoxUniversalCommandResult.IsEnabled = true;
      this.TextExtCommandArgument_1.IsEnabled = true;
      this.TextExtCommandArgument_2.IsEnabled = true;
      this.TextExtCommandArgument_3.IsEnabled = true;
      this.ButtonRunCommand.IsEnabled = true;
      this.ButtonRunCommandPreview.IsEnabled = true;
      this.ButtonBreak.IsEnabled = false;
      this.Cursor = this.defaultCursor;
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.ProgressBar1.Value = obj.ProgressPercentage;
        this.TextBlockStatus.Text = obj.Message;
      }
    }

    private void ButtonBreak_Click(object sender, RoutedEventArgs e)
    {
      this.cancelTokenSource.Cancel();
    }

    private async Task RunCommandFrame()
    {
      this.SetRunState();
      try
      {
        await this.RunCommand();
      }
      catch (OperationCanceledException ex)
      {
      }
      catch (TimeoutException ex)
      {
        this.TextBoxUniversalCommandResult.Text = "Timeout!";
      }
      catch (NACK_Exception ex)
      {
        this.TextBoxUniversalCommandResult.Text = "Device response is NACK: " + ex.Message;
      }
      catch (Exception ex)
      {
        bool isTimeout = false;
        if (ex is AggregateException)
        {
          AggregateException aex = ex as AggregateException;
          int num1;
          for (int i = 0; i < aex.InnerExceptions.Count; num1 = i++)
          {
            Exception theException = aex.InnerExceptions[i];
            if (theException is TimeoutException)
            {
              if (i == aex.InnerExceptions.Count - 1)
              {
                isTimeout = true;
                string newLine = Environment.NewLine;
                num1 = aex.InnerExceptions.Count;
                string str = num1.ToString();
                int num2 = (int) MessageBox.Show("**** Multiple timeouts ****" + newLine + "Timeout count: " + str);
              }
              theException = (Exception) null;
            }
            else
              break;
          }
          aex = (AggregateException) null;
        }
        if (!isTimeout)
        {
          int num = (int) MessageBox.Show(ex.ToString());
        }
      }
      this.SetStopState();
    }

    private async void ButtonRunCommand_Click(object sender, RoutedEventArgs e)
    {
      RadioCommandWindow.result = string.Empty;
      await this.RunCommandFrame();
    }

    private async void ButtonRunCommandPreview_Click(object sender, RoutedEventArgs e)
    {
      RadioCommandWindow.result = "Actual radio data from connected device: \n-----------------------------------------------------";
      this.ComboExtCommand.SelectedItem = (object) RadioCommandWindow.CMD_GetRadioVersion;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) RadioCommandWindow.CMD_GetTransmitPower;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) RadioCommandWindow.CMD_GetCenterFrequency;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) RadioCommandWindow.CMD_GetBandwidth;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) RadioCommandWindow.CMD_GetFrequencyDeviation;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) RadioCommandWindow.CMD_GetFrequencyIncrement;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) RadioCommandWindow.CMD_GetCarrierMode;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) RadioCommandWindow.CMD_GetTxDataRate;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) RadioCommandWindow.CMD_GetRxDataRate;
      await this.RunCommandFrame();
    }

    private void ComboExtCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboExtCommand.SelectedItem != null)
      {
        object selectedItem = this.ComboExtCommand.SelectedItem;
        this.ComboAddCommand.Items.Clear();
        Dictionary<int, string> template = new Dictionary<int, string>();
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_SetTransmitPower))
          template.Add(1, "Transmit power:");
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_SetCenterFrequency))
          template.Add(1, "Center frequency:");
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_SetFrequencyIncrement))
          template.Add(1, "Increment value in Hz:");
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_SetCarrierMode))
          template.Add(0, "Carrier mode:");
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_SetFrequencyDeviation))
          template.Add(1, "Frequency deviation:");
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_SetBandwidth))
        {
          template.Add(1, "Bandwidth:");
          template.Add(2, "AFC value:");
        }
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_SetTxDataRate))
          template.Add(1, "Data rate (Baudrate):");
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_SetRxDataRate))
          template.Add(1, "Data rate (Baudrate):");
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_TransmitUnModulatedCarrier))
          template.Add(1, "Timeout in seconds:");
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_TransmitModulatedCarrier))
          template.Add(1, "Timeout in seconds:");
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_SendTestPacket))
        {
          template.Add(1, "Interval in seconds:");
          template.Add(2, "Timeout in seconds:");
          template.Add(3, "Data to transmit (HEX):");
        }
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_ReceiveRadio3TelegramViaRadio))
        {
          template.Add(1, "Telegram size:");
          template.Add(2, "SyncWord (2 Byte HEX):");
          template.Add(3, "Timeout in seconds (1..255):");
        }
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_ReceiveAndStreamRadio3Telegrams))
        {
          template.Add(1, "Telegram size:");
          template.Add(2, "Timeout in seconds:");
        }
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_MonitorRadio))
          template.Add(1, "Timeout in seconds:");
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_EchoRadio))
        {
          template.Add(1, "Telegram size:");
          template.Add(2, "SyncWord (2 Byte HEX):");
          template.Add(3, "Timeout in seconds (1..65536):");
          template.Add(12, "91D3");
        }
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_SetTxBandwidth))
          template.Add(1, "Bandwidth:");
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_StartTransmissionCycle))
        {
          template.Add(1, "No. of first channel: (0-71)");
          template.Add(2, "Total number of channels: (1-72)");
          template.Add(3, "Payload length (1-60):");
          template.Add(4, "No. of cycles:");
          template.Add(5, "Spreading factor:");
          template.Add(6, "Bandwidth [kHz]:");
        }
        if (selectedItem.ToString().Contains(RadioCommandWindow.CMD_SetNFCField))
        {
          template.Add(1, "Function:");
          template.Add(2, "Timeout:");
        }
        this.SetArgumentFields(template);
        this.ButtonRunCommand.IsEnabled = true;
      }
      else
        this.ButtonRunCommand.IsEnabled = false;
    }

    private void ComboCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboCommand.SelectedIndex < 0)
        return;
      Dictionary<int, string> dictionary = new Dictionary<int, string>();
      if (this.ComboCommand.SelectedItem.ToString().Contains("0x2f"))
      {
        this.setRadioCommands();
        this.ComboExtCommand_Label.Content = (object) "Radio Commands:";
        this.ComboExtCommand_Label.Visibility = Visibility.Visible;
        this.ComboExtCommand.Visibility = Visibility.Visible;
      }
    }

    private void ComboAddCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboAddCommand.SelectedIndex < 0)
        return;
      object selectedItem = this.ComboAddCommand.SelectedItem;
    }

    private void SetArgumentFields(Dictionary<int, string> template)
    {
      this.TextExtCommandArgument_1.Text = string.Empty;
      this.TextExtCommandArgument_2.Text = string.Empty;
      this.TextExtCommandArgument_3.Text = string.Empty;
      this.TextExtCommandArgument_4.Text = string.Empty;
      this.TextExtCommandArgument_5.Text = string.Empty;
      this.TextExtCommandArgument_6.Text = string.Empty;
      this.ComboAddCommand_Label.Visibility = Visibility.Collapsed;
      this.ComboAddCommand.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_1.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_2.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_3.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_4.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_5.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_6.Visibility = Visibility.Collapsed;
      this.TextArgument_1_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_2_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_3_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_4_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_5_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_6_Label.Visibility = Visibility.Collapsed;
      if (template == null)
        return;
      foreach (KeyValuePair<int, string> keyValuePair in template)
      {
        if (keyValuePair.Key == 0 || keyValuePair.Key == 10)
        {
          if (keyValuePair.Key == 0)
          {
            this.ComboAddCommand.Visibility = Visibility.Visible;
            this.ComboAddCommand.Items.Add((object) "FSK         (0x00)");
            this.ComboAddCommand.Items.Add((object) "GFSK        (0x01)");
            this.ComboAddCommand.Items.Add((object) "OOK         (0x02)");
            this.ComboAddCommand.Items.Add((object) "SIGFOX      (0x03)");
            this.ComboAddCommand.Items.Add((object) "LoRa SF7    (0x04)");
            this.ComboAddCommand.Items.Add((object) "LoRa SF8    (0x05)");
            this.ComboAddCommand.Items.Add((object) "LoRa SF9    (0x06)");
            this.ComboAddCommand.Items.Add((object) "LoRa SF10   (0x07)");
            this.ComboAddCommand.Items.Add((object) "LoRa SF11   (0x08)");
            this.ComboAddCommand.Items.Add((object) "LoRa SF12   (0x09)");
            this.ComboAddCommand_Label.Visibility = Visibility.Visible;
            this.ComboAddCommand_Label.Content = (object) keyValuePair.Value;
          }
          if (keyValuePair.Key == 10)
            this.ComboAddCommand.Text = keyValuePair.Value;
        }
        if (keyValuePair.Key == 1 || keyValuePair.Key == 11)
        {
          if (keyValuePair.Key == 1)
          {
            this.TextExtCommandArgument_1.Visibility = Visibility.Visible;
            this.TextArgument_1_Label.Visibility = Visibility.Visible;
            this.TextArgument_1_Label.Content = (object) keyValuePair.Value;
            this.TextExtCommandArgument_1.ContextMenu = this.Argument1ValuesMenu;
          }
          if (keyValuePair.Key == 11)
            this.TextExtCommandArgument_1.Text = keyValuePair.Value;
        }
        if (keyValuePair.Key == 2 || keyValuePair.Key == 12)
        {
          if (keyValuePair.Key == 2)
          {
            this.TextExtCommandArgument_2.Visibility = Visibility.Visible;
            this.TextArgument_2_Label.Visibility = Visibility.Visible;
            this.TextArgument_2_Label.Content = (object) keyValuePair.Value;
            this.TextExtCommandArgument_2.ContextMenu = this.Argument2ValuesMenu;
          }
          if (keyValuePair.Key == 12)
            this.TextExtCommandArgument_2.Text = keyValuePair.Value;
        }
        if (keyValuePair.Key == 3 || keyValuePair.Key == 13)
        {
          if (keyValuePair.Key == 3)
          {
            this.TextExtCommandArgument_3.Visibility = Visibility.Visible;
            this.TextArgument_3_Label.Visibility = Visibility.Visible;
            this.TextArgument_3_Label.Content = (object) keyValuePair.Value;
            this.TextExtCommandArgument_3.ContextMenu = this.Argument3ValuesMenu;
          }
          if (keyValuePair.Key == 13)
            this.TextExtCommandArgument_3.Text = keyValuePair.Value;
        }
        if (keyValuePair.Key == 4 || keyValuePair.Key == 14)
        {
          if (keyValuePair.Key == 4)
          {
            this.TextExtCommandArgument_4.Visibility = Visibility.Visible;
            this.TextArgument_4_Label.Visibility = Visibility.Visible;
            this.TextArgument_4_Label.Content = (object) keyValuePair.Value;
            this.TextExtCommandArgument_4.ContextMenu = this.Argument4ValuesMenu;
          }
          if (keyValuePair.Key == 14)
            this.TextExtCommandArgument_4.Text = keyValuePair.Value;
        }
        if (keyValuePair.Key == 5 || keyValuePair.Key == 15)
        {
          if (keyValuePair.Key == 5)
          {
            this.TextExtCommandArgument_5.Visibility = Visibility.Visible;
            this.TextArgument_5_Label.Visibility = Visibility.Visible;
            this.TextArgument_5_Label.Content = (object) keyValuePair.Value;
            this.TextExtCommandArgument_5.ContextMenu = this.Argument5ValuesMenu;
          }
          if (keyValuePair.Key == 15)
            this.TextExtCommandArgument_5.Text = keyValuePair.Value;
        }
        if (keyValuePair.Key == 6 || keyValuePair.Key == 16)
        {
          if (keyValuePair.Key == 6)
          {
            this.TextExtCommandArgument_6.Visibility = Visibility.Visible;
            this.TextArgument_6_Label.Visibility = Visibility.Visible;
            this.TextArgument_6_Label.Content = (object) keyValuePair.Value;
            this.TextExtCommandArgument_6.ContextMenu = this.Argument5ValuesMenu;
          }
          if (keyValuePair.Key == 16)
            this.TextExtCommandArgument_6.Text = keyValuePair.Value;
        }
      }
    }

    private void SetArgumentFieldsValues(Dictionary<int, string> values)
    {
      if (values == null)
        return;
      foreach (KeyValuePair<int, string> keyValuePair in values)
      {
        if (keyValuePair.Key == 0)
          this.ComboAddCommand.SelectedItem = (object) keyValuePair.Value;
        if (keyValuePair.Key == 1)
          this.TextExtCommandArgument_1.Text = keyValuePair.Value;
        if (keyValuePair.Key == 2)
          this.TextExtCommandArgument_2.Text = keyValuePair.Value;
        if (keyValuePair.Key == 3)
          this.TextExtCommandArgument_3.Text = keyValuePair.Value;
        if (keyValuePair.Key == 4)
          this.TextExtCommandArgument_4.Text = keyValuePair.Value;
        if (keyValuePair.Key == 5)
          this.TextExtCommandArgument_5.Text = keyValuePair.Value;
        if (keyValuePair.Key == 6)
          this.TextExtCommandArgument_6.Text = keyValuePair.Value;
      }
    }

    private async Task RunCommand()
    {
      string FC = this.ComboCommand.SelectedItem.ToString();
      string EFC = this.ComboExtCommand.SelectedItem.ToString();
      object addFC = this.ComboAddCommand.SelectedItem;
      string arg1 = string.IsNullOrEmpty(this.TextExtCommandArgument_1.Text) ? (string) null : this.TextExtCommandArgument_1.Text.Trim();
      string arg2 = string.IsNullOrEmpty(this.TextExtCommandArgument_2.Text) ? (string) null : this.TextExtCommandArgument_2.Text.Trim();
      string arg3 = string.IsNullOrEmpty(this.TextExtCommandArgument_3.Text) ? (string) null : this.TextExtCommandArgument_3.Text.Trim();
      string arg4 = string.IsNullOrEmpty(this.TextExtCommandArgument_4.Text) ? (string) null : this.TextExtCommandArgument_4.Text.Trim();
      string arg5 = string.IsNullOrEmpty(this.TextExtCommandArgument_5.Text) ? (string) null : this.TextExtCommandArgument_5.Text.Trim();
      string arg6 = string.IsNullOrEmpty(this.TextExtCommandArgument_6.Text) ? (string) null : this.TextExtCommandArgument_6.Text.Trim();
      try
      {
        if (FC.Contains("2f"))
        {
          if (EFC.Contains(RadioCommandWindow.CMD_GetRadioVersion))
          {
            ushort version = await this.myRadioCommands.GetRadioVersionAsync(this.progress, this.cancelTokenSource.Token);
            RadioCommandWindow.result = RadioCommandWindow.result + "\nRadio version is " + version.ToString() + " (0x" + version.ToString("x4") + ")";
          }
          uint num1;
          if (EFC.Contains(RadioCommandWindow.CMD_SetTransmitPower))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              string str;
              if (!arg1.Contains("0x"))
              {
                str = arg1;
              }
              else
              {
                num1 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str = num1.ToString();
              }
              arg1 = str;
              await this.myRadioCommands.SetTransmitPowerAsync(ushort.Parse(arg1), this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result = RadioCommandWindow.result + "\nTransmit power set to " + arg1;
            }
            else
            {
              int num2 = (int) MessageBox.Show("Transmit power was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_GetTransmitPower))
          {
            ushort power = await this.myRadioCommands.GetTransmitPowerAsync(this.progress, this.cancelTokenSource.Token);
            RadioCommandWindow.result = RadioCommandWindow.result + "\nTransmit power is " + power.ToString() + " (0x" + power.ToString("x4") + ")";
          }
          if (EFC.Contains(RadioCommandWindow.CMD_SetCenterFrequency))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              string str;
              if (!arg1.Contains("0x"))
              {
                str = arg1;
              }
              else
              {
                num1 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str = num1.ToString();
              }
              arg1 = str;
              await this.myRadioCommands.SetCenterFrequencyAsync(uint.Parse(arg1), this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result = RadioCommandWindow.result + "\nCenter frequency set to " + arg1;
            }
            else
            {
              int num3 = (int) MessageBox.Show("Center frequency was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_GetCenterFrequency))
          {
            uint value = await this.myRadioCommands.GetCenterFrequencyAsync(this.progress, this.cancelTokenSource.Token);
            RadioCommandWindow.result = RadioCommandWindow.result + "\nCenter frequency is " + value.ToString() + " (0x" + value.ToString("x8") + ")";
          }
          if (EFC.Contains(RadioCommandWindow.CMD_SetFrequencyIncrement))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              string str;
              if (!arg1.Contains("0x"))
              {
                str = arg1;
              }
              else
              {
                num1 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str = num1.ToString();
              }
              arg1 = str;
              await this.myRadioCommands.SetFrequencyIncrementAsync(int.Parse(arg1), this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result = RadioCommandWindow.result + "\nFrequency increment set to " + arg1;
            }
            else
            {
              int num4 = (int) MessageBox.Show("Frequency increment was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_GetFrequencyIncrement))
          {
            int value = await this.myRadioCommands.GetFrequencyIncrementAsync(this.progress, this.cancelTokenSource.Token);
            RadioCommandWindow.result = RadioCommandWindow.result + "\nFrequency increment is " + value.ToString();
          }
          if (EFC.Contains(RadioCommandWindow.CMD_SetCarrierMode))
          {
            if (addFC != null)
            {
              string mode = ushort.Parse(addFC.ToString().Split('(')[1].Substring(2, 2)).ToString();
              if (!string.IsNullOrEmpty(mode))
              {
                await this.myRadioCommands.SetCarrierModeAsync(byte.Parse(mode), this.progress, this.cancelTokenSource.Token);
                RadioCommandWindow.result = RadioCommandWindow.result + "\nFrequency increment set to " + this.ComboAddCommand.SelectedItem?.ToString();
              }
              else
              {
                int num5 = (int) MessageBox.Show("Carrier mode was not set correctly!\nPlease set a correct value and try again.");
              }
              mode = (string) null;
            }
            else
            {
              int num6 = (int) MessageBox.Show("Wrong or unknown carrier mode!\nPlease set a correct carrier mode and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_GetCarrierMode))
          {
            byte value = await this.myRadioCommands.GetCarrierModeAsync(this.progress, this.cancelTokenSource.Token);
            RadioCommandWindow.result = RadioCommandWindow.result + "\nCarrier mode is " + value.ToString();
          }
          if (EFC.Contains(RadioCommandWindow.CMD_SetFrequencyDeviation))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              string str;
              if (!arg1.Contains("0x"))
              {
                str = arg1;
              }
              else
              {
                num1 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str = num1.ToString();
              }
              arg1 = str;
              await this.myRadioCommands.SetFrequencyDeviationAsync(ushort.Parse(arg1), this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result = RadioCommandWindow.result + "\nFrequency deviation set to " + arg1;
            }
            else
            {
              int num7 = (int) MessageBox.Show("Frequency deviation was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_GetFrequencyDeviation))
          {
            ushort value = await this.myRadioCommands.GetFrequencyDeviationAsync(this.progress, this.cancelTokenSource.Token);
            RadioCommandWindow.result = RadioCommandWindow.result + "\nFrequency deviation is " + value.ToString() + " (0x" + value.ToString("x4") + ")";
          }
          if (EFC.Contains(RadioCommandWindow.CMD_SetBandwidth))
          {
            if (!string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2))
            {
              string str1;
              if (!arg1.Contains("0x"))
              {
                str1 = arg1;
              }
              else
              {
                num1 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str1 = num1.ToString();
              }
              arg1 = str1;
              string str2;
              if (!arg2.Contains("0x"))
              {
                str2 = arg2;
              }
              else
              {
                num1 = uint.Parse(arg2.Substring(2), NumberStyles.HexNumber);
                str2 = num1.ToString();
              }
              arg2 = str2;
              await this.myRadioCommands.SetBandWidthAsync(uint.Parse(arg1), uint.Parse(arg2), this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result = RadioCommandWindow.result + "Bandwidth set to " + arg1 + " and AFC set to " + arg2;
            }
            else
            {
              int num8 = (int) MessageBox.Show("Bandwidth or AFC value not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_GetBandwidth))
          {
            CommonRadioCommands.RadioBandWidth value = await this.myRadioCommands.GetBandWidthAsync(this.progress, this.cancelTokenSource.Token);
            RadioCommandWindow.result = RadioCommandWindow.result + "\nBandwidth is " + value.BandWidth.ToString() + " (0x" + value.BandWidth.ToString("x8") + ") \nAFC is " + value.AFC.ToString() + " (0x" + value.AFC.ToString("x8") + ")";
            value = (CommonRadioCommands.RadioBandWidth) null;
          }
          if (EFC.Contains(RadioCommandWindow.CMD_SetTxDataRate))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              string str;
              if (!arg1.Contains("0x"))
              {
                str = arg1;
              }
              else
              {
                num1 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str = num1.ToString();
              }
              arg1 = str;
              await this.myRadioCommands.SetTxDataRateAsync(uint.Parse(arg1), this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result = RadioCommandWindow.result + "\nData rate set to " + arg1;
            }
            else
            {
              int num9 = (int) MessageBox.Show("Data rate was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_GetTxDataRate))
          {
            uint value = await this.myRadioCommands.GetTxDataRateAsync(this.progress, this.cancelTokenSource.Token);
            RadioCommandWindow.result = RadioCommandWindow.result + "\nData rate is " + value.ToString() + " (0x" + value.ToString("x8") + ")";
          }
          if (EFC.Contains(RadioCommandWindow.CMD_SetRxDataRate))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              string str;
              if (!arg1.Contains("0x"))
              {
                str = arg1;
              }
              else
              {
                num1 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str = num1.ToString();
              }
              arg1 = str;
              await this.myRadioCommands.SetRxDataRateAsync(uint.Parse(arg1), this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result = RadioCommandWindow.result + "\nData rate set to " + arg1;
            }
            else
            {
              int num10 = (int) MessageBox.Show("Data rate was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_GetRxDataRate))
          {
            uint value = await this.myRadioCommands.GetRxDataRateAsync(this.progress, this.cancelTokenSource.Token);
            RadioCommandWindow.result = RadioCommandWindow.result + "\nData rate is " + value.ToString() + " (0x" + value.ToString("x8") + ")";
          }
          if (EFC.Contains(RadioCommandWindow.CMD_StopRadioTest))
          {
            await this.myRadioCommands.StopRadioTests(this.progress, this.cancelTokenSource.Token);
            RadioCommandWindow.result += "StopRadioTests successfully send.";
          }
          if (EFC.Contains(RadioCommandWindow.CMD_TransmitUnModulatedCarrier))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              await this.myRadioCommands.TransmitUnmodulatedCarrierAsync(ushort.Parse(arg1), this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result += "Transmit unmodulated carrier command OK.";
            }
            else
            {
              int num11 = (int) MessageBox.Show("Timeout was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_TransmitModulatedCarrier))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              await this.myRadioCommands.TransmitModulatedCarrierAsync(ushort.Parse(arg1), this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result += "Transmit modulated carrier command OK.";
            }
            else
            {
              int num12 = (int) MessageBox.Show("Timeout was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_SendTestPacket))
          {
            if (!string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2) && !string.IsNullOrEmpty(arg3))
            {
              this.updateContextMenu3(arg3);
              string str3;
              if (!arg1.Contains("0x"))
              {
                str3 = arg1;
              }
              else
              {
                num1 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str3 = num1.ToString();
              }
              arg1 = str3;
              string str4;
              if (!arg2.Contains("0x"))
              {
                str4 = arg2;
              }
              else
              {
                num1 = uint.Parse(arg2.Substring(2), NumberStyles.HexNumber);
                str4 = num1.ToString();
              }
              arg2 = str4;
              byte[] data = Util.HexStringToByteArray(arg3);
              await this.myRadioCommands.SendTestPacketAsync(ushort.Parse(arg1), ushort.Parse(arg2), data, this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result += "Send test packet command done.";
              data = (byte[]) null;
            }
            else
            {
              int num13 = (int) MessageBox.Show("Interval, timeout or data was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_ReceiveRadio3TelegramViaRadio))
          {
            if (!string.IsNullOrEmpty(arg1) || !string.IsNullOrEmpty(arg2) || arg2.Length == 4 || !string.IsNullOrEmpty(arg3))
            {
              string str5;
              if (!arg1.Contains("0x"))
              {
                str5 = arg1;
              }
              else
              {
                num1 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str5 = num1.ToString();
              }
              arg1 = str5;
              string str6;
              if (!arg3.Contains("0x"))
              {
                str6 = arg3;
              }
              else
              {
                num1 = uint.Parse(arg3.Substring(2), NumberStyles.HexNumber);
                str6 = num1.ToString();
              }
              arg3 = str6;
              byte[] data = new byte[0];
              byte telegramSize = byte.Parse(arg1);
              byte[] syncWord = Util.HexStringToByteArray(arg2);
              byte timeout = byte.Parse(arg3);
              try
              {
                data = await this.myRadioCommands.ReceiveRadio3Scenario3TelegramViaRadioAsync(telegramSize, syncWord, timeout, this.progress, this.cancelTokenSource.Token);
                RadioCommandWindow.result = RadioCommandWindow.result + "Telegram received: " + (data.Length != 0 ? Util.ByteArrayToHexString(data) + "\n" : "none.\n");
              }
              catch (Exception ex)
              {
                if (!ex.Message.Contains("Timeout"))
                  throw new Exception("Exception: " + ex.Message);
                RadioCommandWindow.result += "no data received... \n";
              }
              finally
              {
                RadioCommandWindow.result += "DONE... \n";
              }
              data = (byte[]) null;
              syncWord = (byte[]) null;
            }
            else
            {
              int num14 = (int) MessageBox.Show("Timeout, SyncWord or Telegramsize was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_ReceiveAndStreamRadio3Telegrams))
          {
            try
            {
              if (!string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2))
              {
                byte[] data = new byte[0];
                byte size = 0;
                ushort timeout = 0;
                string str7;
                if (!arg1.Contains("0x"))
                {
                  str7 = arg1;
                }
                else
                {
                  num1 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                  str7 = num1.ToString();
                }
                arg1 = str7;
                string str8;
                if (!arg1.Contains("0x"))
                {
                  str8 = arg2;
                }
                else
                {
                  num1 = uint.Parse(arg2.Substring(2), NumberStyles.HexNumber);
                  str8 = num1.ToString();
                }
                arg2 = str8;
                if (!byte.TryParse(arg1, out size))
                  throw new Exception("Telegramm size is not set correctly");
                if (!ushort.TryParse(arg2, out timeout))
                  throw new Exception("Timeout is not set correctly!");
                await this.myRadioCommands.ReceiveAndStreamRadio3Scenario3TelegramsAsync(byte.Parse(arg1), ushort.Parse(arg2), this.progress, this.cancelTokenSource.Token);
                this.myPort.DiscardInBuffer();
                DateTime start = DateTime.Now;
                DateTime end = start.AddSeconds((double) timeout);
                while (DateTime.Now <= end)
                {
                  await Task.Delay(50);
                  byte[] buf = this.myPort.ReadExisting();
                  if (buf != null)
                    Buffer.BlockCopy((Array) buf, 0, (Array) data, data.Length == 0 ? 0 : data.Length, buf.Length);
                  buf = (byte[]) null;
                }
                RadioCommandWindow.result = RadioCommandWindow.result + "Data received: " + (data.Length != 0 ? Util.ByteArrayToHexString(data) : "none.");
                data = (byte[]) null;
              }
              else
              {
                int num15 = (int) MessageBox.Show("Timeout or telegram size was not set correctly!\nPlease set a correct value and try again.");
              }
            }
            catch (Exception ex)
            {
              int num16 = (int) MessageBox.Show("Error occoured: " + ex.Message);
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_MonitorRadio))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              string str;
              if (!arg1.Contains("0x"))
              {
                str = arg1;
              }
              else
              {
                num1 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str = num1.ToString();
              }
              arg1 = str;
              await this.myRadioCommands.MonitorRadioAsync(ushort.Parse(arg1), this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result += "Command initiated ...";
            }
            else
            {
              int num17 = (int) MessageBox.Show("Timeout was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_EchoRadio))
          {
            if (!string.IsNullOrEmpty(arg1) || !string.IsNullOrEmpty(arg2) || arg2.Length == 4 || !string.IsNullOrEmpty(arg3))
            {
              string str9;
              if (!arg1.Contains("0x"))
              {
                str9 = arg1;
              }
              else
              {
                num1 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str9 = num1.ToString();
              }
              arg1 = str9;
              string str10;
              if (!arg3.Contains("0x"))
              {
                str10 = arg3;
              }
              else
              {
                num1 = uint.Parse(arg3.Substring(2), NumberStyles.HexNumber);
                str10 = num1.ToString();
              }
              arg3 = str10;
              byte telegramSize = byte.Parse(arg1);
              byte[] syncWord = Util.HexStringToByteArray(arg2);
              ushort timeout = ushort.Parse(arg3);
              try
              {
                await this.myRadioCommands.EchoRadio3TelegramViaRadioAsync(telegramSize, syncWord, timeout, this.progress, this.cancelTokenSource.Token);
              }
              catch (Exception ex)
              {
                if (!ex.Message.Contains("Timeout"))
                  throw new Exception("Exception: " + ex.Message);
              }
              finally
              {
                RadioCommandWindow.result += "DONE... \n";
              }
              syncWord = (byte[]) null;
            }
            else
            {
              int num18 = (int) MessageBox.Show("Timeout, SyncWord or Telegramsize was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          ushort num19;
          if (EFC.Contains(RadioCommandWindow.CMD_SetTxBandwidth))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              string str;
              if (!arg1.Contains("0x"))
              {
                str = arg1;
              }
              else
              {
                num19 = ushort.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str = num19.ToString();
              }
              arg1 = str;
              await this.myRadioCommands.SetTxBandWidthAsync(ushort.Parse(arg1), this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result = RadioCommandWindow.result + "Bandwidth set to " + arg1;
            }
            else
            {
              int num20 = (int) MessageBox.Show("Bandwidth value not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(RadioCommandWindow.CMD_GetTxBandwidth))
          {
            ushort value = await this.myRadioCommands.GetTxBandWidthAsync(this.progress, this.cancelTokenSource.Token);
            RadioCommandWindow.result = RadioCommandWindow.result + "\nBandwidth is " + value.ToString() + " (0x" + value.ToString("x4") + ") ";
          }
          if (EFC.Contains(RadioCommandWindow.CMD_StartTransmissionCycle))
          {
            byte firstChannel = string.IsNullOrEmpty(arg1) ? (byte) 1 : (byte) ushort.Parse(arg1);
            byte totalChannels = string.IsNullOrEmpty(arg2) ? (byte) 1 : (byte) ushort.Parse(arg2);
            byte payloadLenght = string.IsNullOrEmpty(arg3) ? (byte) 1 : (byte) ushort.Parse(arg3);
            byte numberCycles = string.IsNullOrEmpty(arg4) ? (byte) 1 : (byte) ushort.Parse(arg4);
            byte spreadFactor = string.IsNullOrEmpty(arg5) ? (byte) 1 : (byte) ushort.Parse(arg5);
            ushort bandwidth = string.IsNullOrEmpty(arg6) ? (ushort) 1024 : ushort.Parse(arg6);
            await this.myRadioCommands.StartTransmissionCycleAsync(firstChannel, totalChannels, payloadLenght, numberCycles, spreadFactor, bandwidth, this.progress, this.cancelTokenSource.Token);
            RadioCommandWindow.result += "\rTransmission Cycle started.... ";
            RadioCommandWindow.result = RadioCommandWindow.result + "\r -> first channel:  " + arg1;
            RadioCommandWindow.result = RadioCommandWindow.result + "\r -> total channels: " + arg2;
            RadioCommandWindow.result = RadioCommandWindow.result + "\r -> payload length: " + arg3;
            RadioCommandWindow.result = RadioCommandWindow.result + "\r -> cycles:         " + arg4;
            RadioCommandWindow.result = RadioCommandWindow.result + "\r -> spread factor:  " + arg5;
            RadioCommandWindow.result = RadioCommandWindow.result + "\r -> bandwidth:      " + arg6;
          }
          if (EFC.Contains(RadioCommandWindow.CMD_SetNFCField))
          {
            if (!string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2))
            {
              arg1 = arg1.Contains("0x") ? byte.Parse(arg1.Substring(2), NumberStyles.HexNumber).ToString() : arg1;
              string str;
              if (!arg2.Contains("0x"))
              {
                str = arg2;
              }
              else
              {
                num19 = ushort.Parse(arg2.Substring(2), NumberStyles.HexNumber);
                str = num19.ToString();
              }
              arg2 = str;
              await this.myRadioCommands.SetNFCFieldAsync(byte.Parse(arg1), ushort.Parse(arg2), this.progress, this.cancelTokenSource.Token);
              RadioCommandWindow.result = RadioCommandWindow.result + "NFC Field set CMD: " + arg1 + " - Timeout: " + arg2;
            }
            else
            {
              int num21 = (int) MessageBox.Show("Set NFC Field values not set correctly!\nPlease set a correct value and try again.");
            }
          }
        }
        if (string.IsNullOrEmpty(RadioCommandWindow.result))
        {
          FC = (string) null;
          EFC = (string) null;
          addFC = (object) null;
          arg1 = (string) null;
          arg2 = (string) null;
          arg3 = (string) null;
          arg4 = (string) null;
          arg5 = (string) null;
          arg6 = (string) null;
        }
        else
        {
          this.TextBoxUniversalCommandResult.Text = RadioCommandWindow.result;
          FC = (string) null;
          EFC = (string) null;
          addFC = (object) null;
          arg1 = (string) null;
          arg2 = (string) null;
          arg3 = (string) null;
          arg4 = (string) null;
          arg5 = (string) null;
          arg6 = (string) null;
        }
      }
      catch (Exception ex)
      {
        RadioCommandWindow.result = RadioCommandWindow.result + "\nFunction (" + EFC + ") \nERROR: " + ex.Message;
        this.TextBoxUniversalCommandResult.Text = RadioCommandWindow.result;
        FC = (string) null;
        EFC = (string) null;
        addFC = (object) null;
        arg1 = (string) null;
        arg2 = (string) null;
        arg3 = (string) null;
        arg4 = (string) null;
        arg5 = (string) null;
        arg6 = (string) null;
      }
    }

    private void mi_Click(object sender, RoutedEventArgs e)
    {
      ((TextBox) ((FrameworkElement) sender).Tag).Text = ((HeaderedItemsControl) sender).Header.ToString();
    }

    private void updateContextMenu1(string packet)
    {
      if (!this.Argument1_last_values.Contains(packet))
        this.Argument1_last_values.Add(packet);
      this.Argument1ValuesMenu.Items.Clear();
      if (this.Argument1_last_values.Count > 20)
        this.Argument1_last_values.RemoveRange(0, this.Argument1_last_values.Count - 20);
      foreach (string argument1LastValue in this.Argument1_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument1LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_1;
        this.Argument1ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu2(string packet)
    {
      if (!this.Argument2_last_values.Contains(packet))
        this.Argument2_last_values.Add(packet);
      this.Argument2ValuesMenu.Items.Clear();
      if (this.Argument2_last_values.Count > 20)
        this.Argument2_last_values.RemoveRange(0, this.Argument2_last_values.Count - 20);
      foreach (string argument2LastValue in this.Argument2_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument2LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_2;
        this.Argument2ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu3(string packet)
    {
      if (!this.Argument3_last_values.Contains(packet))
        this.Argument3_last_values.Add(packet);
      this.Argument3ValuesMenu.Items.Clear();
      if (this.Argument3_last_values.Count > 20)
        this.Argument3_last_values.RemoveRange(0, this.Argument3_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_3;
        this.Argument3ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu4(string packet)
    {
      if (!this.Argument4_last_values.Contains(packet))
        this.Argument4_last_values.Add(packet);
      this.Argument4ValuesMenu.Items.Clear();
      if (this.Argument4_last_values.Count > 20)
        this.Argument4_last_values.RemoveRange(0, this.Argument4_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_4;
        this.Argument4ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu5(string packet)
    {
      if (!this.Argument5_last_values.Contains(packet))
        this.Argument5_last_values.Add(packet);
      this.Argument5ValuesMenu.Items.Clear();
      if (this.Argument5_last_values.Count > 20)
        this.Argument5_last_values.RemoveRange(0, this.Argument5_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_5;
        this.Argument5ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void CheckBoxEncryption_Checked(object sender, RoutedEventArgs e)
    {
      this.myRadioCommands.enDeCrypt = true;
      this.TextBoxEncryptionKey.Visibility = Visibility.Visible;
      this.EncryptionKey_Label.Visibility = Visibility.Visible;
    }

    private void CheckBoxEncryption_UnChecked(object sender, RoutedEventArgs e)
    {
      this.myRadioCommands.enDeCrypt = false;
      this.TextBoxEncryptionKey.Visibility = Visibility.Collapsed;
      this.EncryptionKey_Label.Visibility = Visibility.Collapsed;
    }

    private void TextBoxEncryptionKey_TextChanged(object sender, TextChangedEventArgs e)
    {
      this.myRadioCommands.AES_Key = this.TextBoxEncryptionKey.Text;
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/commandwindowradio.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.TextBlockStatus = (TextBlock) target;
          break;
        case 2:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        case 3:
          this.TextBoxUniversalCommandResult = (TextBox) target;
          break;
        case 4:
          this.StackPanalButtons = (StackPanel) target;
          break;
        case 5:
          this.ComboCommand = (ComboBox) target;
          this.ComboCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboCommand_SelectionChanged);
          break;
        case 6:
          this.CheckBoxEncryption = (CheckBox) target;
          this.CheckBoxEncryption.Checked += new RoutedEventHandler(this.CheckBoxEncryption_Checked);
          this.CheckBoxEncryption.Unchecked += new RoutedEventHandler(this.CheckBoxEncryption_UnChecked);
          break;
        case 7:
          this.EncryptionKey_Label = (Label) target;
          break;
        case 8:
          this.TextBoxEncryptionKey = (TextBox) target;
          this.TextBoxEncryptionKey.TextChanged += new TextChangedEventHandler(this.TextBoxEncryptionKey_TextChanged);
          break;
        case 9:
          this.ComboExtCommand_Label = (Label) target;
          break;
        case 10:
          this.ComboExtCommand = (ComboBox) target;
          this.ComboExtCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboExtCommand_SelectionChanged);
          break;
        case 11:
          this.ComboAddCommand_Label = (Label) target;
          break;
        case 12:
          this.ComboAddCommand = (ComboBox) target;
          this.ComboAddCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboAddCommand_SelectionChanged);
          break;
        case 13:
          this.TextArgument_1_Label = (Label) target;
          break;
        case 14:
          this.TextExtCommandArgument_1 = (TextBox) target;
          break;
        case 15:
          this.TextArgument_2_Label = (Label) target;
          break;
        case 16:
          this.TextExtCommandArgument_2 = (TextBox) target;
          break;
        case 17:
          this.TextArgument_3_Label = (Label) target;
          break;
        case 18:
          this.TextExtCommandArgument_3 = (TextBox) target;
          break;
        case 19:
          this.TextArgument_4_Label = (Label) target;
          break;
        case 20:
          this.TextExtCommandArgument_4 = (TextBox) target;
          break;
        case 21:
          this.TextArgument_5_Label = (Label) target;
          break;
        case 22:
          this.TextExtCommandArgument_5 = (TextBox) target;
          break;
        case 23:
          this.TextArgument_6_Label = (Label) target;
          break;
        case 24:
          this.TextExtCommandArgument_6 = (TextBox) target;
          break;
        case 25:
          this.StackPanalButtons2 = (StackPanel) target;
          break;
        case 26:
          this.ButtonRunCommand = (Button) target;
          this.ButtonRunCommand.Click += new RoutedEventHandler(this.ButtonRunCommand_Click);
          break;
        case 27:
          this.ButtonRunCommandPreview = (Button) target;
          this.ButtonRunCommandPreview.Click += new RoutedEventHandler(this.ButtonRunCommandPreview_Click);
          break;
        case 28:
          this.ButtonBreak = (Button) target;
          this.ButtonBreak.Click += new RoutedEventHandler(this.ButtonBreak_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- RadioTestByDevice.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.RadioTestByDevice
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort;
using CommunicationPort.Functions;
using NLog;
using ReadoutConfiguration;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class RadioTestByDevice
  {
    internal static Logger RadioTestByDeviceLogger = LogManager.GetLogger(nameof (RadioTestByDevice));
    private CommunicationPortFunctions RadioMinoConnectCommunication;
    private CommunicationByMinoConnect MiCon;
    private NfcDeviceCommands NfcCmd;
    private ConfigList RadioDeviceCannelConfigList;
    public DeviceIdentification devIdent;
    private const int PollingMs = 200;
    private Random DeviceID_Random;
    public RadioTestParameters TestParameters;
    private string RadioCOMPort;
    private double LastFrequencyMHz = 0.0;

    public CancellationToken CancelToken
    {
      get => this.MiCon.CancelToken;
      set => this.MiCon.CancelToken = value;
    }

    public RadioTestByDevice(string radioTestComPort, RadioTestParameters testParameters = null)
    {
      this.RadioCOMPort = radioTestComPort;
      this.devIdent = (DeviceIdentification) null;
      this.TestParameters = testParameters != null ? testParameters : new RadioTestParameters();
      if (this.TestParameters.TestDevice == RadioTestByDevice.RadioTestDevice.MinoConnect)
      {
        if (this.TestParameters.TestFrequency != 868.3 && this.TestParameters.TestFrequency != 868.95)
          throw new Exception("MinoConnect test only supported for 868.3 and 868.95 MHz");
        this.RadioDeviceCannelConfigList = ReadoutPreferences.GetConfigListFromProfileId(32);
      }
      else
      {
        if (this.TestParameters.TestDevice != RadioTestByDevice.RadioTestDevice.IUWS)
          throw new ArgumentException("TestDevice");
        this.RadioDeviceCannelConfigList = ReadoutPreferences.GetConfigListFromProfileId(344);
      }
      this.RadioDeviceCannelConfigList.Port = this.RadioCOMPort;
      this.RadioDeviceCannelConfigList.MinoConnectPowerOffTime = 0;
      this.RadioMinoConnectCommunication = new CommunicationPortFunctions();
      this.RadioMinoConnectCommunication.SetReadoutConfiguration(this.RadioDeviceCannelConfigList);
      this.MiCon = this.RadioMinoConnectCommunication.GetCommunicationByMinoConnect();
      this.OpenMinoConnect();
      this.DeviceID_Random = new Random(DateTime.Now.Millisecond);
      if (this.TestParameters.TestDevice == RadioTestByDevice.RadioTestDevice.IUWS)
        this.NfcCmd = new NfcDeviceCommands(this.RadioMinoConnectCommunication);
      this.NLOG_Trace("RadioTestByDevice initialised for TestDevice: " + this.TestParameters.TestDevice.ToString());
    }

    private void NLOG_Trace(string traceMessage)
    {
      RadioTestByDevice.RadioTestByDeviceLogger.Trace(this.RadioDeviceCannelConfigList.ReadingChannelIdentification + ": " + traceMessage);
    }

    private void NLOG_Debug(string traceMessage)
    {
      RadioTestByDevice.RadioTestByDeviceLogger.Debug(this.RadioDeviceCannelConfigList.ReadingChannelIdentification + ": " + traceMessage);
    }

    private void NLOG_Info(string traceMessage)
    {
      RadioTestByDevice.RadioTestByDeviceLogger.Info(this.RadioDeviceCannelConfigList.ReadingChannelIdentification + ": " + traceMessage);
    }

    public CommunicationPortFunctions GetMinoConnectPortFunctions()
    {
      return this.RadioMinoConnectCommunication;
    }

    public void OpenMinoConnect() => this.MiCon.Open();

    public void CloseMinoConnect() => this.MiCon.Close();

    public void SetChannelName(string channelName)
    {
      this.RadioDeviceCannelConfigList.ReadingChannelIdentification = channelName;
    }

    public uint GetRandomDeviceID() => (uint) this.DeviceID_Random.Next(0, 99999999);

    public string GetMiConDeviceInfo() => this.MiCon.GetDeviceInfo();

    public string GetMinoDeviceInfo() => this.RadioMinoConnectCommunication.TransceiverDeviceInfo;

    public async Task SetTestParameterAsync(ProgressHandler progress, bool SetFrequency)
    {
      if (this.TestParameters.TestDevice == RadioTestByDevice.RadioTestDevice.MinoConnect)
      {
        if (this.TestParameters.TestFrequency == 868.3)
          return;
        if (this.TestParameters.TestFrequency != 868.95)
          throw new Exception("MinoConnect only supports 868.3 and 868.95 MHz");
        if (this.MiCon.VersionValue < 2.603M)
          throw new Exception("MinoConnect version < 2.6.3 doesn't support 868.95 MHz");
      }
      else
      {
        if (this.TestParameters.TestDevice != RadioTestByDevice.RadioTestDevice.IUWS)
          throw new Exception("Test device not supported");
        if (!this.NfcCmd.myNfcRepeater.CrcInitValue.HasValue)
        {
          DeviceIdentification deviceIdentification = await this.NfcCmd.ReadVersionAsync(progress, this.CancelToken);
          this.devIdent = deviceIdentification;
          deviceIdentification = (DeviceIdentification) null;
        }
        if (!SetFrequency || this.LastFrequencyMHz == this.TestParameters.TestFrequency)
          return;
        await this.NfcCmd.SetCenterFrequencyMHz(progress, this.CancelToken, this.TestParameters.TestFrequency);
        this.LastFrequencyMHz = this.TestParameters.TestFrequency;
      }
    }

    public async Task StopRadioAsync(ProgressHandler progress)
    {
      if (this.MiCon == null)
        return;
      if (this.TestParameters.TestDevice == RadioTestByDevice.RadioTestDevice.MinoConnect)
        this.MiCon.StopRadio();
      else
        await this.NfcCmd.SetModeAsync(S4_DeviceModes.OperationMode, progress, this.CancelToken);
    }

    public RadioTestResult ReceiveOnePacket(int serialnumber, ushort timeoutInSec, string syncWord)
    {
      if (this.TestParameters.TestDevice != 0)
        throw new Exception("Function only allowed for MinoConnect as test device");
      if (this.TestParameters.TestFrequency == 868.3)
        return this.MiCon.ReceiveOnePacket(RadioMode.Radio3, serialnumber, timeoutInSec, syncWord);
      if (this.TestParameters.TestFrequency == 868.95)
        return this.MiCon.ReceiveOnePacket(RadioMode.Radio3_868_95, serialnumber, timeoutInSec, syncWord);
      throw new Exception("Not supported radio frequency");
    }

    public void SendTestPacket(uint deviceID, byte power, string syncWord, string testPacket)
    {
      if (this.TestParameters.TestDevice != 0)
        throw new Exception("Function only allowed for MinoConnect as test device");
      if (this.TestParameters.TestFrequency == 868.3)
      {
        this.MiCon.SendTestPacket(deviceID, RadioMode.Radio3, power, syncWord, testPacket);
      }
      else
      {
        if (this.TestParameters.TestFrequency != 868.95)
          throw new Exception("Not supported radio frequency");
        this.MiCon.SendTestPacket(deviceID, RadioMode.Radio3_868_95, power, syncWord, testPacket);
      }
    }

    public async Task<RadioTestResult> ReceiveOnePacketAsync(
      ProgressHandler progress,
      uint deviceID,
      ushort timeoutSeconds,
      byte[] testPacket)
    {
      this.NLOG_Trace("ReceiveOnePacketAsync started");
      if (this.TestParameters.TestDevice != RadioTestByDevice.RadioTestDevice.IUWS)
        throw new Exception("Function only allowed for IUWS as test device");
      if (timeoutSeconds > (ushort) byte.MaxValue)
        throw new ArgumentException("Timeout > 255 not allowed.");
      Exception localException = (Exception) null;
      RadioTestResult testResults = new RadioTestResult();
      try
      {
        List<byte> modeParameter = new List<byte>();
        modeParameter.Add((byte) testPacket.Length);
        modeParameter.Add((byte) ((uint) this.TestParameters.SyncWord >> 8));
        modeParameter.Add((byte) this.TestParameters.SyncWord);
        modeParameter.Add((byte) timeoutSeconds);
        await this.NfcCmd.SetModeAsync(S4_DeviceModes.RadioTestReceiveTestPacket, progress, this.CancelToken, modeParameter.ToArray());
        DateTime timeoutTime = DateTime.Now.AddSeconds((double) timeoutSeconds);
        while (DateTime.Now <= timeoutTime)
        {
          this.NLOG_Trace("IUWS state called");
          S4_SystemState iuwState = await this.NfcCmd.GetDeviceStatesAsync(progress, this.CancelToken);
          this.NLOG_Trace("IUWS state received");
          if (iuwState.DeviceMode != S4_DeviceModes.RadioTestReceiveTestPacket)
          {
            if (iuwState.DeviceMode == S4_DeviceModes.RadioTestReceiveTestPacketDone)
            {
              if (iuwState.ModeResultData != null && iuwState.ModeResultData.Length > 5)
              {
                byte[] receivedPacketBytes = new byte[iuwState.ModeResultData.Length - 4];
                Buffer.BlockCopy((Array) iuwState.ModeResultData, 2, (Array) receivedPacketBytes, 0, receivedPacketBytes.Length);
                if (((IEnumerable<byte>) receivedPacketBytes).SequenceEqual<byte>((IEnumerable<byte>) testPacket))
                {
                  this.NLOG_Debug("Received packet == testPacket");
                  testResults.RSSI = Util.RssiToRssi_dBm(iuwState.ModeResultData[0]);
                  testResults.Payload = receivedPacketBytes;
                }
                else
                  this.NLOG_Info("Received packet != testPacket");
                receivedPacketBytes = (byte[]) null;
                break;
              }
              progress.Report("Packet received but no data");
              break;
            }
            if (iuwState.DeviceMode == S4_DeviceModes.RadioTestReceiveTestPacketTimeout)
            {
              progress.Report("Receive timeout by device");
              break;
            }
            progress.Report("Illegal state change");
            break;
          }
          iuwState = (S4_SystemState) null;
        }
        modeParameter = (List<byte>) null;
      }
      catch (Exception ex)
      {
        localException = new Exception("Receive packed by TestDevice", ex);
      }
      this.NLOG_Trace("ReceiveOnePacketAsync finished");
      if (localException == null)
        return testResults.Payload == null ? (RadioTestResult) null : testResults;
      if (localException.InnerException is TaskCanceledException)
        return (RadioTestResult) null;
      throw localException;
    }

    public async Task SendTestPacketAsync(
      ProgressHandler progress,
      uint deviceID,
      ushort timeoutSeconds,
      byte[] sendPacketBytes)
    {
      this.NLOG_Trace("SendTestPacketAsync started");
      if (this.TestParameters.TestDevice != RadioTestByDevice.RadioTestDevice.IUWS)
        throw new Exception("Function only allowed for IUWS as test device");
      List<byte> modeParameter = new List<byte>();
      modeParameter.AddRange((IEnumerable<byte>) BitConverter.GetBytes((ushort) 0));
      modeParameter.AddRange((IEnumerable<byte>) BitConverter.GetBytes(timeoutSeconds));
      modeParameter.AddRange((IEnumerable<byte>) sendPacketBytes);
      await this.NfcCmd.SetModeAsync(S4_DeviceModes.RadioTestSendTestPacket, progress, this.CancelToken, modeParameter.ToArray());
      this.NLOG_Trace("SendTestPacketAsync finished");
      modeParameter = (List<byte>) null;
    }

    public async Task<DeviceIdentification> ReadDeviceIdentification(
      ProgressHandler progress,
      CancellationToken token)
    {
      if (this.TestParameters.TestDevice == RadioTestByDevice.RadioTestDevice.IUWS && !this.NfcCmd.myNfcRepeater.CrcInitValue.HasValue)
      {
        DeviceIdentification deviceIdentification = await this.NfcCmd.ReadVersionAsync(progress, token);
        this.devIdent = deviceIdentification;
        deviceIdentification = (DeviceIdentification) null;
      }
      return this.devIdent;
    }

    public enum RadioTestDevice
    {
      MinoConnect,
      IUWS,
    }
  }
}


--- RadioTestLog.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.RadioTestLog
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Data;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class RadioTestLog
  {
    private DataTable LogData;
    private int Order;

    public RadioTestLog()
    {
      this.LogData = new DataTable();
      this.LogData.Columns.Add(new DataColumn(RadioTestLog.LogColumnNames.Order.ToString())
      {
        DataType = typeof (int)
      });
      this.LogData.Columns.Add(new DataColumn(RadioTestLog.LogColumnNames.LogTime.ToString())
      {
        DataType = typeof (DateTime)
      });
      this.LogData.Columns.Add(new DataColumn(RadioTestLog.LogColumnNames.Frequency.ToString())
      {
        DataType = typeof (double)
      });
      this.LogData.Columns.Add(new DataColumn(RadioTestLog.LogColumnNames.Direction.ToString())
      {
        DataType = typeof (string)
      });
      this.LogData.Columns.Add(new DataColumn(RadioTestLog.LogColumnNames.ReceiveInfo.ToString())
      {
        DataType = typeof (string)
      });
      this.LogData.Columns.Add(new DataColumn(RadioTestLog.LogColumnNames.RSSI.ToString())
      {
        DataType = typeof (int)
      });
      this.Order = 0;
    }

    public void AddTest(
      double Frequency,
      RadioTestLog.RadioTestDirection direction,
      RadioTestLog.ReceiveInfo receiveInfo,
      int rssi)
    {
      DataRow row = this.LogData.NewRow();
      row[RadioTestLog.LogColumnNames.Order.ToString()] = (object) this.Order;
      row[RadioTestLog.LogColumnNames.LogTime.ToString()] = (object) DateTime.Now;
      row[RadioTestLog.LogColumnNames.Frequency.ToString()] = (object) Frequency;
      row[RadioTestLog.LogColumnNames.Direction.ToString()] = (object) direction.ToString();
      row[RadioTestLog.LogColumnNames.ReceiveInfo.ToString()] = (object) receiveInfo.ToString();
      if (receiveInfo == RadioTestLog.ReceiveInfo.ok)
        row[RadioTestLog.LogColumnNames.RSSI.ToString()] = (object) rssi;
      this.LogData.Rows.Add(row);
      ++this.Order;
    }

    public void ShowLog(string tableName)
    {
      ExcelConnect excelConnect = new ExcelConnect();
      excelConnect.AddTable(this.LogData, tableName, false, false);
      excelConnect.ShowWorkbook();
    }

    private enum LogColumnNames
    {
      Order,
      LogTime,
      Direction,
      Frequency,
      ReceiveInfo,
      RSSI,
    }

    public enum RadioTestDirection
    {
      DUT_To_MinoConnect,
      MinoConnect_To_DUT,
      DUT_To_IUWS,
      IUWS_To_DUT,
    }

    public enum ReceiveInfo
    {
      ok,
      timeout,
      error,
    }
  }
}


--- RadioTestLoopResults.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.RadioTestLoopResults
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

#nullable disable
namespace HandlerLib
{
  public class RadioTestLoopResults
  {
    private DateTime StartTime;
    private List<double> RSSI_List;
    private List<double> LQI_List;

    public string MessageText { get; set; }

    public int TestCount { get; set; }

    public int SendCount { get; set; }

    public int ReceiveCount => this.RSSI_List.Count;

    public int NoDataCount { get; set; }

    public int PollingCount { get; set; }

    public double MinRSSI
    {
      get => this.RSSI_List.Count == 0 ? (double) int.MinValue : this.RSSI_List.Min();
    }

    public double MaxRSSI
    {
      get => this.RSSI_List.Count == 0 ? (double) int.MinValue : this.RSSI_List.Max();
    }

    public double AvarageRSSI_Unfilterd
    {
      get
      {
        if (this.RSSI_List.Count == 0)
          return (double) int.MinValue;
        double num = 0.0;
        for (int index = 0; index < this.RSSI_List.Count; ++index)
          num += this.RSSI_List[index];
        return num / (double) this.RSSI_List.Count;
      }
    }

    public double AvarageRSSI
    {
      get
      {
        if (this.RSSI_List.Count == 0)
          return (double) int.MinValue;
        List<double> list = this.RSSI_List.ToList<double>();
        list.Sort();
        double num1 = 0.0;
        int num2 = list.Count / 5;
        for (int index = num2; index < list.Count - num2; ++index)
          num1 += list[index];
        return num1 / (double) (list.Count - 2 * num2);
      }
    }

    public string RSSI_Values
    {
      get
      {
        StringBuilder stringBuilder = new StringBuilder();
        foreach (int rssi in this.RSSI_List)
        {
          if (stringBuilder.Length > 0)
            stringBuilder.Append(';');
          stringBuilder.Append(rssi.ToString("0.##"));
        }
        return stringBuilder.ToString();
      }
    }

    public double MinLQI => this.LQI_List.Count == 0 ? (double) int.MinValue : this.LQI_List.Min();

    public double MaxLQI => this.LQI_List.Count == 0 ? (double) int.MinValue : this.LQI_List.Max();

    public double AvarageLQI_Unfilterd
    {
      get
      {
        if (this.LQI_List.Count == 0)
          return (double) int.MinValue;
        double num = 0.0;
        for (int index = 0; index < this.LQI_List.Count; ++index)
          num += this.LQI_List[index];
        return num / (double) this.LQI_List.Count;
      }
    }

    public double AvarageLQI
    {
      get
      {
        if (this.LQI_List.Count == 0)
          return (double) int.MinValue;
        List<double> list = this.LQI_List.ToList<double>();
        list.Sort();
        double num1 = 0.0;
        int num2 = list.Count / 5;
        for (int index = num2; index < list.Count - num2; ++index)
          num1 += list[index];
        return num1 / (double) (list.Count - 2 * num2);
      }
    }

    public string LQI_Values
    {
      get
      {
        StringBuilder stringBuilder = new StringBuilder();
        foreach (int lqi in this.LQI_List)
        {
          if (stringBuilder.Length > 0)
            stringBuilder.Append(';');
          stringBuilder.Append(lqi.ToString("0.##"));
        }
        return stringBuilder.ToString();
      }
    }

    public RadioTestLoopResults()
    {
      this.MessageText = string.Empty;
      this.RSSI_List = new List<double>();
      this.LQI_List = new List<double>();
      this.StartTime = DateTime.Now;
    }

    public void AddRSSI(int newRSSI, int? newLQI = null) => this.RSSI_List.Add((double) newRSSI);

    public void AddLoopResults(RadioTestLoopResults radioTestLoopResults)
    {
      if (radioTestLoopResults == null)
        return;
      this.TestCount += radioTestLoopResults.TestCount;
      this.SendCount += radioTestLoopResults.SendCount;
      this.NoDataCount += radioTestLoopResults.NoDataCount;
      this.PollingCount += radioTestLoopResults.PollingCount;
      this.RSSI_List.Add(radioTestLoopResults.AvarageRSSI);
    }

    public override string ToString()
    {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.AppendLine(this.MessageText);
      stringBuilder.AppendLine("SendCount: .. " + this.SendCount.ToString());
      stringBuilder.AppendLine("ReceiveCount: " + this.ReceiveCount.ToString());
      if (this.RSSI_List.Count > 0)
      {
        stringBuilder.AppendLine();
        stringBuilder.AppendLine("MinRSSI: ............. " + this.MinRSSI.ToString("0.##"));
        stringBuilder.AppendLine("MaxRSSI: ............. " + this.MaxRSSI.ToString("0.##"));
        stringBuilder.AppendLine("AvarageRSSI .......... " + this.AvarageRSSI.ToString("0.##"));
        stringBuilder.AppendLine("AvarageRSSI_Unfilterd: " + this.AvarageRSSI_Unfilterd.ToString("0.##"));
        stringBuilder.AppendLine("RSSI_Values: ......... " + this.RSSI_Values);
      }
      if (this.LQI_List.Count > 0)
      {
        stringBuilder.AppendLine();
        stringBuilder.AppendLine("MinLQI: ............. " + this.MinLQI.ToString("0.##"));
        stringBuilder.AppendLine("MaxLQI: ............. " + this.MaxLQI.ToString("0.##"));
        stringBuilder.AppendLine("AvarageLQI: ......... " + this.AvarageLQI.ToString("0.##"));
        stringBuilder.AppendLine("AvarageLQI_Unfilterd: " + this.AvarageLQI_Unfilterd.ToString("0.##"));
        stringBuilder.AppendLine("LQI_Values: ......... " + this.LQI_Values);
      }
      return stringBuilder.ToString();
    }
  }
}


--- RadioTestParameters.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.RadioTestParameters
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public class RadioTestParameters
  {
    public RadioTestByDevice.RadioTestDevice TestDevice { get; private set; }

    public ushort SyncWord { get; private set; }

    public double TestFrequency { get; private set; }

    public int AverageRSSITx { get; set; }

    public int AverageRSSIRx { get; set; }

    public RadioTestParameters()
    {
      this.TestDevice = RadioTestByDevice.RadioTestDevice.MinoConnect;
      this.TestFrequency = 868.3;
      this.SyncWord = (ushort) 37331;
    }

    public RadioTestParameters(
      RadioTestByDevice.RadioTestDevice testDevice,
      double testFrequency,
      ushort radioSyncWord)
    {
      this.TestDevice = testDevice;
      this.TestFrequency = testFrequency;
      this.SyncWord = radioSyncWord;
    }

    public override string ToString()
    {
      return "Test device: " + this.TestDevice.ToString() + "\r Frequency: " + this.TestFrequency.ToString() + "\r SyncWord: " + this.SyncWord.ToString() + "\r AvgRSSITx: " + this.AverageRSSITx.ToString() + "\r AvgRSSIRx: " + this.AverageRSSIRx.ToString();
    }
  }
}


--- RangeListVisualisation.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.RangeListVisualisation
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommonWPF;
using System;
using System.Collections.Generic;
using System.Text;

#nullable disable
namespace HandlerLib
{
  public class RangeListVisualisation
  {
    public RangeListVisualisation(string caption, List<AddressRangeInfo> ranges)
    {
      StringBuilder stringBuilder1 = new StringBuilder();
      stringBuilder1.AppendLine("*** " + caption + " ***");
      stringBuilder1.AppendLine();
      if (ranges == null)
      {
        stringBuilder1.AppendLine("Ranges not defined");
      }
      else
      {
        int totalWidth = 0;
        int num1 = 1;
        foreach (AddressRangeInfo range in ranges)
        {
          range.Order = num1;
          ++num1;
          if (!string.IsNullOrEmpty(range.RangeInfo) && range.RangeInfo.Length > totalWidth)
            totalWidth = range.RangeInfo.Length;
        }
        foreach (AddressRangeInfo range in ranges)
        {
          int num2 = (int) (Math.Log10((double) range.ByteSize) * 10.0);
          stringBuilder1.Append(range.RangeInfo.PadRight(totalWidth) + " ");
          stringBuilder1.Append(range.Order.ToString("d2") + " ");
          StringBuilder stringBuilder2 = stringBuilder1;
          uint num3 = range.StartAddress;
          string str1 = "0x" + num3.ToString("x08");
          stringBuilder2.Append(str1);
          stringBuilder1.Append(" - ");
          StringBuilder stringBuilder3 = stringBuilder1;
          num3 = range.EndAddress;
          string str2 = "0x" + num3.ToString("x08");
          stringBuilder3.Append(str2);
          StringBuilder stringBuilder4 = stringBuilder1;
          num3 = range.ByteSize;
          string str3 = ": 0x" + num3.ToString("x04");
          stringBuilder4.Append(str3);
          stringBuilder1.Append(" ");
          for (int index = 0; index < num2; ++index)
            stringBuilder1.Append("#");
          stringBuilder1.AppendLine();
        }
      }
      GmmMessage.Show(stringBuilder1.ToString(), "Range view", true);
    }
  }
}


--- ReadPartsSelection.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ReadPartsSelection
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  [Flags]
  public enum ReadPartsSelection : uint
  {
    Dump = 2147483647, // 0x7FFFFFFF
    All = 536870911, // 0x1FFFFFFF
    AllWithoutLogger = 251723775, // 0x0F00FFFF
    IdentificationMask = 15, // 0x0000000F
    FirmwareVersion = 1,
    Identification = 2,
    EnhancedIdentification = 4,
    ConfigMask = 240, // 0x000000F0
    CompleteConfiguration = ConfigMask, // 0x000000F0
    BasicConfiguration = 16, // 0x00000010
    Calibration = 32, // 0x00000020
    RangesMask = 3840, // 0x00000F00
    RAM_range = 256, // 0x00000100
    FLASH_range = 512, // 0x00000200
    BACKUP_range = 1024, // 0x00000400
    CLONE_range = 2048, // 0x00000800
    CumulatedDataMask = 61440, // 0x0000F000
    AllCumulatedData = CumulatedDataMask, // 0x0000F000
    CurrentMeasurementValues = 4096, // 0x00001000
    LoggersMask = 2031616, // 0x001F0000
    AllLoggers = LoggersMask, // 0x001F0000
    KeyData = 65536, // 0x00010000
    MonthLogger = 131072, // 0x00020000
    SmartFunctionLoggers = 524288, // 0x00080000
    SmartFunctions = 2097152, // 0x00200000
    ScenarioMask = 12582912, // 0x00C00000
    AllScenarios = ScenarioMask, // 0x00C00000
    ScenarioConfiguration = 4194304, // 0x00400000
    DeveloperMask = 1879048192, // 0x70000000
    BackupBlocks = 268435456, // 0x10000000
    RamDiagnosticParameters = 536870912, // 0x20000000
    ProtocolOnlyMode = 2147483648, // 0x80000000
  }
}


--- ReceiveTestPacketMiConWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ReceiveTestPacketMiConWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort;
using CommunicationPort.Functions;
using ReadoutConfiguration;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class ReceiveTestPacketMiConWindow : Window, IComponentConnector
  {
    private RadioMode mode;
    private CommunicationByMinoConnect micon;
    internal Button ButtonReceiveTestPacket;
    internal TextBox TextBoxTimeout;
    internal TextBox TextBoxOutput;
    internal ProgressBar ProgressBarRadioTest;
    internal TextBox TextBoxSerialnumber;
    internal Button ButtonConnectionProfile;
    private bool _contentLoaded;

    public ReceiveTestPacketMiConWindow()
    {
      this.InitializeComponent();
      this.Closing += new CancelEventHandler(this.Window_Closing);
    }

    private void Window_Closing(object sender, CancelEventArgs e) => this.Dispose();

    public static void Show(Window owner)
    {
      ReceiveTestPacketMiConWindow packetMiConWindow = new ReceiveTestPacketMiConWindow();
      if (owner != null)
        packetMiConWindow.Owner = owner;
      packetMiConWindow.Show();
    }

    public static void ShowDialog(Window owner)
    {
      ReceiveTestPacketMiConWindow packetMiConWindow = new ReceiveTestPacketMiConWindow();
      if (owner != null)
        packetMiConWindow.Owner = owner;
      if (packetMiConWindow.ShowDialog().Value)
        ;
    }

    private void Dispose()
    {
      if (this.micon == null)
        return;
      this.micon.Close();
      this.micon.Dispose();
      this.micon = (CommunicationByMinoConnect) null;
    }

    private void ButtonConnectionProfile_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.Dispose();
        ConfigList configList = ReadoutConfigMain.ShowDialog(32);
        if (configList == null)
          return;
        if (!Enum.IsDefined(typeof (RadioMode), (object) configList["BusMode"]))
        {
          int num = (int) MessageBox.Show((Window) this, "This profile is not supported!", "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
        }
        else
        {
          this.mode = (RadioMode) Enum.Parse(typeof (RadioMode), configList["BusMode"], true);
          CommunicationPortFunctions communicationPortFunctions = new CommunicationPortFunctions();
          communicationPortFunctions.SetReadoutConfiguration(configList);
          communicationPortFunctions.Open();
          this.micon = communicationPortFunctions.GetCommunicationByMinoConnect();
        }
      }
      catch (Exception ex)
      {
        ErrorMessageBox.ShowDialog((Window) this, ex.Message, ex);
      }
    }

    private async void ButtonReceiveTestPacket_Click(object sender, RoutedEventArgs e)
    {
      if (this.micon == null)
      {
        int num1 = (int) MessageBox.Show((Window) this, "Please select a profile!", "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      else
      {
        ushort timeoutInSec;
        if (!ushort.TryParse(this.TextBoxTimeout.Text, out timeoutInSec))
        {
          int num2 = (int) MessageBox.Show((Window) this, "Timeout is wrong!", "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
        }
        else if (timeoutInSec == (ushort) 0)
        {
          int num3 = (int) MessageBox.Show((Window) this, "Timeout is wrong! It should be greater as 0.", "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
        }
        else if (!int.TryParse(this.TextBoxSerialnumber.Text, out int _))
        {
          int num4 = (int) MessageBox.Show((Window) this, "Serialnumber is invalid!", "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
        }
        else
        {
          try
          {
            this.ButtonReceiveTestPacket.IsEnabled = false;
            RadioTestResult result = (RadioTestResult) null;
            await Task.Run((Action) (() => result = this.micon.ReceiveOnePacket(this.mode, serialnumber, timeoutInSec, "0FF0")));
            if (result != null)
            {
              byte[] arbitraryData = new byte[28];
              Buffer.BlockCopy((Array) result.Payload, 11, (Array) arbitraryData, 0, arbitraryData.Length);
              this.TextBoxOutput.AppendText(Utility.ByteArrayToHexString(result.ReceiveBuffer));
              this.TextBoxOutput.AppendText(" RSSI: ");
              this.TextBoxOutput.AppendText(result.RSSI.ToString());
              this.TextBoxOutput.AppendText(" LQI: ");
              this.TextBoxOutput.AppendText(result.LQI.ToString("X2") + "h");
              this.TextBoxOutput.AppendText(" MCT: ");
              this.TextBoxOutput.AppendText(result.MCT.ToString());
              this.TextBoxOutput.AppendText(Environment.NewLine);
              this.TextBoxOutput.ScrollToEnd();
              arbitraryData = (byte[]) null;
            }
            else
            {
              this.TextBoxOutput.AppendText("NULL");
              this.TextBoxOutput.AppendText(Environment.NewLine);
              this.TextBoxOutput.ScrollToEnd();
            }
          }
          catch (Exception ex)
          {
            int num5 = (int) MessageBox.Show((Window) this, ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
          }
          finally
          {
            this.ButtonReceiveTestPacket.IsEnabled = true;
          }
        }
      }
    }

    private void TextBoxTimeout_TextChanged(object sender, TextChangedEventArgs e)
    {
      TextBox textBox = sender as TextBox;
      int result;
      if (!int.TryParse(textBox.Text, out result))
        return;
      if (result > (int) byte.MaxValue)
        textBox.Text = "65535";
      else if (result < 0)
        textBox.Text = "0";
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/receivetestpacketmiconwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.ButtonReceiveTestPacket = (Button) target;
          this.ButtonReceiveTestPacket.Click += new RoutedEventHandler(this.ButtonReceiveTestPacket_Click);
          break;
        case 2:
          this.TextBoxTimeout = (TextBox) target;
          this.TextBoxTimeout.TextChanged += new TextChangedEventHandler(this.TextBoxTimeout_TextChanged);
          break;
        case 3:
          this.TextBoxOutput = (TextBox) target;
          break;
        case 4:
          this.ProgressBarRadioTest = (ProgressBar) target;
          break;
        case 5:
          this.TextBoxSerialnumber = (TextBox) target;
          break;
        case 6:
          this.ButtonConnectionProfile = (Button) target;
          this.ButtonConnectionProfile.Click += new RoutedEventHandler(this.ButtonConnectionProfile_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- ReceiveTestPacketWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ReceiveTestPacketWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class ReceiveTestPacketWindow : Window, IComponentConnector
  {
    private DeviceCommandsMBus cmd;
    private CommonRadioCommands radio;
    internal Button ButtonStart;
    internal TextBox TextBoxSize;
    internal TextBox TextBoxTimeout;
    internal TextBox TextBoxOutput;
    internal ProgressBar ProgressBarRadioTest;
    internal Button ButtonExport;
    private bool _contentLoaded;

    public ReceiveTestPacketWindow() => this.InitializeComponent();

    public static void ShowDialog(Window owner, DeviceCommandsMBus cmd, CommonRadioCommands radio)
    {
      if (cmd == null)
        throw new NullReferenceException(nameof (cmd));
      ReceiveTestPacketWindow testPacketWindow = new ReceiveTestPacketWindow();
      testPacketWindow.Owner = owner;
      testPacketWindow.cmd = cmd;
      testPacketWindow.radio = radio;
      if (testPacketWindow.ShowDialog().Value)
        ;
    }

    private async void ButtonStart_Click(object sender, RoutedEventArgs e)
    {
      byte telegramSize;
      ProgressHandler dummy1;
      CancellationToken dummy2;
      if (!byte.TryParse(this.TextBoxSize.Text, out telegramSize))
      {
        int num = (int) MessageBox.Show((Window) this, "Size is wrong!", "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
        dummy1 = (ProgressHandler) null;
        dummy2 = new CancellationToken();
      }
      else
      {
        ushort timeoutInSec;
        if (!ushort.TryParse(this.TextBoxTimeout.Text, out timeoutInSec))
        {
          int num = (int) MessageBox.Show((Window) this, "Timeout is wrong!", "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
          dummy1 = (ProgressHandler) null;
          dummy2 = new CancellationToken();
        }
        else if (timeoutInSec == (ushort) 0)
        {
          int num = (int) MessageBox.Show((Window) this, "Timeout is wrong! It should be greater as 0.", "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
          dummy1 = (ProgressHandler) null;
          dummy2 = new CancellationToken();
        }
        else
        {
          dummy1 = new ProgressHandler((Action<ProgressArg>) (x => { }));
          dummy2 = new CancellationToken();
          try
          {
            this.ButtonStart.IsEnabled = false;
            bool isConnected = this.cmd.ConnectedReducedID != null;
            if (!isConnected)
            {
              DeviceVersionMBus deviceVersionMbus = await this.cmd.ReadVersionAsync(dummy1, dummy2);
            }
            await this.radio.ReceiveAndStreamRadio3Scenario3TelegramsAsync(telegramSize, timeoutInSec, dummy1, dummy2);
            this.cmd.MBus.Repeater.Port.DiscardInBuffer();
            DateTime start = DateTime.Now;
            DateTime end = start.AddSeconds((double) timeoutInSec);
            while (DateTime.Now <= end)
            {
              await Task.Delay(500);
              ulong current = Convert.ToUInt64((DateTime.Now - start).TotalSeconds);
              this.Log(this.cmd.MBus.Repeater.Port.ReadExisting(), Convert.ToInt32(current * 100UL / (ulong) timeoutInSec));
            }
            dummy1 = (ProgressHandler) null;
            dummy2 = new CancellationToken();
          }
          catch (Exception ex)
          {
            int num = (int) MessageBox.Show((Window) this, ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
            dummy1 = (ProgressHandler) null;
            dummy2 = new CancellationToken();
          }
          finally
          {
            this.ButtonStart.IsEnabled = true;
          }
        }
      }
    }

    private void Log(byte[] buffer, int progress)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.Log(buffer, progress)));
      }
      else
      {
        this.ProgressBarRadioTest.Value = (double) progress;
        if (buffer == null)
          return;
        this.TextBoxOutput.AppendText(Utility.ByteArrayToHexString(buffer));
        this.TextBoxOutput.AppendText(Environment.NewLine);
        this.TextBoxOutput.ScrollToEnd();
      }
    }

    private void TextBoxSize_TextChanged(object sender, TextChangedEventArgs e)
    {
      TextBox textBox = sender as TextBox;
      int result;
      if (!int.TryParse(textBox.Text, out result))
        return;
      if (result > (int) byte.MaxValue)
        textBox.Text = "255";
      else if (result < 0)
        textBox.Text = "0";
    }

    private void TextBoxTimeout_TextChanged(object sender, TextChangedEventArgs e)
    {
      TextBox textBox = sender as TextBox;
      int result;
      if (!int.TryParse(textBox.Text, out result))
        return;
      if (result > (int) byte.MaxValue)
        textBox.Text = "65535";
      else if (result < 0)
        textBox.Text = "0";
    }

    private void ButtonExport_Click(object sender, RoutedEventArgs e)
    {
      string str1 = this.TextBoxOutput.Text.Replace(Environment.NewLine, string.Empty);
      if (string.IsNullOrEmpty(str1))
        return;
      int startIndex1 = 0;
      while (startIndex1 >= 0)
      {
        int startIndex2 = str1.IndexOf("68", startIndex1);
        if (startIndex2 >= 0)
        {
          if (startIndex2 != 0 && startIndex2 >= 0 && startIndex2 + 8 <= str1.Length && str1[startIndex2 + 6] == '6' && str1[startIndex2 + 7] == '8')
          {
            str1 = str1.Insert(startIndex2, "|");
            startIndex1 = startIndex2 + 9;
          }
          else
            startIndex1 = startIndex2 + 1;
        }
        else
          break;
      }
      string[] strArray = str1.Split('|');
      string str2 = Path.Combine(Path.GetTempPath(), "SaveFile.csv");
      using (StreamWriter streamWriter = new StreamWriter(str2))
      {
        foreach (string str3 in strArray)
        {
          streamWriter.Write(str3);
          streamWriter.WriteLine(";");
        }
      }
      Process.Start(str2);
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/receivetestpacketwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.ButtonStart = (Button) target;
          this.ButtonStart.Click += new RoutedEventHandler(this.ButtonStart_Click);
          break;
        case 2:
          this.TextBoxSize = (TextBox) target;
          this.TextBoxSize.TextChanged += new TextChangedEventHandler(this.TextBoxSize_TextChanged);
          break;
        case 3:
          this.TextBoxTimeout = (TextBox) target;
          this.TextBoxTimeout.TextChanged += new TextChangedEventHandler(this.TextBoxTimeout_TextChanged);
          break;
        case 4:
          this.TextBoxOutput = (TextBox) target;
          break;
        case 5:
          this.ProgressBarRadioTest = (ProgressBar) target;
          break;
        case 6:
          this.ButtonExport = (Button) target;
          this.ButtonExport.Click += new RoutedEventHandler(this.ButtonExport_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- Retry.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.Retry
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;
using System.Threading;

#nullable disable
namespace HandlerLib
{
  public static class Retry
  {
    public static void Do(Action action, TimeSpan retryInterval, int retryCount = 3)
    {
      Retry.Do<object>((Func<object>) (() =>
      {
        action();
        return (object) null;
      }), retryInterval, retryCount);
    }

    public static T Do<T>(
      Func<T> action,
      TimeSpan retryInterval,
      int retryCount = 3,
      Action nextAttemptAction = null)
    {
      List<Exception> innerExceptions = new List<Exception>();
      for (int index = 0; index < retryCount; ++index)
      {
        try
        {
          if (index > 0)
          {
            Thread.Sleep(retryInterval);
            if (nextAttemptAction != null)
              nextAttemptAction();
          }
          return action();
        }
        catch (Exception ex)
        {
          innerExceptions.Add(ex);
        }
      }
      throw new AggregateException((IEnumerable<Exception>) innerExceptions);
    }
  }
}


--- ReturnValue.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ReturnValue
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public class ReturnValue
  {
    public byte[] basedata { get; set; }
  }
}


--- RowScaling.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.RowScaling
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  internal class RowScaling
  {
    internal double Xmin;
    internal double Xmax;
    internal double Ymin;
    internal double Ymax;
  }
}


--- S4_DeviceModes.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.S4_DeviceModes
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum S4_DeviceModes
  {
    OperationMode = 0,
    DeliveryMode = 1,
    TestModePrepared = 128, // 0x00000080
    FlyingTestStart = 145, // 0x00000091
    FlyingTestRun = 146, // 0x00000092
    FlyingTestOrderStop = 147, // 0x00000093
    FlyingTestStoped = 148, // 0x00000094
    CurrentTest = 161, // 0x000000A1
    ZeroOffsetTestStart = 177, // 0x000000B1
    ZeroOffsetTestOrderStop = 179, // 0x000000B3
    ZeroOffsetTestStoped = 180, // 0x000000B4
    RtcCalibrationTestStart = 193, // 0x000000C1
    RtcCalibrationOrderStop = 195, // 0x000000C3
    RtcCalibrationStoped = 196, // 0x000000C4
    TdcLevelTest = 209, // 0x000000D1
    LcdTest = 225, // 0x000000E1
    RadioTestTransmitUnmodulatedCarrier = 227, // 0x000000E3
    RadioTestTransmitUnmodulatedCarrierFinished = 228, // 0x000000E4
    RadioTestTransmitModulatedCarrier = 229, // 0x000000E5
    RadioTestTransmitModulatedCarrierFinished = 230, // 0x000000E6
    RadioTestSendTestPacket = 231, // 0x000000E7
    RadioTestSendTestPacketFinished = 232, // 0x000000E8
    RadioTestReceiveTestPacket = 233, // 0x000000E9
    RadioTestReceiveTestPacketDone = 234, // 0x000000EA
    RadioTestReceiveTestPacketTimeout = 235, // 0x000000EB
    RadioTestRadioSimulation = 236, // 0x000000EC
  }
}


--- S4_SystemState.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.S4_SystemState
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

#nullable disable
namespace HandlerLib
{
  public class S4_SystemState
  {
    private static List<S4_SystemState.ModeMapping> CommonModeMapping = new List<S4_SystemState.ModeMapping>();
    private uint sysState;
    private uint sysInfos;

    static S4_SystemState()
    {
      S4_SystemState.CommonModeMapping.Add(new S4_SystemState.ModeMapping()
      {
        DeviceModes = HandlerFunctionsForProduction.CommonDeviceModes.OperationMode,
        IuwModes = S4_DeviceModes.OperationMode
      });
      S4_SystemState.CommonModeMapping.Add(new S4_SystemState.ModeMapping()
      {
        DeviceModes = HandlerFunctionsForProduction.CommonDeviceModes.DeliveryMode,
        IuwModes = S4_DeviceModes.OperationMode
      });
      S4_SystemState.CommonModeMapping.Add(new S4_SystemState.ModeMapping()
      {
        DeviceModes = HandlerFunctionsForProduction.CommonDeviceModes.StandbyCurrentMode,
        IuwModes = S4_DeviceModes.OperationMode
      });
      S4_SystemState.CommonModeMapping.Add(new S4_SystemState.ModeMapping()
      {
        DeviceModes = HandlerFunctionsForProduction.CommonDeviceModes.RTC_CalibrationMode,
        IuwModes = S4_DeviceModes.RtcCalibrationTestStart
      });
      S4_SystemState.CommonModeMapping.Add(new S4_SystemState.ModeMapping()
      {
        DeviceModes = HandlerFunctionsForProduction.CommonDeviceModes.RTC_CalibrationVerifyMode,
        IuwModes = S4_DeviceModes.RtcCalibrationTestStart
      });
      S4_SystemState.CommonModeMapping.Add(new S4_SystemState.ModeMapping()
      {
        DeviceModes = HandlerFunctionsForProduction.CommonDeviceModes.UltrasonicLevelTest,
        IuwModes = S4_DeviceModes.TdcLevelTest
      });
      S4_SystemState.CommonModeMapping.Add(new S4_SystemState.ModeMapping()
      {
        DeviceModes = HandlerFunctionsForProduction.CommonDeviceModes.LcdTest,
        IuwModes = S4_DeviceModes.LcdTest
      });
      S4_SystemState.CommonModeMapping.Add(new S4_SystemState.ModeMapping()
      {
        DeviceModes = HandlerFunctionsForProduction.CommonDeviceModes.RadioTestTransmitUnmodulatedCarrier,
        IuwModes = S4_DeviceModes.RadioTestTransmitUnmodulatedCarrier
      });
      S4_SystemState.CommonModeMapping.Add(new S4_SystemState.ModeMapping()
      {
        DeviceModes = HandlerFunctionsForProduction.CommonDeviceModes.RadioTestTransmitModulatedCarrier,
        IuwModes = S4_DeviceModes.RadioTestTransmitModulatedCarrier
      });
      S4_SystemState.CommonModeMapping.Add(new S4_SystemState.ModeMapping()
      {
        DeviceModes = HandlerFunctionsForProduction.CommonDeviceModes.RadioTestReceiveTestPacket,
        IuwModes = S4_DeviceModes.RadioTestReceiveTestPacket
      });
      S4_SystemState.CommonModeMapping.Add(new S4_SystemState.ModeMapping()
      {
        DeviceModes = HandlerFunctionsForProduction.CommonDeviceModes.RadioTestSendTestPacket,
        IuwModes = S4_DeviceModes.RadioTestSendTestPacket
      });
    }

    public S4_SystemState(byte[] receiveFrame)
    {
      int offset = 2;
      this.sysState = ByteArrayScanner.ScanUInt32(receiveFrame, ref offset);
      this.NfcPowerfail = new uint?((uint) ByteArrayScanner.ScanUInt16(receiveFrame, ref offset));
      this.sysInfos = ByteArrayScanner.ScanUInt32(receiveFrame, ref offset);
      int count = receiveFrame.Length - offset;
      if (count <= 0)
        return;
      this.ModeResultData = new byte[count];
      Buffer.BlockCopy((Array) receiveFrame, offset, (Array) this.ModeResultData, 0, count);
    }

    public S4_SystemState(uint systemInfo) => this.sysInfos = systemInfo;

    public byte[] ModeResultData { get; private set; }

    public SystemInfo SysInfo => (SystemInfo) this.sysInfos;

    public bool IsWriteProtected => S4_SystemState.GetWriteProtection(this.sysState);

    public bool IsMeterKeyDefined => S4_SystemState.GetMeterKeyDefined(this.sysState);

    public static bool GetWriteProtection(uint sysState) => (sysState & 1024U) > 0U;

    public static bool GetMeterKeyDefined(uint sysState) => (sysState & 512U) > 0U;

    public bool IsCRCRunning() => S4_SystemState.GetIsCRCRunning(this.sysState);

    public static bool GetIsCRCRunning(uint sysState) => (sysState & 32768U) > 0U;

    public bool IsTestModeEnabled
    {
      get => (this.DeviceMode & S4_DeviceModes.TestModePrepared) == S4_DeviceModes.TestModePrepared;
    }

    public S4_DeviceModes DeviceMode => (S4_DeviceModes) (byte) (this.sysState >> 16);

    public bool IsCommonDeviceModeActive(
      HandlerFunctionsForProduction.CommonDeviceModes commonDeviceMode)
    {
      S4_SystemState.ModeMapping modeMapping = S4_SystemState.CommonModeMapping.FirstOrDefault<S4_SystemState.ModeMapping>((Func<S4_SystemState.ModeMapping, bool>) (x => x.DeviceModes == commonDeviceMode));
      return modeMapping != null && this.DeviceMode == modeMapping.IuwModes;
    }

    public Test_State TestState => (Test_State) ((int) (this.sysState >> 16) & 15);

    public uint? NfcPowerfail { get; private set; }

    public override string ToString()
    {
      StringBuilder info = new StringBuilder();
      for (uint index = 1; index > 0U; index <<= 1)
      {
        if ((index & this.sysInfos) > 0U && Enum.IsDefined(typeof (SystemInfo), (object) index))
          this.appendFlagToList(info, ((SystemInfo) index).ToString());
      }
      return info.ToString();
    }

    private void appendFlagToList(StringBuilder info, string flag)
    {
      if (info.Length > 0)
        info.Append(',');
      info.Append(flag);
    }

    public string ToTextBlock()
    {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.AppendLine("DeviceMode : " + this.DeviceMode.ToString());
      stringBuilder.AppendLine("NfcPowerfails : " + this.NfcPowerfail.ToString());
      stringBuilder.AppendLine("SysteInfoBits :");
      for (uint index = 1; index > 0U; index <<= 1)
      {
        if ((index & this.sysInfos) > 0U && Enum.IsDefined(typeof (SystemInfo), (object) index))
          stringBuilder.AppendLine("   " + ((SystemInfo) index).ToString());
      }
      return stringBuilder.ToString();
    }

    [Flags]
    public enum sysStateBits : uint
    {
      STATUS_METERKEY_IS_SET = 512, // 0x00000200
      STATUS_DEVICE_IS_PROTECTED = 1024, // 0x00000400
      STATUS_DEVICE_SLEEP = 2048, // 0x00000800
      STATUS_CRC_CHECK_IS_RUNNING = 32768, // 0x00008000
      STATUS_DEFBACKUP_AT_PROTECTION = 16384, // 0x00004000
      STATUS_BATTERY_DOWN = 8192, // 0x00002000
      STATUS_PVD_LOW_BAT = 4096, // 0x00001000
      STATUS_DEVICE_SLEEP_REQUEST = 256, // 0x00000100
    }

    private class ModeMapping
    {
      internal HandlerFunctionsForProduction.CommonDeviceModes DeviceModes;
      internal S4_DeviceModes IuwModes;
    }
  }
}


--- SCENARIO.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SCENARIO
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum SCENARIO : byte
  {
    SCENARIO_1 = 1,
    SCENARIO_2 = 2,
  }
}


--- SendTestPacketMiConWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SendTestPacketMiConWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.Functions;
using ReadoutConfiguration;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class SendTestPacketMiConWindow : Window, IComponentConnector
  {
    private RadioMode mode;
    private CommunicationByMinoConnect micon;
    internal Button ButtonConnectionProfile;
    internal Button ButtonSend;
    internal TextBox TextBoxSerialnumber;
    internal ComboBox ComboBoxMode;
    private bool _contentLoaded;

    public SendTestPacketMiConWindow()
    {
      this.InitializeComponent();
      this.Closing += new CancelEventHandler(this.Window_Closing);
      this.ComboBoxMode.ItemsSource = (IEnumerable) Enum.GetValues(typeof (RadioMode));
      this.ComboBoxMode.SelectedItem = (object) RadioMode.Radio3;
    }

    public static void ShowDialog(Window owner)
    {
      SendTestPacketMiConWindow packetMiConWindow = new SendTestPacketMiConWindow();
      packetMiConWindow.Owner = owner;
      packetMiConWindow.ShowDialog();
    }

    public static void Show(Window owner)
    {
      SendTestPacketMiConWindow packetMiConWindow = new SendTestPacketMiConWindow();
      packetMiConWindow.Owner = owner;
      packetMiConWindow.Show();
    }

    private void ButtonSend_Click(object sender, RoutedEventArgs e)
    {
      if (this.micon == null)
      {
        int num1 = (int) MessageBox.Show((Window) this, "Please select a profile!", "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      else
      {
        try
        {
          uint deviceID = uint.Parse(this.TextBoxSerialnumber.Text);
          if (deviceID.ToString().Length > 8)
          {
            int num2 = (int) MessageBox.Show((Window) this, "The serialnumber must be less or equal as 8 chars!", "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
          }
          else
            this.micon.SendTestPacket(deviceID, this.mode, (byte) 7, "0FF0");
        }
        catch (Exception ex)
        {
          ErrorMessageBox.ShowDialog((Window) this, ex.Message, ex);
        }
      }
    }

    private void ButtonConnectionProfile_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        this.Dispose();
        ConfigList configList = ReadoutConfigMain.ShowDialog(32);
        if (configList == null)
          return;
        if (!Enum.IsDefined(typeof (RadioMode), (object) configList["BusMode"]))
        {
          int num = (int) MessageBox.Show((Window) this, "This profile is not supported!", "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
        }
        else
        {
          this.mode = (RadioMode) Enum.Parse(typeof (RadioMode), this.ComboBoxMode.SelectedItem.ToString(), true);
          CommunicationPortFunctions communicationPortFunctions = new CommunicationPortFunctions();
          communicationPortFunctions.SetReadoutConfiguration(configList);
          communicationPortFunctions.Open();
          this.micon = communicationPortFunctions.GetCommunicationByMinoConnect();
        }
      }
      catch (Exception ex)
      {
        ErrorMessageBox.ShowDialog((Window) this, ex.Message, ex);
      }
    }

    private void Dispose()
    {
      if (this.micon == null)
        return;
      this.micon.Close();
      this.micon.Dispose();
      this.micon = (CommunicationByMinoConnect) null;
    }

    private void Window_Closing(object sender, CancelEventArgs e) => this.Dispose();

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/sendtestpacketmiconwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.ButtonConnectionProfile = (Button) target;
          this.ButtonConnectionProfile.Click += new RoutedEventHandler(this.ButtonConnectionProfile_Click);
          break;
        case 2:
          this.ButtonSend = (Button) target;
          this.ButtonSend.Click += new RoutedEventHandler(this.ButtonSend_Click);
          break;
        case 3:
          this.TextBoxSerialnumber = (TextBox) target;
          break;
        case 4:
          this.ComboBoxMode = (ComboBox) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- SENSUSConnector.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SENSUSConnector
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.Functions;
using NLog;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class SENSUSConnector
  {
    internal static Logger SENSUSConnector_Logger = LogManager.GetLogger("FirmwareUpdateToolSENSUS");
    internal ConfigList configList;
    internal CommunicationPortFunctions myPort;
    private readonly uint[] waitTimeArray = new uint[8]
    {
      200U,
      300U,
      500U,
      700U,
      1000U,
      1400U,
      1800U,
      2200U
    };
    public static byte[] CMD_READ_VOL_FORMAT = new byte[7]
    {
      (byte) 6,
      (byte) 1,
      (byte) 0,
      (byte) 0,
      (byte) 0,
      (byte) 61,
      (byte) 170
    };
    public static byte[] CMD_SET_FORMAT = new byte[7]
    {
      (byte) 6,
      (byte) 0,
      (byte) 8,
      (byte) 1,
      (byte) 1,
      (byte) 9,
      (byte) 101
    };
    public static byte[] CMD_GET_VERSION = new byte[7]
    {
      (byte) 85,
      (byte) 90,
      (byte) 165,
      (byte) 165,
      (byte) 90,
      (byte) 161,
      (byte) 117
    };
    public static byte[] CMD_GO = new byte[7]
    {
      (byte) 4,
      (byte) 90,
      (byte) 165,
      (byte) 165,
      (byte) 90,
      (byte) 194,
      (byte) 202
    };
    public static string CMD_GET_VERSION_STR = "555aa5a55aa175";
    public static string CMD_GO_STR = "045AA5A55AC2CA";
    public static string CMD_WRITE_MEMORY = "01#ADDRESS#000000#DATA##CRC16#";
    public static string CMD_READ_MEMORY = "02#ADDRESS##CRC16#";
    public static string CMD_READ_ADDRESS = "03#ADDRESS##CRC16#";
    public static byte ResponseACK = 229;
    public static byte ResponseNACK = 26;
    public static byte ResponseFORMAT = 6;
    public static int FW_ERR_NONE = 0;
    public static int FW_ERR_PARITY = 1;
    public static int FW_ERR_STOP = 2;
    public static int FW_ERR_CRC = 16;
    public static int FW_ERR_CMD = 32;
    public static int FW_ERR_ADR = 48;
    private string stringVersion;
    public byte[] Response;

    public SENSUSSTATE Status { get; private set; }

    public FirmwareVersion FwV { get; private set; }

    public string HV { get; private set; }

    public string UID { get; private set; }

    public SENSUSConnector()
      : this((CommunicationPortFunctions) null, string.Empty, (ConfigList) null)
    {
    }

    public SENSUSConnector(string strVersion)
      : this((CommunicationPortFunctions) null, strVersion, (ConfigList) null)
    {
    }

    public SENSUSConnector(ConfigList configList)
      : this((CommunicationPortFunctions) null, string.Empty, configList)
    {
    }

    public SENSUSConnector(CommunicationPortFunctions Port)
      : this(Port, string.Empty, (ConfigList) null)
    {
    }

    public SENSUSConnector(CommunicationPortFunctions Port, ConfigList configList)
      : this(Port, string.Empty, configList)
    {
    }

    public SENSUSConnector(
      CommunicationPortFunctions Port,
      string strVersion,
      ConfigList configList)
    {
      this.myPort = Port;
      this.stringVersion = strVersion;
      this.parseVersion();
      this.configList = configList;
    }

    public void SetConfigurationList(ConfigList configList) => this.configList = configList;

    public void SetPortFunctions(CommunicationPortFunctions Port) => this.myPort = Port;

    public void SetFirmwareVersion(string fwVersion)
    {
      this.stringVersion = fwVersion;
      this.parseVersion();
    }

    public bool isSensusConnectorReady() => this.myPort != null && this.configList != null;

    public bool isSensusConnectorOnline()
    {
      FirmwareVersion fwV;
      int num;
      if (this.FwV.Major > (byte) 0)
      {
        fwV = this.FwV;
        if (fwV.Minor >= (byte) 0)
        {
          num = 1;
          goto label_6;
        }
      }
      fwV = this.FwV;
      if (fwV.Major == (byte) 0)
      {
        fwV = this.FwV;
        num = fwV.Minor > (byte) 0 ? 1 : 0;
      }
      else
        num = 0;
label_6:
      return num != 0;
    }

    private void parseVersion()
    {
      if (string.IsNullOrEmpty(this.stringVersion))
        return;
      int startIndex1 = this.stringVersion.IndexOf("FV") + 2;
      int length1 = this.stringVersion.IndexOf(";", startIndex1) - startIndex1;
      string str = this.stringVersion.Substring(startIndex1, length1);
      if (!string.IsNullOrEmpty(str) && (str.ElementAt<char>(6) != '2' || str.ElementAt<char>(7) != '6'))
        str = str.Remove(6, 2) + "26";
      this.FwV = new FirmwareVersion(str);
      int startIndex2 = this.stringVersion.IndexOf("HV") + 2;
      int length2 = this.stringVersion.IndexOf(";", startIndex2) - startIndex2;
      this.HV = this.stringVersion.Substring(startIndex2, length2);
      int startIndex3 = this.stringVersion.IndexOf("UID") + 3;
      int length3 = this.stringVersion.Length - startIndex3;
      this.UID = this.stringVersion.Substring(startIndex3, length3);
    }

    public override string ToString()
    {
      return "" + "\rFW version: " + this.FwV.ToString() + "\rHV version: " + this.HV + "\rARM UID:    " + this.UID;
    }

    internal async Task InitMinoConnect(ProgressHandler progress, CancellationToken cancelToken)
    {
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus - Init MinoConnect...");
      progress.Report(10, " -> Init MinoConnect...");
      CommunicationByMinoConnect MiCon = this.myPort.GetCommunicationByMinoConnect();
      MiCon.WriteCommand("#com off\r\n");
      MiCon.WriteCommand("#comcl\r\n");
      MiCon.WriteCommand("#broff\r\n");
      MiCon.WriteCommand("#ver\r\n");
      MiCon.WriteCommand("#com rs485 9600 8e1\r\n");
      MiCon.WriteCommand("#3von\r\n");
      MiCon.WriteCommand("#apo 0\r\n");
      MiCon.WriteCommand("#out 1\r\n");
      MiCon.WriteCommand("#fs\r\n");
      await Task.Delay(1);
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus - Init MinoConnect - DONE.");
      progress.Report(100, " -> Init MinoConnect - DONE.");
      MiCon = (CommunicationByMinoConnect) null;
    }

    internal async Task WakeUpSensusModuleStartEnd(
      ProgressHandler progress,
      CancellationToken cancelToken,
      ushort delay = 500)
    {
      CommunicationByMinoConnect MiCon = this.myPort.GetCommunicationByMinoConnect();
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus - WakeUp Module");
      progress.Report(10, "Sensus - WakeUp Module");
      MiCon.WriteCommand("#485ton\r\n");
      MiCon.WriteCommand("#bron\r\n");
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus clock low");
      progress.Report(50, "Sensus clock low");
      await Task.Delay((int) delay);
      MiCon.WriteCommand("#485toff\r\n");
      MiCon.WriteCommand("#broff\r\n");
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus clock high");
      progress.Report(100, "Sensus clock high");
      MiCon = (CommunicationByMinoConnect) null;
    }

    internal async Task StartWakeUpSensusModule(
      ProgressHandler progress,
      CancellationToken cancelToken,
      ushort delay = 1)
    {
      CommunicationByMinoConnect MiCon = this.myPort.GetCommunicationByMinoConnect();
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus - WakeUp Module START");
      progress.Report(10, "Sensus - WakeUp Module START");
      MiCon.WriteCommand("#485ton\r\n");
      MiCon.WriteCommand("#bron\r\n");
      await Task.Delay((int) delay);
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus clock low");
      progress.Report(100, "Sensus clock low");
      MiCon = (CommunicationByMinoConnect) null;
    }

    internal async Task EndWakeUpSensusModule(
      ProgressHandler progress,
      CancellationToken cancelToken,
      ushort delay = 1)
    {
      CommunicationByMinoConnect MiCon = this.myPort.GetCommunicationByMinoConnect();
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus - WakeUp Module END");
      progress.Report(10, "Sensus - WakeUp Module END");
      MiCon.WriteCommand("#485toff\r\n");
      MiCon.WriteCommand("#broff\r\n");
      await Task.Delay((int) delay);
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus clock high");
      progress.Report(100, "Sensus clock high");
      MiCon = (CommunicationByMinoConnect) null;
    }

    public async Task<byte[]> ReadVolFormatSensusModule(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      ushort responseByteCount = 6;
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus - read volume format ...");
      await this.StartWakeUpSensusModule(progress, cancelToken, (ushort) 500);
      await this.EndWakeUpSensusModule(progress, cancelToken, (ushort) 1500);
      this.myPort.Write(SENSUSConnector.CMD_GET_VERSION);
      await Task.Delay(500);
      this.myPort.DiscardInBuffer();
      this.myPort.Write(SENSUSConnector.CMD_READ_VOL_FORMAT);
      byte[] response = await this.handleResponseFromSensus(progress, cancelToken, responseByteCount);
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus - read - DONE.");
      progress.Report(100, "read... DONE.");
      byte[] numArray = response;
      response = (byte[]) null;
      return numArray;
    }

    private async Task<byte[]> SetFormatToSensusConnector(
      ProgressHandler progress,
      CancellationToken cancelToken,
      byte[] command,
      ushort responseCount = 6,
      ushort delay = 200)
    {
      ushort responseByteCount = responseCount;
      progress.Report(10, "Set format to Sensus Connector...");
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus - set format ...");
      progress.Report(20, "WakeUp sensus module ...");
      await this.StartWakeUpSensusModule(progress, cancelToken, (ushort) 500);
      await this.EndWakeUpSensusModule(progress, cancelToken, (ushort) 1500);
      progress.Report(30, "WakeUp done...");
      this.myPort.Write(SENSUSConnector.CMD_GET_VERSION);
      progress.Report(40, "write command to SENSUSConnector ...");
      await Task.Delay((int) delay);
      this.myPort.Write(command);
      progress.Report(60, "received response ... check");
      byte[] response = await this.handleResponseFromSensus(progress, cancelToken, responseByteCount);
      SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus - set format - DONE.");
      progress.Report(100, "check ... DONE.");
      byte[] sensusConnector = response;
      response = (byte[]) null;
      return sensusConnector;
    }

    public async Task<byte[]> SetFormat(
      ProgressHandler progress,
      CancellationToken cancelToken,
      byte usFormat,
      byte usTrunc)
    {
      progress.Report("Sensus - set format ");
      Logger sensusConnectorLogger = SENSUSConnector.SENSUSConnector_Logger;
      SENSUSVOLFORMAT sensusvolformat = (SENSUSVOLFORMAT) usFormat;
      string message1 = "Sensus - set " + sensusvolformat.ToString() + " trunc " + ((SENSUSVOLFORMATTRUNCATE) usTrunc).ToString();
      sensusConnectorLogger.Trace(message1);
      SENSUSConnector.CMD_SET_FORMAT[2] = usFormat;
      SENSUSConnector.CMD_SET_FORMAT[3] = usTrunc;
      ushort crc16 = Util.CalculatesCRC16(SENSUSConnector.CMD_SET_FORMAT, 0, 5);
      SENSUSConnector.CMD_SET_FORMAT[5] = BitConverter.GetBytes(crc16)[0];
      SENSUSConnector.CMD_SET_FORMAT[6] = BitConverter.GetBytes(crc16)[1];
      byte[] response = await this.SetFormatToSensusConnector(progress, cancelToken, SENSUSConnector.CMD_SET_FORMAT);
      if (response != null)
      {
        if ((int) response[1] == (int) SENSUSConnector.CMD_SET_FORMAT[2] && (int) response[2] == (int) SENSUSConnector.CMD_SET_FORMAT[3])
        {
          SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus - set Format - DONE.");
          ProgressHandler progressHandler = progress;
          string[] strArray = new string[5]
          {
            "Sensus - set ",
            null,
            null,
            null,
            null
          };
          sensusvolformat = (SENSUSVOLFORMAT) usFormat;
          strArray[1] = sensusvolformat.ToString();
          strArray[2] = " trunc ";
          strArray[3] = ((SENSUSVOLFORMATTRUNCATE) usTrunc).ToString();
          strArray[4] = " - DONE.";
          string message2 = string.Concat(strArray);
          progressHandler.Report(100, message2);
        }
        else
        {
          SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus - set Format - ERROR. (" + Util.ByteArrayToHexString(response) + ")");
          progress.Report(0, "Sensus - set Format - ERROR.");
        }
      }
      else
      {
        SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus - set Format - ERROR. --- no response");
        progress.Report(0, "Sensus - set Format - ERROR. --- no response ");
      }
      byte[] numArray = response;
      response = (byte[]) null;
      return numArray;
    }

    private async Task<byte[]> handleResponseFromSensus(
      ProgressHandler progress,
      CancellationToken cancelToken,
      ushort responseBytes = 53)
    {
      int maxRepeats = this.configList.MaxRequestRepeat;
      byte[] response = (byte[]) null;
      bool byteCntChanged = false;
      SENSUSConnector.SENSUSConnector_Logger.Trace("handle response from SENSUS connector asynchron.");
      for (int w = 0; w < maxRepeats; ++w)
      {
        progress.Report(65 + w * 5, "handling response ...");
        if (!cancelToken.IsCancellationRequested)
        {
          try
          {
            byte[] responseH = new byte[1];
            responseH = this.myPort.ReadHeader(1);
            if (this.myPort.BytesToRead > 0 && this.myPort.BytesToRead < (int) responseBytes)
            {
              responseBytes = (ushort) (this.myPort.BytesToRead - 1);
              byteCntChanged = true;
            }
            byte[] responseE = new byte[(int) responseBytes];
            if (responseBytes > (ushort) 0)
              responseE = this.myPort.ReadEnd((int) responseBytes);
            response = new byte[(int) responseBytes + 1];
            Buffer.BlockCopy((Array) responseH, 0, (Array) response, 0, 1);
            Buffer.BlockCopy((Array) responseE, 0, (Array) response, 1, responseE.Length);
            responseH = (byte[]) null;
            responseE = (byte[]) null;
          }
          catch (TimeoutException ex)
          {
            progress.Report(71, "timeout!!! ");
            if (response != null)
              SENSUSConnector.SENSUSConnector_Logger.Trace("timeout but received: " + Util.ByteArrayToHexString(response));
            else
              SENSUSConnector.SENSUSConnector_Logger.Trace("timeout without data");
            response = (byte[]) null;
          }
          if (response == null)
          {
            progress.Report(71, "no response");
            SENSUSConnector.SENSUSConnector_Logger.Trace("no response");
            await Task.Delay(this.configList.WaitBeforeRepeatTime);
          }
          else
            break;
        }
        else
          break;
      }
      if (response != null)
      {
        if (response.Length != (int) responseBytes && !byteCntChanged)
        {
          string msg = "Internal error. ReadHeader management problem";
          progress.Report(msg);
          throw new Exception(msg);
        }
        string strResponse = Util.ByteArrayToHexString(response);
        progress.Report(80, "received: " + strResponse);
        SENSUSConnector.SENSUSConnector_Logger.Trace("received: " + strResponse);
        return response;
      }
      string msg1 = "no response, could not connect to SENSUSConnector!!!";
      progress.Report(90, msg1);
      SENSUSConnector.SENSUSConnector_Logger.Trace(msg1);
      msg1 = (string) null;
      return response;
    }

    public async Task<byte[]> readDataFromSensusAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      int lenHeader,
      int lenData,
      string command,
      bool getDataOnly = false)
    {
      byte[] cmd = Util.HexStringToByteArray(command);
      byte[] numArray = await this.readDataFromSensusAsync(progress, cancelToken, lenHeader, lenData, cmd, getDataOnly);
      cmd = (byte[]) null;
      return numArray;
    }

    public async Task<byte[]> readDataFromSensusAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      int lenHeader,
      int lenData,
      byte[] cmd,
      bool getDataOnly = false)
    {
      if (!this.isSensusConnectorReady())
        throw new Exception("SensusConnector not ready, check Port and ConfigurationList!");
      int lenCRC = 2;
      int maxRepeats = this.configList.MaxRequestRepeat;
      byte[] response = (byte[]) null;
      byte[] header = new byte[lenHeader];
      byte[] CRC = new byte[lenCRC];
      SENSUSConnector.SENSUSConnector_Logger.Trace("read SENSUS connector asynchron.");
      this.myPort.DiscardInBuffer();
      for (int w = 0; w < maxRepeats && !cancelToken.IsCancellationRequested; ++w)
      {
        SENSUSConnector.SENSUSConnector_Logger.Trace("read SENSUS version (" + w.ToString() + 1.ToString() + ") ");
        if (!this.myPort.IsOpen)
        {
          this.myPort.Open();
          SENSUSConnector.SENSUSConnector_Logger.Trace("open port OK.");
        }
        SENSUSConnector.SENSUSConnector_Logger.Trace("sending: " + Util.ByteArrayToHexString(cmd));
        this.myPort.Write(cmd);
        await Task.Delay(this.configList.RecTime_BeforFirstByte);
        for (int r = 0; r < 3; ++r)
        {
          try
          {
            header = this.myPort.ReadHeader(lenHeader);
            SENSUSConnector.SENSUSConnector_Logger.Trace("received header: " + Util.ByteArrayToHexString(header));
            if (header != null)
              break;
          }
          catch (Exception ex)
          {
            SENSUSConnector.SENSUSConnector_Logger.Trace("ERROR: received header: " + Util.ByteArrayToHexString(header));
            SENSUSConnector.SENSUSConnector_Logger.Trace("ERROR: " + ex.Message);
            header = (byte[]) null;
          }
        }
        if (header != null)
        {
          byte[] data = this.myPort.ReadEnd(lenData);
          Buffer.BlockCopy((Array) data, data.Length - 2, (Array) CRC, 0, 2);
          if (getDataOnly)
          {
            response = new byte[lenData - lenCRC];
            Buffer.BlockCopy((Array) data, 0, (Array) response, 0, response.Length);
          }
          else
          {
            response = new byte[lenData + lenHeader];
            Buffer.BlockCopy((Array) header, 0, (Array) response, 0, header.Length);
            Buffer.BlockCopy((Array) data, 0, (Array) response, header.Length, data.Length);
          }
          SENSUSConnector.SENSUSConnector_Logger.Trace("received data: " + Util.ByteArrayToHexString(response));
          if (response == null)
            data = (byte[]) null;
          else
            break;
        }
        SENSUSConnector.SENSUSConnector_Logger.Trace("repeat reading data from SENSUS");
        await Task.Delay(this.configList.WaitBeforeRepeatTime);
      }
      byte[] numArray = response;
      response = (byte[]) null;
      header = (byte[]) null;
      CRC = (byte[]) null;
      return numArray;
    }

    public async Task<bool> keepAliveSensusAsync()
    {
      if (!this.isSensusConnectorReady())
        throw new Exception("SensusConnector not ready, check Port and ConfigurationList!");
      SENSUSConnector.SENSUSConnector_Logger.Trace("keep alive SENSUS connector asynchron.");
      if (this.Status != SENSUSSTATE.KEEP_ALIVE)
        return false;
      SENSUSConnector.SENSUSConnector_Logger.Trace("sending " + SENSUSConnector.CMD_GET_VERSION?.ToString());
      this.myPort.Write(SENSUSConnector.CMD_GET_VERSION);
      await Task.Delay(1000);
      byte[] response = this.myPort.ReadExisting();
      SENSUSConnector.SENSUSConnector_Logger.Trace("received: " + Util.ByteArrayToHexString(response));
      return response != null;
    }

    public async Task<bool> doSensusConnectionTestAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      int iDelay)
    {
      if (!this.isSensusConnectorReady())
        throw new Exception("SensusConnector not ready, check Port and ConfigurationList!");
      string msg = "read version of SENSUS connector asynchron.";
      SENSUSConnector.SENSUSConnector_Logger.Trace(msg);
      msg = "sending " + SENSUSConnector.CMD_GET_VERSION?.ToString();
      SENSUSConnector.SENSUSConnector_Logger.Trace(msg);
      this.myPort.Write(SENSUSConnector.CMD_GET_VERSION);
      msg = "wait for receiving first byte: " + this.configList.RecTime_BeforFirstByte.ToString();
      SENSUSConnector.SENSUSConnector_Logger.Trace(msg);
      byte[] response = (byte[]) null;
      try
      {
        response = this.myPort.ReadHeader(47);
      }
      catch (TimeoutException ex)
      {
        msg = msg + "--> ERROR: " + ex.Message;
      }
      msg = msg + "received: " + Util.ByteArrayToHexString(response);
      SENSUSConnector.SENSUSConnector_Logger.Trace(msg);
      if (response != null && response.Length == 47)
      {
        byte[] responseData = new byte[response.Length - 2];
        Buffer.BlockCopy((Array) response, 0, (Array) responseData, 0, responseData.Length);
        string strResponse = Util.ByteArrayToString(responseData);
        this.SetFirmwareVersion(strResponse);
        SENSUSConnector.SENSUSConnector_Logger.Trace("\rresponse: " + this.ToString());
        responseData = (byte[]) null;
        strResponse = (string) null;
      }
      else if (response != null && response.Length != 47)
        SENSUSConnector.SENSUSConnector_Logger.Trace("\r!--> wrong response, pleas check connection! ");
      else if (response == null)
        SENSUSConnector.SENSUSConnector_Logger.Trace("\r!--> if this happens again, please try to re-plug Sensus to MinoConnect! ");
      await Task.Delay(iDelay);
      bool flag = response != null;
      msg = (string) null;
      response = (byte[]) null;
      return flag;
    }

    public async Task<string> readSensusVersionAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      bool isNewConnection = true)
    {
      SENSUSConnector sensusTemp = await this.readSensusConnectorAsync(progress, cancelToken, isNewConnection);
      string str = sensusTemp.ToString();
      sensusTemp = (SENSUSConnector) null;
      return str;
    }

    public async Task<SENSUSConnector> readSensusConnectorAsync(
      ProgressHandler progress,
      CancellationToken cancelToken,
      bool isNewConnection = true)
    {
      if (!this.isSensusConnectorReady())
        throw new Exception("SensusConnector not ready, check Port and ConfigurationList!");
      int responseBytes = 47;
      if (this.myPort == null)
        throw new Exception("\rPort is not available!");
      SENSUSConnector.SENSUSConnector_Logger.Trace("read SENSUS connector asynchron.");
      byte[] cmd = (byte[]) null;
      byte[] response = (byte[]) null;
      int maxW = this.configList.MaxRequestRepeat;
      for (int w = 0; w < maxW; ++w)
      {
        SENSUSConnector.SENSUSConnector_Logger.Trace("read SENSUS version (" + w.ToString() + 1.ToString() + ") ");
        this.GuaranteePortOpen();
        CommunicationByMinoConnect MiCon = this.myPort.GetCommunicationByMinoConnect();
        MiCon.WriteCommand("#485ton\r\n");
        MiCon.WriteCommand("#bron\r\n");
        await Task.Delay(1000);
        SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus clock low");
        MiCon.WriteCommand("#485toff\r\n");
        MiCon.WriteCommand("#broff\r\n");
        await Task.Delay(1000);
        SENSUSConnector.SENSUSConnector_Logger.Trace("Sensus clock high");
        for (int i = 0; i < ((IEnumerable<uint>) this.waitTimeArray).Count<uint>(); ++i)
        {
          this.myPort.DiscardInBuffer();
          int waitTime = (int) this.waitTimeArray[i];
          SENSUSConnector.SENSUSConnector_Logger.Trace("sending: " + Util.ByteArrayToHexString(cmd));
          this.myPort.Write(SENSUSConnector.CMD_GET_VERSION);
          SENSUSConnector.SENSUSConnector_Logger.Trace("Delay(" + i.ToString() + "): " + waitTime.ToString());
          await Task.Delay(waitTime);
          try
          {
            response = this.myPort.ReadHeader(responseBytes);
          }
          catch (TimeoutException ex)
          {
            if (response != null)
              SENSUSConnector.SENSUSConnector_Logger.Trace("timeout but received: " + Util.ByteArrayToHexString(response));
            else
              SENSUSConnector.SENSUSConnector_Logger.Trace("timeout without data");
            response = (byte[]) null;
          }
          if (response == null)
          {
            SENSUSConnector.SENSUSConnector_Logger.Trace("no response");
          }
          else
          {
            SENSUSConnector.SENSUSConnector_Logger.Trace(" ... response after " + waitTime.ToString() + " ms.");
            break;
          }
        }
        if (response == null)
          MiCon = (CommunicationByMinoConnect) null;
        else
          break;
      }
      if (response != null)
      {
        if (response.Length != responseBytes)
          throw new Exception("Internal error. ReadHeader management problem");
        byte[] responseData = new byte[responseBytes - 2];
        byte[] responseDataCRC = new byte[2];
        Buffer.BlockCopy((Array) response, 0, (Array) responseData, 0, responseBytes - 2);
        Buffer.BlockCopy((Array) response, responseBytes - 2, (Array) responseDataCRC, 0, 2);
        string strResponse = Util.ByteArrayToString(responseData);
        SENSUSConnector.SENSUSConnector_Logger.Trace("received: " + strResponse);
        if (!string.IsNullOrEmpty(strResponse))
        {
          if (isNewConnection)
          {
            SENSUSConnector.SENSUSConnector_Logger.Trace("create LOCAL SENSUSConnector object!");
            SENSUSConnector localSensusConnector = new SENSUSConnector(strResponse);
            return localSensusConnector;
          }
          this.SetFirmwareVersion(strResponse);
          return this;
        }
        SENSUSConnector.SENSUSConnector_Logger.Trace("no response, could not connect to SENSUSConnector!!!");
        throw new Exception("\rERROR, could not connect to SENSUS connector ...");
      }
      string message = "\r\rNo response from device, please unplug and reconnect MinoConnect!!!";
      message += "\r +---------------------------------------------------------------+";
      message += "\r | After reconnect there is a time gap of 30 seconds to update!  |";
      message += "\r +---------------------------------------------------------------+";
      throw new Exception(message);
    }

    public async Task initSensusFirmwareAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (!this.isSensusConnectorReady())
        throw new Exception("SensusConnector not ready, check Port and ConfigurationList!");
      if (this.myPort == null || this.FwV.Version <= 0U)
        throw new Exception("\rNo connection to sensus device, please reconnect!!!");
      string msg = "initialize new firmware ...";
      progress.Report(msg);
      SENSUSConnector.SENSUSConnector_Logger.Trace(msg);
      this.Status = SENSUSSTATE.INIT;
      SENSUSConnector.SENSUSConnector_Logger.Trace("sending command: " + SENSUSConnector.CMD_GO?.ToString());
      this.myPort.Write(SENSUSConnector.CMD_GO);
      await Task.Delay(1200);
      SENSUSConnector.SENSUSConnector_Logger.Trace("send command OK.");
      SENSUSConnector.SENSUSConnector_Logger.Trace("wait 2 seconds for init is done..");
      await Task.Delay(1200);
      progress.Report("New firmware initialized! ");
      msg = (string) null;
    }

    public async Task<byte[]> readSensusAdressAsync(
      uint address,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (!this.isSensusConnectorReady())
        throw new Exception("SensusConnector not ready, check Port and ConfigurationList!");
      if (this.myPort == null || this.FwV.Version <= 0U)
        throw new Exception("\rNo connection to sensus device, please reconnect!!!");
      if (address >= 0U && address < 2576980377U)
      {
        this.Status = SENSUSSTATE.READING;
        List<byte> cmdBuilder = new List<byte>()
        {
          (byte) 3
        };
        cmdBuilder.AddRange((IEnumerable<byte>) BitConverter.GetBytes(address));
        ushort crc16 = Util.CalculatesCRC16(cmdBuilder.ToArray<byte>());
        cmdBuilder.AddRange((IEnumerable<byte>) BitConverter.GetBytes(crc16));
        byte[] cmdComplete = cmdBuilder.ToArray<byte>();
        int maxW = this.configList.MaxRequestRepeat;
        for (int i = 0; i < maxW; ++i)
        {
          SENSUSConnector.SENSUSConnector_Logger.Trace("sending command: " + cmdComplete?.ToString());
          this.GuaranteePortOpen();
          this.myPort.Write(cmdComplete);
          byte[] response = new byte[522];
          try
          {
            this.myPort.ReadHeader(response.Length);
            SENSUSConnector.SENSUSConnector_Logger.Trace("response: " + Util.ByteArrayToHexString(response));
          }
          catch (TimeoutException ex)
          {
            if (response != null)
              SENSUSConnector.SENSUSConnector_Logger.Trace("timeout but received: " + Util.ByteArrayToHexString(response));
            else
              SENSUSConnector.SENSUSConnector_Logger.Trace("timeout without data");
            response = (byte[]) null;
          }
          if (response != null)
          {
            byte[] data = new byte[512];
            Buffer.BlockCopy((Array) data, 8, (Array) response, 0, data.Length);
            SENSUSConnector.SENSUSConnector_Logger.Trace("response data: " + Util.ByteArrayToHexString(response));
            return data;
          }
          await Task.Delay(this.configList.WaitBeforeRepeatTime);
          response = (byte[]) null;
        }
        throw new Exception("\rNo data received from device on address: " + address.ToString("x8"));
      }
      throw new Exception("\rAdress out of range!!!");
    }

    public async Task<byte[]> readSensusMemoryAsync(
      uint address,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (!this.isSensusConnectorReady())
        throw new Exception("SensusConnector not ready, check Port and ConfigurationList!");
      await Task.Delay(1);
      if (this.myPort == null || this.FwV.Version <= 0U)
        throw new Exception("\rNo connection to sensus device, please reconnect!!!");
      if (address >= 0U && address < 2576980377U)
      {
        List<byte> cmdBuilder = new List<byte>()
        {
          (byte) 2
        };
        cmdBuilder.AddRange((IEnumerable<byte>) BitConverter.GetBytes(address));
        ushort crc16 = Util.CalculatesCRC16(cmdBuilder.ToArray<byte>());
        cmdBuilder.AddRange((IEnumerable<byte>) BitConverter.GetBytes(crc16));
        byte[] cmdComplete = cmdBuilder.ToArray<byte>();
        int maxW = this.configList.MaxRequestRepeat;
        for (int i = 0; i < maxW; ++i)
        {
          SENSUSConnector.SENSUSConnector_Logger.Trace("sending command: " + cmdComplete?.ToString());
          this.GuaranteePortOpen();
          this.myPort.Write(cmdComplete);
          byte[] response = new byte[522];
          try
          {
            response = this.myPort.ReadHeader(response.Length);
            SENSUSConnector.SENSUSConnector_Logger.Trace("response header: " + Util.ByteArrayToHexString(response));
          }
          catch (TimeoutException ex)
          {
            if (response != null)
              SENSUSConnector.SENSUSConnector_Logger.Trace("timeout but received: " + Util.ByteArrayToHexString(response));
            else
              SENSUSConnector.SENSUSConnector_Logger.Trace("timeout without data");
            response = (byte[]) null;
          }
          if (response != null)
          {
            byte[] data = new byte[512];
            SENSUSConnector.SENSUSConnector_Logger.Trace("response: " + Util.ByteArrayToHexString(response));
            Buffer.BlockCopy((Array) response, 8, (Array) data, 0, data.Length);
            return data;
          }
          response = (byte[]) null;
        }
        throw new Exception("\rNo data received from device on address: " + address.ToString("x8"));
      }
      throw new Exception("\rAdress out of range!!!");
    }

    public async Task<byte[]> writeSensusMemoryAsync(
      uint address,
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      if (!this.isSensusConnectorReady())
        throw new Exception("SensusConnector not ready, check Port and ConfigurationList!");
      bool SlowWrite = false;
      if (this.myPort == null || this.FwV.Version <= 0U)
        throw new Exception("\rNo connection to sensus device, please reconnect!!!");
      if (address < 0U || address >= 2576980377U)
        throw new Exception("\rAdress out of range!!!");
      await Task.Delay(1);
      progress.Report("Writing at address: " + address.ToString("x8"));
      this.myPort.DiscardInBuffer();
      this.Status = SENSUSSTATE.WRITING;
      int maxW = this.configList.MaxRequestRepeat;
      byte[] response = (byte[]) null;
      bool anyResponse = false;
      List<byte> cmdBuilder = new List<byte>() { (byte) 1 };
      cmdBuilder.AddRange((IEnumerable<byte>) BitConverter.GetBytes(address));
      cmdBuilder.AddRange((IEnumerable<byte>) new byte[3]);
      cmdBuilder.AddRange((IEnumerable<byte>) data);
      ushort crc16 = Util.CalculatesCRC16(cmdBuilder.ToArray<byte>());
      cmdBuilder.AddRange((IEnumerable<byte>) BitConverter.GetBytes(crc16));
      byte[] cmdComplete = cmdBuilder.ToArray<byte>();
      for (int w = 0; w < maxW; ++w)
      {
        if (w == maxW - 1 & anyResponse && !SlowWrite)
        {
          SlowWrite = true;
          SENSUSConnector.SENSUSConnector_Logger.Warn("Switched to SlowWrite. Wait 500ms and restart repeats.");
          await Task.Delay(500);
          w = 0;
        }
        if (w > 0)
          SENSUSConnector.SENSUSConnector_Logger.Warn("Repeat: " + w.ToString());
        if (!SlowWrite)
        {
          this.myPort.Write(cmdComplete);
        }
        else
        {
          byte[] singleByte = new byte[1];
          int[] sendTimes = new int[cmdComplete.Length];
          DateTime NextTime = DateTime.MinValue;
          for (int i = 0; i < cmdComplete.Length; ++i)
          {
            DateTime TimeNow;
            do
            {
              TimeNow = DateTime.Now;
            }
            while (TimeNow < NextTime);
            NextTime = TimeNow.AddMilliseconds(5.0);
            sendTimes[i] = TimeNow.Millisecond;
            singleByte[0] = cmdComplete[i];
            this.myPort.Write(singleByte);
          }
          singleByte = (byte[]) null;
          sendTimes = (int[]) null;
        }
        response = (byte[]) null;
        try
        {
          response = this.myPort.ReadHeader(3);
          if (response == null || response.Length != 3)
          {
            string err = "Internal error. Illegal answer length";
            SENSUSConnector.SENSUSConnector_Logger.Error(err);
            throw new Exception(err);
          }
          anyResponse = true;
          if ((int) response[0] != (int) SENSUSConnector.ResponseACK)
          {
            await Task.Delay(20);
            byte[] additionalBytes = this.myPort.ReadExisting();
            if (additionalBytes != null && additionalBytes.Length != 0)
            {
              Array.Resize<byte>(ref response, response.Length + additionalBytes.Length);
              Buffer.BlockCopy((Array) additionalBytes, 0, (Array) response, 3, additionalBytes.Length);
            }
            additionalBytes = (byte[]) null;
          }
          SENSUSConnector.SENSUSConnector_Logger.Trace("Response: " + Util.ByteArrayToHexString(response));
          ushort CRCRet = BitConverter.ToUInt16(response, response.Length - 2);
          ushort CRCCheck = Util.CalculatesCRC16(response, 0, response.Length - 2);
          if ((int) CRCRet != (int) CRCCheck)
            SENSUSConnector.SENSUSConnector_Logger.Warn(" --> CRC is wrong !!!");
          else if ((int) response[0] != (int) SENSUSConnector.ResponseACK)
          {
            if ((int) response[0] == (int) SENSUSConnector.ResponseNACK)
            {
              byte lowNibble = (byte) ((uint) response[1] & 15U);
              byte highNibble = (byte) ((uint) response[1] & 240U);
              if (((uint) lowNibble & 1U) > 0U)
                SENSUSConnector.SENSUSConnector_Logger.Warn("Response: NACK received. Parity bit error");
              if (((uint) lowNibble & 2U) > 0U)
                SENSUSConnector.SENSUSConnector_Logger.Warn("Response: NACK received. Stop bit error");
              switch (highNibble)
              {
                case 16:
                  SENSUSConnector.SENSUSConnector_Logger.Warn("Response: NACK received. CRC error");
                  break;
                case 48:
                  SENSUSConnector.SENSUSConnector_Logger.Warn("Response: NACK received. Address error");
                  break;
                default:
                  if (((int) lowNibble & 3) == 0)
                  {
                    SENSUSConnector.SENSUSConnector_Logger.Warn("Response: NACK received");
                    break;
                  }
                  break;
              }
              if (response.Length == 6)
              {
                ushort errorIndex = BitConverter.ToUInt16(response, 2);
                SENSUSConnector.SENSUSConnector_Logger.Warn("Receive error index: " + errorIndex.ToString());
              }
            }
            else
              SENSUSConnector.SENSUSConnector_Logger.Warn("Unexpected response");
          }
          else
            goto label_48;
        }
        catch (TimeoutException ex)
        {
          if (response != null)
          {
            anyResponse = true;
            SENSUSConnector.SENSUSConnector_Logger.Warn("timeout but received: " + Util.ByteArrayToHexString(response));
          }
          else
            SENSUSConnector.SENSUSConnector_Logger.Warn("timeout without data");
          response = (byte[]) null;
        }
        await Task.Delay(this.configList.WaitBeforeRepeatTime);
      }
      SENSUSConnector.SENSUSConnector_Logger.Error("Write memory error");
label_48:
      return response;
    }

    public SortedDictionary<uint, byte[]> prepareDataForSensusWrite(
      SortedDictionary<uint, byte[]> firmware,
      int cmdSize = 512)
    {
      SortedDictionary<uint, byte[]> sortedDictionary = new SortedDictionary<uint, byte[]>();
      SENSUSConnector.SENSUSConnector_Logger.Trace("prepare data for size: " + cmdSize.ToString());
      int length1 = firmware.Values.First<byte[]>().Length;
      uint num = firmware.Keys.Last<uint>();
      if (cmdSize % length1 != 0)
        throw new Exception("\rPrepareData: not valid command size given!");
      uint key1 = 0;
      byte[] dst = new byte[cmdSize];
      for (int index = 0; index < dst.Length; ++index)
        dst[index] = (byte) 0;
      foreach (uint key2 in firmware.Keys)
      {
        SENSUSConnector.SENSUSConnector_Logger.Trace("prepare of address: " + key2.ToString());
        if (key1 == 0U)
          key1 = key2;
        byte[] src = firmware[key2];
        int dstOffset1 = (int) key2 - (int) key1;
        int length2 = src.Length;
        if (dstOffset1 < cmdSize && dstOffset1 + length2 <= cmdSize || (int) key2 == (int) num)
          Buffer.BlockCopy((Array) src, 0, (Array) dst, dstOffset1, length2);
        else if (dstOffset1 < cmdSize && dstOffset1 + length2 > cmdSize)
        {
          int count1 = (int) ((long) (dstOffset1 + length2) - ((long) key2 + (long) cmdSize));
          int count2 = length2 - count1;
          Buffer.BlockCopy((Array) src, 0, (Array) dst, dstOffset1, count2);
          sortedDictionary.Add(key1, dst);
          key1 = (uint) ((ulong) key2 + (ulong) cmdSize + 1UL);
          dst = new byte[cmdSize];
          for (int index = 0; index < dst.Length; ++index)
            dst[index] = (byte) 0;
          int dstOffset2 = 0;
          Buffer.BlockCopy((Array) src, 0, (Array) dst, dstOffset2, count1);
        }
        else if (dstOffset1 >= cmdSize && length2 > 0)
        {
          sortedDictionary.Add(key1, dst);
          key1 = key2;
          dst = new byte[cmdSize];
          for (int index = 0; index < dst.Length; ++index)
            dst[index] = (byte) 0;
          int dstOffset3 = 0;
          Buffer.BlockCopy((Array) src, 0, (Array) dst, dstOffset3, length2);
        }
      }
      return sortedDictionary;
    }

    internal void GuaranteePortOpen()
    {
      if (!this.isSensusConnectorReady())
        throw new Exception("SensusConnector not ready, check Port and ConfigurationList!");
      if (this.myPort.IsOpen)
        return;
      SENSUSConnector.SENSUSConnector_Logger.Trace("open port (" + this.myPort.PortType.ToString() + ")");
      this.myPort.Open();
      SENSUSConnector.SENSUSConnector_Logger.Trace("open port OK.");
    }

    private void myPort_OnResponse(object sender, byte[] e)
    {
      Type type = sender.GetType();
      SENSUSConnector.SENSUSConnector_Logger.Trace("On_Response called.");
      SENSUSConnector.SENSUSConnector_Logger.Trace("On_Response - " + e.ToString());
      SENSUSConnector.SENSUSConnector_Logger.Trace("On_Response - sender: " + type.FullName);
    }
  }
}


--- SENSUSReader.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SENSUSReader
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using NLog;
using System;
using System.Collections.Generic;
using System.IO.Ports;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;
using ZENNER.CommonLibrary.Entities;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class SENSUSReader
  {
    internal static Logger SensusReader_Logger = LogManager.GetLogger("Sensus_SensusReader");
    internal string[] strBuffer;
    internal int strBufferPos;
    internal static readonly string SENSUS_CMD_VALUES = "sensus values\r\n";
    internal static readonly string SENSUS_CMD_SERIALNO = "version ?\r\n";
    internal static readonly string SENSUS_CMD_PROG = "sensus prog\r\n";
    internal static readonly int bufferSize = 10;
    internal string SerialPortID_STD = "ZR_SENSUSREADER_V4_DEV1";
    internal string SerialPortID_AtLEAST = "ZR_SENSUSREADER";
    internal string SerialPortID = "ZR_SENSUSREADER_V4_DEV1";
    internal string SerialPortIDFunc = "ZR_SENSUSREADER_V4_DEV2";
    internal bool newDataAvail;
    internal bool isFunctionPort = false;
    internal int localTimeOut = 3600;
    internal static readonly string SENSUS_SERIALNUMBER_FOR_FIRMWARE_UPDATE = "FDEV5A78787801";
    internal static volatile bool checkLocked = false;

    public SerialPort localPort { get; private set; }

    public string MyPortName { get; private set; }

    public string FWversion { get; private set; }

    internal FirmwareVersion zFWVersion { get; private set; }

    public byte[] actualByteBuffer { get; private set; }

    public SENSUSReader(string serialPortName = null, bool isFunctionPort = false)
    {
      this.strBuffer = new string[SENSUSReader.bufferSize];
      this.strBufferPos = -1;
      this.isFunctionPort = isFunctionPort;
      this.FWversion = "0";
      this.newDataAvail = false;
      this.SerialPortID = serialPortName;
      this.doInitialize(this.SerialPortID);
    }

    internal bool doInitialize(string serialPortName = null)
    {
      try
      {
        SENSUSReader.SensusReader_Logger.Debug(nameof (doInitialize));
        if (this.localPort != null)
        {
          this.Close();
          this.localPort = (SerialPort) null;
          Task.Delay(this.localTimeOut);
        }
        this.SerialPortID = serialPortName != null ? serialPortName : this.SerialPortID_STD;
        if (this.isFunctionPort)
          this.SerialPortID = serialPortName != null ? serialPortName : this.SerialPortIDFunc;
        this.MyPortName = this.GetComPortFromIdentification(this.SerialPortID);
        if (string.IsNullOrEmpty(this.MyPortName) && !string.IsNullOrEmpty(serialPortName))
          this.MyPortName = serialPortName;
        else if (string.IsNullOrEmpty(this.MyPortName) && string.IsNullOrEmpty(serialPortName))
          this.MyPortName = this.GetComPortFromIdentification(this.SerialPortID_AtLEAST);
        this.localPort = new SerialPort(this.MyPortName);
        this.localPort.Open();
        this.localPort.RtsEnable = true;
        this.localPort.DiscardInBuffer();
        this.localPort.DiscardOutBuffer();
        this.localPort.DataReceived -= new SerialDataReceivedEventHandler(this.MyPort_DataReceived);
        this.localPort.DataReceived += new SerialDataReceivedEventHandler(this.MyPort_DataReceived);
        this.localPort.ErrorReceived -= new SerialErrorReceivedEventHandler(this.LocalPort_ErrorReceived);
        this.localPort.ErrorReceived += new SerialErrorReceivedEventHandler(this.LocalPort_ErrorReceived);
        this.localPort.ReadTimeout = this.localTimeOut;
        this.localPort.WriteTimeout = 777;
        if (this.localPort != null)
          this.localPort.Close();
        return true;
      }
      catch (Exception ex)
      {
        switch (ex)
        {
          case UnauthorizedAccessException _:
            throw new Exception("\nPort: " + this.MyPortName + " is actually used by another process!!!");
          case ArgumentException _:
            throw new Exception("\nPort: " + this.MyPortName + " could not be found on this computer!!!");
          case NullReferenceException _:
            throw new Exception("\nThe equipment value of SerialPortID could not be found, please check.");
          default:
            if (ex.Message.Contains("NULL"))
              throw ex;
            if (ex.Message.Length > 0)
              throw ex;
            return false;
        }
      }
    }

    private string GetComPortFromIdentification(string identification)
    {
      string empty = string.Empty;
      List<ValueItem> availableComPorts = Constants.GetAvailableComPorts();
      if (string.IsNullOrEmpty(identification))
        throw new Exception("Identification string of SerialPort is NULL !!!");
      try
      {
        foreach (ValueItem valueItem in availableComPorts)
        {
          if (valueItem.Info.Contains(identification))
            return valueItem.Value;
        }
        return empty;
      }
      catch
      {
        return empty;
      }
    }

    public bool Close()
    {
      SENSUSReader.SensusReader_Logger.Debug("Close Port");
      if (this.localPort == null)
        return false;
      this.localPort.Close();
      return true;
    }

    private async void LocalPort_ErrorReceived(object sender, SerialErrorReceivedEventArgs e)
    {
      SENSUSReader.SensusReader_Logger.Debug("Port_ErrorReceived");
      SENSUSReader.SensusReader_Logger.Debug("Data: " + e.EventType.ToString());
      string str = await this.checkDataReceived();
      throw new Exception(" receiving data error, please check connection!");
    }

    public async void MyPort_DataReceived(object sender, SerialDataReceivedEventArgs e)
    {
      SENSUSReader.SensusReader_Logger.Debug("Port_DataReceived");
      if (e.EventType == SerialData.Chars)
      {
        SENSUSReader.SensusReader_Logger.Debug("Data: " + e.EventType.ToString());
        string str = await this.checkDataReceived();
      }
      else
      {
        if (e.EventType != SerialData.Eof)
          return;
        SENSUSReader.SensusReader_Logger.Debug("Data: EOF!");
      }
    }

    public async Task<string> checkDataReceived()
    {
      if (!SENSUSReader.checkLocked)
      {
        SENSUSReader.checkLocked = true;
        try
        {
          string val = string.Empty;
          this.newDataAvail = false;
          await Task.Delay(10);
          if (this.localPort.BytesToRead > 0)
          {
            byte[] buffer = new byte[this.localPort.BytesToRead];
            this.localPort.Read(buffer, 0, buffer.Length);
            if (buffer != null)
            {
              val = Util.ByteArrayToString(buffer);
              SENSUSReader.SensusReader_Logger.Debug(" -> Data: " + val);
              if ((long) this.strBufferPos == (long) (uint) (this.strBuffer.Length - 1))
              {
                this.strBuffer = new string[SENSUSReader.bufferSize];
                this.strBufferPos = -1;
              }
              ++this.strBufferPos;
              this.strBuffer[this.strBufferPos] = val;
              this.actualByteBuffer = new byte[buffer.Length];
              Buffer.BlockCopy((Array) buffer, 0, (Array) this.actualByteBuffer, 0, buffer.Length);
              this.newDataAvail = true;
            }
            buffer = (byte[]) null;
          }
          return val;
        }
        finally
        {
          SENSUSReader.checkLocked = false;
        }
      }
      else
      {
        this.newDataAvail = false;
        return string.Empty;
      }
    }

    private async Task<string> checkNewDataFromBuffer()
    {
      string retVal = (string) null;
      if (this.newDataAvail)
      {
        retVal = this.strBuffer[this.strBufferPos];
        this.newDataAvail = false;
        await Task.Delay(10);
      }
      string str = retVal;
      retVal = (string) null;
      return str;
    }

    public async Task<string> setProgrammingMode()
    {
      SENSUSReader.SensusReader_Logger.Debug("Set programming mode!");
      if (this.localPort != null && !this.localPort.IsOpen)
        this.localPort.Open();
      if (this.localPort != null)
      {
        this.localPort.Write(SENSUSReader.SENSUS_CMD_PROG);
        await Task.Delay(this.localPort.ReadTimeout);
      }
      string str = await this.checkNewDataFromBuffer();
      return str;
    }

    public async Task<FirmwareVersion> readSerialNumber()
    {
      try
      {
        SENSUSReader.SensusReader_Logger.Debug("read serial number!");
        if (this.localPort != null && !this.localPort.IsOpen)
          this.localPort.Open();
        for (int i = 1; i < 10; ++i)
        {
          if (this.localPort != null)
          {
            this.localPort.Write(SENSUSReader.SENSUS_CMD_SERIALNO);
            await Task.Delay(520 * i);
            if (this.newDataAvail)
              break;
          }
        }
        string valHex = await this.checkNewDataFromBuffer();
        if (!string.IsNullOrEmpty(valHex) && valHex.Contains("FWversion:"))
        {
          valHex = valHex.Replace("FWversion:", "").Trim();
          uint version = new FirmwareVersion(valHex).Version;
          this.zFWVersion = new FirmwareVersion(version);
        }
        valHex = (string) null;
      }
      catch (Exception ex)
      {
        this.zFWVersion = new FirmwareVersion(0U);
      }
      return this.zFWVersion;
    }

    public async Task<string> readData()
    {
      try
      {
        for (int i = 1; i < 5; ++i)
        {
          SENSUSReader.SensusReader_Logger.Debug("read data from SENSUS!");
          if (this.localPort != null && !this.localPort.IsOpen)
            this.localPort.Open();
          if (this.localPort != null)
          {
            this.localPort.Write(SENSUSReader.SENSUS_CMD_VALUES);
            await Task.Delay(520 * i);
            if (this.newDataAvail)
              break;
          }
        }
      }
      catch (Exception ex)
      {
        return "Error while reading data! \n" + ex.Message;
      }
      string str = await this.checkNewDataFromBuffer();
      return str;
    }

    public async Task<string> sendCommand(string COMMAND)
    {
      SENSUSReader.SensusReader_Logger.Debug("send command: " + COMMAND);
      this.actualByteBuffer = new byte[0];
      if (this.localPort != null && !this.localPort.IsOpen)
        this.localPort.Open();
      if (this.localPort == null || string.IsNullOrEmpty(COMMAND))
        return string.Empty;
      this.localPort.Write(COMMAND);
      await Task.Delay(this.localPort.ReadTimeout + 333);
      string str = await this.checkNewDataFromBuffer();
      return str;
    }

    public async Task<bool> checkSENSUSConnectorOK()
    {
      SENSUSReader.SensusReader_Logger.Debug("check SENSUS ...");
      string data = await this.readData();
      bool flag = data.Contains("Data not available") || data.Contains("V;");
      data = (string) null;
      return flag;
    }
  }
}


--- SENSUSSTATE.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SENSUSSTATE
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum SENSUSSTATE
  {
    INIT,
    READING,
    WRITING,
    KEEP_ALIVE,
  }
}


--- SensusToolWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SensusToolWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class SensusToolWindow : Window, IComponentConnector
  {
    private static SensusToolWindow window;
    private SENSUSConnector handler;
    public ProgressHandler progress;
    public CancellationToken cancelToken;
    private double progressVal = 0.0;
    private bool isDeveloper = false;
    internal TextBox TextBoxInfo;
    internal ProgressBar progressBar_ONE;
    internal Label LabelState;
    internal Button ButtonReadVolFormat;
    internal ComboBox ComboBoxFormat;
    internal ComboBox ComboBoxTrunc;
    internal Button ButtonSetFormat;
    private bool _contentLoaded;

    private SensusToolWindow() => this.InitializeComponent();

    private void MyWindow_Loaded(object sender, RoutedEventArgs e)
    {
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
      this.cancelToken = new CancellationToken(false);
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.progressVal = obj.ProgressPercentage;
        this.progressBar_ONE.Value = this.progressVal;
        this.LabelState.Content = (object) obj.Message;
        this.addInfoText(obj.Message);
      }
    }

    private void addInfoText(string msg, bool newLine = true, bool clear = false, bool force = false)
    {
      if (clear)
        this.TextBoxInfo.Clear();
      TextBox textBoxInfo = this.TextBoxInfo;
      textBoxInfo.Text = textBoxInfo.Text + (newLine ? Environment.NewLine + (this.isDeveloper ? DateTime.Now.ToString() + " - " : string.Empty) : string.Empty) + msg;
      this.TextBoxInfo.CaretIndex = this.TextBoxInfo.LineCount < 0 ? 0 : this.TextBoxInfo.LineCount;
      this.TextBoxInfo.ScrollToEnd();
    }

    public static async Task<byte[]> ShowDialog(Window owner, SENSUSConnector handler)
    {
      await Task.Delay(1);
      SensusToolWindow.window = new SensusToolWindow();
      SensusToolWindow.window.Owner = owner;
      SensusToolWindow.window.handler = handler;
      bool canEnable = handler.myPort != null;
      FirmwareVersion fwV;
      int num;
      if (handler.FwV.Major >= (byte) 2)
      {
        fwV = handler.FwV;
        if (fwV.Minor >= (byte) 2)
        {
          fwV = handler.FwV;
          if (fwV.Revision >= (ushort) 3)
          {
            num = 1;
            goto label_6;
          }
        }
      }
      fwV = handler.FwV;
      num = fwV.Major >= (byte) 3 ? 1 : 0;
label_6:
      bool canEnableFormat = num != 0;
      SensusToolWindow.window.ButtonReadVolFormat.IsEnabled = canEnableFormat;
      SensusToolWindow.window.ButtonSetFormat.IsEnabled = canEnableFormat;
      SensusToolWindow.window.TextBoxInfo.Visibility = Visibility.Visible;
      SensusToolWindow.window.setFormatToComboBox();
      SensusToolWindow.window.setTruncateToComboBox();
      SensusToolWindow.window.isDeveloper = UserManager.CurrentUser.UserRole == UserManager.Role_Developer;
      if (SensusToolWindow.window.handler != null)
      {
        SensusToolWindow.window.addInfoText("Information:");
        SensusToolWindow.window.addInfoText("SENSUS Connector available ...");
        SensusToolWindow.window.addInfoText("SENSUS Connector: " + handler.ToString());
        SensusToolWindow.window.addInfoText("Set Format is " + (canEnableFormat ? " ENANLED " : " NOT ENABLED (firmware to old)"));
      }
      SensusToolWindow.window.Loaded += new RoutedEventHandler(SensusToolWindow.window.MyWindow_Loaded);
      byte[] numArray;
      try
      {
        if (!SensusToolWindow.window.ShowDialog().Value)
          ;
        numArray = (byte[]) null;
      }
      finally
      {
        SensusToolWindow.window.Loaded -= new RoutedEventHandler(SensusToolWindow.window.MyWindow_Loaded);
      }
      return numArray;
    }

    private void setFormatToComboBox()
    {
      for (int index = 4; index <= 9; ++index)
        this.ComboBoxFormat.Items.Add((object) index.ToString());
    }

    private void setTruncateToComboBox()
    {
      for (int index = 0; index <= 5; ++index)
        this.ComboBoxTrunc.Items.Add((object) index.ToString());
    }

    private async void ButtonReadVolFormat_Click(object sender, RoutedEventArgs e)
    {
      this.addInfoText("", clear: true);
      await this.ReadVolFormat();
    }

    private async Task ReadVolFormat()
    {
      byte[] retVal = await this.handler.ReadVolFormatSensusModule(this.progress, this.cancelToken);
      if (retVal != null && (int) retVal[0] == (int) SENSUSConnector.ResponseFORMAT && retVal.Length > 3)
      {
        ushort usFormat = (ushort) retVal[1];
        ushort usTrunc = (ushort) retVal[2];
        this.ComboBoxFormat.SelectedItem = (object) usFormat.ToString();
        this.ComboBoxTrunc.SelectedItem = (object) usTrunc.ToString();
        this.addInfoText(Util.ByteArrayToHexString(retVal));
        retVal = (byte[]) null;
      }
      else if (retVal == null || (int) retVal[0] != (int) SENSUSConnector.ResponseNACK)
      {
        retVal = (byte[]) null;
      }
      else
      {
        this.addInfoText("--> NACK received ... command not possible! ");
        this.addInfoText(Util.ByteArrayToHexString(retVal));
        retVal = (byte[]) null;
      }
    }

    private void ComboBoxFormat_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
    }

    private void ComboBoxTrunc_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
    }

    private async void ButtonSetFormat_Click(object sender, RoutedEventArgs e)
    {
      byte[] retVal;
      if (this.ComboBoxFormat.SelectedItem == null || this.ComboBoxTrunc.SelectedItem == null)
      {
        int num = (int) MessageBox.Show("Please select a FORMAT and TRUNCATION first.");
        retVal = (byte[]) null;
      }
      else
      {
        ushort usFormat = 0;
        ushort.TryParse(this.ComboBoxFormat.SelectedItem.ToString(), out usFormat);
        ushort usTrunc = 0;
        ushort.TryParse(this.ComboBoxTrunc.SelectedItem.ToString(), out usTrunc);
        retVal = await this.handler.SetFormat(this.progress, this.cancelToken, (byte) usFormat, (byte) usTrunc);
        this.addInfoText(Util.ByteArrayToHexString(retVal));
        retVal = (byte[]) null;
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/sensustoolwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.TextBoxInfo = (TextBox) target;
          break;
        case 2:
          this.progressBar_ONE = (ProgressBar) target;
          break;
        case 3:
          this.LabelState = (Label) target;
          break;
        case 4:
          this.ButtonReadVolFormat = (Button) target;
          this.ButtonReadVolFormat.Click += new RoutedEventHandler(this.ButtonReadVolFormat_Click);
          break;
        case 5:
          this.ComboBoxFormat = (ComboBox) target;
          this.ComboBoxFormat.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxFormat_SelectionChanged);
          break;
        case 6:
          this.ComboBoxTrunc = (ComboBox) target;
          this.ComboBoxTrunc.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxTrunc_SelectionChanged);
          break;
        case 7:
          this.ButtonSetFormat = (Button) target;
          this.ButtonSetFormat.Click += new RoutedEventHandler(this.ButtonSetFormat_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- SENSUSVOLFORMAT.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SENSUSVOLFORMAT
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum SENSUSVOLFORMAT : ushort
  {
    FOUR = 4,
    FIVE = 5,
    SIX = 6,
    SEVEN = 7,
    EIGHT = 8,
    NINE = 9,
  }
}


--- SENSUSVOLFORMATTRUNCATE.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SENSUSVOLFORMATTRUNCATE
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum SENSUSVOLFORMATTRUNCATE : ushort
  {
    ZERO,
    ONE,
    TWO,
    THREE,
    FOUR,
    FIVE,
  }
}


--- SmartFunctionIdentAndResult.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SmartFunctionIdentAndResult
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  public class SmartFunctionIdentAndResult : 
    SmartFunctionRuntimeResult,
    IComparable<SmartFunctionIdentAndResult>
  {
    public string Name { get; protected set; }

    public byte Version { get; protected set; }

    protected SmartFunctionIdentAndResult()
    {
    }

    protected SmartFunctionIdentAndResult(
      string name,
      byte version,
      ushort functionResult,
      ushort errorOffset)
    {
      this.Name = name;
      this.Version = version;
      this.FunctionResult = (SmartFunctionResult) functionResult;
      if (!this.Blocked)
        return;
      this.ErrorOffset = new ushort?(errorOffset);
    }

    public int CompareTo(SmartFunctionIdentAndResult obj)
    {
      if (obj == null)
        return 1;
      int num = this.Name.CompareTo(obj.Name);
      return num != 0 ? num : this.Version.CompareTo(obj.Version);
    }
  }
}


--- SmartFunctionIdentResultAndCalls.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SmartFunctionIdentResultAndCalls
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public class SmartFunctionIdentResultAndCalls : SmartFunctionIdentAndResult
  {
    public uint Calls { get; private set; }

    public SmartFunctionIdentResultAndCalls(byte[] byteArray, ref int offset)
    {
      this.Name = ByteArrayScanner.ScanString(byteArray, ref offset);
      this.Version = ByteArrayScanner.ScanByte(byteArray, ref offset);
      this.Calls = ByteArrayScanner.ScanUInt32(byteArray, ref offset);
      this.FunctionResult = (SmartFunctionResult) ByteArrayScanner.ScanUInt16(byteArray, ref offset);
      ushort num = ByteArrayScanner.ScanUInt16(byteArray, ref offset);
      if (!this.Blocked)
        return;
      this.ErrorOffset = new ushort?(num);
    }

    public override string ToString()
    {
      return this.Name.PadRight(30) + " ; Version:" + this.Version.ToString("d3") + " ; Calles:" + this.Calls.ToString("d5") + " ; Blocked:" + this.Blocked.ToString();
    }
  }
}


--- SmartFunctionResult.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SmartFunctionResult
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum SmartFunctionResult : ushort
  {
    NoError = 0,
    IllegalStorageTypeCode = 1,
    NoData = 2,
    EndOfAsciiStringNotFound = 3,
    IllegalDateStamp = 4,
    IllegalDateTimeStamp = 5,
    OutOfMemory = 6,
    LoggerParameterNotFirstParameter = 7,
    LoggerParameterNoUInt16 = 8,
    IllegalLoggerStorage = 9,
    FlashOutOfMemory = 10, // 0x000A
    RamOutOfMemory = 11, // 0x000B
    BackupOutOfMemory = 12, // 0x000C
    IllegalDataTypeCode = 13, // 0x000D
    RuntimeLoop = 14, // 0x000E
    WorkLevelExceeded = 15, // 0x000F
    StringLength20Exceeded = 16, // 0x0010
    UnknownMemory = 17, // 0x0011
    RegisterOpterationWithDifferentTypes = 18, // 0x0012
    NotSupportedOpcode = 19, // 0x0013
    StorageNotAllowedForLogger = 20, // 0x0014
    LoggerParameterNotInitialised = 21, // 0x0015
    LoggerWithoutData = 22, // 0x0016
    IllegalRegisterTypeForSaveEvent = 23, // 0x0017
    IllegalRegisterTypeForLoRaSendAlarm = 24, // 0x0018
    IllegalStateCounter = 25, // 0x0019
    ToManyParameters = 26, // 0x001A
    NotSupportedEvent = 27, // 0x001B
    IllegalParameterValue = 28, // 0x001C
    NotSupportedCycleSeconds = 29, // 0x001D
    NotSupportedInterpreterVersion = 30, // 0x001E
    FunctionAlreadyInstalled = 31, // 0x001F
    FunctionNotFound = 32, // 0x0020
    ParameterNotFound = 33, // 0x0021
    LongRunTime30ms = 34, // 0x0022
    RegisterOperationNAN = 35, // 0x0023
    RegisterOperationDivNULL = 36, // 0x0024
    DeactivatedByCommand = 65535, // 0xFFFF
  }
}


--- SmartFunctionRuntimeResult.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SmartFunctionRuntimeResult
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public class SmartFunctionRuntimeResult
  {
    public SmartFunctionResult FunctionResult { get; protected set; }

    public ushort? ErrorOffset { get; protected set; }

    public bool Blocked => this.FunctionResult != 0;

    public string Error => this.Blocked ? this.FunctionResult.ToString() : (string) null;

    public SmartFunctionRuntimeResult()
    {
    }

    public SmartFunctionRuntimeResult(byte[] response)
    {
      int offset = 2;
      this.FunctionResult = (SmartFunctionResult) ByteArrayScanner.ScanUInt16(response, ref offset);
      ushort num = ByteArrayScanner.ScanUInt16(response, ref offset);
      if (!this.Blocked)
        return;
      this.ErrorOffset = new ushort?(num);
    }
  }
}


--- SmartFunctions_EDC.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SmartFunctions_EDC
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text.RegularExpressions;

#nullable disable
namespace HandlerLib
{
  internal static class SmartFunctions_EDC
  {
    public static Dictionary<string, int> WaterMeterRollersInLiterCogCountEDC = new Dictionary<string, int>()
    {
      {
        "8R",
        8
      },
      {
        "6R+3ZK",
        9
      },
      {
        "6R+3ZK+1V",
        10
      }
    };

    public static bool CalculateSmartFunctionsParamEDCByQ3ANDVolumeUnit(
      string volWaterMeterPulseValueInLiterString,
      string waterMeterNominalFlowQMPerHourString,
      out int burstDiff,
      out int undersizeDiff,
      out int OversizeDiff,
      out int leak_lower,
      out int leak_upper)
    {
      burstDiff = int.MinValue;
      undersizeDiff = int.MinValue;
      OversizeDiff = int.MinValue;
      leak_lower = -1900;
      leak_upper = 1900;
      double Q3InQMPerHour = double.MinValue;
      if (!SmartFunctions_EDC.GetQ3FlowQMPerHourFromCacheString(waterMeterNominalFlowQMPerHourString, out Q3InQMPerHour))
        return false;
      double waterMeterNominalFlowLiter = Q3InQMPerHour * 1000.0;
      double wmDiscMultiplierLiterPerRotation = double.MinValue;
      return SmartFunctions_EDC.GetvolMeterPulseValueFromCacheString(volWaterMeterPulseValueInLiterString, out wmDiscMultiplierLiterPerRotation) && SmartFunctions_EDC.CalculateSmartFunctionsParamEDCByQ3ANDVolumeUnit(wmDiscMultiplierLiterPerRotation, waterMeterNominalFlowLiter, out burstDiff, out undersizeDiff, out OversizeDiff, out leak_lower, out leak_upper);
    }

    private static bool CalculateSmartFunctionsParamEDCByQ3ANDVolumeUnit(
      double WaterMeterPulseValueInLiter,
      double waterMeterNominalFlowLiter,
      out int burstDiff,
      out int undersizeDiff,
      out int OversizeDiff,
      out int leak_lower,
      out int leak_upper)
    {
      burstDiff = (int) Convert.ToUInt16(0.3 * waterMeterNominalFlowLiter / WaterMeterPulseValueInLiter / 4.0);
      undersizeDiff = (int) Convert.ToUInt16(waterMeterNominalFlowLiter / WaterMeterPulseValueInLiter / 4.0);
      OversizeDiff = (int) Convert.ToUInt16(0.1 * waterMeterNominalFlowLiter / WaterMeterPulseValueInLiter / 4.0);
      leak_lower = -1900;
      leak_upper = 1900;
      return true;
    }

    private static bool calculateRotationSpeedDiscInRotationsPerSecond(
      string FlowLiterPerHourWaterMeterCacheString,
      string PulseMultiplierWaterMeterLiterPerRotationCacheString,
      out double equivalentRotationSpeedDiscEDC)
    {
      equivalentRotationSpeedDiscEDC = double.MinValue;
      double Q3InQMPerHour = double.MinValue;
      if (!SmartFunctions_EDC.GetQ3FlowQMPerHourFromCacheString(FlowLiterPerHourWaterMeterCacheString, out Q3InQMPerHour))
        return false;
      double FlowLiterPerHourWaterMeter = Q3InQMPerHour * 1000.0;
      double wmDiscMultiplierLiterPerRotation = double.MinValue;
      if (!SmartFunctions_EDC.GetvolMeterPulseValueFromCacheString(PulseMultiplierWaterMeterLiterPerRotationCacheString, out wmDiscMultiplierLiterPerRotation))
        return false;
      equivalentRotationSpeedDiscEDC = SmartFunctions_EDC.calculateRotationSpeedDiscInRotationsPerSecond(FlowLiterPerHourWaterMeter, wmDiscMultiplierLiterPerRotation);
      return true;
    }

    private static double calculateRotationSpeedDiscInRotationsPerSecond(
      double FlowLiterPerHourWaterMeter,
      double PulseMultiplierWaterMeterLiterPerRotation)
    {
      return FlowLiterPerHourWaterMeter / 3600.0 / PulseMultiplierWaterMeterLiterPerRotation;
    }

    private static uint countdigits(uint x)
    {
      uint num1 = 1;
      uint num2 = 10;
      while (x >= num2)
      {
        num2 *= 10U;
        ++num1;
      }
      return num1;
    }

    public static bool CalculateMultiplierEDC(
      int waterMeterMultiplierLiterPerRotation,
      int edcVolumeUnitInLiter,
      out int edcMultiplier)
    {
      edcMultiplier = int.MinValue;
      double d = (double) waterMeterMultiplierLiterPerRotation / (double) edcVolumeUnitInLiter;
      if (Math.Floor(d) / d != 1.0)
        return false;
      edcMultiplier = (int) d;
      if (edcMultiplier >= 1)
        return true;
      edcMultiplier = int.MinValue;
      return false;
    }

    public static bool CalculateCogCountEDC(
      string numberOfRollsCache,
      uint volumeUnitEDCInLiter,
      out int cogCountEDC)
    {
      int num;
      if (!SmartFunctions_EDC.WaterMeterRollersInLiterCogCountEDC.TryGetValue(numberOfRollsCache, out num))
      {
        cogCountEDC = int.MinValue;
        return false;
      }
      cogCountEDC = num - ((int) SmartFunctions_EDC.countdigits(volumeUnitEDCInLiter) - 1);
      return true;
    }

    private static bool GetQ3FlowQMPerHourFromCacheString(
      string flowInQMPerHour,
      out double Q3InQMPerHour)
    {
      Q3InQMPerHour = double.MinValue;
      if (!flowInQMPerHour.Contains("m\u00B3/h"))
        return false;
      if (flowInQMPerHour.Contains("Q3 "))
        flowInQMPerHour = flowInQMPerHour.Replace("Q3 ", "");
      return !flowInQMPerHour.Contains(",") && double.TryParse(Regex.Replace(flowInQMPerHour, "[^0-9.]", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out Q3InQMPerHour);
    }

    private static bool GetEDCVolumeUnitFromCacheString(
      string edcVolumeUnit,
      out double edcVolumeUnitValue)
    {
      edcVolumeUnitValue = double.MinValue;
      return (edcVolumeUnit.Contains("L") || edcVolumeUnit.Contains("l")) && !edcVolumeUnit.Contains(",") && double.TryParse(Regex.Replace(edcVolumeUnit, "[^0-9.]", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out edcVolumeUnitValue);
    }

    public static bool GetvolMeterPulseValueFromCacheString(
      string volMeterPulseValueInLiterPerRotation,
      out double wmDiscMultiplierLiterPerRotation)
    {
      wmDiscMultiplierLiterPerRotation = double.MinValue;
      return (volMeterPulseValueInLiterPerRotation.Contains("L") || volMeterPulseValueInLiterPerRotation.Contains("l")) && !volMeterPulseValueInLiterPerRotation.Contains(",") && double.TryParse(Regex.Replace(volMeterPulseValueInLiterPerRotation, "[^0-9.]", ""), NumberStyles.Number, (IFormatProvider) CultureInfo.InvariantCulture, out wmDiscMultiplierLiterPerRotation);
    }
  }
}


--- SpecialCommands.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SpecialCommands
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using NLog;
using System;
using System.Threading;
using System.Threading.Tasks;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public sealed class SpecialCommands : IZRCommand
  {
    private static Logger logger = LogManager.GetLogger(nameof (SpecialCommands));
    private Common32BitCommands commonCMD;
    private bool crypt = false;
    private string AESKey = (string) null;

    public bool enDeCrypt
    {
      get => this.crypt;
      set
      {
        this.crypt = value;
        if (this.commonCMD == null)
          return;
        this.commonCMD.enDeCrypt = value;
      }
    }

    public string AES_Key
    {
      get => this.AESKey;
      set
      {
        this.AESKey = value;
        if (this.commonCMD == null)
          return;
        this.commonCMD.AES_Key = value;
      }
    }

    public SpecialCommands(Common32BitCommands commonCMD)
    {
      this.commonCMD = commonCMD;
      this.setCryptValuesFromBaseClass();
    }

    public void setCryptValuesFromBaseClass()
    {
      this.enDeCrypt = this.commonCMD.enDeCrypt;
      this.AES_Key = this.commonCMD.AES_Key;
    }

    public async Task<ushort> GetSpecialCommandFCVersionAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetSpecialCommandFCVersion_0x00, progress, cancelToken);
      ushort uint16 = BitConverter.ToUInt16(theData, 0);
      theData = (byte[]) null;
      return uint16;
    }

    public async Task<SpecialCommands.Metrology_Parameters> GetSCMetrologyParametersAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetSetMetrologyParameters_0x02, progress, cancelToken);
      SpecialCommands.Metrology_Parameters retData = new SpecialCommands.Metrology_Parameters();
      retData.basedata = theData;
      Buffer.BlockCopy((Array) theData, 0, (Array) retData.Identity, 0, 2);
      Buffer.BlockCopy((Array) theData, 2, (Array) retData.Options, 0, theData.Length - 2);
      SpecialCommands.Metrology_Parameters metrologyParametersAsync = retData;
      theData = (byte[]) null;
      retData = (SpecialCommands.Metrology_Parameters) null;
      return metrologyParametersAsync;
    }

    public async Task SetSCMetrologyParametersAsync(
      byte[] identity,
      byte[] options,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] data = new byte[12];
      data[0] = identity[0];
      data[1] = identity[1];
      Buffer.BlockCopy((Array) options, 0, (Array) data, 2, options.Length);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetSetMetrologyParameters_0x02, data, progress, cancelToken);
      data = (byte[]) null;
    }

    public async Task<SpecialCommands.SD_Rules_Options> GetSDRulesAsync(
      byte rule,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] data = new byte[1]{ rule };
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetSetSDRules_0x0A, data, progress, cancelToken);
      SpecialCommands.SD_Rules_Options retData = new SpecialCommands.SD_Rules_Options();
      retData.basedata = theData;
      retData.Selection = theData[0];
      retData.Flag = theData[1];
      Buffer.BlockCopy((Array) theData, 2, (Array) retData.options, 0, 4);
      SpecialCommands.SD_Rules_Options sdRulesAsync = retData;
      data = (byte[]) null;
      theData = (byte[]) null;
      retData = (SpecialCommands.SD_Rules_Options) null;
      return sdRulesAsync;
    }

    public async Task SetSDRulesAsync(
      byte selection,
      byte flag,
      byte[] options,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] data = new byte[6]
      {
        selection,
        flag,
        (byte) 0,
        (byte) 0,
        (byte) 0,
        (byte) 0
      };
      Buffer.BlockCopy((Array) options, 0, (Array) data, 2, 4);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetSetSDRules_0x0A, data, progress, cancelToken);
      data = (byte[]) null;
    }

    public async Task<byte[]> GetFlowCheckStateAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetClearFlowCheckStates_0x09, progress, cancelToken);
      byte[] flowCheckStateAsync = theData;
      theData = (byte[]) null;
      return flowCheckStateAsync;
    }

    public async Task ClearFlowCheckStatesAsync(
      ushort state,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] data = BitConverter.GetBytes(state);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetClearFlowCheckStates_0x09, data, progress, cancelToken);
      data = (byte[]) null;
    }

    public async Task<byte> GetSummertimeCountingSuppressionAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetSetSummertimeCouningSuppression_0x06, progress, cancelToken);
      byte suppressionAsync = theData[0];
      theData = (byte[]) null;
      return suppressionAsync;
    }

    public async Task SetSummertimeCountingSuppressionAsync(
      byte state,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] data = new byte[1]{ state };
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetSetSummertimeCouningSuppression_0x06, data, progress, cancelToken);
      data = (byte[]) null;
    }

    public async Task<byte[]> GetProductFactorAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetSetProductionFactor_0x04, progress, cancelToken);
      byte[] productFactorAsync = theData;
      theData = (byte[]) null;
      return productFactorAsync;
    }

    public async Task SetProductFactorAsync(
      byte[] factor,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] data = new byte[2];
      Buffer.BlockCopy((Array) factor, 0, (Array) data, 0, 2);
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetSetProductionFactor_0x04, data, progress, cancelToken);
      data = (byte[]) null;
    }

    public async Task<byte[]> GetCurrentMeasuringModeAsync(
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetCurrentMeasuringMode_0x01, progress, cancelToken);
      byte[] measuringModeAsync = theData;
      theData = (byte[]) null;
      return measuringModeAsync;
    }

    public async Task<byte[]> SendToNfcDeviceAsync(
      byte[] NFCrequest,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await Task.Delay(200);
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.SendToNfcDevice_0x0B, NFCrequest, progress, cancelToken);
      byte[] nfcDeviceAsync = theData;
      theData = (byte[]) null;
      return nfcDeviceAsync;
    }

    public async Task<SpecialCommands.NFC_Identification> GetNfcDeviceIdentification(
      byte[] NFCrequest,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] theData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.GetNfcDeviceIdentification_0x0C, NFCrequest, progress, cancelToken);
      ushort arrayPos = 0;
      ushort version = (ushort) theData[0];
      SpecialCommands.NFC_Identification nfcIdent = new SpecialCommands.NFC_Identification();
      nfcIdent.basedata = theData;
      nfcIdent.IdentificationResponseVersion = theData[(int) arrayPos];
      ++arrayPos;
      nfcIdent.NFCProtocolVersion = theData[(int) arrayPos];
      ++arrayPos;
      nfcIdent.MBusMedium = theData[(int) arrayPos];
      ++arrayPos;
      nfcIdent.OBISMedium = theData[(int) arrayPos];
      ++arrayPos;
      Buffer.BlockCopy((Array) theData, (int) arrayPos, (Array) nfcIdent.Manufacturer, 0, 2);
      arrayPos += (ushort) 2;
      nfcIdent.Generation = theData[(int) arrayPos];
      ++arrayPos;
      Buffer.BlockCopy((Array) theData, (int) arrayPos, (Array) nfcIdent.Serialnumber, 0, 4);
      arrayPos += (ushort) 4;
      switch (version)
      {
        case 0:
          Buffer.BlockCopy((Array) theData, (int) arrayPos, (Array) nfcIdent.HardwareIdentification, 0, 4);
          arrayPos += (ushort) 4;
          break;
        case 1:
          Buffer.BlockCopy((Array) theData, (int) arrayPos, (Array) nfcIdent.HardwareIdentification, 0, 2);
          arrayPos += (ushort) 2;
          Buffer.BlockCopy((Array) theData, (int) arrayPos, (Array) nfcIdent.SystemState, 0, 2);
          arrayPos += (ushort) 2;
          break;
        case 2:
          Buffer.BlockCopy((Array) theData, (int) arrayPos, (Array) nfcIdent.HardwareIdentification, 0, 2);
          arrayPos += (ushort) 2;
          Buffer.BlockCopy((Array) theData, (int) arrayPos, (Array) nfcIdent.SystemInfos, 0, 4);
          arrayPos += (ushort) 4;
          break;
      }
      Buffer.BlockCopy((Array) theData, (int) arrayPos, (Array) nfcIdent.FirmwareVersion, 0, 4);
      arrayPos += (ushort) 4;
      nfcIdent.MeterID = BitConverter.ToUInt32(theData, (int) arrayPos);
      arrayPos += (ushort) 4;
      nfcIdent.BuildRevision = BitConverter.ToUInt32(theData, (int) arrayPos);
      arrayPos += (ushort) 4;
      nfcIdent.BuildTime = BitConverter.ToUInt32(theData, (int) arrayPos);
      arrayPos += (ushort) 4;
      nfcIdent.CompilerVersion = BitConverter.ToUInt32(theData, (int) arrayPos);
      arrayPos += (ushort) 4;
      nfcIdent.FirmwareSignature = BitConverter.ToUInt16(theData, (int) arrayPos);
      arrayPos += (ushort) 2;
      nfcIdent.NumberOfAvailableParameterGroups = theData[(int) arrayPos];
      ++arrayPos;
      nfcIdent.NumberOfAvailableParameters = BitConverter.ToUInt16(theData, (int) arrayPos);
      arrayPos += (ushort) 2;
      nfcIdent.NumberOfSelectedParameterGroups = theData[(int) arrayPos];
      ++arrayPos;
      nfcIdent.NumberOfSelectedParameters = BitConverter.ToUInt16(theData, (int) arrayPos);
      arrayPos += (ushort) 2;
      nfcIdent.MaximumRecordLength = theData[(int) arrayPos];
      ++arrayPos;
      SpecialCommands.NFC_Identification deviceIdentification = nfcIdent;
      theData = (byte[]) null;
      nfcIdent = (SpecialCommands.NFC_Identification) null;
      return deviceIdentification;
    }

    public async Task SetReligiousDay(
      byte[] data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.SetReligiousDay_0x0D, data, progress, cancelToken);
    }

    public async Task SetSmartFunctions(
      byte[] Data,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      await this.commonCMD.TransmitAndCheckAckAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.SetGetSmartFunctions_0x0E, Data, progress, cancelToken);
    }

    public async Task<byte[]> GetSmartFunctions(
      byte SmartFunctionCode,
      ProgressHandler progress,
      CancellationToken cancelToken)
    {
      byte[] ReturnData = await this.commonCMD.TransmitAndGetDataAsync(Manufacturer_FC.SpecialCommands_0x36, SpecialCommands_EFC.SetGetSmartFunctions_0x0E, new byte[1]
      {
        SmartFunctionCode
      }, progress, cancelToken);
      byte[] smartFunctions = ReturnData;
      ReturnData = (byte[]) null;
      return smartFunctions;
    }

    public class SD_Rules_Options : ReturnValue
    {
      public byte Selection = 1;
      public byte Flag = 0;
      public byte[] options = new byte[4];
    }

    public class Metrology_Parameters : ReturnValue
    {
      public byte[] Identity = new byte[2];
      public byte[] Options = new byte[10];
    }

    public class NFC_Identification : ReturnValue
    {
      public byte IdentificationResponseVersion = 0;
      public byte NFCProtocolVersion = 0;
      public byte MBusMedium = 0;
      public byte OBISMedium = 0;
      public byte[] Manufacturer = new byte[2];
      public byte Generation = 0;
      public byte[] Serialnumber = new byte[4];
      public byte[] HardwareIdentification = new byte[4];
      public byte[] SystemState = new byte[2];
      public byte[] SystemInfos = new byte[4];
      public byte[] FirmwareVersion = new byte[4];
      public uint MeterID = 0;
      public uint BuildRevision = 0;
      public uint BuildTime = 0;
      public uint CompilerVersion = 0;
      public ushort FirmwareSignature = 0;
      public byte NumberOfAvailableParameterGroups = 0;
      public ushort NumberOfAvailableParameters = 0;
      public byte NumberOfSelectedParameterGroups = 0;
      public ushort NumberOfSelectedParameters = 0;
      public byte MaximumRecordLength = 0;
    }
  }
}


--- SpecialCommands_EFC.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SpecialCommands_EFC
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum SpecialCommands_EFC : byte
  {
    GetSpecialCommandFCVersion_0x00 = 0,
    GetCurrentMeasuringMode_0x01 = 1,
    GetSetMetrologyParameters_0x02 = 2,
    GetSetProductionFactor_0x04 = 4,
    GetSetCountingMode_0x05 = 5,
    GetSetSummertimeCouningSuppression_0x06 = 6,
    GetClearFlowCheckStates_0x09 = 9,
    GetSetSDRules_0x0A = 10, // 0x0A
    SendToNfcDevice_0x0B = 11, // 0x0B
    GetNfcDeviceIdentification_0x0C = 12, // 0x0C
    SetReligiousDay_0x0D = 13, // 0x0D
    SetGetSmartFunctions_0x0E = 14, // 0x0E
  }
}


--- SpecialCommandWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SpecialCommandWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZENNER.CommonLibrary.Exceptions;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class SpecialCommandWindow : Window, IComponentConnector
  {
    private SpecialCommands mySpecialCommands;
    private List<string> Argument1_last_values;
    private List<string> Argument2_last_values;
    private List<string> Argument3_last_values;
    private List<string> Argument4_last_values;
    private List<string> Argument5_last_values;
    private ContextMenu Argument1ValuesMenu;
    private ContextMenu Argument2ValuesMenu;
    private ContextMenu Argument3ValuesMenu;
    private ContextMenu Argument4ValuesMenu;
    private ContextMenu Argument5ValuesMenu;
    private static string result = "";
    private static readonly string CMD_GetVersion = "Get version (0x00)";
    private static readonly string CMD_GetMetrologyParameters = "Get metrology parameters (0x02)";
    private static readonly string CMD_SetMetrologyParameters = "Set metrology parameters (0x02)";
    private static readonly string CMD_GetCurrentMeasuringMode = "Get current measuring mode (0x01)";
    private static readonly string CMD_SetProductFactor = "Set product factor (0x04)";
    private static readonly string CMD_GetProductFactor = "Get product factor (0x04)";
    private static readonly string CMD_SetSummertimeCountingSuppression = "Set summertime counting suppression (0x06)";
    private static readonly string CMD_GetSummertimeCountingSuppression = "Get summertime counting suppression (0x06)";
    private static readonly string CMD_ClearFlowCheckStates = "Clear flow check states (0x09)";
    private static readonly string CMD_GetFlowCheckStates = "Get flow check states (0x09)";
    private static readonly string CMD_SetSDRules = "Set SD Rules (0x0A)";
    private static readonly string CMD_GetSDRules = "Get SD Rules (0x0A)";
    private static readonly string CMD_SendNfc2Device = "Send to NFC device (0x0B)";
    private static readonly string CMD_GetNfcDeviceIdentification = "Get NFC device identification (0x0C)";
    private static readonly string CMD_SetReligiousDay = "Set religious day (0x0D)";
    private static readonly string CMD_SetSmartFunctions = "Set smart functions (0x0E)";
    private static readonly string CMD_GetSmartFunctions = "Get smart functions (0x0E)";
    private Cursor defaultCursor;
    private CancellationTokenSource cancelTokenSource;
    private ProgressHandler progress;
    internal TextBlock TextBlockStatus;
    internal ProgressBar ProgressBar1;
    internal TextBox TextBoxUniversalCommandResult;
    internal StackPanel StackPanalButtons;
    internal ComboBox ComboCommand;
    internal CheckBox CheckBoxEncryption;
    internal Label EncryptionKey_Label;
    internal TextBox TextBoxEncryptionKey;
    internal Label ComboExtCommand_Label;
    internal ComboBox ComboExtCommand;
    internal Label ComboAddCommand_Label;
    internal ComboBox ComboAddCommand;
    internal Label TextArgument_1_Label;
    internal TextBox TextExtCommandArgument_1;
    internal Label TextArgument_2_Label;
    internal TextBox TextExtCommandArgument_2;
    internal Label TextArgument_3_Label;
    internal TextBox TextExtCommandArgument_3;
    internal Label TextArgument_4_Label;
    internal TextBox TextExtCommandArgument_4;
    internal Label TextArgument_5_Label;
    internal TextBox TextExtCommandArgument_5;
    internal StackPanel StackPanalButtons2;
    internal Button ButtonRunCommand;
    internal Button ButtonRunCommandPreview;
    internal Button ButtonBreak;
    private bool _contentLoaded;

    public SpecialCommandWindow(SpecialCommands SpecialCMDs)
    {
      this.InitializeComponent();
      this.mySpecialCommands = SpecialCMDs;
      this.mySpecialCommands.setCryptValuesFromBaseClass();
      this.ButtonRunCommand.IsEnabled = false;
      this.SetArgumentFields((Dictionary<int, string>) null);
      this.setFunctionCodes();
      this.Argument1_last_values = new List<string>();
      this.Argument2_last_values = new List<string>();
      this.Argument3_last_values = new List<string>();
      this.Argument4_last_values = new List<string>();
      this.Argument5_last_values = new List<string>();
      this.Argument1ValuesMenu = new ContextMenu();
      this.Argument2ValuesMenu = new ContextMenu();
      this.Argument3ValuesMenu = new ContextMenu();
      this.Argument4ValuesMenu = new ContextMenu();
      this.Argument5ValuesMenu = new ContextMenu();
      this.setEncryptionState();
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
    }

    private void setEncryptionState()
    {
      this.CheckBoxEncryption.IsChecked = new bool?(this.mySpecialCommands.enDeCrypt);
      if (!this.mySpecialCommands.enDeCrypt)
        this.CheckBoxEncryption_UnChecked((object) null, (RoutedEventArgs) null);
      this.TextBoxEncryptionKey.Text = this.mySpecialCommands.AES_Key;
    }

    private void setFunctionCodes()
    {
      this.ComboExtCommand_Label.Visibility = Visibility.Hidden;
      this.ComboExtCommand.Visibility = Visibility.Hidden;
      this.ComboCommand.Items.Clear();
      this.ComboCommand.Items.Add((object) "Special Commands (0x36)");
      this.ComboCommand.SelectedIndex = 0;
    }

    private void setSpecialCommands()
    {
      Dictionary<string, string> valuesForCommands = GetCommandValues.GetAllPrivateStaticFieldValuesForCommands((object) this);
      this.ComboExtCommand.Items.Clear();
      foreach (KeyValuePair<string, string> keyValuePair in valuesForCommands)
        this.ComboExtCommand.Items.Add((object) keyValuePair.Value);
      this.ComboExtCommand.SelectedIndex = 0;
    }

    private void SetRunState()
    {
      this.cancelTokenSource = new CancellationTokenSource();
      this.progress.Reset();
      this.progress.Split(new double[2]{ 2.0, 98.0 });
      this.progress.Report("Run");
      this.ComboCommand.IsEnabled = false;
      this.ComboExtCommand.IsEnabled = false;
      this.TextBoxUniversalCommandResult.IsEnabled = false;
      this.TextExtCommandArgument_1.IsEnabled = false;
      this.TextExtCommandArgument_2.IsEnabled = false;
      this.TextExtCommandArgument_3.IsEnabled = false;
      this.ButtonRunCommand.IsEnabled = false;
      this.ButtonRunCommandPreview.IsEnabled = false;
      this.ButtonBreak.IsEnabled = true;
      this.defaultCursor = this.Cursor;
      this.Cursor = Cursors.Wait;
    }

    private void SetStopState()
    {
      this.ComboCommand.IsEnabled = true;
      this.ComboExtCommand.IsEnabled = true;
      this.TextBoxUniversalCommandResult.IsEnabled = true;
      this.TextExtCommandArgument_1.IsEnabled = true;
      this.TextExtCommandArgument_2.IsEnabled = true;
      this.TextExtCommandArgument_3.IsEnabled = true;
      this.ButtonRunCommand.IsEnabled = true;
      this.ButtonRunCommandPreview.IsEnabled = true;
      this.ButtonBreak.IsEnabled = false;
      this.Cursor = this.defaultCursor;
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.ProgressBar1.Value = obj.ProgressPercentage;
        this.TextBlockStatus.Text = obj.Message;
      }
    }

    private void ButtonBreak_Click(object sender, RoutedEventArgs e)
    {
      this.cancelTokenSource.Cancel();
    }

    private async Task RunCommandFrame()
    {
      this.SetRunState();
      try
      {
        await this.RunCommand();
      }
      catch (OperationCanceledException ex)
      {
      }
      catch (TimeoutException ex)
      {
        this.TextBoxUniversalCommandResult.Text = "Timeout!";
      }
      catch (NACK_Exception ex)
      {
        this.TextBoxUniversalCommandResult.Text = "Device response is NACK: " + ex.Message;
      }
      catch (Exception ex)
      {
        bool isTimeout = false;
        if (ex is AggregateException)
        {
          AggregateException aex = ex as AggregateException;
          int num1;
          for (int i = 0; i < aex.InnerExceptions.Count; num1 = i++)
          {
            Exception theException = aex.InnerExceptions[i];
            if (theException is TimeoutException)
            {
              if (i == aex.InnerExceptions.Count - 1)
              {
                isTimeout = true;
                string newLine = Environment.NewLine;
                num1 = aex.InnerExceptions.Count;
                string str = num1.ToString();
                int num2 = (int) MessageBox.Show("**** Multiple timeouts ****" + newLine + "Timeout count: " + str);
              }
              theException = (Exception) null;
            }
            else
              break;
          }
          aex = (AggregateException) null;
        }
        if (!isTimeout)
        {
          int num = (int) MessageBox.Show(ex.ToString());
        }
      }
      this.SetStopState();
    }

    private async void ButtonRunCommand_Click(object sender, RoutedEventArgs e)
    {
      SpecialCommandWindow.result = string.Empty;
      await this.RunCommandFrame();
    }

    private async void ButtonRunCommandPreview_Click(object sender, RoutedEventArgs e)
    {
      Dictionary<int, string> myTemplate = new Dictionary<int, string>();
      SpecialCommandWindow.result = "Actual data from connected device: \n-----------------------------------------------------";
      this.ComboExtCommand.SelectedItem = (object) SpecialCommandWindow.CMD_GetVersion;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) SpecialCommandWindow.CMD_GetFlowCheckStates;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) SpecialCommandWindow.CMD_GetCurrentMeasuringMode;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) SpecialCommandWindow.CMD_GetProductFactor;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) SpecialCommandWindow.CMD_GetSummertimeCountingSuppression;
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) SpecialCommandWindow.CMD_GetSDRules;
      myTemplate.Add(1, "0x01");
      this.SetArgumentFieldsValues(myTemplate);
      myTemplate.Clear();
      await this.RunCommandFrame();
      this.ComboExtCommand.SelectedItem = (object) SpecialCommandWindow.CMD_GetSDRules;
      myTemplate.Add(1, "0x02");
      this.SetArgumentFieldsValues(myTemplate);
      myTemplate.Clear();
      await this.RunCommandFrame();
      myTemplate = (Dictionary<int, string>) null;
    }

    private void ComboExtCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboExtCommand.SelectedItem != null)
      {
        object selectedItem = this.ComboExtCommand.SelectedItem;
        this.ComboAddCommand.Items.Clear();
        Dictionary<int, string> template = new Dictionary<int, string>();
        if (selectedItem.ToString().Contains(SpecialCommandWindow.CMD_SetMetrologyParameters))
        {
          template.Add(1, "Identity (2 bytes) :");
          template.Add(2, "Options (10 bytes) :");
        }
        if (selectedItem.ToString().Contains(SpecialCommandWindow.CMD_SetProductFactor))
          template.Add(1, "Productfactor :");
        if (selectedItem.ToString().Contains(SpecialCommandWindow.CMD_SetSummertimeCountingSuppression))
          template.Add(1, "Flag (0x00 off : 0x01 on):");
        if (selectedItem.ToString().Contains(SpecialCommandWindow.CMD_ClearFlowCheckStates))
          template.Add(1, "Flow check state (state):");
        if (selectedItem.ToString().Contains(SpecialCommandWindow.CMD_GetSDRules))
          template.Add(1, "Selection (rule):");
        if (selectedItem.ToString().Contains(SpecialCommandWindow.CMD_SetSDRules))
        {
          template.Add(1, "Selection (rule):");
          template.Add(2, "Flag :");
          template.Add(3, "Options :");
        }
        if (selectedItem.ToString().Contains(SpecialCommandWindow.CMD_SendNfc2Device))
          template.Add(1, "NFC request:");
        if (selectedItem.ToString().Contains(SpecialCommandWindow.CMD_GetNfcDeviceIdentification))
          template.Add(1, "NFC request:");
        if (selectedItem.ToString().Contains(SpecialCommandWindow.CMD_SetReligiousDay))
          template.Add(1, "Data:");
        if (selectedItem.ToString().Contains(SpecialCommandWindow.CMD_SetSmartFunctions))
        {
          template.Add(1, "SmartFunctionCode(0~7):");
          template.Add(2, "Parameter A~F decimal values splite by ';'" + Environment.NewLine + "(Example: 0;1;-1;0;0)");
        }
        if (selectedItem.ToString().Contains(SpecialCommandWindow.CMD_GetSmartFunctions))
          template.Add(1, "SmartFunctionCode(0~7):");
        this.SetArgumentFields(template);
        this.ButtonRunCommand.IsEnabled = true;
      }
      else
        this.ButtonRunCommand.IsEnabled = false;
    }

    private void ComboCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboCommand.SelectedIndex < 0)
        return;
      Dictionary<int, string> dictionary = new Dictionary<int, string>();
      if (this.ComboCommand.SelectedItem.ToString().Contains("0x36"))
      {
        this.setSpecialCommands();
        this.ComboExtCommand_Label.Content = (object) "Special Commands:";
        this.ComboExtCommand_Label.Visibility = Visibility.Visible;
        this.ComboExtCommand.Visibility = Visibility.Visible;
      }
    }

    private void ComboAddCommand_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      if (this.ComboAddCommand.SelectedIndex < 0)
        return;
      object selectedItem = this.ComboAddCommand.SelectedItem;
    }

    private void SetArgumentFields(Dictionary<int, string> template)
    {
      this.TextExtCommandArgument_1.Text = string.Empty;
      this.TextExtCommandArgument_2.Text = string.Empty;
      this.TextExtCommandArgument_3.Text = string.Empty;
      this.TextExtCommandArgument_4.Text = string.Empty;
      this.TextExtCommandArgument_5.Text = string.Empty;
      this.ComboAddCommand_Label.Visibility = Visibility.Collapsed;
      this.ComboAddCommand.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_1.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_2.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_3.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_4.Visibility = Visibility.Collapsed;
      this.TextExtCommandArgument_5.Visibility = Visibility.Collapsed;
      this.TextArgument_1_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_2_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_3_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_4_Label.Visibility = Visibility.Collapsed;
      this.TextArgument_5_Label.Visibility = Visibility.Collapsed;
      if (template == null)
        return;
      foreach (KeyValuePair<int, string> keyValuePair in template)
      {
        if (keyValuePair.Key == 0 || keyValuePair.Key == 10)
        {
          if (keyValuePair.Key == 0)
          {
            this.ComboAddCommand.Visibility = Visibility.Visible;
            this.ComboAddCommand.Items.Add((object) "FSK         (0x00)");
            this.ComboAddCommand.Items.Add((object) "GFSK        (0x01)");
            this.ComboAddCommand.Items.Add((object) "OOK         (0x02)");
            this.ComboAddCommand.Items.Add((object) "SIGFOX      (0x03)");
            this.ComboAddCommand.Items.Add((object) "LoRa SF7    (0x04)");
            this.ComboAddCommand.Items.Add((object) "LoRa SF8    (0x05)");
            this.ComboAddCommand.Items.Add((object) "LoRa SF9    (0x06)");
            this.ComboAddCommand.Items.Add((object) "LoRa SF10   (0x07)");
            this.ComboAddCommand.Items.Add((object) "LoRa SF11   (0x08)");
            this.ComboAddCommand.Items.Add((object) "LoRa SF12   (0x09)");
            this.ComboAddCommand_Label.Visibility = Visibility.Visible;
            this.ComboAddCommand_Label.Content = (object) keyValuePair.Value;
          }
          if (keyValuePair.Key == 10)
            this.ComboAddCommand.Text = keyValuePair.Value;
        }
        if (keyValuePair.Key == 1 || keyValuePair.Key == 11)
        {
          if (keyValuePair.Key == 1)
          {
            this.TextExtCommandArgument_1.Visibility = Visibility.Visible;
            this.TextArgument_1_Label.Visibility = Visibility.Visible;
            this.TextArgument_1_Label.Content = (object) keyValuePair.Value;
            this.TextExtCommandArgument_1.ContextMenu = this.Argument1ValuesMenu;
          }
          if (keyValuePair.Key == 11)
            this.TextExtCommandArgument_1.Text = keyValuePair.Value;
        }
        if (keyValuePair.Key == 2 || keyValuePair.Key == 12)
        {
          if (keyValuePair.Key == 2)
          {
            this.TextExtCommandArgument_2.Visibility = Visibility.Visible;
            this.TextArgument_2_Label.Visibility = Visibility.Visible;
            this.TextArgument_2_Label.Content = (object) keyValuePair.Value;
            this.TextExtCommandArgument_2.ContextMenu = this.Argument2ValuesMenu;
          }
          if (keyValuePair.Key == 12)
            this.TextExtCommandArgument_2.Text = keyValuePair.Value;
        }
        if (keyValuePair.Key == 3 || keyValuePair.Key == 13)
        {
          if (keyValuePair.Key == 3)
          {
            this.TextExtCommandArgument_3.Visibility = Visibility.Visible;
            this.TextArgument_3_Label.Visibility = Visibility.Visible;
            this.TextArgument_3_Label.Content = (object) keyValuePair.Value;
            this.TextExtCommandArgument_3.ContextMenu = this.Argument3ValuesMenu;
          }
          if (keyValuePair.Key == 13)
            this.TextExtCommandArgument_3.Text = keyValuePair.Value;
        }
        if (keyValuePair.Key == 4 || keyValuePair.Key == 14)
        {
          if (keyValuePair.Key == 4)
          {
            this.TextExtCommandArgument_4.Visibility = Visibility.Visible;
            this.TextArgument_4_Label.Visibility = Visibility.Visible;
            this.TextArgument_4_Label.Content = (object) keyValuePair.Value;
            this.TextExtCommandArgument_4.ContextMenu = this.Argument4ValuesMenu;
          }
          if (keyValuePair.Key == 14)
            this.TextExtCommandArgument_4.Text = keyValuePair.Value;
        }
        if (keyValuePair.Key == 5 || keyValuePair.Key == 15)
        {
          if (keyValuePair.Key == 5)
          {
            this.TextExtCommandArgument_5.Visibility = Visibility.Visible;
            this.TextArgument_5_Label.Visibility = Visibility.Visible;
            this.TextArgument_5_Label.Content = (object) keyValuePair.Value;
            this.TextExtCommandArgument_5.ContextMenu = this.Argument5ValuesMenu;
          }
          if (keyValuePair.Key == 15)
            this.TextExtCommandArgument_5.Text = keyValuePair.Value;
        }
      }
    }

    private void SetArgumentFieldsValues(Dictionary<int, string> values)
    {
      if (values == null)
        return;
      foreach (KeyValuePair<int, string> keyValuePair in values)
      {
        if (keyValuePair.Key == 0)
          this.ComboAddCommand.SelectedItem = (object) keyValuePair.Value;
        if (keyValuePair.Key == 1)
          this.TextExtCommandArgument_1.Text = keyValuePair.Value;
        if (keyValuePair.Key == 2)
          this.TextExtCommandArgument_2.Text = keyValuePair.Value;
        if (keyValuePair.Key == 3)
          this.TextExtCommandArgument_3.Text = keyValuePair.Value;
        if (keyValuePair.Key == 4)
          this.TextExtCommandArgument_4.Text = keyValuePair.Value;
        if (keyValuePair.Key == 5)
          this.TextExtCommandArgument_5.Text = keyValuePair.Value;
      }
    }

    private async Task RunCommand()
    {
      string FC = this.ComboCommand.SelectedItem.ToString();
      string EFC = this.ComboExtCommand.SelectedItem.ToString();
      object addFC = this.ComboAddCommand.SelectedItem;
      string arg1 = string.IsNullOrEmpty(this.TextExtCommandArgument_1.Text) ? (string) null : this.TextExtCommandArgument_1.Text.Trim();
      string arg2 = string.IsNullOrEmpty(this.TextExtCommandArgument_2.Text) ? (string) null : this.TextExtCommandArgument_2.Text.Trim();
      string arg3 = string.IsNullOrEmpty(this.TextExtCommandArgument_3.Text) ? (string) null : this.TextExtCommandArgument_3.Text.Trim();
      string arg4 = string.IsNullOrEmpty(this.TextExtCommandArgument_4.Text) ? (string) null : this.TextExtCommandArgument_4.Text.Trim();
      string arg5 = string.IsNullOrEmpty(this.TextExtCommandArgument_5.Text) ? (string) null : this.TextExtCommandArgument_5.Text.Trim();
      this.mySpecialCommands.enDeCrypt = this.CheckBoxEncryption.IsChecked.Value;
      this.mySpecialCommands.AES_Key = this.TextBoxEncryptionKey.Text.Trim();
      try
      {
        if (FC.Contains("36"))
        {
          if (EFC.Contains(SpecialCommandWindow.CMD_GetVersion))
          {
            ushort version = await this.mySpecialCommands.GetSpecialCommandFCVersionAsync(this.progress, this.cancelTokenSource.Token);
            SpecialCommandWindow.result = SpecialCommandWindow.result + "\nSpecial Cmd FC version is " + version.ToString() + " (0x" + version.ToString("x4") + ")";
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_GetCurrentMeasuringMode))
          {
            byte[] mode = await this.mySpecialCommands.GetCurrentMeasuringModeAsync(this.progress, this.cancelTokenSource.Token);
            if (mode != null && mode.Length != 0)
              SpecialCommandWindow.result = SpecialCommandWindow.result + "\nCurrent measureing mode is " + BitConverter.ToUInt16(mode, 0).ToString() + " (0x" + BitConverter.ToUInt16(mode, 0).ToString("x2") + ")";
            else
              SpecialCommandWindow.result += "\nCurrent measureing mode brought no value back ";
            mode = (byte[]) null;
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_GetMetrologyParameters))
          {
            SpecialCommands.Metrology_Parameters parameter = await this.mySpecialCommands.GetSCMetrologyParametersAsync(this.progress, this.cancelTokenSource.Token);
            if (parameter != null)
            {
              SpecialCommandWindow.result = SpecialCommandWindow.result + "\nIdentity: " + BitConverter.ToUInt16(parameter.Identity, 0).ToString();
              SpecialCommandWindow.result = SpecialCommandWindow.result + "\nOptions: " + Utility.ByteArrayToHexString(parameter.Options);
            }
            else
              SpecialCommandWindow.result += "\nNO value returned by this functions !!!";
            parameter = (SpecialCommands.Metrology_Parameters) null;
          }
          ushort num1;
          if (EFC.Contains(SpecialCommandWindow.CMD_SetMetrologyParameters))
          {
            string str;
            if (!arg1.Contains("0x"))
            {
              str = arg1;
            }
            else
            {
              num1 = ushort.Parse(arg1.Substring(2), NumberStyles.HexNumber);
              str = num1.ToString();
            }
            arg1 = str;
            if (!string.IsNullOrEmpty(arg1))
            {
              arg2 = string.IsNullOrEmpty(arg2) ? "00" : arg2;
              byte[] identity = new byte[2];
              identity = !arg1.Contains("0x") ? Encoding.UTF8.GetBytes(arg1) : Utility.HexStringToByteArray(arg1);
              byte[] options = new byte[10];
              options = Encoding.UTF8.GetBytes(arg2);
              await this.mySpecialCommands.SetSCMetrologyParametersAsync(identity, options, this.progress, this.cancelTokenSource.Token);
              SpecialCommandWindow.result += "\nSetting Metrology Parameters ... Done.";
              identity = (byte[]) null;
              options = (byte[]) null;
            }
            else
              SpecialCommandWindow.result += "\nValue for Identity is not set !!!";
          }
          uint uint32;
          if (EFC.Contains(SpecialCommandWindow.CMD_SetProductFactor))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              string str;
              if (!arg1.Contains("0x"))
              {
                str = arg1;
              }
              else
              {
                uint32 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str = uint32.ToString();
              }
              arg1 = str;
              ushort Options = ushort.Parse(arg1);
              await this.mySpecialCommands.SetProductFactorAsync(BitConverter.GetBytes(Options), this.progress, this.cancelTokenSource.Token);
              SpecialCommandWindow.result += "\nSetting product factor ... Done.";
            }
            else
            {
              int num2 = (int) MessageBox.Show("Product factor was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_GetProductFactor))
          {
            byte[] mode = await this.mySpecialCommands.GetProductFactorAsync(this.progress, this.cancelTokenSource.Token);
            string[] strArray = new string[6]
            {
              SpecialCommandWindow.result,
              "\nCurrent product factor is ",
              null,
              null,
              null,
              null
            };
            num1 = BitConverter.ToUInt16(mode, 0);
            strArray[2] = num1.ToString();
            strArray[3] = " (0x";
            num1 = BitConverter.ToUInt16(mode, 0);
            strArray[4] = num1.ToString("x2");
            strArray[5] = ")";
            SpecialCommandWindow.result = string.Concat(strArray);
            mode = (byte[]) null;
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_SetSummertimeCountingSuppression))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              string str;
              if (!arg1.Contains("0x"))
              {
                str = arg1;
              }
              else
              {
                uint32 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str = uint32.ToString();
              }
              arg1 = str;
              ushort Options = ushort.Parse(arg1);
              await this.mySpecialCommands.SetSummertimeCountingSuppressionAsync(BitConverter.GetBytes(Options)[0], this.progress, this.cancelTokenSource.Token);
              SpecialCommandWindow.result += "\nSetting summertimecountingsuppression ... Done.";
            }
            else
            {
              int num3 = (int) MessageBox.Show("Product factor was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_GetSummertimeCountingSuppression))
          {
            byte mode = await this.mySpecialCommands.GetSummertimeCountingSuppressionAsync(this.progress, this.cancelTokenSource.Token);
            SpecialCommandWindow.result = SpecialCommandWindow.result + "\nSummertime counting suppression is " + mode.ToString() + " (0x" + mode.ToString("x2") + ")";
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_ClearFlowCheckStates))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              string str;
              if (!arg1.Contains("0x"))
              {
                str = arg1;
              }
              else
              {
                num1 = ushort.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str = num1.ToString();
              }
              arg1 = str;
              ushort state = ushort.Parse(arg1);
              await this.mySpecialCommands.ClearFlowCheckStatesAsync(state, this.progress, this.cancelTokenSource.Token);
              SpecialCommandWindow.result = SpecialCommandWindow.result + "\nClearing CheckState " + state.ToString() + " - Done.";
            }
            else
            {
              int num4 = (int) MessageBox.Show("Clearing CheckState was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_GetFlowCheckStates))
          {
            byte[] bytes = await this.mySpecialCommands.GetFlowCheckStateAsync(this.progress, this.cancelTokenSource.Token);
            EDC_Warning state = (EDC_Warning) BitConverter.ToUInt16(bytes, 0);
            string stateString = string.Join<Enum>(Environment.NewLine, state.GetIndividualFlags());
            string result = SpecialCommandWindow.result;
            num1 = (ushort) state;
            string str = num1.ToString("X4");
            SpecialCommandWindow.result = result + "\n0x" + str;
            SpecialCommandWindow.result = SpecialCommandWindow.result + "\n" + (string.IsNullOrEmpty(stateString.Trim()) ? "No bit set" : stateString);
            bytes = (byte[]) null;
            stateString = (string) null;
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_SetSDRules))
          {
            if (!string.IsNullOrEmpty(arg1) && !string.IsNullOrEmpty(arg2))
            {
              string str1;
              if (!arg1.Contains("0x"))
              {
                str1 = arg1;
              }
              else
              {
                uint32 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str1 = uint32.ToString();
              }
              arg1 = str1;
              string str2;
              if (!arg2.Contains("0x"))
              {
                str2 = arg2;
              }
              else
              {
                uint32 = uint.Parse(arg2.Substring(2), NumberStyles.HexNumber);
                str2 = uint32.ToString();
              }
              arg2 = str2;
              string str3;
              if (!arg3.Contains("0x"))
              {
                str3 = arg3;
              }
              else
              {
                uint32 = uint.Parse(arg3.Substring(2), NumberStyles.HexNumber);
                str3 = uint32.ToString();
              }
              arg3 = str3;
              uint Options = uint.Parse(arg3);
              await this.mySpecialCommands.SetSDRulesAsync(byte.Parse(arg1), byte.Parse(arg2), BitConverter.GetBytes(Options), this.progress, this.cancelTokenSource.Token);
              SpecialCommandWindow.result += "\nSetting rules ... Done.";
            }
            else
            {
              int num5 = (int) MessageBox.Show("Configuration Rules was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_GetSDRules))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              string str;
              if (!arg1.Contains("0x"))
              {
                str = arg1;
              }
              else
              {
                uint32 = uint.Parse(arg1.Substring(2), NumberStyles.HexNumber);
                str = uint32.ToString();
              }
              arg1 = str;
              SpecialCommands.SD_Rules_Options rules = await this.mySpecialCommands.GetSDRulesAsync(byte.Parse(arg1), this.progress, this.cancelTokenSource.Token);
              string[] strArray = new string[14]
              {
                SpecialCommandWindow.result,
                "\nConfiguration rules are: \nSelection : ",
                rules.Selection.ToString(),
                " (0x",
                rules.Selection.ToString("x2"),
                ")\nFlag : ",
                rules.Flag.ToString(),
                " (0x",
                rules.Flag.ToString("x2"),
                ")\nOptions : ",
                null,
                null,
                null,
                null
              };
              uint32 = BitConverter.ToUInt32(rules.options, 0);
              strArray[10] = uint32.ToString();
              strArray[11] = " (0x";
              strArray[12] = Util.ByteArrayToHexString(rules.options);
              strArray[13] = ")";
              SpecialCommandWindow.result = string.Concat(strArray);
              rules = (SpecialCommands.SD_Rules_Options) null;
            }
            else
            {
              int num6 = (int) MessageBox.Show("Configuration Rules was not set correctly!\nPlease set a correct value and try again.");
            }
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_SendNfc2Device))
          {
            if (!string.IsNullOrEmpty(arg1))
            {
              byte[] NFCrequest = Util.HexStringToByteArray(arg1);
              byte[] retVal = await this.mySpecialCommands.SendToNfcDeviceAsync(NFCrequest, this.progress, this.cancelTokenSource.Token);
              SpecialCommandWindow.result += Util.ByteArrayToHexString(retVal);
              NFCrequest = (byte[]) null;
              retVal = (byte[]) null;
            }
            else
            {
              int num7 = (int) MessageBox.Show("NFC command not set.");
            }
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_GetNfcDeviceIdentification))
          {
            byte[] NFCrequest = new byte[6];
            if (!string.IsNullOrEmpty(arg1))
              NFCrequest = Util.HexStringToByteArray(arg1);
            SpecialCommands.NFC_Identification devIdent = await this.mySpecialCommands.GetNfcDeviceIdentification(NFCrequest, this.progress, this.cancelTokenSource.Token);
            SpecialCommandWindow.result = SpecialCommandWindow.result + "\nNFC_Identification: \nIdentification response Selection : (0x" + devIdent.IdentificationResponseVersion.ToString("x2") + ")\nNFC protocol version : (0x" + devIdent.NFCProtocolVersion.ToString("x2") + ")\nMBus Medium : (0x" + devIdent.MBusMedium.ToString("x2") + ")\nOBIS Medium : (0x" + devIdent.OBISMedium.ToString("x2") + ")\nManufacturer: (0x" + Util.ByteArrayToHexString(devIdent.Manufacturer) + ")\nGeneration : (0x" + devIdent.Generation.ToString("x2") + ")\nSerial number : (0x" + Util.ByteArrayToHexString(devIdent.Serialnumber) + ")\nHardwareIdentification : (0x" + Util.ByteArrayToHexString(devIdent.HardwareIdentification) + ")\nSystemState : (0x" + Util.ByteArrayToHexString(devIdent.SystemState) + ")\nSystemInfos : (0x" + Util.ByteArrayToHexString(devIdent.SystemInfos) + ")\nFirmwareVersion : (0x" + Util.ByteArrayToHexString(devIdent.FirmwareVersion) + ")\nMeterID : " + devIdent.MeterID.ToString() + "\nBuildRevision : " + devIdent.BuildRevision.ToString() + "\nBuildTime : " + devIdent.BuildTime.ToString() + "\nCompilerVersion : " + devIdent.CompilerVersion.ToString() + "\nFirmwareSignature : " + devIdent.FirmwareSignature.ToString() + "\nNumberOfAvailableParameterGroups : (0x" + devIdent.NumberOfAvailableParameterGroups.ToString("x2") + ")\nNumberOfAvailableParameters : " + devIdent.NumberOfAvailableParameters.ToString() + "\nNumberOfSelectedParameterGroups : (0x" + devIdent.NumberOfSelectedParameterGroups.ToString("x2") + ")\nNumberOfSelectedParameters : " + devIdent.NumberOfSelectedParameters.ToString() + "\nMaximum record length : (0x" + devIdent.MaximumRecordLength.ToString("x2") + ")";
            NFCrequest = (byte[]) null;
            devIdent = (SpecialCommands.NFC_Identification) null;
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_SetReligiousDay))
          {
            byte[] Data = new byte[0];
            if (!string.IsNullOrEmpty(arg1))
              Data = Util.HexStringToByteArray(arg1);
            if (Data.Length == 0 || Data.Length > 2)
            {
              int num8 = (int) MessageBox.Show("Wrong Argument");
              FC = (string) null;
              EFC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              arg4 = (string) null;
              arg5 = (string) null;
              return;
            }
            if (Data[0] != (byte) 0 || Data[0] != (byte) 1)
            {
              int num9 = (int) MessageBox.Show("Wrong Argument");
              FC = (string) null;
              EFC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              arg4 = (string) null;
              arg5 = (string) null;
              return;
            }
            await this.mySpecialCommands.SetReligiousDay(Data, this.progress, this.cancelTokenSource.Token);
            SpecialCommandWindow.result += "\nSuccess";
            Data = (byte[]) null;
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_SetSmartFunctions))
          {
            if (string.IsNullOrEmpty(arg1))
            {
              int num10 = (int) MessageBox.Show("SmartFunctionCode is null");
              FC = (string) null;
              EFC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              arg4 = (string) null;
              arg5 = (string) null;
              return;
            }
            byte Code = byte.Parse(arg1);
            byte[] CmdData = new byte[13];
            CmdData[0] = Code;
            string[] Splits = arg2.Split(new char[1]{ ';' }, StringSplitOptions.RemoveEmptyEntries);
            for (int i = 0; i < 6; ++i)
            {
              byte[] data = new byte[2];
              if (i < Splits.Length)
                data = !Splits[i].Contains("-") ? BitConverter.GetBytes(ushort.Parse(Splits[i])) : BitConverter.GetBytes(short.Parse(Splits[i]));
              Array.Copy((Array) data, 0, (Array) CmdData, i * 2 + 1, 2);
              data = (byte[]) null;
            }
            await this.mySpecialCommands.SetSmartFunctions(CmdData, this.progress, this.cancelTokenSource.Token);
            SpecialCommandWindow.result += "\nSet smart functions done.";
            CmdData = (byte[]) null;
            Splits = (string[]) null;
          }
          if (EFC.Contains(SpecialCommandWindow.CMD_GetSmartFunctions))
          {
            if (string.IsNullOrEmpty(arg1))
            {
              int num11 = (int) MessageBox.Show("SmartFunctionCode is null");
              FC = (string) null;
              EFC = (string) null;
              addFC = (object) null;
              arg1 = (string) null;
              arg2 = (string) null;
              arg3 = (string) null;
              arg4 = (string) null;
              arg5 = (string) null;
              return;
            }
            byte Code = byte.Parse(arg1);
            byte[] ReturnData = await this.mySpecialCommands.GetSmartFunctions(Code, this.progress, this.cancelTokenSource.Token);
            if (Code == (byte) 0)
            {
              SpecialCommandWindow.result = SpecialCommandWindow.result + "\nSmart function codes implemented in the device:" + Environment.NewLine;
              for (int i = 1; i < ReturnData.Length; ++i)
                SpecialCommandWindow.result = SpecialCommandWindow.result + ReturnData[i].ToString("X2") + " ";
            }
            else
            {
              if (ReturnData.Length != 13)
              {
                int num12 = (int) MessageBox.Show("Return data wrong");
                FC = (string) null;
                EFC = (string) null;
                addFC = (object) null;
                arg1 = (string) null;
                arg2 = (string) null;
                arg3 = (string) null;
                arg4 = (string) null;
                arg5 = (string) null;
                return;
              }
              SpecialCommandWindow.result = SpecialCommandWindow.result + "\nSmart function code:" + ReturnData[0].ToString("X2") + Environment.NewLine;
              string[] NameList = new string[6]
              {
                "A",
                "B",
                "C",
                "D",
                "E",
                "F"
              };
              for (int i = 0; i < 6; ++i)
              {
                if (i > 0)
                  SpecialCommandWindow.result += Environment.NewLine;
                SpecialCommandWindow.result = SpecialCommandWindow.result + "Parameter " + NameList[i] + ":" + ReturnData[2 * i + 2].ToString("X2") + " " + ReturnData[2 * i + 1].ToString("X2");
              }
              NameList = (string[]) null;
            }
            ReturnData = (byte[]) null;
          }
        }
        if (string.IsNullOrEmpty(SpecialCommandWindow.result))
        {
          FC = (string) null;
          EFC = (string) null;
          addFC = (object) null;
          arg1 = (string) null;
          arg2 = (string) null;
          arg3 = (string) null;
          arg4 = (string) null;
          arg5 = (string) null;
        }
        else
        {
          this.TextBoxUniversalCommandResult.Text = SpecialCommandWindow.result;
          FC = (string) null;
          EFC = (string) null;
          addFC = (object) null;
          arg1 = (string) null;
          arg2 = (string) null;
          arg3 = (string) null;
          arg4 = (string) null;
          arg5 = (string) null;
        }
      }
      catch (Exception ex)
      {
        SpecialCommandWindow.result = SpecialCommandWindow.result + "\nFunction (" + EFC + ") \nERROR: " + ex.Message;
        this.TextBoxUniversalCommandResult.Text = SpecialCommandWindow.result;
        FC = (string) null;
        EFC = (string) null;
        addFC = (object) null;
        arg1 = (string) null;
        arg2 = (string) null;
        arg3 = (string) null;
        arg4 = (string) null;
        arg5 = (string) null;
      }
    }

    private void mi_Click(object sender, RoutedEventArgs e)
    {
      ((TextBox) ((FrameworkElement) sender).Tag).Text = ((HeaderedItemsControl) sender).Header.ToString();
    }

    private void updateContextMenu1(string packet)
    {
      if (!this.Argument1_last_values.Contains(packet))
        this.Argument1_last_values.Add(packet);
      this.Argument1ValuesMenu.Items.Clear();
      if (this.Argument1_last_values.Count > 20)
        this.Argument1_last_values.RemoveRange(0, this.Argument1_last_values.Count - 20);
      foreach (string argument1LastValue in this.Argument1_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument1LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_1;
        this.Argument1ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu2(string packet)
    {
      if (!this.Argument2_last_values.Contains(packet))
        this.Argument2_last_values.Add(packet);
      this.Argument2ValuesMenu.Items.Clear();
      if (this.Argument2_last_values.Count > 20)
        this.Argument2_last_values.RemoveRange(0, this.Argument2_last_values.Count - 20);
      foreach (string argument2LastValue in this.Argument2_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument2LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_2;
        this.Argument2ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu3(string packet)
    {
      if (!this.Argument3_last_values.Contains(packet))
        this.Argument3_last_values.Add(packet);
      this.Argument3ValuesMenu.Items.Clear();
      if (this.Argument3_last_values.Count > 20)
        this.Argument3_last_values.RemoveRange(0, this.Argument3_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_3;
        this.Argument3ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu4(string packet)
    {
      if (!this.Argument4_last_values.Contains(packet))
        this.Argument4_last_values.Add(packet);
      this.Argument4ValuesMenu.Items.Clear();
      if (this.Argument4_last_values.Count > 20)
        this.Argument4_last_values.RemoveRange(0, this.Argument4_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_4;
        this.Argument4ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void updateContextMenu5(string packet)
    {
      if (!this.Argument5_last_values.Contains(packet))
        this.Argument5_last_values.Add(packet);
      this.Argument5ValuesMenu.Items.Clear();
      if (this.Argument5_last_values.Count > 20)
        this.Argument5_last_values.RemoveRange(0, this.Argument5_last_values.Count - 20);
      foreach (string argument3LastValue in this.Argument3_last_values)
      {
        MenuItem newItem = new MenuItem();
        newItem.Header = (object) argument3LastValue;
        newItem.Click += new RoutedEventHandler(this.mi_Click);
        newItem.Tag = (object) this.TextExtCommandArgument_5;
        this.Argument5ValuesMenu.Items.Add((object) newItem);
      }
    }

    private void CheckBoxEncryption_Checked(object sender, RoutedEventArgs e)
    {
      this.mySpecialCommands.enDeCrypt = true;
      this.TextBoxEncryptionKey.Visibility = Visibility.Visible;
      this.EncryptionKey_Label.Visibility = Visibility.Visible;
    }

    private void CheckBoxEncryption_UnChecked(object sender, RoutedEventArgs e)
    {
      this.mySpecialCommands.enDeCrypt = false;
      this.TextBoxEncryptionKey.Visibility = Visibility.Collapsed;
      this.EncryptionKey_Label.Visibility = Visibility.Collapsed;
    }

    private void TextBoxEncryptionKey_TextChanged(object sender, TextChangedEventArgs e)
    {
      this.mySpecialCommands.AES_Key = this.TextBoxEncryptionKey.Text;
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/commandwindowspecial.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.TextBlockStatus = (TextBlock) target;
          break;
        case 2:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        case 3:
          this.TextBoxUniversalCommandResult = (TextBox) target;
          break;
        case 4:
          this.StackPanalButtons = (StackPanel) target;
          break;
        case 5:
          this.ComboCommand = (ComboBox) target;
          this.ComboCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboCommand_SelectionChanged);
          break;
        case 6:
          this.CheckBoxEncryption = (CheckBox) target;
          this.CheckBoxEncryption.Checked += new RoutedEventHandler(this.CheckBoxEncryption_Checked);
          this.CheckBoxEncryption.Unchecked += new RoutedEventHandler(this.CheckBoxEncryption_UnChecked);
          break;
        case 7:
          this.EncryptionKey_Label = (Label) target;
          break;
        case 8:
          this.TextBoxEncryptionKey = (TextBox) target;
          this.TextBoxEncryptionKey.TextChanged += new TextChangedEventHandler(this.TextBoxEncryptionKey_TextChanged);
          break;
        case 9:
          this.ComboExtCommand_Label = (Label) target;
          break;
        case 10:
          this.ComboExtCommand = (ComboBox) target;
          this.ComboExtCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboExtCommand_SelectionChanged);
          break;
        case 11:
          this.ComboAddCommand_Label = (Label) target;
          break;
        case 12:
          this.ComboAddCommand = (ComboBox) target;
          this.ComboAddCommand.SelectionChanged += new SelectionChangedEventHandler(this.ComboAddCommand_SelectionChanged);
          break;
        case 13:
          this.TextArgument_1_Label = (Label) target;
          break;
        case 14:
          this.TextExtCommandArgument_1 = (TextBox) target;
          break;
        case 15:
          this.TextArgument_2_Label = (Label) target;
          break;
        case 16:
          this.TextExtCommandArgument_2 = (TextBox) target;
          break;
        case 17:
          this.TextArgument_3_Label = (Label) target;
          break;
        case 18:
          this.TextExtCommandArgument_3 = (TextBox) target;
          break;
        case 19:
          this.TextArgument_4_Label = (Label) target;
          break;
        case 20:
          this.TextExtCommandArgument_4 = (TextBox) target;
          break;
        case 21:
          this.TextArgument_5_Label = (Label) target;
          break;
        case 22:
          this.TextExtCommandArgument_5 = (TextBox) target;
          break;
        case 23:
          this.StackPanalButtons2 = (StackPanel) target;
          break;
        case 24:
          this.ButtonRunCommand = (Button) target;
          this.ButtonRunCommand.Click += new RoutedEventHandler(this.ButtonRunCommand_Click);
          break;
        case 25:
          this.ButtonRunCommandPreview = (Button) target;
          this.ButtonRunCommandPreview.Click += new RoutedEventHandler(this.ButtonRunCommandPreview_Click);
          break;
        case 26:
          this.ButtonBreak = (Button) target;
          this.ButtonBreak.Click += new RoutedEventHandler(this.ButtonBreak_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- SubCommands_FC.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SubCommands_FC
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum SubCommands_FC : byte
  {
    CommonRadioCommands_0x2f = 47, // 0x2F
    CommonMBusCommands_0x34 = 52, // 0x34
    CommonLoRaCommands_0x35 = 53, // 0x35
    SpecialCommands_0x36 = 54, // 0x36
    CommonNBIoTCommands_0x37 = 55, // 0x37
    SendNfcCommand_0x38 = 56, // 0x38
  }
}


--- SystemInfo.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.SystemInfo
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  [Flags]
  public enum SystemInfo : uint
  {
    SYS_INFO_ERROR_MASK = 4278190080, // 0xFF000000
    SYS_INFO_ALERT_MASK = 16711680, // 0x00FF0000
    SYS_INFO_WARNING_MASK = 65535, // 0x0000FFFF
    BatteryDown = 2147483648, // 0x80000000
    TDC_Error = 1073741824, // 0x40000000
    AccumulatedDataLost = 536870912, // 0x20000000
    NoWater = 8388608, // 0x00800000
    Bubbles = 4194304, // 0x00400000
    CRC_ErrorConfiguration = 131072, // 0x00020000
    CRC_ErrorFirmware = 65536, // 0x00010000
    FlowRateOutOfRange = 32768, // 0x00008000
    TemperatureOutOfRange = 16384, // 0x00004000
    ReverseFlow = 8192, // 0x00002000
    TestViewActive = 4096, // 0x00001000
    TemperatureSensorDefect = 2048, // 0x00000800
    UltrasonicChannel2_Corrupt = 1024, // 0x00000400
    UltrasonicChannel1_Corrupt = 512, // 0x00000200
    WriteProtectionNotActive = 256, // 0x00000100
    BatteryUnderVoltage = 128, // 0x00000080
    BatteryLiveTimeOver = 64, // 0x00000040
    DisplayInterpreterError = 32, // 0x00000020
    NFC_TAG_fault = 16, // 0x00000010
    Sleep = 8,
    ScenarioNotSupported = 2,
    SmartFunctionEventDisplayed = 1,
  }
}


--- TemperatureSensorParameters.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.TemperatureSensorParameters
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public class TemperatureSensorParameters
  {
    public int NominalResistorValue;
    public double T1;
    public double R1;
    public double T2;
    public double R2;
    public double T3;
    public double R3;
    public double R0;
    public double A;
    public double B;
    public double T1Set;
    public double T2Set;
    public double T3Set;
  }
}


--- Test_Mode.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.Test_Mode
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum Test_Mode
  {
    TEST_MODE_TDC_LEVEL_TEST = 81, // 0x00000051
  }
}


--- Test_State.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.Test_State
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum Test_State
  {
    TEST_STATE_OFF,
    TEST_STATE_ORDER_START,
    TEST_STATE_RUNNING,
    TEST_STATE_ORDER_STOP,
    TEST_STATE_STOPPED,
  }
}


--- TestCommunicationWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.TestCommunicationWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.UserInterface;
using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Media;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class TestCommunicationWindow : Window, IComponentConnector
  {
    private bool isRunning;
    private bool isInit;
    private CancellationTokenSource cancelToken;
    private ProgressHandler progress;
    public BaseMemoryAccess DeviceCommands;
    public CommunicationPortWindowFunctions myPort;
    internal ConfigList usedConfigList;
    private Brush DefaultBackground;
    private Brush ChangedBackground;
    internal TextBlock TextBlockStatus;
    internal ProgressBar ProgressBar1;
    internal TextBox TextBlockResult;
    internal WrapPanel PanalButtons;
    internal TextBox TextBoxCyles;
    internal TextBox TextBoxCycleSuccessful;
    internal TextBox TextBoxCycleFailed;
    internal WrapPanel PanalButtons2;
    internal TextBox TextBoxCycleStopAfterErrors;
    internal TextBox TextBoxCycleTime;
    internal WrapPanel PanalButtons3;
    internal CheckBox CheckBoxHaltOnFirst;
    internal CheckBox CheckBoxRunCyle;
    internal CheckBox CheckBoxInterruptConnection;
    internal StackPanel StackPanalButtons2;
    internal StackPanel StackPanalButton3;
    internal Button ButtonRunCommand;
    internal Button ButtonBreak;
    private bool _contentLoaded;

    public TestCommunicationWindow()
    {
      this.InitializeComponent();
      this.isRunning = false;
      this.isInit = true;
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
      this.TextBoxCyles.Text = "0";
      this.TextBoxCycleFailed.Text = "0";
      this.TextBoxCycleSuccessful.Text = "0";
      this.TextBoxCycleStopAfterErrors.Text = "3";
      this.TextBoxCycleTime.Text = "200";
      this.DefaultBackground = this.TextBoxCycleTime.Background;
      this.ChangedBackground = (Brush) Brushes.Yellow;
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.ProgressBar1.Value = obj.ProgressPercentage;
        this.TextBlockStatus.Text = obj.Message;
      }
    }

    private void Window_Closing(object sender, CancelEventArgs e)
    {
      if (this.cancelToken == null)
        return;
      this.cancelToken.Cancel();
    }

    public static void Show(CommunicationPortWindowFunctions port, BaseMemoryAccess deviceCommands)
    {
      TestCommunicationWindow communicationWindow = new TestCommunicationWindow()
      {
        DeviceCommands = deviceCommands,
        myPort = port
      };
      communicationWindow.usedConfigList = port.GetReadoutConfiguration();
      communicationWindow.TextBoxCycleTime.Text = communicationWindow.usedConfigList.CycleTime.ToString();
      communicationWindow.isInit = false;
      communicationWindow.ShowDialog();
    }

    private void ButtonBreak_Click(object sender, RoutedEventArgs e)
    {
      if (this.cancelToken == null)
        return;
      this.cancelToken.Cancel();
      this.isRunning = false;
    }

    private async void ButtonRunCommand_Click(object sender, RoutedEventArgs e)
    {
      this.ButtonRunCommand.IsEnabled = false;
      this.TextBoxCycleStopAfterErrors.IsReadOnly = true;
      this.CheckBoxHaltOnFirst.IsEnabled = false;
      await this.RunCommand();
      this.ButtonRunCommand.IsEnabled = true;
      this.TextBoxCycleStopAfterErrors.IsReadOnly = false;
      this.CheckBoxHaltOnFirst.IsEnabled = true;
    }

    private async Task RunCommand()
    {
      if (this.isRunning)
        return;
      this.TextBlockResult.Text = string.Empty;
      this.isRunning = true;
      this.cancelToken = new CancellationTokenSource();
      int count = 0;
      int successful = 0;
      int failed = 0;
      int maxFails = int.Parse(this.TextBoxCycleStopAfterErrors.Text);
      this.SetValuesForProgress(0, 0, 0);
      DateTime startTime = DateTime.Now;
      while (!this.cancelToken.IsCancellationRequested)
      {
        if (count % 100 == 0)
          this.progress.Reset(100);
        try
        {
          if (maxFails == failed)
          {
            this.TextBlockStatus.Text = "STOPPED ... TO MANY FAILURES ...";
            break;
          }
          DeviceIdentification version = await this.DeviceCommands.ReadVersionAsync(this.progress, this.cancelToken.Token);
          ++successful;
          if (this.CheckBoxInterruptConnection.IsChecked.Value)
            await this.DeviceCommands.InterruptConnection(this.progress, this.cancelToken.Token);
          if (this.usedConfigList.CycleTime > 0)
          {
            startTime = startTime.AddMilliseconds((double) this.usedConfigList.CycleTime);
            int wait_ms = (int) (startTime - DateTime.Now).TotalMilliseconds;
            string versionPrint = version.Print();
            this.TextBlockResult.Text = "Wait ms: " + wait_ms.ToString() + Environment.NewLine + versionPrint;
            if (wait_ms > 0)
              await Task.Delay(wait_ms);
            else
              startTime = DateTime.Now;
            versionPrint = (string) null;
          }
          else
            this.TextBlockResult.Text = version.Print();
          version = (DeviceIdentification) null;
        }
        catch (OperationCanceledException ex)
        {
          this.progress.Reset("Canceled");
          break;
        }
        catch (Exception ex)
        {
          this.TextBlockResult.Text = ex.Message;
          ++failed;
        }
        finally
        {
          this.isRunning = false;
        }
        this.SetValuesForProgress(++count, successful, failed);
        if (!this.CheckBoxRunCyle.IsChecked.Value)
          break;
      }
    }

    public void SetValuesForProgress(int cycle, int success, int fail)
    {
      this.TextBoxCyles.Text = cycle.ToString();
      this.TextBoxCycleSuccessful.Text = success.ToString();
      this.TextBoxCycleFailed.Text = fail.ToString();
    }

    private void TextBoxCycleTime_LostFocus(object sender, RoutedEventArgs e)
    {
      if (this.isInit)
        return;
      string text = this.TextBoxCycleTime.Text;
      int result = 200;
      if (int.TryParse(text, out result) && result != this.usedConfigList.CycleTime)
        this.usedConfigList.CycleTime = result;
    }

    private void TextBoxCycleTime_KeyDown(object sender, KeyEventArgs e)
    {
      if (e.Key == Key.Return)
      {
        string text = this.TextBoxCycleTime.Text;
        int result = 200;
        if (!int.TryParse(text, out result) || result == this.usedConfigList.CycleTime)
          return;
        this.usedConfigList.CycleTime = result;
        this.TextBoxCycleTime.Background = this.DefaultBackground;
      }
      else
        this.TextBoxCycleTime.Background = this.ChangedBackground;
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/testcommunicationwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          ((Window) target).Closing += new CancelEventHandler(this.Window_Closing);
          break;
        case 2:
          this.TextBlockStatus = (TextBlock) target;
          break;
        case 3:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        case 4:
          this.TextBlockResult = (TextBox) target;
          break;
        case 5:
          this.PanalButtons = (WrapPanel) target;
          break;
        case 6:
          this.TextBoxCyles = (TextBox) target;
          break;
        case 7:
          this.TextBoxCycleSuccessful = (TextBox) target;
          break;
        case 8:
          this.TextBoxCycleFailed = (TextBox) target;
          break;
        case 9:
          this.PanalButtons2 = (WrapPanel) target;
          break;
        case 10:
          this.TextBoxCycleStopAfterErrors = (TextBox) target;
          break;
        case 11:
          this.TextBoxCycleTime = (TextBox) target;
          this.TextBoxCycleTime.LostFocus += new RoutedEventHandler(this.TextBoxCycleTime_LostFocus);
          this.TextBoxCycleTime.KeyDown += new KeyEventHandler(this.TextBoxCycleTime_KeyDown);
          break;
        case 12:
          this.PanalButtons3 = (WrapPanel) target;
          break;
        case 13:
          this.CheckBoxHaltOnFirst = (CheckBox) target;
          break;
        case 14:
          this.CheckBoxRunCyle = (CheckBox) target;
          break;
        case 15:
          this.CheckBoxInterruptConnection = (CheckBox) target;
          break;
        case 16:
          this.StackPanalButtons2 = (StackPanel) target;
          break;
        case 17:
          this.StackPanalButton3 = (StackPanel) target;
          break;
        case 18:
          this.ButtonRunCommand = (Button) target;
          this.ButtonRunCommand.Click += new RoutedEventHandler(this.ButtonRunCommand_Click);
          break;
        case 19:
          this.ButtonBreak = (Button) target;
          this.ButtonBreak.Click += new RoutedEventHandler(this.ButtonBreak_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- TimeControl.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.TimeControl
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;

#nullable disable
namespace HandlerLib
{
  public class TimeControl : UserControl, IComponentConnector
  {
    internal TextBox txtHours;
    internal TextBox txtMinutes;
    internal TextBox txtSeconds;
    private bool _contentLoaded;

    public TimeControl() => this.InitializeComponent();

    public DateTime? DateTimeValue
    {
      get
      {
        DateTime result;
        return DateTime.TryParse(string.Format("{0:00}:{1:00}:{2:00}", (object) this.txtHours.Text, (object) this.txtMinutes.Text, (object) this.txtSeconds.Text), out result) ? new DateTime?(result) : new DateTime?();
      }
      set
      {
        DateTime? nullable = value;
        if (!nullable.HasValue)
          return;
        this.txtHours.Text = nullable.Value.Hour.ToString("00");
        this.txtMinutes.Text = nullable.Value.Minute.ToString("00");
        this.txtSeconds.Text = nullable.Value.Second.ToString("00");
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/util/timecontrol.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.txtHours = (TextBox) target;
          break;
        case 2:
          this.txtMinutes = (TextBox) target;
          break;
        case 3:
          this.txtSeconds = (TextBox) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- TimeZoneSupport.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.TimeZoneSupport
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;

#nullable disable
namespace HandlerLib
{
  public class TimeZoneSupport
  {
    public DateTimeOffset TimeZoneTime;

    public TimeZoneSupport(DateTimeOffset timeZoneTime) => this.TimeZoneTime = timeZoneTime;

    public TimeZoneSupport(DateTime theTime, byte timeZoneByte)
    {
      int num = (int) (sbyte) timeZoneByte;
      int hours = num / 4;
      int minutes = (num - hours * 4) * 15;
      TimeSpan offset = new TimeSpan(hours, minutes, 0);
      this.TimeZoneTime = new DateTimeOffset(theTime, offset);
    }

    public TimeZoneSupport(DateTime theTime, Decimal timeZone)
    {
      int hours = (int) timeZone;
      int minutes = (int) ((timeZone - (Decimal) hours) * 60M);
      TimeSpan offset = new TimeSpan(hours, minutes, 0);
      this.TimeZoneTime = new DateTimeOffset(theTime, offset);
    }

    public TimeZoneSupport(Decimal timeZone)
    {
      DateTime dateTime = new DateTime(DateTime.Now.ToUniversalTime().Ticks);
      int hours = (int) timeZone;
      int minutes = (int) ((timeZone - (Decimal) hours) * 60M);
      TimeSpan offset = new TimeSpan(hours, minutes, 0);
      this.TimeZoneTime = new DateTimeOffset(dateTime + offset, offset);
    }

    public byte GetTimeZoneAsByte() => (byte) (sbyte) (this.TimeZoneTime.Offset.TotalHours * 4.0);

    public Decimal GetTimeZoneAsDecimal() => (Decimal) this.TimeZoneTime.Offset.TotalHours;

    public override string ToString() => this.TimeZoneTime.ToString();
  }
}


--- TypeEditorWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.TypeEditorWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using GmmDbLib;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;

#nullable disable
namespace HandlerLib
{
  public class TypeEditorWindow : Window, IComponentConnector
  {
    private string[] hardwareName;
    private byte[] compressedData;
    private BaseType baseType;
    private int? meterInfoID;
    internal ComboBox ComboBoxHardwareType;
    internal TextBox TextBoxSapNumber;
    internal TextBox TextBoxDescription;
    internal TextBox TextBoxTypeCreationString;
    internal CheckBox CheckBoxBASETYPE;
    internal Button ButtonCreate;
    internal Button ButtonSave;
    private bool _contentLoaded;

    private TypeEditorWindow() => this.InitializeComponent();

    public static int? ShowDialog(
      Window owner,
      string hardwareName,
      BaseType baseType,
      byte[] compressedData,
      string newTypeCreationString = null)
    {
      return TypeEditorWindow.ShowDialog(owner, new string[1]
      {
        hardwareName
      }, baseType, compressedData, newTypeCreationString);
    }

    public static int? ShowDialog(
      Window owner,
      string[] hardwareName,
      BaseType baseType,
      byte[] compressedData,
      string newTypeCreationString = null)
    {
      List<HardwareType> hardwareTypeList = HardwareType.LoadHardwareType(hardwareName);
      TypeEditorWindow typeEditorWindow = new TypeEditorWindow();
      typeEditorWindow.Owner = owner;
      typeEditorWindow.baseType = baseType;
      typeEditorWindow.hardwareName = hardwareName;
      typeEditorWindow.compressedData = compressedData;
      typeEditorWindow.ComboBoxHardwareType.ItemsSource = (IEnumerable) hardwareTypeList;
      typeEditorWindow.ButtonSave.IsEnabled = baseType != null;
      if (baseType != null)
      {
        typeEditorWindow.TextBoxSapNumber.Text = baseType.MeterInfo.PPSArtikelNr;
        typeEditorWindow.TextBoxDescription.Text = baseType.MeterInfo.Description;
        typeEditorWindow.TextBoxTypeCreationString.Text = baseType.Data.TypeCreationString;
        if (hardwareTypeList != null)
          typeEditorWindow.ComboBoxHardwareType.SelectedItem = (object) hardwareTypeList.Find((Predicate<HardwareType>) (x => x.HardwareTypeID == baseType.MeterInfo.HardwareTypeID));
      }
      if (newTypeCreationString != null)
        typeEditorWindow.TextBoxTypeCreationString.Text = newTypeCreationString;
      bool? nullable = typeEditorWindow.ShowDialog();
      bool flag = false;
      return nullable.GetValueOrDefault() == flag & nullable.HasValue ? new int?() : typeEditorWindow.meterInfoID;
    }

    private void ButtonCreate_Click(object sender, RoutedEventArgs e)
    {
      if (string.IsNullOrEmpty(this.TextBoxSapNumber.Text.Trim()))
      {
        int num1 = (int) MessageBox.Show((Window) this, "SAP Number can not be empty!", "SAP Number", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      else if (!(this.ComboBoxHardwareType.SelectedItem is HardwareType selectedItem))
      {
        int num2 = (int) MessageBox.Show((Window) this, "Hardware type is not selected!", "Hardware type", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      else if (string.IsNullOrEmpty(this.TextBoxDescription.Text.Trim()))
      {
        int num3 = (int) MessageBox.Show((Window) this, "Description can not be empty!", "Description", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      else
      {
        if (!string.IsNullOrEmpty(this.TextBoxTypeCreationString.Text.Trim()))
        {
          try
          {
            OverwriteSupport.PrepareOverwriteData(this.TextBoxTypeCreationString.Text);
          }
          catch (Exception ex)
          {
            int num4 = (int) MessageBox.Show((Window) this, ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
            return;
          }
        }
        try
        {
          int meterHardwareId = this.baseType == null || this.baseType.MeterInfo == null ? 0 : this.baseType.MeterInfo.MeterHardwareID;
          this.meterInfoID = BaseType.CreateType(selectedItem.HardwareName, this.TextBoxSapNumber.Text.Trim(), selectedItem.HardwareTypeID, meterHardwareId, this.TextBoxDescription.Text.Trim(), this.compressedData, this.TextBoxTypeCreationString.Text, this.CheckBoxBASETYPE.IsChecked.Value);
        }
        catch (Exception ex)
        {
          int num5 = (int) MessageBox.Show((Window) this, ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
        }
        this.DialogResult = new bool?(true);
        this.Close();
      }
    }

    private void ButtonSave_Click(object sender, RoutedEventArgs e)
    {
      if (this.baseType == null || this.baseType.MeterInfo == null || this.baseType.MeterInfo.MeterInfoID == 0)
      {
        int num1 = (int) MessageBox.Show((Window) this, "Invalid BaseType!", "BaseType error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      else if (string.IsNullOrEmpty(this.TextBoxSapNumber.Text.Trim()))
      {
        int num2 = (int) MessageBox.Show((Window) this, "SAP Number can not be empty!", "SAP Number", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      else if (!(this.ComboBoxHardwareType.SelectedItem is HardwareType selectedItem))
      {
        int num3 = (int) MessageBox.Show((Window) this, "Hardware type is not selected!", "Hardware type", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      else if (string.IsNullOrEmpty(this.TextBoxDescription.Text.Trim()))
      {
        int num4 = (int) MessageBox.Show((Window) this, "Description can not be empty!", "Description", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      else
      {
        try
        {
          int? meterTypeID = this.baseType.MeterType != null ? new int?(this.baseType.MeterType.MeterTypeID) : new int?();
          BaseType.UpdateType(selectedItem.HardwareName, this.baseType.MeterInfo.MeterInfoID, meterTypeID, this.TextBoxSapNumber.Text.Trim(), selectedItem.HardwareTypeID, this.TextBoxDescription.Text.Trim(), this.compressedData, this.TextBoxTypeCreationString.Text);
          this.meterInfoID = new int?(this.baseType.MeterInfo.MeterInfoID);
        }
        catch (Exception ex)
        {
          int num5 = (int) MessageBox.Show((Window) this, ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
        }
        this.DialogResult = new bool?(true);
        this.Close();
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/typeeditorwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.ComboBoxHardwareType = (ComboBox) target;
          break;
        case 2:
          this.TextBoxSapNumber = (TextBox) target;
          break;
        case 3:
          this.TextBoxDescription = (TextBox) target;
          break;
        case 4:
          this.TextBoxTypeCreationString = (TextBox) target;
          break;
        case 5:
          this.CheckBoxBASETYPE = (CheckBox) target;
          break;
        case 6:
          this.ButtonCreate = (Button) target;
          this.ButtonCreate.Click += new RoutedEventHandler(this.ButtonCreate_Click);
          break;
        case 7:
          this.ButtonSave = (Button) target;
          this.ButtonSave.Click += new RoutedEventHandler(this.ButtonSave_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- TypeOverwriteData.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.TypeOverwriteData
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System.Text;

#nullable disable
namespace HandlerLib
{
  public class TypeOverwriteData
  {
    public int MeterInfoID;
    public OverwriteConditions Condition;
    public CommonOverwriteGroups[] OverwriteGroups;

    public override string ToString()
    {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.Append(this.MeterInfoID);
      stringBuilder.Append(" Cond:" + this.Condition.ToString());
      stringBuilder.Append(" Groups:");
      if (this.OverwriteGroups != null)
      {
        for (int index = 0; index < this.OverwriteGroups.Length; ++index)
        {
          if (index > 0)
            stringBuilder.Append(",");
          stringBuilder.Append(this.OverwriteGroups[index].ToString());
        }
      }
      return stringBuilder.ToString();
    }
  }
}


--- TypeWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.TypeWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using GmmDbLib;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;

#nullable disable
namespace HandlerLib
{
  public class TypeWindow : Window, IComponentConnector
  {
    private MeterInfo meterInfo;
    private string[] hardwareName;
    internal TextBox TextBoxSapNumber;
    internal Button ButtonOpen;
    internal DataGrid DataGridTypes;
    internal MenuItem MenuItemDelete;
    private bool _contentLoaded;

    private TypeWindow() => this.InitializeComponent();

    public static MeterInfo ShowDialog(Window owner, string hardwareName)
    {
      return TypeWindow.ShowDialog(owner, new string[1]
      {
        hardwareName
      });
    }

    public static MeterInfo ShowDialog(Window owner, string[] hardwareName)
    {
      List<MeterInfo> meterInfoList = MeterInfo.LoadMeterInfo(hardwareName);
      TypeWindow typeWindow = new TypeWindow();
      typeWindow.Owner = owner;
      typeWindow.hardwareName = hardwareName;
      typeWindow.DataGridTypes.ItemsSource = (IEnumerable) meterInfoList;
      if (meterInfoList != null)
        typeWindow.Title = "Types (" + meterInfoList.Count.ToString() + ")";
      bool? nullable = typeWindow.ShowDialog();
      bool flag = true;
      return !(nullable.GetValueOrDefault() == flag & nullable.HasValue) || typeWindow.meterInfo == null ? (MeterInfo) null : typeWindow.meterInfo;
    }

    private void TextBoxSapNumber_KeyDown(object sender, KeyEventArgs e)
    {
      if (e.Key != Key.Return || !this.OpenBySapNumber())
        return;
      this.DialogResult = new bool?(true);
      this.Close();
    }

    private void ButtonOpen_Click(object sender, RoutedEventArgs e)
    {
      if (!this.OpenBySapNumber())
        this.meterInfo = this.DataGridTypes.SelectedItem as MeterInfo;
      this.DialogResult = new bool?(true);
      this.Close();
    }

    private bool OpenBySapNumber()
    {
      string sapNumber = this.TextBoxSapNumber.Text.Trim();
      if (sapNumber != null && sapNumber.Length >= 6 && this.DataGridTypes.ItemsSource is List<MeterInfo>)
      {
        List<MeterInfo> itemsSource = (List<MeterInfo>) this.DataGridTypes.ItemsSource;
        int index = itemsSource.FindIndex((Predicate<MeterInfo>) (x => x.PPSArtikelNr == sapNumber));
        if (index >= 0)
        {
          this.meterInfo = itemsSource[index];
          return true;
        }
      }
      return false;
    }

    private void DataGridTypes_MouseDoubleClick(object sender, MouseButtonEventArgs e)
    {
      if (e.LeftButton != MouseButtonState.Pressed || this.DataGridTypes.SelectedItem == null)
        return;
      this.ButtonOpen_Click(sender, (RoutedEventArgs) null);
    }

    private void MenuItemDelete_Click(object sender, RoutedEventArgs e)
    {
      this.meterInfo = this.DataGridTypes.SelectedItem as MeterInfo;
      if (this.meterInfo == null)
        return;
      if (!UserManager.CheckPermission("Developer"))
      {
        int num1 = (int) MessageBox.Show((Window) this, "You have no permission to delete type!", "Access forbidden", MessageBoxButton.OK, MessageBoxImage.Asterisk);
      }
      else
      {
        if (MessageBox.Show((Window) this, "Are you sure?", "Delete?", MessageBoxButton.YesNo, MessageBoxImage.Question) != MessageBoxResult.Yes)
          return;
        try
        {
          BaseType.DeleteType(this.meterInfo);
          List<MeterInfo> meterInfoList = MeterInfo.LoadMeterInfo(this.hardwareName);
          this.DataGridTypes.ItemsSource = (IEnumerable) meterInfoList;
          if (meterInfoList == null)
            return;
          this.Title = "Types (" + meterInfoList.Count.ToString() + ")";
        }
        catch (Exception ex)
        {
          int num2 = (int) MessageBox.Show((Window) this, ex.Message, "Error", MessageBoxButton.OK, MessageBoxImage.Hand);
        }
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/typewindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.TextBoxSapNumber = (TextBox) target;
          this.TextBoxSapNumber.KeyDown += new KeyEventHandler(this.TextBoxSapNumber_KeyDown);
          break;
        case 2:
          this.ButtonOpen = (Button) target;
          this.ButtonOpen.Click += new RoutedEventHandler(this.ButtonOpen_Click);
          break;
        case 3:
          this.DataGridTypes = (DataGrid) target;
          this.DataGridTypes.MouseDoubleClick += new MouseButtonEventHandler(this.DataGridTypes_MouseDoubleClick);
          break;
        case 4:
          this.MenuItemDelete = (MenuItem) target;
          this.MenuItemDelete.Click += new RoutedEventHandler(this.MenuItemDelete_Click);
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- VersionProtocolTypes.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.VersionProtocolTypes
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

#nullable disable
namespace HandlerLib
{
  public enum VersionProtocolTypes
  {
    NotDefined,
    Series2,
    Series3,
    Series4,
    SmokeDetector,
  }
}


--- VersionWindow.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.VersionWindow
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class VersionWindow : Window, IComponentConnector
  {
    private bool isRunning;
    private CancellationTokenSource cancelToken;
    private ProgressHandler progress;
    private DeviceCommandsMBus deviceCommands;
    internal Button ButtonReadVersion;
    internal Button ButtonReadVersionAsync;
    internal Button ButtonReadVersionAsyncLoop;
    internal Button ButtonStop;
    internal Label LabelLoopInfo;
    internal ProgressBar ProgressBar1;
    internal TextBlock TextBlockMessage;
    internal TextBox TextBlockOutput;
    private bool _contentLoaded;

    public VersionWindow()
    {
      this.InitializeComponent();
      this.isRunning = false;
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
    }

    private void OnProgress(ProgressArg obj)
    {
      if (!this.CheckAccess())
      {
        this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
      }
      else
      {
        this.ProgressBar1.Value = obj.ProgressPercentage;
        this.TextBlockMessage.Text = obj.Message;
      }
    }

    public static void Show(Window owner, DeviceCommandsMBus deviceCommands)
    {
      VersionWindow versionWindow = new VersionWindow();
      versionWindow.deviceCommands = deviceCommands;
      versionWindow.Owner = owner;
      versionWindow.ShowDialog();
    }

    private void ButtonReadVersion_Click(object sender, RoutedEventArgs e)
    {
      this.TextBlockOutput.Text = string.Empty;
      try
      {
        this.cancelToken = new CancellationTokenSource();
        this.progress.Reset();
        this.TextBlockOutput.Text = this.deviceCommands.ReadVersion(this.progress, this.cancelToken.Token).Print(0);
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Read version error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
    }

    private async void ButtonReadVersionAsync_Click(object sender, RoutedEventArgs e)
    {
      if (this.isRunning)
        return;
      this.isRunning = true;
      this.TextBlockOutput.Text = string.Empty;
      try
      {
        this.cancelToken = new CancellationTokenSource();
        this.progress.Reset();
        DeviceVersionMBus version = await this.deviceCommands.ReadVersionAsync(this.progress, this.cancelToken.Token);
        this.TextBlockOutput.Text = version.Print(0);
        version = (DeviceVersionMBus) null;
      }
      catch (OperationCanceledException ex)
      {
        this.progress.Reset("Canceled");
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show((Window) this, ex.Message, "Read version error", MessageBoxButton.OK, MessageBoxImage.Hand);
      }
      finally
      {
        this.isRunning = false;
      }
    }

    private async void ButtonReadVersionAsyncLoop_Click(object sender, RoutedEventArgs e)
    {
      if (this.isRunning)
        return;
      this.TextBlockOutput.Text = string.Empty;
      this.isRunning = true;
      this.cancelToken = new CancellationTokenSource();
      int count = 0;
      int successful = 0;
      int failed = 0;
      while (!this.cancelToken.IsCancellationRequested)
      {
        if (count % 100 == 0)
          this.progress.Reset(100);
        try
        {
          DeviceVersionMBus version = await this.deviceCommands.ReadVersionAsync(this.progress, this.cancelToken.Token);
          this.TextBlockOutput.Text = version.Print(0);
          ++successful;
          version = (DeviceVersionMBus) null;
        }
        catch (OperationCanceledException ex)
        {
          this.progress.Reset("Canceled");
          break;
        }
        catch
        {
          ++failed;
        }
        finally
        {
          this.isRunning = false;
        }
        this.LabelLoopInfo.Content = (object) string.Format("Count: {0}, Successful: {1}, Failed: {2}", (object) ++count, (object) successful, (object) failed);
      }
    }

    private void ButtonStop_Click(object sender, RoutedEventArgs e)
    {
      if (this.cancelToken == null)
        return;
      this.cancelToken.Cancel();
      this.isRunning = false;
    }

    private void Window_Closing(object sender, CancelEventArgs e)
    {
      if (this.cancelToken == null)
        return;
      this.cancelToken.Cancel();
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/versionwindow.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          ((Window) target).Closing += new CancelEventHandler(this.Window_Closing);
          break;
        case 2:
          this.ButtonReadVersion = (Button) target;
          this.ButtonReadVersion.Click += new RoutedEventHandler(this.ButtonReadVersion_Click);
          break;
        case 3:
          this.ButtonReadVersionAsync = (Button) target;
          this.ButtonReadVersionAsync.Click += new RoutedEventHandler(this.ButtonReadVersionAsync_Click);
          break;
        case 4:
          this.ButtonReadVersionAsyncLoop = (Button) target;
          this.ButtonReadVersionAsyncLoop.Click += new RoutedEventHandler(this.ButtonReadVersionAsyncLoop_Click);
          break;
        case 5:
          this.ButtonStop = (Button) target;
          this.ButtonStop.Click += new RoutedEventHandler(this.ButtonStop_Click);
          break;
        case 6:
          this.LabelLoopInfo = (Label) target;
          break;
        case 7:
          this.ProgressBar1 = (ProgressBar) target;
          break;
        case 8:
          this.TextBlockMessage = (TextBlock) target;
          break;
        case 9:
          this.TextBlockOutput = (TextBox) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- ViewCommandWindowBusModule.xaml.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.View.CommandWindowBusModule
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommonWPF;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using ZENNER.CommonLibrary;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib.View
{
  public partial class CommandWindowBusModule : Window, IComponentConnector
  {
    private List<string> ModuleCommands;
    private NfcDeviceCommands NFC_Commands;
    private BusModuleInfo ModuleInfo;
    private CancellationTokenSource cancelTokenSource;
    private ProgressHandler progress;
    internal DockPanel DockPanelButtons;
    internal StackPanel StackPanelBottomButtoms;
    internal Button ButtomRunCommand;
    internal Button ButtomBreak;
    internal StackPanel StackPanelTopButtoms;
    internal ComboBox ComboBoxCommands;
    internal Label LabelAdditionalCommands;
    internal TextBox TextBoxAdditionalCommandBytes;
    internal TextBox TextBoxResults;
    private bool _contentLoaded;

    public CommandWindowBusModule(NfcDeviceCommands NFC_Commands, BusModuleInfo moduleInfo)
    {
      this.NFC_Commands = NFC_Commands;
      this.ModuleInfo = moduleInfo;
      this.InitializeComponent();
      this.cancelTokenSource = new CancellationTokenSource();
      this.progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgress));
      this.Title = this.Title + "  " + this.ModuleInfo.BusModuleType.ToString() + ": " + this.ModuleInfo.BusModuleSerialNumber.ToString();
      string[] names = Enum.GetNames(typeof (BusModuleCommand));
      BusModuleCommand[] values = (BusModuleCommand[]) Enum.GetValues(typeof (BusModuleCommand));
      this.ModuleCommands = new List<string>();
      for (int index = 0; index < names.Length; ++index)
        this.ModuleCommands.Add(names[index].Replace("BUS_ASYNC_", "") + "_0x" + ((int) values[index]).ToString("x02"));
      this.ModuleCommands.Sort();
      this.ComboBoxCommands.ItemsSource = (IEnumerable) this.ModuleCommands;
    }

    private void OnProgress(ProgressArg obj)
    {
      if (this.CheckAccess())
        return;
      this.Dispatcher.Invoke((Action) (() => this.OnProgress(obj)));
    }

    private void ComboBoxCommands_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      this.TextBoxAdditionalCommandBytes.Focus();
    }

    private void ComboBoxCommands_PreviewKeyDown(object sender, KeyEventArgs e)
    {
      if (e.Key != Key.Return)
        return;
      e.Handled = true;
      this.TextBoxAdditionalCommandBytes.Focus();
    }

    private async void TextBoxAdditionalCommandBytes_PreviewKeyDown(object sender, KeyEventArgs e)
    {
      if (e.Key != Key.Return)
        return;
      e.Handled = true;
      await this.RunCommand();
    }

    private async void ButtomRunCommand_Click(object sender, RoutedEventArgs e)
    {
      await this.RunCommand();
    }

    private async Task RunCommand()
    {
      try
      {
        string commandText = this.ComboBoxCommands.Text;
        int hexTokenindex = commandText.IndexOf("_0x");
        byte commandCode = hexTokenindex < 0 ? byte.Parse(commandText, NumberStyles.HexNumber) : byte.Parse(commandText.Substring(hexTokenindex + 3), NumberStyles.HexNumber);
        string additionalBytesString = this.TextBoxAdditionalCommandBytes.Text.Trim();
        string additionalBytesFormated = "";
        byte[] additionalBytes = (byte[]) null;
        if (additionalBytesString.Length > 0)
        {
          additionalBytes = Util.HexStringToByteArray(additionalBytesString);
          additionalBytesFormated = " " + Util.ByteArrayToHexString(additionalBytes);
        }
        this.TextBoxResults.AppendText("Command code: 0x" + commandCode.ToString("x02") + additionalBytesFormated + Environment.NewLine);
        byte[] transparentToModule;
        if (additionalBytes == null)
        {
          transparentToModule = new byte[1];
        }
        else
        {
          transparentToModule = new byte[additionalBytes.Length + 1];
          additionalBytes.CopyTo((Array) transparentToModule, 1);
        }
        transparentToModule[0] = commandCode;
        byte[] result = await this.NFC_Commands.SendTransparentToModuleAsync(this.progress, this.cancelTokenSource.Token, this.ModuleInfo, BusModuleCommand.BUS_ASYNC_TRANSPARENT_TO_MODULE, transparentToModule);
        string resultString = Util.ByteArrayToHexString(result);
        this.TextBoxResults.AppendText("Result: " + resultString + Environment.NewLine);
        commandText = (string) null;
        additionalBytesString = (string) null;
        additionalBytesFormated = (string) null;
        additionalBytes = (byte[]) null;
        transparentToModule = (byte[]) null;
        result = (byte[]) null;
        resultString = (string) null;
      }
      catch (Exception ex)
      {
        ExceptionViewer.Show(ex);
      }
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/commandwindowbusmodule.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.DockPanelButtons = (DockPanel) target;
          break;
        case 2:
          this.StackPanelBottomButtoms = (StackPanel) target;
          break;
        case 3:
          this.ButtomRunCommand = (Button) target;
          this.ButtomRunCommand.Click += new RoutedEventHandler(this.ButtomRunCommand_Click);
          break;
        case 4:
          this.ButtomBreak = (Button) target;
          break;
        case 5:
          this.StackPanelTopButtoms = (StackPanel) target;
          break;
        case 6:
          this.ComboBoxCommands = (ComboBox) target;
          this.ComboBoxCommands.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxCommands_SelectionChanged);
          this.ComboBoxCommands.PreviewKeyDown += new KeyEventHandler(this.ComboBoxCommands_PreviewKeyDown);
          break;
        case 7:
          this.LabelAdditionalCommands = (Label) target;
          break;
        case 8:
          this.TextBoxAdditionalCommandBytes = (TextBox) target;
          this.TextBoxAdditionalCommandBytes.PreviewKeyDown += new KeyEventHandler(this.TextBoxAdditionalCommandBytes_PreviewKeyDown);
          break;
        case 9:
          this.TextBoxResults = (TextBox) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- ViewMBus_IO_Management.xaml.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.View.MBus_IO_Management
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib.View
{
  public partial class MBus_IO_Management : Window, IComponentConnector
  {
    private uint OkCounts = 0;
    private uint ErrorCounts = 0;
    private Common16BitCommands Commands16Bit;
    internal Button ButtonSingleAccess;
    internal Button ButtonBreak;
    internal TextBlock TextBlockOkCounts;
    internal TextBlock TextBlockErrorCounts;
    internal CheckBox CheckBoxInputState1;
    internal CheckBox CheckBoxOutputState1;
    internal CheckBox CheckBoxOutputSet1;
    internal CheckBox CheckBoxOutputMask1;
    internal CheckBox CheckBoxInputState2;
    internal CheckBox CheckBoxOutputState2;
    internal CheckBox CheckBoxOutputSet2;
    internal CheckBox CheckBoxOutputMask2;
    internal CheckBox CheckBoxInputState3;
    internal CheckBox CheckBoxOutputState3;
    internal CheckBox CheckBoxOutputSet3;
    internal CheckBox CheckBoxOutputMask3;
    private bool _contentLoaded;

    public MBus_IO_Management(Common16BitCommands commands16Bit)
    {
      this.Commands16Bit = commands16Bit;
      this.InitializeComponent();
    }

    private void ButtonSingleAccess_Click(object sender, RoutedEventArgs e)
    {
      ProgressHandler progress = new ProgressHandler(new Action<ProgressArg>(this.OnProgressHandler));
      CancellationToken token = new CancellationToken();
      uint NewOutputMask = 0;
      uint NewOutputState = 0;
      uint OldOutputState = 0;
      uint OldInputState = 0;
      if (this.CheckBoxOutputSet1.IsChecked.Value)
        NewOutputState |= 1U;
      if (this.CheckBoxOutputSet2.IsChecked.Value)
        NewOutputState |= 2U;
      if (this.CheckBoxOutputSet3.IsChecked.Value)
        NewOutputState |= 4U;
      if (this.CheckBoxOutputMask1.IsChecked.Value)
        NewOutputMask |= 1U;
      if (this.CheckBoxOutputMask2.IsChecked.Value)
        NewOutputMask |= 2U;
      if (this.CheckBoxOutputMask3.IsChecked.Value)
        NewOutputMask |= 4U;
      try
      {
        this.Commands16Bit.DigitalInputsAndOutputs(progress, token, NewOutputMask, NewOutputState, ref OldOutputState, ref OldInputState);
        ++this.OkCounts;
        this.TextBlockOkCounts.Text = this.OkCounts.ToString();
      }
      catch
      {
        ++this.ErrorCounts;
        this.TextBlockErrorCounts.Text = this.ErrorCounts.ToString();
        return;
      }
      this.CheckBoxInputState1.IsChecked = new bool?((OldInputState & 1U) > 0U);
      this.CheckBoxInputState2.IsChecked = new bool?((OldInputState & 2U) > 0U);
      this.CheckBoxInputState3.IsChecked = new bool?((OldInputState & 4U) > 0U);
      this.CheckBoxOutputState1.IsChecked = new bool?((OldInputState & 1U) > 0U);
      this.CheckBoxOutputState2.IsChecked = new bool?((OldInputState & 2U) > 0U);
      this.CheckBoxOutputState3.IsChecked = new bool?((OldInputState & 4U) > 0U);
    }

    private void OnProgressHandler(ProgressArg obj)
    {
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/mbus_io_management.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.ButtonSingleAccess = (Button) target;
          this.ButtonSingleAccess.Click += new RoutedEventHandler(this.ButtonSingleAccess_Click);
          break;
        case 2:
          this.ButtonBreak = (Button) target;
          break;
        case 3:
          this.TextBlockOkCounts = (TextBlock) target;
          break;
        case 4:
          this.TextBlockErrorCounts = (TextBlock) target;
          break;
        case 5:
          this.CheckBoxInputState1 = (CheckBox) target;
          break;
        case 6:
          this.CheckBoxOutputState1 = (CheckBox) target;
          break;
        case 7:
          this.CheckBoxOutputSet1 = (CheckBox) target;
          break;
        case 8:
          this.CheckBoxOutputMask1 = (CheckBox) target;
          break;
        case 9:
          this.CheckBoxInputState2 = (CheckBox) target;
          break;
        case 10:
          this.CheckBoxOutputState2 = (CheckBox) target;
          break;
        case 11:
          this.CheckBoxOutputSet2 = (CheckBox) target;
          break;
        case 12:
          this.CheckBoxOutputMask2 = (CheckBox) target;
          break;
        case 13:
          this.CheckBoxInputState3 = (CheckBox) target;
          break;
        case 14:
          this.CheckBoxOutputState3 = (CheckBox) target;
          break;
        case 15:
          this.CheckBoxOutputSet3 = (CheckBox) target;
          break;
        case 16:
          this.CheckBoxOutputMask3 = (CheckBox) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- ViewVMCP_Tool.xaml.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.View.VMCP_Tool
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.UserInterface;
using ReadoutConfiguration;
using StartupLib;
using System;
using System.CodeDom.Compiler;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Markup;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib.View
{
  public partial class VMCP_Tool : Window, IComponentConnector
  {
    private CommunicationPortWindowFunctions myPortWindowFunctions;
    private ConfigList configList;
    private bool BreakLoop = false;
    private bool TransmitProtocol = false;
    private byte[] TransmitProtocolData;
    private string TransmitProtocolName;
    private byte[] SetIdProtocol = new byte[15]
    {
      (byte) 104,
      (byte) 9,
      (byte) 9,
      (byte) 104,
      (byte) 83,
      (byte) 1,
      (byte) 81,
      (byte) 12,
      (byte) 121,
      (byte) 85,
      (byte) 22,
      (byte) 96,
      (byte) 96,
      (byte) 85,
      (byte) 22
    };
    private byte[] SetDN50_UnitsProtocol = new byte[17]
    {
      (byte) 104,
      (byte) 11,
      (byte) 11,
      (byte) 104,
      (byte) 83,
      (byte) 1,
      (byte) 81,
      (byte) 15,
      (byte) 22,
      (byte) 0,
      (byte) 0,
      (byte) 6,
      (byte) 1,
      (byte) 250,
      (byte) 0,
      (byte) 203,
      (byte) 22
    };
    private byte[] Set_CycleTime_Protocol = new byte[13]
    {
      (byte) 104,
      (byte) 7,
      (byte) 7,
      (byte) 104,
      (byte) 83,
      (byte) 254,
      (byte) 81,
      (byte) 15,
      (byte) 49,
      (byte) 0,
      (byte) 0,
      (byte) 226,
      (byte) 22
    };
    private byte[] Get_Identification_Protocol = new byte[12]
    {
      (byte) 104,
      (byte) 6,
      (byte) 6,
      (byte) 104,
      (byte) 83,
      (byte) 254,
      (byte) 81,
      (byte) 15,
      (byte) 53,
      (byte) 0,
      (byte) 230,
      (byte) 22
    };
    private byte[] VmcpDemoProtocol = new byte[19]
    {
      (byte) 91,
      (byte) 135,
      (byte) 101,
      (byte) 67,
      (byte) 50,
      (byte) 120,
      (byte) 86,
      (byte) 52,
      (byte) 120,
      (byte) 86,
      (byte) 52,
      (byte) 18,
      (byte) 120,
      (byte) 86,
      (byte) 52,
      (byte) 18,
      (byte) 0,
      (byte) 0,
      (byte) 230
    };
    private StringBuilder StatusInfo = new StringBuilder();
    private DateTime lastCycleTime;
    internal GmmCorporateControl gmmCorporateControl1;
    internal ComboBox ComboBoxComPort;
    internal StackPanel StackPanelButtons;
    internal Button ButtonReceiveCycle;
    internal Button ButtonRequestIdentification;
    internal TextBox TextBoxVmcpCycle;
    internal Button ButtonSetVmcpCycle;
    internal TextBox TextBoxNewId;
    internal Button ButtonSetID;
    internal Button ButtonSetDN50Calibration;
    internal Button ButtonBreak;
    internal TextBox TextBoxStatus;
    private bool _contentLoaded;

    public VMCP_Tool()
    {
      this.InitializeComponent();
      this.myPortWindowFunctions = new CommunicationPortWindowFunctions();
      this.configList = new ConfigList(ReadoutConfigFunctions.Manager.GetConnectionProfile(59).GetSettingsList());
      this.configList.MinoConnectBaseState = "RS232_3V";
      this.myPortWindowFunctions.SetReadoutConfiguration(this.configList);
      this.ComboBoxComPort.ItemsSource = (IEnumerable) Constants.GetAvailableComPorts();
      string str = PlugInLoader.GmmConfiguration.GetValue("HandlerLibVmcpTool", "SelectedComPort");
      if (!string.IsNullOrEmpty(str))
      {
        for (int index = 0; index < this.ComboBoxComPort.Items.Count; ++index)
        {
          string fromComInfoString = this.GetComPortFromComInfoString(this.ComboBoxComPort.Items[index].ToString());
          if (str == fromComInfoString)
          {
            this.ComboBoxComPort.SelectedIndex = index;
            break;
          }
        }
      }
      if (this.ComboBoxComPort.SelectedIndex < 0)
        this.ComboBoxComPort.SelectedIndex = 0;
      bool flag = this.IsProtocolChecksumOk(this.SetIdProtocol);
      flag = this.IsProtocolChecksumOk(this.SetDN50_UnitsProtocol);
      flag = this.IsCycleProtocolChecksumOk(this.VmcpDemoProtocol);
      this.ButtonBreak.IsEnabled = false;
      this.AddStatusTimeLine("Tool loaded");
      this.UpdateStatus();
    }

    private void ComboBoxComPort_SelectionChanged(object sender, SelectionChangedEventArgs e)
    {
      string fromComInfoString = this.GetComPortFromComInfoString(this.ComboBoxComPort.SelectedItem.ToString());
      if (fromComInfoString == null || this.configList.Port != null && !(this.configList.Port != fromComInfoString))
        return;
      this.configList.Port = fromComInfoString;
      PlugInLoader.GmmConfiguration.SetOrUpdateValue("HandlerLibVmcpTool", "SelectedComPort", fromComInfoString);
    }

    private string GetComPortFromComInfoString(string comInfoString)
    {
      string[] strArray = comInfoString.Split(' ');
      return strArray != null && strArray.Length != 0 && !string.IsNullOrEmpty(strArray[0]) ? strArray[0] : (string) null;
    }

    private async void Button_Click(object sender, RoutedEventArgs e)
    {
      try
      {
        if (sender == this.ButtonReceiveCycle)
        {
          this.BreakLoop = false;
          this.ButtonReceiveCycle.IsEnabled = false;
          this.ButtonBreak.IsEnabled = true;
          await Task.Run((Action) (() => this.RunReceiveLoop()));
          this.ButtonReceiveCycle.IsEnabled = true;
          this.ButtonBreak.IsEnabled = false;
        }
        else if (sender == this.ButtonRequestIdentification)
        {
          this.TransmitProtocolData = this.Get_Identification_Protocol;
          this.TransmitProtocolName = "Get Identification";
          this.TransmitProtocol = true;
        }
        else if (sender == this.ButtonSetID)
        {
          uint theID = uint.Parse(this.TextBoxNewId.Text, NumberStyles.HexNumber);
          Buffer.BlockCopy((Array) BitConverter.GetBytes(theID), 0, (Array) this.SetIdProtocol, 9, 4);
          this.SetProtocolChecksum(this.SetIdProtocol);
          this.TransmitProtocolData = this.SetIdProtocol;
          this.TransmitProtocolName = "Set device ID";
          this.TransmitProtocol = true;
        }
        else if (sender == this.ButtonSetVmcpCycle)
        {
          int cycleTime = int.Parse(this.TextBoxVmcpCycle.Text);
          this.Set_CycleTime_Protocol[this.Set_CycleTime_Protocol.Length - 3] = (byte) cycleTime;
          this.SetProtocolChecksum(this.Set_CycleTime_Protocol);
          this.TransmitProtocolData = this.Set_CycleTime_Protocol;
          this.TransmitProtocolName = "Set cycle time = " + cycleTime.ToString();
          this.TransmitProtocol = true;
        }
        else
        {
          if (sender != this.ButtonSetDN50Calibration)
            return;
          this.TransmitProtocolData = this.SetDN50_UnitsProtocol;
          this.TransmitProtocolName = "Set DN50 Units";
          this.TransmitProtocol = true;
        }
      }
      catch (Exception ex)
      {
        int num = (int) MessageBox.Show(ex.ToString());
        this.BreakLoop = true;
        this.ButtonReceiveCycle.IsEnabled = true;
        this.ButtonBreak.IsEnabled = false;
      }
    }

    private void AddStatusTimeLine(string statusInfo)
    {
      this.StartStatusTimeLine(statusInfo);
      this.StatusInfo.AppendLine();
    }

    private void StartStatusTimeLine(string statusInfo)
    {
      DateTime now = DateTime.Now;
      DateTime lastCycleTime = this.lastCycleTime;
      if (false)
        this.lastCycleTime = now;
      TimeSpan timeSpan = now - this.lastCycleTime;
      this.lastCycleTime = now;
      this.StatusInfo.Append(timeSpan.TotalSeconds.ToString("000.000"));
      this.StatusInfo.Append("; " + DateTime.Now.ToString("HH:mm:ss.FFF") + ": ");
      this.StatusInfo.Append(statusInfo);
    }

    private void UpdateStatus() => this.UpdateStatusD((object) this, 0);

    private void UpdateStatusD(object sender, int dummy)
    {
      if (this.Dispatcher.Thread != Thread.CurrentThread)
      {
        try
        {
          this.Dispatcher.BeginInvoke((Delegate) new EventHandler<int>(this.UpdateStatusD), sender, (object) dummy);
        }
        catch
        {
        }
      }
      else
      {
        lock (this.StatusInfo)
        {
          string source = this.StatusInfo.ToString();
          int num1 = source.Count<char>((Func<char, bool>) (x => x == '\n'));
          int num2 = 0;
          for (; num1 > 20; --num1)
            num2 = source.IndexOf(Environment.NewLine, num2) + Environment.NewLine.Length;
          if (num2 > 0)
          {
            this.StatusInfo.Remove(0, num2);
            source = this.StatusInfo.ToString();
          }
          this.TextBoxStatus.Text = source;
        }
      }
    }

    private void RunReceiveLoop()
    {
      this.myPortWindowFunctions.portFunctions.Open();
      while (!this.BreakLoop)
      {
        try
        {
          if (this.TransmitProtocol)
          {
            lock (this.StatusInfo)
              this.AddStatusTimeLine(this.TransmitProtocolName);
            this.myPortWindowFunctions.portFunctions.Write(this.TransmitProtocolData);
            this.TransmitProtocol = false;
            Thread.Sleep(10);
          }
          else
          {
            byte num1 = this.myPortWindowFunctions.portFunctions.ReadHeader(1)[0];
            switch (num1)
            {
              case 91:
                byte[] dst = new byte[19];
                dst[0] = num1;
                Buffer.BlockCopy((Array) this.myPortWindowFunctions.portFunctions.ReadEnd(18), 0, (Array) dst, 1, 18);
                lock (this.StatusInfo)
                {
                  this.StartStatusTimeLine("Cycle");
                  byte num2 = 0;
                  for (int index = 0; index < 18; ++index)
                    num2 += dst[index];
                  if ((int) num2 == (int) dst[18])
                  {
                    this.StatusInfo.Append("; SN:" + BitConverter.ToUInt32(dst, 1).ToString("x08"));
                    double num3 = 0.0;
                    double num4 = 1E-06;
                    for (int index = 5; index <= 11; ++index)
                    {
                      double num5 = num3 + (double) ((int) dst[index] & 15) * num4;
                      double num6 = num4 * 10.0;
                      num3 = num5 + (double) (((int) dst[index] & 240) >> 4) * num6;
                      num4 = num6 * 10.0;
                    }
                    this.StatusInfo.Append("; Vol:" + num3.ToString() + "m\u00B3");
                    double num7 = 0.0;
                    double num8 = 0.001;
                    for (int index = 12; index <= 15; ++index)
                    {
                      double num9 = num7 + (double) ((int) dst[index] & 15) * num8;
                      double num10 = num8 * 10.0;
                      num7 = num9 + (double) (((int) dst[index] & 240) >> 4) * num10;
                      num8 = num10 * 10.0;
                    }
                    this.StatusInfo.Append("; Flow:" + num7.ToString() + "m\u00B3/h");
                    ushort uint16 = BitConverter.ToUInt16(dst, 16);
                    if (((uint) uint16 & 1U) > 0U)
                      this.StatusInfo.Append("; Backflow");
                    if (((uint) uint16 & 4U) > 0U)
                      this.StatusInfo.Append("; Undervoltage");
                    if (((uint) uint16 & 16U) > 0U)
                      this.StatusInfo.Append("; PipeEmpty");
                    if (((uint) uint16 & 32U) > 0U)
                      this.StatusInfo.Append("; TransducerAlarm");
                  }
                  else
                    this.StatusInfo.Append("; Checksum error");
                  this.StatusInfo.AppendLine();
                }
                this.UpdateStatus();
                break;
              case 104:
                byte[] numArray = new byte[15];
                numArray[0] = num1;
                Buffer.BlockCopy((Array) this.myPortWindowFunctions.portFunctions.ReadEnd(14), 0, (Array) numArray, 1, 14);
                lock (this.StatusInfo)
                {
                  this.StartStatusTimeLine("Get_Identification received");
                  if (this.IsProtocolChecksumOk(numArray))
                    this.StatusInfo.Append("; SN:" + BitConverter.ToUInt32(numArray, 9).ToString("x08"));
                  else
                    this.StatusInfo.Append("; Checksum error");
                  this.StatusInfo.AppendLine();
                }
                this.UpdateStatus();
                break;
            }
          }
        }
        catch (TimeoutException ex)
        {
        }
        catch (Exception ex)
        {
          this.StartStatusTimeLine("Exception !!!! -> " + ex.Message);
          this.StatusInfo.AppendLine();
        }
      }
      this.myPortWindowFunctions.portFunctions.Close();
    }

    private bool IsCycleProtocolChecksumOk(byte[] protocol)
    {
      byte num = 0;
      for (int index = 0; index < protocol.Length - 1; ++index)
        num += protocol[index];
      return (int) protocol[protocol.Length - 1] == (int) num;
    }

    private bool IsProtocolChecksumOk(byte[] protocol)
    {
      byte protocolChecksum = this.CalculateProtocolChecksum(protocol);
      return (int) protocol[protocol.Length - 2] == (int) protocolChecksum;
    }

    private void SetProtocolChecksum(byte[] protocol)
    {
      byte protocolChecksum = this.CalculateProtocolChecksum(protocol);
      protocol[protocol.Length - 2] = protocolChecksum;
    }

    private byte CalculateProtocolChecksum(byte[] protocol)
    {
      byte protocolChecksum = 0;
      for (int index = 4; index < protocol.Length - 2; ++index)
        protocolChecksum += protocol[index];
      return protocolChecksum;
    }

    private void ButtonBreak_Click(object sender, RoutedEventArgs e) => this.BreakLoop = true;

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/vmcp_tool.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.gmmCorporateControl1 = (GmmCorporateControl) target;
          break;
        case 2:
          this.ComboBoxComPort = (ComboBox) target;
          this.ComboBoxComPort.SelectionChanged += new SelectionChangedEventHandler(this.ComboBoxComPort_SelectionChanged);
          break;
        case 3:
          this.StackPanelButtons = (StackPanel) target;
          break;
        case 4:
          this.ButtonReceiveCycle = (Button) target;
          this.ButtonReceiveCycle.Click += new RoutedEventHandler(this.Button_Click);
          break;
        case 5:
          this.ButtonRequestIdentification = (Button) target;
          this.ButtonRequestIdentification.Click += new RoutedEventHandler(this.Button_Click);
          break;
        case 6:
          this.TextBoxVmcpCycle = (TextBox) target;
          break;
        case 7:
          this.ButtonSetVmcpCycle = (Button) target;
          this.ButtonSetVmcpCycle.Click += new RoutedEventHandler(this.Button_Click);
          break;
        case 8:
          this.TextBoxNewId = (TextBox) target;
          break;
        case 9:
          this.ButtonSetID = (Button) target;
          this.ButtonSetID.Click += new RoutedEventHandler(this.Button_Click);
          break;
        case 10:
          this.ButtonSetDN50Calibration = (Button) target;
          this.ButtonSetDN50Calibration.Click += new RoutedEventHandler(this.Button_Click);
          break;
        case 11:
          this.ButtonBreak = (Button) target;
          this.ButtonBreak.Click += new RoutedEventHandler(this.ButtonBreak_Click);
          break;
        case 12:
          this.TextBoxStatus = (TextBox) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- VolumeCalibrationValues.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.VolumeCalibrationValues
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.Collections.Generic;
using ZR_ClassLibrary;

#nullable disable
namespace HandlerLib
{
  public class VolumeCalibrationValues
  {
    public SortedList<double, double> CalibrationFactors;

    public VolumeCalibrationValues(ConfigurationParameterListSupport confListSupport)
    {
      double key1 = double.NaN;
      double num1 = double.NaN;
      double key2 = double.NaN;
      double num2 = double.NaN;
      double key3 = double.NaN;
      double num3 = double.NaN;
      ConfigurationParameter parameterFromList1 = confListSupport.GetWorkParameterFromList(OverrideID.CalVolMaxFlowLiterPerHour);
      if (parameterFromList1 != null && parameterFromList1.ParameterValue != null && ((double) parameterFromList1.ParameterValue).CompareTo(double.NaN) != 0)
        key1 = (double) parameterFromList1.ParameterValue / 1000.0;
      ConfigurationParameter parameterFromList2 = confListSupport.GetWorkParameterFromList(OverrideID.CalVolMaxErrorPercent);
      if (parameterFromList2 != null && parameterFromList2.ParameterValue != null && ((double) parameterFromList2.ParameterValue).CompareTo(double.NaN) != 0)
      {
        if (key1.CompareTo(double.NaN) == 0)
          throw new ArgumentException("CalVolMaxFlowLiterPerHour cannot be NaN if CalVolMaxErrorPercent is set");
        num1 = (double) parameterFromList2.ParameterValue;
      }
      else if (key1.CompareTo(double.NaN) != 0)
        throw new ArgumentException("CalVolMaxErrorPercent cannot be NaN if CalVolMaxFlowLiterPerHour is set");
      ConfigurationParameter parameterFromList3 = confListSupport.GetWorkParameterFromList(OverrideID.CalVolNominalFlowLiterPerHour);
      if (parameterFromList3 != null && parameterFromList3.ParameterValue != null && ((double) parameterFromList3.ParameterValue).CompareTo(double.NaN) != 0)
      {
        key2 = (double) parameterFromList3.ParameterValue / 1000.0;
        if (key1.CompareTo(double.NaN) != 0 && key1 <= key2)
          throw new ArgumentException("CalVolMaxFlowLiterPerHour has to be higher then CalVolNominalFlowLiterPerHour");
      }
      ConfigurationParameter parameterFromList4 = confListSupport.GetWorkParameterFromList(OverrideID.CalVolNominalErrorPercent);
      if (parameterFromList4 != null && parameterFromList4.ParameterValue != null && ((double) parameterFromList4.ParameterValue).CompareTo(double.NaN) != 0)
      {
        if (key2.CompareTo(double.NaN) == 0)
          throw new ArgumentException("CalVolNominalFlowLiterPerHour cannot be NaN if CalVolNominalErrorPercent is set");
        num2 = (double) parameterFromList4.ParameterValue;
      }
      else if (key2.CompareTo(double.NaN) != 0)
        throw new ArgumentException("CalVolNominalErrorPercent cannot be NaN if CalVolNominalFlowLiterPerHour is set");
      ConfigurationParameter parameterFromList5 = confListSupport.GetWorkParameterFromList(OverrideID.CalVolMinFlowLiterPerHour);
      if (parameterFromList5 != null && parameterFromList5.ParameterValue != null && ((double) parameterFromList5.ParameterValue).CompareTo(double.NaN) != 0)
      {
        key3 = (double) parameterFromList5.ParameterValue / 1000.0;
        if (key1.CompareTo(double.NaN) != 0 && key1 <= key3)
          throw new ArgumentException("CalVolMaxFlowLiterPerHour has to be higher then CalVolMinFlowLiterPerHour");
        if (key2.CompareTo(double.NaN) != 0 && key2 <= key3)
          throw new ArgumentException("CalVolNominalFlowLiterPerHour has to be higher then CalVolMinFlowLiterPerHour");
      }
      ConfigurationParameter parameterFromList6 = confListSupport.GetWorkParameterFromList(OverrideID.CalVolMinErrorPercent);
      if (parameterFromList6 != null && parameterFromList6.ParameterValue != null && ((double) parameterFromList6.ParameterValue).CompareTo(double.NaN) != 0)
      {
        if (key3.CompareTo(double.NaN) == 0)
          throw new ArgumentException("CalVolMinFlowLiterPerHour cannot be NaN if CalVolMinErrorPercent is set");
        num3 = (double) parameterFromList6.ParameterValue;
      }
      else if (key3.CompareTo(double.NaN) != 0)
        throw new ArgumentException("CalVolMinErrorPercent cannot be NaN if CalVolMinFlowLiterPerHour is set");
      this.CalibrationFactors = new SortedList<double, double>();
      if (key1.CompareTo(double.NaN) != 0)
        this.CalibrationFactors.Add(key1, 100.0 / (100.0 + num1));
      if (key2.CompareTo(double.NaN) != 0)
        this.CalibrationFactors.Add(key2, 100.0 / (100.0 + num2));
      if (key3.CompareTo(double.NaN) == 0)
        return;
      this.CalibrationFactors.Add(key3, 100.0 / (100.0 + num3));
    }
  }
}


--- VolumeSimulator.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.VolumeSimulator
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using CommunicationPort.UserInterface;
using ReadoutConfiguration;
using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Markup;
using System.Windows.Threading;
using ZENNER.CommonLibrary;

#nullable disable
namespace HandlerLib
{
  public class VolumeSimulator : Window, IComponentConnector
  {
    private CommunicationPortWindowFunctions myPort;
    private bool threadRun;
    private int intervalSeconds;
    private DateTime intervalStartTime;
    private DateTime intervalEndTime;
    private DateTime nextRefreshTime;
    private double volume;
    private double flow;
    private uint volMeterID = 12345678;
    internal Button ButtonRunStop;
    internal Button ButtonSetCom;
    internal TextBox TextBoxVolume;
    internal TextBox TextBoxFlow;
    internal TextBox TextBoxCycleTime;
    internal TextBox TextBoxSecondsToProtocol;
    internal TextBox TextBoxProtocolCount;
    internal TextBox TextBoxVolumeMeterID;
    private bool _contentLoaded;

    public static void RunVolumeSimulator()
    {
      Thread thread = new Thread((ThreadStart) (() =>
      {
        SynchronizationContext.SetSynchronizationContext((SynchronizationContext) new DispatcherSynchronizationContext(Dispatcher.CurrentDispatcher));
        new VolumeSimulator().Show();
        Dispatcher.Run();
      }));
      thread.CurrentUICulture = Thread.CurrentThread.CurrentUICulture;
      thread.Name = "Translator";
      thread.IsBackground = true;
      thread.SetApartmentState(ApartmentState.STA);
      thread.Start();
    }

    public VolumeSimulator()
    {
      this.InitializeComponent();
      int.TryParse(this.TextBoxCycleTime.Text, out this.intervalSeconds);
      this.ButtonRunStop.Content = (object) "Run";
      this.myPort = new CommunicationPortWindowFunctions();
      this.myPort.SetReadoutConfiguration(new ConfigList(ReadoutConfigFunctions.Manager.GetConnectionProfile(155).GetSettingsList())
      {
        Wakeup = WakeupSystem.None.ToString(),
        Port = "COM18",
        MinoConnectBaseState = "RS232_3V"
      });
    }

    private void ButtonSetCom_Click(object sender, RoutedEventArgs e)
    {
      this.myPort.ShowMainWindow();
    }

    private void ButtonRunStop_Click(object sender, RoutedEventArgs e)
    {
      if (this.ButtonRunStop.Content.ToString() == "Run")
      {
        this.TextBoxVolume.IsEnabled = false;
        this.ButtonSetCom.IsEnabled = false;
        this.ButtonRunStop.Content = (object) "Stop";
        this.threadRun = true;
        int.TryParse(this.TextBoxCycleTime.Text, out this.intervalSeconds);
        double.TryParse(this.TextBoxVolume.Text, out this.volume);
        double.TryParse(this.TextBoxFlow.Text, out this.flow);
        uint.TryParse(this.TextBoxVolumeMeterID.Text, out this.volMeterID);
        ThreadPool.QueueUserWorkItem(new WaitCallback(this.ThreadLoopFunction));
      }
      else
      {
        this.TextBoxVolume.IsEnabled = true;
        this.ButtonSetCom.IsEnabled = true;
        this.ButtonRunStop.Content = (object) "Run";
        this.threadRun = false;
      }
    }

    private void RefreshUI(object sender, int dummy)
    {
      if (this.Dispatcher.Thread != Thread.CurrentThread)
      {
        try
        {
          this.Dispatcher.BeginInvoke((Delegate) new EventHandler<int>(this.RefreshUI), sender, (object) dummy);
        }
        catch
        {
        }
      }
      else
        this.TextBoxVolume.Text = this.volume.ToString("0.000000");
    }

    private void ThreadLoopFunction(object dummy)
    {
      this.intervalStartTime = DateTime.Now;
      this.intervalEndTime = this.intervalStartTime.AddSeconds((double) this.intervalSeconds);
      this.nextRefreshTime = DateTime.Now;
      while (this.threadRun)
      {
        DateTime now = DateTime.Now;
        if (now > this.intervalEndTime)
        {
          if (this.intervalStartTime != DateTime.MinValue)
            this.volume += this.flow / 3600.0 * now.Subtract(this.intervalStartTime).TotalSeconds;
          byte[] buffer = new byte[19];
          int num1 = 0;
          byte[] numArray1 = buffer;
          int index1 = num1;
          int num2 = index1 + 1;
          numArray1[index1] = (byte) 91;
          uint volMeterId = this.volMeterID;
          for (int index2 = 0; index2 < 4; ++index2)
          {
            buffer[num2++] = (byte) volMeterId;
            volMeterId >>= 8;
          }
          this.intervalStartTime = now;
          this.intervalEndTime = this.intervalStartTime.AddSeconds((double) this.intervalSeconds);
          string str1 = ((long) (this.volume * 1000000.0)).ToString();
          int num3 = str1.Length - 1;
          for (int index3 = 0; index3 < 7; ++index3)
          {
            byte num4 = 0;
            if (num3 >= 0)
              num4 = (byte) ((uint) (byte) str1[num3--] - 48U);
            byte num5 = num4;
            byte num6 = 0;
            if (num3 >= 0)
              num6 = (byte) ((uint) (byte) str1[num3--] - 48U);
            byte num7 = (byte) ((uint) num5 | (uint) (byte) ((uint) num6 << 4));
            buffer[num2++] = num7;
          }
          string str2 = ((long) (this.flow * 1000.0)).ToString();
          int num8 = str2.Length - 1;
          for (int index4 = 0; index4 < 4; ++index4)
          {
            byte num9 = 0;
            if (num8 >= 0)
              num9 = (byte) ((uint) (byte) str2[num8--] - 48U);
            byte num10 = num9;
            byte num11 = 0;
            if (num8 >= 0)
              num11 = (byte) ((uint) (byte) str2[num8--] - 48U);
            byte num12 = (byte) ((uint) num10 | (uint) (byte) ((uint) num11 << 4));
            buffer[num2++] = num12;
          }
          byte[] numArray2 = buffer;
          int index5 = num2;
          int num13 = index5 + 1;
          numArray2[index5] = (byte) 0;
          byte[] numArray3 = buffer;
          int index6 = num13;
          int index7 = index6 + 1;
          numArray3[index6] = (byte) 0;
          byte num14 = 0;
          for (int index8 = 0; index8 < index7; ++index8)
            num14 += buffer[index8];
          buffer[index7] = num14;
          this.myPort.portFunctions.communicationObject.Write(buffer);
        }
        else if (now > this.nextRefreshTime)
        {
          this.RefreshUI((object) this, 0);
          this.nextRefreshTime = now.AddSeconds(1.0);
        }
        else
          Thread.Sleep(50);
      }
    }

    private void TextBoxFlow_LostFocus(object sender, RoutedEventArgs e) => this.ChangeFlow();

    private void TextBoxFlow_PreviewKeyDown(object sender, KeyEventArgs e)
    {
      if (e.Key != Key.Return)
        return;
      this.ChangeFlow();
    }

    private void ChangeFlow() => double.TryParse(this.TextBoxFlow.Text, out this.flow);

    private void TextBoxCycleTime_LostFocus(object sender, RoutedEventArgs e)
    {
      this.ChangeCycleTime();
    }

    private void TextBoxCycleTime_PreviewKeyDown(object sender, KeyEventArgs e)
    {
      if (e.Key != Key.Return)
        return;
      this.ChangeCycleTime();
    }

    private void ChangeCycleTime()
    {
      if (int.TryParse(this.TextBoxCycleTime.Text, out this.intervalSeconds))
      {
        if (this.intervalSeconds < 1)
        {
          this.intervalSeconds = 4;
          this.TextBoxCycleTime.Text = this.intervalSeconds.ToString();
        }
        this.intervalEndTime = this.intervalStartTime.AddSeconds((double) this.intervalSeconds);
      }
      else
        this.TextBoxCycleTime.Text = this.intervalSeconds.ToString();
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    public void InitializeComponent()
    {
      if (this._contentLoaded)
        return;
      this._contentLoaded = true;
      Application.LoadComponent((object) this, new Uri("/HandlerLib;component/view/volumesimulator.xaml", UriKind.Relative));
    }

    [DebuggerNonUserCode]
    [GeneratedCode("PresentationBuildTasks", "4.0.0.0")]
    [EditorBrowsable(EditorBrowsableState.Never)]
    void IComponentConnector.Connect(int connectionId, object target)
    {
      switch (connectionId)
      {
        case 1:
          this.ButtonRunStop = (Button) target;
          this.ButtonRunStop.Click += new RoutedEventHandler(this.ButtonRunStop_Click);
          break;
        case 2:
          this.ButtonSetCom = (Button) target;
          this.ButtonSetCom.Click += new RoutedEventHandler(this.ButtonSetCom_Click);
          break;
        case 3:
          this.TextBoxVolume = (TextBox) target;
          break;
        case 4:
          this.TextBoxFlow = (TextBox) target;
          this.TextBoxFlow.PreviewKeyDown += new KeyEventHandler(this.TextBoxFlow_PreviewKeyDown);
          this.TextBoxFlow.LostFocus += new RoutedEventHandler(this.TextBoxFlow_LostFocus);
          break;
        case 5:
          this.TextBoxCycleTime = (TextBox) target;
          this.TextBoxCycleTime.LostFocus += new RoutedEventHandler(this.TextBoxCycleTime_LostFocus);
          this.TextBoxCycleTime.PreviewKeyDown += new KeyEventHandler(this.TextBoxCycleTime_PreviewKeyDown);
          break;
        case 6:
          this.TextBoxSecondsToProtocol = (TextBox) target;
          break;
        case 7:
          this.TextBoxProtocolCount = (TextBox) target;
          break;
        case 8:
          this.TextBoxVolumeMeterID = (TextBox) target;
          break;
        default:
          this._contentLoaded = true;
          break;
      }
    }
  }
}


--- ZipUnzip.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: HandlerLib.ZipUnzip
// Assembly: HandlerLib, Version=1.0.0.0, Culture=neutral, PublicKeyToken=f5405c50fba4c3ca
// MVID: 32680C26-DD6F-4028-82D3-7440714FE33F
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\HandlerLib.dll

using System;
using System.IO;
using System.IO.Compression;
using System.Text;

#nullable disable
namespace HandlerLib
{
  public static class ZipUnzip
  {
    public static byte[] GetZipedBytesFromString(string theString)
    {
      byte[] zipedBytes = ZipUnzip.GetZipedBytes(Encoding.UTF8.GetBytes(theString));
      if (Encoding.UTF8.GetString(ZipUnzip.GetBytesFromZipedBytes(zipedBytes)) != theString)
        throw new Exception("Compression check shows an error");
      return zipedBytes;
    }

    public static string GetZipedStringFromString(string theString)
    {
      string packedStringFromBytes = ZipUnzip.GetPackedStringFromBytes(ZipUnzip.GetZipedBytes(Encoding.UTF8.GetBytes(theString)));
      if (Encoding.UTF8.GetString(ZipUnzip.GetBytesFromZipedBytes(ZipUnzip.GetBytesFromPackedString(packedStringFromBytes))) != theString)
        throw new Exception("Compression check shows an error");
      return packedStringFromBytes;
    }

    public static byte[] GetZipedBytes(byte[] originalBytes)
    {
      byte[] array;
      using (MemoryStream memoryStream = new MemoryStream())
      {
        using (GZipStream destination = new GZipStream((Stream) memoryStream, CompressionMode.Compress))
        {
          new MemoryStream(originalBytes).CopyTo((Stream) destination);
          destination.Flush();
        }
        array = memoryStream.ToArray();
      }
      return array;
    }

    private static string GetPackedStringFromBytes(byte[] theBytes)
    {
      StringBuilder stringBuilder = new StringBuilder();
      if ((theBytes.Length & 1) != 0)
        stringBuilder.Append('1');
      else
        stringBuilder.Append('0');
      for (int index = 0; index < theBytes.Length; index += 2)
      {
        ushort theByte = (ushort) theBytes[index];
        if (index + 1 < theBytes.Length)
          theByte += (ushort) ((uint) theBytes[index + 1] << 8);
        stringBuilder.Append((char) theByte);
      }
      return stringBuilder.ToString();
    }

    public static string GetStringFromZipedBytes(byte[] zipedBytes)
    {
      return Encoding.UTF8.GetString(ZipUnzip.GetBytesFromZipedBytes(zipedBytes));
    }

    public static string GetStringFromZipedString(string theString)
    {
      return Encoding.UTF8.GetString(ZipUnzip.GetBytesFromZipedBytes(ZipUnzip.GetBytesFromPackedString(theString)));
    }

    public static byte[] GetBytesFromZipedBytes(byte[] zipedBytes)
    {
      byte[] array;
      using (MemoryStream memoryStream = new MemoryStream(zipedBytes))
      {
        using (MemoryStream destination = new MemoryStream())
        {
          using (GZipStream gzipStream = new GZipStream((Stream) memoryStream, CompressionMode.Decompress))
          {
            gzipStream.CopyTo((Stream) destination);
            gzipStream.Flush();
          }
          array = destination.ToArray();
        }
      }
      return array;
    }

    private static byte[] GetBytesFromPackedString(string theString)
    {
      int length = (theString.Length - 1) * 2;
      if (theString[0] == '1')
        --length;
      byte[] fromPackedString = new byte[length];
      int num = 0;
      for (int index = 1; index < theString.Length; ++index)
      {
        fromPackedString[num++] = (byte) ((uint) theString[index] & (uint) byte.MaxValue);
        if (num < fromPackedString.Length)
          fromPackedString[num++] = (byte) ((int) theString[index] >> 8 & (int) byte.MaxValue);
      }
      return fromPackedString;
    }
  }
}

