
--- DeviceTypeHelper.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.DeviceTypeHelper
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

using MSS.Core.Model.Meters;
using MSS.Utils.Utils;
using System;
using System.Collections.ObjectModel;
using System.Windows.Media.Imaging;

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public class DeviceTypeHelper
  {
    public static ObservableCollection<DeviceType> GetDeviceTypeCollection()
    {
      ObservableCollection<DeviceType> deviceTypeCollection = new ObservableCollection<DeviceType>();
      deviceTypeCollection.Add(DeviceTypeHelper.GetDeviceType(DeviceTypeEnum.MinotelContactRadio3, "pack://application:,,,/Styles;component/Images/SmallIcons/home-selected.png"));
      deviceTypeCollection.Add(DeviceTypeHelper.GetDeviceType(DeviceTypeEnum.M7, "pack://application:,,,/Styles;component/Images/SmallIcons/home-selected.png"));
      deviceTypeCollection.Add(DeviceTypeHelper.GetDeviceType(DeviceTypeEnum.C5MBus, "pack://application:,,,/Styles;component/Images/SmallIcons/home-selected.png"));
      deviceTypeCollection.Add(DeviceTypeHelper.GetDeviceType(DeviceTypeEnum.EDCRadio, "pack://application:,,,/Styles;component/Images/SmallIcons/home-selected.png"));
      deviceTypeCollection.Add(DeviceTypeHelper.GetDeviceType(DeviceTypeEnum.C5Radio, "pack://application:,,,/Styles;component/Images/SmallIcons/home-selected.png"));
      deviceTypeCollection.Add(DeviceTypeHelper.GetDeviceType(DeviceTypeEnum.MultidataN1, "pack://application:,,,/Styles;component/Images/SmallIcons/home-selected.png"));
      deviceTypeCollection.Add(DeviceTypeHelper.GetDeviceType(DeviceTypeEnum.MultidataS1, "pack://application:,,,/Styles;component/Images/SmallIcons/home-selected.png"));
      deviceTypeCollection.Add(DeviceTypeHelper.GetDeviceType(DeviceTypeEnum.WR3, "pack://application:,,,/Styles;component/Images/SmallIcons/home-selected.png"));
      deviceTypeCollection.Add(DeviceTypeHelper.GetDeviceType(DeviceTypeEnum.Zelsius, "pack://application:,,,/Styles;component/Images/SmallIcons/home-selected.png"));
      return deviceTypeCollection;
    }

    private static DeviceType GetDeviceType(DeviceTypeEnum deviceTypeEnum, string imagePath)
    {
      return new DeviceType()
      {
        DeviceTypeEnum = deviceTypeEnum,
        DeviceName = deviceTypeEnum.GetStringValue(),
        DeviceTypeImage = new BitmapImage(new Uri(imagePath))
      };
    }
  }
}


--- FixedStructureNodesValidator.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.FixedStructureNodesValidator
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

using MSS.Core.Model.Structures;

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public class FixedStructureNodesValidator : StructureNodesValidator
  {
    public FixedStructureNodesValidator()
    {
      this._invalidCombinations[StructureNodeTypeEnum.Meter].Add(new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter));
    }
  }
}


--- FixedStructureNodeTypesEnum.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.FixedStructureNodeTypesEnum
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public enum FixedStructureNodeTypesEnum
  {
    Location,
    Tenant,
    Meter,
    Minomat,
  }
}


--- FloorHelper.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.FloorHelper
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

using MSS.Business.Utils;
using MSS.Core.Model.MSSClient;
using MSS.DTO.Structures;
using MSS.Utils.Utils;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public static class FloorHelper
  {
    public static IEnumerable<FloorNameDTO> GetFloorNames()
    {
      ObservableCollection<FloorNameDTO> floorNames = new ObservableCollection<FloorNameDTO>();
      Dictionary<string, string> enumElements = EnumHelper.GetEnumElements<FloorNamesEnum>();
      int num = 1;
      foreach (KeyValuePair<string, string> keyValuePair in enumElements)
      {
        switch ((FloorNamesEnum) Enum.Parse(typeof (FloorNamesEnum), keyValuePair.Key, true))
        {
          case FloorNamesEnum.BM:
            floorNames.Add(new FloorNameDTO()
            {
              Id = num,
              FloorName = FloorNamesEnum.BM.GetStringValue(),
              FloorNameEnum = FloorNamesEnum.BM
            });
            break;
          case FloorNamesEnum.GF:
            floorNames.Add(new FloorNameDTO()
            {
              Id = num,
              FloorName = FloorNamesEnum.GF.GetStringValue(),
              FloorNameEnum = FloorNamesEnum.GF
            });
            break;
          case FloorNamesEnum.UF:
            floorNames.Add(new FloorNameDTO()
            {
              Id = num,
              FloorName = FloorNamesEnum.UF.GetStringValue(),
              FloorNameEnum = FloorNamesEnum.UF
            });
            break;
          case FloorNamesEnum.TF:
            floorNames.Add(new FloorNameDTO()
            {
              Id = num,
              FloorName = FloorNamesEnum.TF.GetStringValue(),
              FloorNameEnum = FloorNamesEnum.TF
            });
            break;
        }
        ++num;
      }
      return (IEnumerable<FloorNameDTO>) floorNames;
    }

    public static IEnumerable<DirectionDTO> GetDirections()
    {
      ObservableCollection<DirectionDTO> directions = new ObservableCollection<DirectionDTO>();
      Dictionary<string, string> enumElements = EnumHelper.GetEnumElements<DirectionsEnum>();
      int num = 1;
      foreach (KeyValuePair<string, string> keyValuePair in enumElements)
      {
        switch ((DirectionsEnum) Enum.Parse(typeof (DirectionsEnum), keyValuePair.Key, true))
        {
          case DirectionsEnum.Left:
            directions.Add(new DirectionDTO()
            {
              Id = num,
              Direction = DirectionsEnum.Left.GetStringValue(),
              DirectionEnum = DirectionsEnum.Left
            });
            break;
          case DirectionsEnum.Middle:
            directions.Add(new DirectionDTO()
            {
              Id = num,
              Direction = DirectionsEnum.Middle.GetStringValue(),
              DirectionEnum = DirectionsEnum.Middle
            });
            break;
          case DirectionsEnum.Right:
            directions.Add(new DirectionDTO()
            {
              Id = num,
              Direction = DirectionsEnum.Right.GetStringValue(),
              DirectionEnum = DirectionsEnum.Right
            });
            break;
        }
        ++num;
      }
      return (IEnumerable<DirectionDTO>) directions;
    }
  }
}


--- Group.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.Group
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

using MSS.Business.DTO;
using System.Collections.ObjectModel;

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public class Group
  {
    public Group() => this.Participants = new ObservableCollection<StructureNodeDTO>();

    public string Name { get; set; }

    public ObservableCollection<StructureNodeDTO> Participants { get; set; }
  }
}


--- InstallationMeterUniqueIdentifier.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.InstallationMeterUniqueIdentifier
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public struct InstallationMeterUniqueIdentifier
  {
    public string SerialNumber;
    public string TenantNo;
  }
}


--- LocationManager.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.LocationManager
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

using AutoMapper;
using MSS.Core.Model.MSSClient;
using MSS.Core.Model.Structures;
using MSS.DTO.Clients;
using MSS.DTO.Structures;
using MSS.Interfaces;
using MSS.Utils.Utils;
using Ninject;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public class LocationManager
  {
    private readonly IRepository<Location> _locationRepository;
    private readonly IRepository<Scenario> _scenarioRepository;
    private readonly IRepositoryFactory _repositoryFactory;

    [Inject]
    public LocationManager(IRepositoryFactory repositoryFactory)
    {
      this._repositoryFactory = repositoryFactory;
      this._locationRepository = repositoryFactory.GetRepository<Location>();
      this._scenarioRepository = repositoryFactory.GetRepository<Scenario>();
      Mapper.CreateMap<LocationDTO, Location>();
    }

    public IEnumerable<Scenario> GetScenarios()
    {
      return (IEnumerable<Scenario>) this._scenarioRepository.GetAll().OrderBy<Scenario, int>((Func<Scenario, int>) (x => x.Code));
    }

    public IEnumerable<EnumObj> GetGenerations()
    {
      ObservableCollection<EnumObj> generations = new ObservableCollection<EnumObj>();
      IEnumerable<GenerationEnum> source1 = Enum.GetValues(typeof (GenerationEnum)).Cast<GenerationEnum>();
      if (!(source1 is GenerationEnum[] generationEnumArray))
        generationEnumArray = source1.ToArray<GenerationEnum>();
      GenerationEnum[] source2 = generationEnumArray;
      if (((IEnumerable<GenerationEnum>) source2).Count<GenerationEnum>() != 0)
      {
        for (int index = 0; index < ((IEnumerable<GenerationEnum>) source2).Count<GenerationEnum>(); ++index)
        {
          GenerationEnum generationEnum = source2[index];
          EnumObj enumObj = new EnumObj()
          {
            IdEnum = index + 2,
            StatusFromObj = generationEnum.GetStringValue()
          };
          generations.Add(enumObj);
        }
      }
      return (IEnumerable<EnumObj>) generations;
    }

    public IEnumerable<EnumObj> GetScales()
    {
      ObservableCollection<EnumObj> scales = new ObservableCollection<EnumObj>();
      IEnumerable<ScaleEnum> source1 = Enum.GetValues(typeof (ScaleEnum)).Cast<ScaleEnum>();
      if (!(source1 is ScaleEnum[] scaleEnumArray))
        scaleEnumArray = source1.ToArray<ScaleEnum>();
      ScaleEnum[] source2 = scaleEnumArray;
      if (((IEnumerable<ScaleEnum>) source2).Count<ScaleEnum>() != 0)
      {
        for (int index = 0; index < ((IEnumerable<ScaleEnum>) source2).Count<ScaleEnum>(); ++index)
        {
          ScaleEnum scaleEnum = source2[index];
          EnumObj enumObj = new EnumObj()
          {
            IdEnum = index,
            StatusFromObj = scaleEnum.GetStringValue()
          };
          scales.Add(enumObj);
        }
      }
      return (IEnumerable<EnumObj>) scales;
    }
  }
}


--- ReadingMeterUniqueIdentifier.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.ReadingMeterUniqueIdentifier
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public struct ReadingMeterUniqueIdentifier
  {
    public string SerialNumber;
    public int GroupNumber;
    public string TenantNo;
  }
}


--- StructureEntrancesManager.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.StructureEntrancesManager
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

using MSS.Business.DTO;
using MSS.Core.Model.DataCollectors;
using MSS.Core.Model.Structures;
using MSS.DTO.Structures;
using MSS.Interfaces;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public class StructureEntrancesManager
  {
    private IRepositoryFactory _repositoryFactory;

    public List<string> GetStructureEntrances(
      StructureNodeDTO node,
      IRepositoryFactory repositoryFactory)
    {
      this._repositoryFactory = repositoryFactory;
      List<string> first = new List<string>();
      List<Guid> minomatGuidList = new List<Guid>();
      foreach (StructureNodeDTO subNode in (Collection<StructureNodeDTO>) node.RootNode.SubNodes)
      {
        if (subNode.Entity != null)
        {
          string name = subNode.NodeType?.Name;
          if (name != null)
          {
            switch ((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), name, true))
            {
              case StructureNodeTypeEnum.Tenant:
                string entrance = subNode.Entity is TenantDTO entity1 ? entity1.Entrance : (string) null;
                if (entrance != null && !first.Contains(entrance))
                {
                  first.Add(entrance);
                  break;
                }
                break;
              case StructureNodeTypeEnum.MinomatMaster:
                if (subNode.Entity is MinomatSerializableDTO entity3)
                {
                  Guid id1 = entity3.Id;
                  if (id1 != Guid.Empty)
                    minomatGuidList.Add(id1);
                  using (IEnumerator<StructureNodeDTO> enumerator = subNode.SubNodes.GetEnumerator())
                  {
                    while (enumerator.MoveNext())
                    {
                      if (enumerator.Current.Entity is MinomatSerializableDTO entity2)
                      {
                        Guid id2 = entity2.Id;
                        if (id2 != Guid.Empty)
                          minomatGuidList.Add(id2);
                      }
                    }
                    break;
                  }
                }
                else
                  break;
            }
          }
        }
      }
      List<string> stringList;
      if (minomatGuidList.Count <= 0)
        stringList = new List<string>();
      else
        stringList = this._repositoryFactory.GetRepository<MinomatRadioDetails>().Where((Expression<Func<MinomatRadioDetails, bool>>) (x => minomatGuidList.Contains(x.Minomat.Id))).Select<MinomatRadioDetails, string>((Expression<Func<MinomatRadioDetails, string>>) (x => x.Entrance)).Distinct<string>().ToList<string>();
      List<string> second = stringList;
      return first.Union<string>((IEnumerable<string>) second).OrderBy<string, string>((Func<string, string>) (x => x)).ToList<string>();
    }
  }
}


--- StructureNodesValidator.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.StructureNodesValidator
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

using MSS.Business.DTO;
using MSS.Business.Modules.GMM;
using MSS.Core.Model.Structures;
using MSS.Utils.Utils;
using System;
using System.Collections.Generic;
using System.Linq;

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public class StructureNodesValidator
  {
    protected internal Dictionary<StructureNodeTypeEnum, List<StructureNodeTypeEnum?>> _invalidCombinations;

    public StructureNodesValidator()
    {
      this._invalidCombinations = new Dictionary<StructureNodeTypeEnum, List<StructureNodeTypeEnum?>>();
      this._invalidCombinations.Add(StructureNodeTypeEnum.Meter, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Location),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.MinomatMaster),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.MinomatSlave),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Radio)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.COMServer, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.City, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.CityArea, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.Converter, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.Country, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.RadioMeter, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.COMServer),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.City),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.CityArea),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Converter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Country),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Minomat),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.MinomatMaster),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.MinomatSlave),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.DeviceGroup),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Flat),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Floor),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.House),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Location),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Manifold),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Repeater),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Street),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Tenant),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.User),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.UserDevice),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.UserGroup)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.Minomat, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Tenant),
        new StructureNodeTypeEnum?()
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.MinomatMaster, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Tenant),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.MinomatMaster),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.MinomatSlave),
        new StructureNodeTypeEnum?(),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.MinomatSlave, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Tenant),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.MinomatSlave),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Location),
        new StructureNodeTypeEnum?(),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.DeviceGroup, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.Flat, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.Floor, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.House, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.Location, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Tenant),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Location),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.MinomatMaster),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.MinomatSlave),
        new StructureNodeTypeEnum?(),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.Manifold, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.Repeater, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.Street, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.Tenant, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Tenant),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.MinomatMaster),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.MinomatSlave),
        new StructureNodeTypeEnum?(),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.User, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.UserDevice, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
      this._invalidCombinations.Add(StructureNodeTypeEnum.UserGroup, new List<StructureNodeTypeEnum?>()
      {
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.Meter),
        new StructureNodeTypeEnum?(StructureNodeTypeEnum.RadioMeter)
      });
    }

    public List<StructureNodeLinks> PhysicalLinks { get; set; }

    public bool IsValidNodesRelationship(
      StructureNodeDTO node,
      StructureNodeDTO parentNode,
      bool isDragFromTreelist)
    {
      if (node == null)
        return false;
      StructureNodeTypeEnum key = (StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), node.NodeType.Name, true);
      if (key == StructureNodeTypeEnum.Folder)
        return false;
      StructureNodeTypeEnum? typeParent = new StructureNodeTypeEnum?();
      if (parentNode != null)
      {
        StructureNodeDTO root = parentNode.RootNode == null || parentNode.RootNode == parentNode ? parentNode : parentNode.RootNode;
        StructureTypeEnum? structureType = root.StructureType;
        StructureTypeEnum structureTypeEnum1 = StructureTypeEnum.Logical;
        if (structureType.GetValueOrDefault() == structureTypeEnum1 && structureType.HasValue)
        {
          IEnumerable<StructureNodeDTO> source1 = StructuresHelper.Descendants(root);
          if (!isDragFromTreelist)
          {
            structureType = node.StructureType;
            StructureTypeEnum structureTypeEnum2 = StructureTypeEnum.Physical;
            if (structureType.GetValueOrDefault() == structureTypeEnum2 && structureType.HasValue && (source1.Any<StructureNodeDTO>((Func<StructureNodeDTO, bool>) (s => s.Id == node.Id)) || node.Entity == null && (node.NodeType.Name == StructureNodeTypeEnum.Meter.GetStringName() || node.NodeType.Name == StructureNodeTypeEnum.Location.GetStringName() || node.NodeType.Name == StructureNodeTypeEnum.Tenant.GetStringName())))
              return false;
          }
          else
          {
            StructureNodeDTO structureNodeDto1 = node.RootNode == null || node.RootNode == node || !(node.RootNode.NodeType.Name != StructureNodeTypeEnum.Folder.GetStringName()) ? node : node.RootNode;
            if (root != structureNodeDto1)
            {
              IEnumerable<StructureNodeDTO> source2 = StructuresHelper.Descendants(node);
              foreach (StructureNodeDTO structureNodeDto2 in source1)
              {
                StructureNodeDTO structureNodeDto = structureNodeDto2;
                if (source2.Any<StructureNodeDTO>((Func<StructureNodeDTO, bool>) (nodeDto => structureNodeDto.Id == nodeDto.Id && nodeDto.Id != Guid.Empty)))
                  return false;
              }
            }
          }
        }
        typeParent = new StructureNodeTypeEnum?((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), parentNode.NodeType.Name, true));
      }
      else if (this.PhysicalLinks != null && this.PhysicalLinks.Any<StructureNodeLinks>())
      {
        StructureTypeEnum? structureType;
        int num1;
        if (!node.IsNewNode)
        {
          structureType = node.StructureType;
          if (structureType.HasValue)
          {
            structureType = node.StructureType;
            num1 = structureType.Value != StructureTypeEnum.Logical ? 0 : (this.PhysicalLinks.Select<StructureNodeLinks, Guid>((Func<StructureNodeLinks, Guid>) (l => l.Node.Id)).Contains<Guid>(node.Id) ? 1 : 0);
            goto label_26;
          }
        }
        num1 = 0;
label_26:
        int num2 = isDragFromTreelist ? 1 : 0;
        if ((num1 & num2) != 0)
          return false;
        int num3;
        if (!node.IsNewNode)
        {
          structureType = node.StructureType;
          if (structureType.HasValue)
          {
            structureType = node.StructureType;
            num3 = structureType.Value == StructureTypeEnum.Physical ? 1 : 0;
            goto label_32;
          }
        }
        num3 = 0;
label_32:
        int num4 = isDragFromTreelist ? 1 : 0;
        if ((num3 & num4) != 0)
          return false;
        int num5;
        if (!node.IsNewNode)
        {
          structureType = node.StructureType;
          if (structureType.HasValue)
          {
            structureType = node.StructureType;
            if (structureType.Value == StructureTypeEnum.Physical)
            {
              num5 = !isDragFromTreelist ? 1 : 0;
              goto label_39;
            }
          }
        }
        num5 = 0;
label_39:
        if (num5 != 0)
          return false;
      }
      else
      {
        StructureTypeEnum? structureType;
        int num6;
        if (!node.IsNewNode)
        {
          structureType = node.StructureType;
          if (structureType.HasValue)
          {
            structureType = node.StructureType;
            if (structureType.Value == StructureTypeEnum.Physical)
            {
              num6 = !isDragFromTreelist ? 1 : 0;
              goto label_46;
            }
          }
        }
        num6 = 0;
label_46:
        if (num6 != 0)
          return false;
        int num7;
        if (isDragFromTreelist && node.RootNode != null)
        {
          structureType = node.RootNode.StructureType;
          StructureTypeEnum structureTypeEnum3 = StructureTypeEnum.Logical;
          if ((structureType.GetValueOrDefault() == structureTypeEnum3 ? (structureType.HasValue ? 1 : 0) : 0) != 0)
          {
            structureType = node.StructureType;
            StructureTypeEnum structureTypeEnum4 = StructureTypeEnum.Physical;
            if ((structureType.GetValueOrDefault() == structureTypeEnum4 ? (structureType.HasValue ? 1 : 0) : 0) != 0)
            {
              num7 = node.RootNode != node ? 1 : 0;
              goto label_53;
            }
          }
        }
        num7 = 0;
label_53:
        if (num7 != 0)
          return false;
      }
      if (ScanMinoConnectManager.IsScanningStarted || WalkByTestManager.IsWalkByTestStarted)
        return false;
      List<StructureNodeTypeEnum?> source;
      this._invalidCombinations.TryGetValue(key, out source);
      return source == null || source.All<StructureNodeTypeEnum?>((Func<StructureNodeTypeEnum?, bool>) (n =>
      {
        StructureNodeTypeEnum? nullable1 = n;
        StructureNodeTypeEnum? nullable2 = typeParent;
        return nullable1.GetValueOrDefault() != nullable2.GetValueOrDefault() || nullable1.HasValue != nullable2.HasValue;
      }));
    }
  }
}


--- StructuresHelper.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.StructuresHelper
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

using AutoMapper;
using MSS.Business.DTO;
using MSS.Business.Utils;
using MSS.Core.Model.DataCollectors;
using MSS.Core.Model.Meters;
using MSS.Core.Model.Orders;
using MSS.Core.Model.Structures;
using MSS.Core.Utils;
using MSS.DTO.Meters;
using MSS.DTO.Minomat;
using MSS.DTO.Orders;
using MSS.DTO.Structures;
using MSS.Interfaces;
using NHibernate;
using NHibernate.Linq;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Linq.Expressions;
using System.Windows;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Xml.Serialization;

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public static class StructuresHelper
  {
    public static void InitializeMappings()
    {
      Mapper.CreateMap<Meter, MeterSerializableDTO>().ForMember((Expression<Func<MeterSerializableDTO, object>>) (mDTO => (object) mDTO.RoomTypeId), (Action<IMemberConfigurationExpression<Meter>>) (x => x.MapFrom<Guid>((Expression<Func<Meter, Guid>>) (m => m.Room.Id)))).ForMember((Expression<Func<MeterSerializableDTO, object>>) (mDTO => (object) mDTO.ReadingUnitId), (Action<IMemberConfigurationExpression<Meter>>) (x => x.MapFrom<Guid>((Expression<Func<Meter, Guid>>) (m => m.ReadingUnit.Id)))).ForMember((Expression<Func<MeterSerializableDTO, object>>) (mDTO => (object) mDTO.ImpulsUnitId), (Action<IMemberConfigurationExpression<Meter>>) (x => x.MapFrom<Guid>((Expression<Func<Meter, Guid>>) (m => m.ImpulsUnit.Id)))).ForMember((Expression<Func<MeterSerializableDTO, object>>) (mDTO => (object) mDTO.ChannelId), (Action<IMemberConfigurationExpression<Meter>>) (x => x.MapFrom<Guid>((Expression<Func<Meter, Guid>>) (m => m.Channel.Id)))).ForMember((Expression<Func<MeterSerializableDTO, object>>) (mDTO => mDTO.RoomTypeCode), (Action<IMemberConfigurationExpression<Meter>>) (x => x.MapFrom<string>((Expression<Func<Meter, string>>) (m => m.Room.Code)))).ForMember((Expression<Func<MeterSerializableDTO, object>>) (mDTO => mDTO.ImpulsUnitCelestaCode), (Action<IMemberConfigurationExpression<Meter>>) (x => x.MapFrom<string>((Expression<Func<Meter, string>>) (m => m.ImpulsUnit.CelestaCode)))).ForMember((Expression<Func<MeterSerializableDTO, object>>) (mDTO => mDTO.ReadingUnitCelestaCode), (Action<IMemberConfigurationExpression<Meter>>) (x => x.MapFrom<string>((Expression<Func<Meter, string>>) (m => m.ReadingUnit.CelestaCode)))).ForMember((Expression<Func<MeterSerializableDTO, object>>) (mDTO => (object) mDTO.ConnectedDeviceTypeId), (Action<IMemberConfigurationExpression<Meter>>) (x => x.MapFrom<Guid>((Expression<Func<Meter, Guid>>) (m => m.ConnectedDeviceType.Id))));
      Mapper.CreateMap<Location, LocationSerializableDTO>().ForMember((Expression<Func<LocationSerializableDTO, object>>) (locDTO => (object) locDTO.ScenarioId), (Action<IMemberConfigurationExpression<Location>>) (x => x.MapFrom<Guid>((Expression<Func<Location, Guid>>) (loc => loc.Scenario.Id)))).ForMember((Expression<Func<LocationSerializableDTO, object>>) (locDTO => (object) locDTO.CountryId), (Action<IMemberConfigurationExpression<Location>>) (x => x.MapFrom<Guid>((Expression<Func<Location, Guid>>) (loc => loc.Country.Id))));
      Mapper.CreateMap<Tenant, TenantSerializableDTO>();
      Mapper.CreateMap<StructureNode, StructureNodeSerializableDTO>().ForMember((Expression<Func<StructureNodeSerializableDTO, object>>) (m => (object) m.NodeType), (Action<IMemberConfigurationExpression<StructureNode>>) (a => a.MapFrom<Guid>((Expression<Func<StructureNode, Guid>>) (e => e.NodeType.Id))));
      Mapper.CreateMap<StructureNodeLinks, StructureNodeLinksSerializableDTO>();
      Mapper.CreateMap<MSS.Core.Model.DataCollectors.Minomat, MinomatSerializableDTO>().ForMember((Expression<Func<MinomatSerializableDTO, object>>) (x => (object) x.ProviderId), (Action<IMemberConfigurationExpression<MSS.Core.Model.DataCollectors.Minomat>>) (x => x.MapFrom<Guid>((Expression<Func<MSS.Core.Model.DataCollectors.Minomat, Guid>>) (y => y.Provider.Id))));
    }

    public static void LoadItemsInGroup(
      Group group,
      ObservableCollection<StructureNodeDTO> availableNodes)
    {
      foreach (StructureNodeDTO availableNode in (Collection<StructureNodeDTO>) availableNodes)
        group.Participants.Add(availableNode);
    }

    public static IEnumerable<StructureNodeDTO> Descendants(StructureNodeDTO root)
    {
      Stack<StructureNodeDTO> nodes = new Stack<StructureNodeDTO>((IEnumerable<StructureNodeDTO>) new StructureNodeDTO[1]
      {
        root
      });
      while (nodes.Any<StructureNodeDTO>())
      {
        StructureNodeDTO node = nodes.Pop();
        yield return node;
        foreach (StructureNodeDTO n in (Collection<StructureNodeDTO>) node.SubNodes)
          nodes.Push(n);
        node = (StructureNodeDTO) null;
      }
    }

    public static ObservableCollection<StructureNodeDTO> GetTreeFromList(
      IList<StructureNodeType> structureNodeTypeList,
      IList<StructureNodeLinks> structureNodeLinksList,
      Dictionary<Guid, object> entitiesDictionary,
      List<string> duplicateMeterSerialNumbers = null,
      IList<MeterReplacementHistorySerializableDTO> meterReplacementHistoryList = null,
      bool loadOnDemand = false)
    {
      structureNodeLinksList = (IList<StructureNodeLinks>) structureNodeLinksList.OrderBy<StructureNodeLinks, int>((Func<StructureNodeLinks, int>) (l => l.OrderNr)).ToList<StructureNodeLinks>();
      Mapper.CreateMap<Meter, MeterDTO>();
      Mapper.CreateMap<Location, LocationDTO>();
      Mapper.CreateMap<Tenant, TenantDTO>();
      Mapper.CreateMap<MSS.Core.Model.DataCollectors.Minomat, MinomatSerializableDTO>().ForMember((Expression<Func<MinomatSerializableDTO, object>>) (x => (object) x.ProviderId), (Action<IMemberConfigurationExpression<MSS.Core.Model.DataCollectors.Minomat>>) (x => x.ResolveUsing((Func<MSS.Core.Model.DataCollectors.Minomat, object>) (y => y.Provider != null ? (object) y.Provider.Id : (object) Guid.Empty))));
      ObservableCollection<StructureNodeDTO> treeFromList = new ObservableCollection<StructureNodeDTO>();
      IList<StructureNodeLinks> list = (IList<StructureNodeLinks>) structureNodeLinksList.Where<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (x => x.ParentNodeId == Guid.Empty && x.RootNode.Id == x.Node.Id)).ToList<StructureNodeLinks>();
      IDictionary<Guid, StructureNodeType> dictionary1 = (IDictionary<Guid, StructureNodeType>) structureNodeTypeList.ToDictionary<StructureNodeType, Guid, StructureNodeType>((Func<StructureNodeType, Guid>) (x => x.Id), (Func<StructureNodeType, StructureNodeType>) (x => x));
      Dictionary<Guid, \u003C\u003Ef__AnonymousType0<Guid, ILookup<Guid, StructureNodeLinks>>> dictionary2 = structureNodeLinksList.GroupBy((Func<StructureNodeLinks, Guid>) (p => p.RootNode.Id), (key, g) => new
      {
        TreeRootNode = key,
        TreeElements = g.ToLookup<StructureNodeLinks, Guid>((Func<StructureNodeLinks, Guid>) (x => x.ParentNodeId))
      }).ToDictionary(x => x.TreeRootNode);
      foreach (StructureNodeLinks structureNodeLink in (IEnumerable<StructureNodeLinks>) list)
      {
        StructureNodeDTO newNode = StructuresHelper.CreateNewNode(structureNodeLink, dictionary1, entitiesDictionary, meterReplacementHistoryList);
        newNode.RootNode = newNode;
        newNode.IsEmpty = false;
        treeFromList.Add(newNode);
        Guid id = newNode.Id;
        if (!loadOnDemand && dictionary2.ContainsKey(id))
        {
          ILookup<Guid, StructureNodeLinks> treeElements = dictionary2[id].TreeElements;
          StructuresHelper.FillChild(newNode, newNode.Id, treeElements, dictionary1, entitiesDictionary, duplicateMeterSerialNumbers, meterReplacementHistoryList);
        }
      }
      return treeFromList;
    }

    public static ObservableCollection<StructureNodeDTO> GetTreeFromList(
      IEnumerable<StructureNodeType> structureNodeTypeList,
      IEnumerable<StructureNodeLinks> structureNodeLinksList,
      IEnumerable<StructureNode> nodesToBeColored,
      Dictionary<Guid, object> entitiesDictionary,
      List<string> duplicateMeterSerialNumbers = null)
    {
      Mapper.CreateMap<Meter, MeterDTO>();
      Mapper.CreateMap<Location, LocationDTO>();
      Mapper.CreateMap<Tenant, TenantDTO>();
      ObservableCollection<StructureNodeDTO> treeFromList = new ObservableCollection<StructureNodeDTO>();
      IDictionary<Guid, StructureNodeType> structureNodeTypeDictionary = (IDictionary<Guid, StructureNodeType>) structureNodeTypeList.ToDictionary<StructureNodeType, Guid, StructureNodeType>((Func<StructureNodeType, Guid>) (x => x.Id), (Func<StructureNodeType, StructureNodeType>) (x => x));
      foreach (StructureNodeDTO structureNodeDto in structureNodeLinksList.Where<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (structureNodeLink => structureNodeLink.ParentNodeId == Guid.Empty && structureNodeLink.RootNode.Id == structureNodeLink.Node.Id)).Select<StructureNodeLinks, StructureNodeDTO>((Func<StructureNodeLinks, StructureNodeDTO>) (structureNodeLink => StructuresHelper.CreateNewNode(structureNodeLink, structureNodeTypeDictionary, entitiesDictionary))))
      {
        StructureNodeDTO parentNode = structureNodeDto;
        if (nodesToBeColored.Any<StructureNode>((Func<StructureNode, bool>) (u => u.Id == parentNode.Id)))
          parentNode.BackgroundColor = (System.Windows.Media.Brush) System.Windows.Media.Brushes.LightGreen;
        parentNode.RootNode = parentNode;
        treeFromList.Add(parentNode);
        Guid id = parentNode.Id;
        StructuresHelper.FillChild(parentNode, id, parentNode.Id, structureNodeLinksList, structureNodeTypeDictionary, nodesToBeColored, entitiesDictionary, duplicateMeterSerialNumbers);
      }
      return treeFromList;
    }

    public static void FillChild(
      StructureNodeDTO parentNode,
      Guid parentNodeId,
      ILookup<Guid, StructureNodeLinks> currentTreeLookup,
      IDictionary<Guid, StructureNodeType> structureNodeTypeDictionary,
      Dictionary<Guid, object> entitiesDictionary,
      List<string> duplicateMeterSerialNumbers,
      IList<MeterReplacementHistorySerializableDTO> meterReplacementHistoryList = null)
    {
      if (!currentTreeLookup.Contains(parentNodeId))
        return;
      foreach (StructureNodeLinks structureNodeLink in currentTreeLookup[parentNodeId])
      {
        StructureNodeDTO childNode = StructuresHelper.CreateNewNode(structureNodeLink, structureNodeTypeDictionary, entitiesDictionary, meterReplacementHistoryList);
        if (childNode.NodeType.Name == StructureNodeTypeEnum.Tenant.ToString())
        {
          SolidColorBrush solidColorBrush = new SolidColorBrush(System.Windows.Media.Color.FromRgb((byte) 237, (byte) 237, (byte) 237));
          solidColorBrush.Freeze();
          childNode.BackgroundColor = (System.Windows.Media.Brush) solidColorBrush;
        }
        if (duplicateMeterSerialNumbers != null && duplicateMeterSerialNumbers.Count > 0 && (childNode.NodeType.Name == "Meter" || childNode.NodeType.Name == "RadioMeter") && duplicateMeterSerialNumbers.Contains(childNode.Entity is MeterDTO entity ? entity.SerialNumber : (string) null))
          childNode.IsDuplicate = true;
        childNode.IsEmpty = !currentTreeLookup.Any<IGrouping<Guid, StructureNodeLinks>>((Func<IGrouping<Guid, StructureNodeLinks>, bool>) (v => v.Any<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (l => l.ParentNodeId == childNode.Id && !l.EndDate.HasValue))));
        parentNode.SubNodes.Add(childNode);
        StructuresHelper.FillChild(childNode, childNode.Id, currentTreeLookup, structureNodeTypeDictionary, entitiesDictionary, duplicateMeterSerialNumbers, meterReplacementHistoryList);
      }
    }

    public static void FillChild(
      StructureNodeDTO parentNode,
      Guid rootNodeId,
      Guid parentNodeId,
      IEnumerable<StructureNodeLinks> structureNodeLinksList,
      IDictionary<Guid, StructureNodeType> structureNodeTypeDictionary,
      IEnumerable<StructureNode> nodesToBeColored,
      Dictionary<Guid, object> entitiesDictionary,
      List<string> duplicateMeterSerialNumbers)
    {
      IEnumerable<StructureNodeLinks> source = structureNodeLinksList.Where<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (s => s.ParentNodeId == parentNodeId && s.RootNode.Id == rootNodeId));
      if (!source.Any<StructureNodeLinks>())
        return;
      foreach (StructureNodeDTO structureNodeDto in source.Select<StructureNodeLinks, StructureNodeDTO>((Func<StructureNodeLinks, StructureNodeDTO>) (structureNode => StructuresHelper.CreateNewNode(structureNode, structureNodeTypeDictionary, entitiesDictionary))))
      {
        StructureNodeDTO childNode = structureNodeDto;
        if (nodesToBeColored.Any<StructureNode>((Func<StructureNode, bool>) (u => u.Id == childNode.Id)))
          childNode.BackgroundColor = (System.Windows.Media.Brush) System.Windows.Media.Brushes.LightGreen;
        string name1 = childNode.NodeType.Name;
        StructureNodeTypeEnum structureNodeTypeEnum = StructureNodeTypeEnum.Tenant;
        string str1 = structureNodeTypeEnum.ToString();
        if (name1 == str1)
        {
          SolidColorBrush solidColorBrush = new SolidColorBrush(System.Windows.Media.Color.FromRgb((byte) 237, (byte) 237, (byte) 237));
          solidColorBrush.Freeze();
          childNode.BackgroundColor = (System.Windows.Media.Brush) solidColorBrush;
        }
        if (duplicateMeterSerialNumbers != null && duplicateMeterSerialNumbers.Count > 0)
        {
          string name2 = childNode.NodeType.Name;
          structureNodeTypeEnum = StructureNodeTypeEnum.Meter;
          string str2 = structureNodeTypeEnum.ToString();
          if (name2 == str2 && duplicateMeterSerialNumbers.Contains((childNode.Entity as MeterDTO).SerialNumber))
            childNode.IsDuplicate = true;
        }
        parentNode.SubNodes.Add(childNode);
        StructuresHelper.FillChild(childNode, rootNodeId, childNode.Id, structureNodeLinksList, structureNodeTypeDictionary, nodesToBeColored, entitiesDictionary, duplicateMeterSerialNumbers);
      }
    }

    public static StructureNodeDTO CreateNewNode(
      StructureNodeLinks structureNodeLink,
      IDictionary<Guid, StructureNodeType> structureNodeTypeDictionary,
      Dictionary<Guid, object> entitiesDictionary,
      IList<MeterReplacementHistorySerializableDTO> meterReplacementHistoryList = null)
    {
      StructureNodeDTO node = new StructureNodeDTO();
      if (structureNodeLink.Node != null)
      {
        node.Id = structureNodeLink.Node.Id;
        node.Name = structureNodeLink.Node.Name;
        node.Description = structureNodeLink.Node.Description;
        node.StructureType = new StructureTypeEnum?(structureNodeLink.StructureType);
        node.OrderNr = structureNodeLink.OrderNr;
        node.IsDuplicate = false;
        if (structureNodeTypeDictionary.ContainsKey(structureNodeLink.Node.NodeType.Id))
        {
          StructureNodeType structureNodeType = structureNodeTypeDictionary[structureNodeLink.Node.NodeType.Id];
          node.NodeType = structureNodeType;
          if (structureNodeLink.Node.EntityId != Guid.Empty && entitiesDictionary.ContainsKey(structureNodeLink.Node.EntityId))
          {
            object entities = entitiesDictionary[structureNodeLink.Node.EntityId];
            if (entities != null)
            {
              object entityDto = StructuresHelper.GetEntityDTO((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), structureNodeType.Name, true), entities);
              if (entityDto is MeterDTO meterDto && meterReplacementHistoryList != null)
                StructuresHelper.UpdateMeterReplacementHistory(meterDto, meterReplacementHistoryList);
              node.Entity = entityDto;
            }
          }
        }
        BitmapImage imageForNode = StructuresHelper.GetImageForNode(node, node.Entity != null);
        imageForNode.Freeze();
        node.Image = imageForNode;
      }
      return node;
    }

    public static void UpdateMeterReplacementHistory(
      MeterDTO meterDto,
      IList<MeterReplacementHistorySerializableDTO> meterReplacementHistoryList)
    {
      if (!meterDto.IsReplaced)
        return;
      IEnumerable<MeterReplacementHistorySerializableDTO> source = meterReplacementHistoryList.Where<MeterReplacementHistorySerializableDTO>((Func<MeterReplacementHistorySerializableDTO, bool>) (m => m.CurrentMeterId == meterDto.Id));
      meterDto.MeterReplacementHistoryList = source.ToList<MeterReplacementHistorySerializableDTO>();
    }

    public static List<MeterReplacementHistorySerializableDTO> GetMeterReplacementHistorySerializableDTO(
      IList<MeterReplacementHistory> meterReplacementHistoryList)
    {
      List<MeterReplacementHistorySerializableDTO> historySerializableDto1 = new List<MeterReplacementHistorySerializableDTO>();
      foreach (MeterReplacementHistory replacementHistory in (IEnumerable<MeterReplacementHistory>) meterReplacementHistoryList)
      {
        MeterReplacementHistorySerializableDTO historySerializableDto2 = new MeterReplacementHistorySerializableDTO()
        {
          CurrentMeterId = replacementHistory.CurrentMeter.Id,
          ReplacedMeterId = replacementHistory.ReplacedMeter.Id,
          ReplacedMeterDeviceType = replacementHistory.ReplacedMeter.DeviceType,
          ReplacedMeterSerialNumber = replacementHistory.ReplacedMeter.SerialNumber,
          ReplacementDate = replacementHistory.ReplacementDate,
          ReplacedByUserId = replacementHistory.ReplacedByUser.Id,
          LastChangedOn = replacementHistory.LastChangedOn
        };
        historySerializableDto1.Add(historySerializableDto2);
      }
      return historySerializableDto1;
    }

    public static BitmapImage GetImageForNode(StructureNodeDTO node, bool hasEntity)
    {
      StructureNodeType nodeType = node.NodeType;
      string[] files1 = new string[2]
      {
        nodeType.IconPath,
        "pack://application:,,,/Styles;component/Images/StructureIcons/exclamation2.png"
      };
      BitmapImage imageForNode = new BitmapImage(new Uri("pack://application:,,,/Styles;component/Images/StructureIcons/replace-meter4.png"));
      string[] files2 = new string[2]
      {
        "pack://application:,,,/Styles;component/Images/StructureIcons/replace-meter4.png",
        "pack://application:,,,/Styles;component/Images/StructureIcons/exclamation2.png"
      };
      switch ((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), nodeType.Name, true))
      {
        case StructureNodeTypeEnum.Location:
          return hasEntity ? new BitmapImage(new Uri(nodeType.IconPath)) : ImageHelper.Instance.GetBitmapImageFromFiles(files1);
        case StructureNodeTypeEnum.Tenant:
          return hasEntity ? new BitmapImage(new Uri(nodeType.IconPath)) : ImageHelper.Instance.GetBitmapImageFromFiles(files1);
        case StructureNodeTypeEnum.Meter:
        case StructureNodeTypeEnum.RadioMeter:
          MeterDTO entity1 = node.Entity as MeterDTO;
          StructureTypeEnum? structureType = node.StructureType;
          StructureTypeEnum structureTypeEnum1 = StructureTypeEnum.Fixed;
          if (structureType.GetValueOrDefault() == structureTypeEnum1 && structureType.HasValue)
          {
            bool? isConfigured;
            int num1;
            if (hasEntity && entity1 != null && entity1.IsReplaced)
            {
              isConfigured = entity1.IsConfigured;
              bool flag = true;
              num1 = isConfigured.GetValueOrDefault() == flag ? (isConfigured.HasValue ? 1 : 0) : 0;
            }
            else
              num1 = 0;
            if (num1 != 0)
              return imageForNode;
            int num2;
            if (hasEntity && entity1 != null && entity1.IsReplaced)
            {
              isConfigured = entity1.IsConfigured;
              bool flag = false;
              num2 = isConfigured.GetValueOrDefault() == flag ? (isConfigured.HasValue ? 1 : 0) : 0;
            }
            else
              num2 = 0;
            if (num2 != 0)
              return ImageHelper.Instance.GetBitmapImageFromFiles(files2);
            int num3;
            if (hasEntity && entity1 != null)
            {
              isConfigured = entity1.IsConfigured;
              bool flag = true;
              num3 = isConfigured.GetValueOrDefault() == flag ? (isConfigured.HasValue ? 1 : 0) : 0;
            }
            else
              num3 = 0;
            return num3 != 0 ? new BitmapImage(new Uri(nodeType.IconPath)) : ImageHelper.Instance.GetBitmapImageFromFiles(files1);
          }
          structureType = node.StructureType;
          StructureTypeEnum structureTypeEnum2 = StructureTypeEnum.Physical;
          int num;
          if ((structureType.GetValueOrDefault() == structureTypeEnum2 ? (structureType.HasValue ? 1 : 0) : 0) == 0)
          {
            structureType = node.StructureType;
            StructureTypeEnum structureTypeEnum3 = StructureTypeEnum.Logical;
            num = structureType.GetValueOrDefault() == structureTypeEnum3 ? (structureType.HasValue ? 1 : 0) : 0;
          }
          else
            num = 1;
          if (num == 0)
            return !hasEntity || entity1 == null ? ImageHelper.Instance.GetBitmapImageFromFiles(files1) : new BitmapImage(new Uri(nodeType.IconPath));
          if (entity1 != null && entity1.IsReplaced)
            return imageForNode;
          return entity1 != null ? new BitmapImage(new Uri(node.NodeType.IconPath)) : ImageHelper.Instance.GetBitmapImageFromFiles(files1);
        case StructureNodeTypeEnum.MinomatMaster:
        case StructureNodeTypeEnum.MinomatSlave:
          if (node.Entity == null)
            return new BitmapImage(new Uri(node.NodeType.IconPath));
          return !(node.Entity is MinomatSerializableDTO entity2) ? ((node.Entity as MinomatDTO).IsMaster ? new BitmapImage(new Uri(node.NodeType.IconPath)) : new BitmapImage(new Uri("pack://application:,,,/Styles;component/Images/StructureIcons/minomats.png"))) : (entity2.IsMaster ? new BitmapImage(new Uri(node.NodeType.IconPath)) : new BitmapImage(new Uri("pack://application:,,,/Styles;component/Images/StructureIcons/minomats.png")));
        default:
          return new BitmapImage(new Uri(nodeType.IconPath));
      }
    }

    public static BitmapImage Combine2Images(BitmapImage image, SolidColorBrush colorState)
    {
      if (colorState == null)
        return image;
      Bitmap secondImage = (Bitmap) null;
      if (colorState.Equals((object) System.Windows.Media.Brushes.LightGreen))
        secondImage = new Bitmap(Application.GetResourceStream(new Uri("pack://application:,,,/Styles;component/Images/Universal/checkmark-green.png", UriKind.RelativeOrAbsolute)).Stream);
      else if (colorState.Equals((object) System.Windows.Media.Brushes.OrangeRed))
        secondImage = new Bitmap(Application.GetResourceStream(new Uri("pack://application:,,,/Styles;component/Images/Universal/checkmark-red.png", UriKind.RelativeOrAbsolute)).Stream);
      else if (colorState.Equals((object) System.Windows.Media.Brushes.DeepSkyBlue))
        secondImage = new Bitmap(Application.GetResourceStream(new Uri("pack://application:,,,/Styles;component/Images/Universal/checkmark-blue.png", UriKind.RelativeOrAbsolute)).Stream);
      else if (colorState.Equals((object) System.Windows.Media.Brushes.Yellow))
        secondImage = new Bitmap(Application.GetResourceStream(new Uri("pack://application:,,,/Styles;component/Images/Universal/checkmark-yellow.png", UriKind.RelativeOrAbsolute)).Stream);
      return ImageHelper.Instance.Combine2Images(ImageHelper.Instance.BitmapImage2Bitmap(image), secondImage);
    }

    public static BitmapImage GetImageForNode(
      StructureNodeType nodeType,
      object entity,
      bool hasEntity)
    {
      string[] files = new string[2]
      {
        nodeType.IconPath,
        "pack://application:,,,/Styles;component/Images/StructureIcons/exclamation2.png"
      };
      switch ((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), nodeType.Name, true))
      {
        case StructureNodeTypeEnum.Location:
          return hasEntity ? new BitmapImage(new Uri(nodeType.IconPath)) : ImageHelper.Instance.GetBitmapImageFromFiles(files);
        case StructureNodeTypeEnum.Tenant:
          return hasEntity ? new BitmapImage(new Uri(nodeType.IconPath)) : ImageHelper.Instance.GetBitmapImageFromFiles(files);
        case StructureNodeTypeEnum.Meter:
        case StructureNodeTypeEnum.RadioMeter:
          return new BitmapImage(new Uri(nodeType.IconPath));
        case StructureNodeTypeEnum.MinomatMaster:
        case StructureNodeTypeEnum.MinomatSlave:
          if (entity == null)
            return new BitmapImage(new Uri(nodeType.IconPath));
          return !(entity is MinomatSerializableDTO minomatSerializableDto) ? ((entity as MinomatDTO).IsMaster ? new BitmapImage(new Uri(nodeType.IconPath)) : new BitmapImage(new Uri("pack://application:,,,/Styles;component/Images/StructureIcons/minomats.png"))) : (minomatSerializableDto.IsMaster ? new BitmapImage(new Uri(nodeType.IconPath)) : new BitmapImage(new Uri("pack://application:,,,/Styles;component/Images/StructureIcons/minomats.png")));
        default:
          return new BitmapImage(new Uri(nodeType.IconPath));
      }
    }

    public static BitmapImage GetImageForMeterNode(
      MeterMBusStateEnum? meterState,
      StructureNodeType nodeType,
      bool? isMeterConfigured,
      string meterSerialNumber,
      StructureTypeEnum? structureType,
      bool existsMeterWithSameSerialNumberInCurrentStructure,
      HashSet<string> metersMissingTranslationRules = null)
    {
      string[] files1 = new string[2]
      {
        nodeType.IconPath,
        "pack://application:,,,/Styles;component/Images/Universal/checkmark-red.png"
      };
      string[] files2 = new string[2]
      {
        nodeType.IconPath,
        "pack://application:,,,/Styles;component/Images/Universal/checkmark-green.png"
      };
      string[] files3 = new string[2]
      {
        nodeType.IconPath,
        "pack://application:,,,/Styles;component/Images/Universal/checkmark-yellow.png"
      };
      StructureTypeEnum? nullable = structureType;
      StructureTypeEnum structureTypeEnum = StructureTypeEnum.Fixed;
      if (nullable.GetValueOrDefault() == structureTypeEnum && nullable.HasValue)
      {
        if (StructuresHelper.MeterExistsInAnotherStructureOrHasNoSerialNumber(meterState, meterSerialNumber) || isMeterConfigured.HasValue && !isMeterConfigured.Value)
          return ImageHelper.Instance.GetBitmapImageFromFiles(files1);
        return metersMissingTranslationRules != null && metersMissingTranslationRules.Contains(meterSerialNumber) ? ImageHelper.Instance.GetBitmapImageFromFiles(files3) : ImageHelper.Instance.GetBitmapImageFromFiles(files2);
      }
      return StructuresHelper.MeterExistsInAnotherStructureOrHasNoSerialNumber(meterState, meterSerialNumber) || existsMeterWithSameSerialNumberInCurrentStructure && meterState.HasValue && meterState.Value != MeterMBusStateEnum.Update ? ImageHelper.Instance.GetBitmapImageFromFiles(files1) : new BitmapImage(new Uri(nodeType.IconPath));
    }

    public static bool MeterExistsInAnotherStructureOrHasNoSerialNumber(
      MeterMBusStateEnum? meterState,
      string meterSerialNumber)
    {
      int num;
      if (!string.IsNullOrWhiteSpace(meterSerialNumber))
      {
        if (meterState.HasValue)
        {
          if (meterState.Value != MeterMBusStateEnum.ExistingMeterInAnotherStructure)
          {
            MeterMBusStateEnum? nullable = meterState;
            MeterMBusStateEnum meterMbusStateEnum = MeterMBusStateEnum.ExistingMeterInAnotherStructureAndCurrentStructure;
            num = nullable.GetValueOrDefault() == meterMbusStateEnum ? (nullable.HasValue ? 1 : 0) : 0;
          }
          else
            num = 1;
        }
        else
          num = 0;
      }
      else
        num = 1;
      return num != 0;
    }

    public static object GetEntityDTO(StructureNodeTypeEnum structureNodeTypeName, object entityObj)
    {
      object obj = new object();
      object entityDto = new object();
      switch (structureNodeTypeName)
      {
        case StructureNodeTypeEnum.Location:
          entityDto = (object) Mapper.Map<Location, LocationDTO>(entityObj as Location);
          break;
        case StructureNodeTypeEnum.Tenant:
          entityDto = (object) Mapper.Map<Tenant, TenantDTO>(entityObj as Tenant);
          break;
        case StructureNodeTypeEnum.Meter:
        case StructureNodeTypeEnum.RadioMeter:
          entityDto = (object) Mapper.Map<Meter, MeterDTO>(entityObj as Meter);
          break;
        case StructureNodeTypeEnum.MinomatMaster:
        case StructureNodeTypeEnum.MinomatSlave:
          entityDto = (object) Mapper.Map<MSS.Core.Model.DataCollectors.Minomat, MinomatSerializableDTO>(entityObj as MSS.Core.Model.DataCollectors.Minomat);
          break;
      }
      return entityDto;
    }

    public static void GetEntityIdAndEntityType(
      StructureNodeDTO structureNodeDto,
      out Guid entityId,
      out StructureNodeTypeEnum entityType)
    {
      object entity = structureNodeDto.Entity;
      entityId = Guid.Empty;
      entityType = (StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), structureNodeDto.NodeType.Name, true);
      switch (entityType)
      {
        case StructureNodeTypeEnum.Location:
          if (!(entity is Location location))
            break;
          entityId = location.Id;
          break;
        case StructureNodeTypeEnum.Tenant:
          if (!(entity is Tenant tenant))
            break;
          entityId = tenant.Id;
          break;
        case StructureNodeTypeEnum.Meter:
        case StructureNodeTypeEnum.RadioMeter:
          if (!(entity is Meter meter))
            break;
          entityId = meter.Id;
          break;
        case StructureNodeTypeEnum.MinomatMaster:
        case StructureNodeTypeEnum.MinomatSlave:
          if (!(entity is MSS.Core.Model.DataCollectors.Minomat minomat))
            break;
          entityId = minomat.Id;
          break;
        default:
          entityId = Guid.Empty;
          break;
      }
    }

    public static IEnumerable<StructureNodeLinks> GetDescendantsForStructureNodeLink(
      IRepository<StructureNodeLinks> _structureNodeLinksRepository,
      StructureNodeLinks parentStructureNodeLink)
    {
      List<StructureNodeLinks> descendants = new List<StructureNodeLinks>();
      IEnumerable<StructureNodeLinks> nodesForRootNode = StructuresHelper.GetStructureNodesForRootNode(_structureNodeLinksRepository, parentStructureNodeLink.RootNode.Id);
      StructuresHelper.FindChildren(parentStructureNodeLink, nodesForRootNode, ref descendants);
      descendants.Add(parentStructureNodeLink);
      return (IEnumerable<StructureNodeLinks>) descendants;
    }

    private static void FindChildren(
      StructureNodeLinks parentStructureNodeLink,
      IEnumerable<StructureNodeLinks> structureNodeLinkCollection,
      ref List<StructureNodeLinks> descendants)
    {
      IEnumerable<StructureNodeLinks> source = structureNodeLinkCollection.Where<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (s => s.ParentNodeId == parentStructureNodeLink.Node.Id));
      if (!source.Any<StructureNodeLinks>())
        return;
      foreach (StructureNodeLinks parentStructureNodeLink1 in source)
      {
        descendants.Add(parentStructureNodeLink1);
        StructuresHelper.FindChildren(parentStructureNodeLink1, structureNodeLinkCollection, ref descendants);
      }
    }

    public static IEnumerable<StructureNodeLinks> GetStructureNodesForRootNode(
      IRepository<StructureNodeLinks> _structureNodeLinksRepository,
      Guid rootNodeId)
    {
      return (IEnumerable<StructureNodeLinks>) _structureNodeLinksRepository.SearchFor((Expression<Func<StructureNodeLinks, bool>>) (s => s.RootNode.Id == rootNodeId)).ToList<StructureNodeLinks>();
    }

    public static IEnumerable<StructureNodeDTO> GetStructureNodeDTOForRootNode(
      Guid structureRootNodeId,
      IRepository<StructureNodeLinks> structureNodeLinksRepository,
      IRepository<StructureNode> structureNodeReporsitory,
      IRepository<StructureNodeType> structureNodeTypeRepository,
      ISession session,
      IList<MeterReplacementHistorySerializableDTO> meterReplacementHistory = null)
    {
      ObservableCollection<StructureNodeDTO> nodeDtoForRootNode = new ObservableCollection<StructureNodeDTO>();
      if (structureRootNodeId != Guid.Empty)
      {
        StructureNodeLinks structureNodeLinks = structureNodeLinksRepository.FirstOrDefault((Expression<Func<StructureNodeLinks, bool>>) (s => s.Node.Id == structureRootNodeId));
        List<StructureNodeLinks> list = StructuresHelper.GetStructureNodesForRootNode(structureNodeLinksRepository, structureNodeLinks.Node.Id).Where<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (s => !s.EndDate.HasValue)).ToList<StructureNodeLinks>();
        List<Guid> nodeIDs = StructuresHelper.GetNodeIdList((IEnumerable<StructureNodeLinks>) list);
        Dictionary<Guid, object> entitiesDictionary = StructuresHelper.GetEntitiesDictionary(structureNodeReporsitory.SearchFor((Expression<Func<StructureNode, bool>>) (s => nodeIDs.Contains(s.Id) && s.EndDate == new DateTime?())), session);
        nodeDtoForRootNode = StructuresHelper.GetTreeFromList(structureNodeTypeRepository.GetAll(), (IList<StructureNodeLinks>) list, entitiesDictionary, meterReplacementHistoryList: meterReplacementHistory);
      }
      return (IEnumerable<StructureNodeDTO>) nodeDtoForRootNode;
    }

    public static Dictionary<Guid, object> GetEntitiesDictionary(
      IList<StructureNode> structureNodeList,
      ISession session)
    {
      Dictionary<Guid, object> entitiesDictionary = new Dictionary<Guid, object>();
      foreach (StructureNode structureNode in (IEnumerable<StructureNode>) structureNodeList)
      {
        if (structureNode.EntityId != Guid.Empty)
        {
          object entity = StructuresHelper.GetEntity((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), structureNode.EntityName, true), structureNode, session);
          entitiesDictionary.Add(structureNode.EntityId, entity);
        }
      }
      return entitiesDictionary;
    }

    public static List<Guid> GetNodeIdList(IEnumerable<StructureNodeLinks> structureNodeLinks)
    {
      List<Guid> nodeIDs = new List<Guid>();
      foreach (StructureNodeLinks structureNodeLinks1 in structureNodeLinks.Where<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (structureNode => !nodeIDs.Contains(structureNode.Node.Id))))
        nodeIDs.Add(structureNodeLinks1.Node.Id);
      return nodeIDs;
    }

    public static object GetEntity(
      StructureNodeTypeEnum structureNodeTypeName,
      StructureNode structureNode,
      ISession session)
    {
      object entity = new object();
      switch (structureNodeTypeName)
      {
        case StructureNodeTypeEnum.Location:
          entity = (object) StructuresHelper.GetEntity<Location>(structureNode.EntityId, session);
          break;
        case StructureNodeTypeEnum.Tenant:
          entity = (object) StructuresHelper.GetEntity<Tenant>(structureNode.EntityId, session);
          break;
        case StructureNodeTypeEnum.Meter:
        case StructureNodeTypeEnum.RadioMeter:
          entity = (object) StructuresHelper.GetEntity<Meter>(structureNode.EntityId, session);
          break;
        case StructureNodeTypeEnum.MinomatMaster:
        case StructureNodeTypeEnum.MinomatSlave:
          entity = (object) StructuresHelper.GetEntity<MSS.Core.Model.DataCollectors.Minomat>(structureNode.EntityId, session);
          break;
      }
      return entity;
    }

    public static T GetEntity<T>(Guid entityId, ISession session)
    {
      return session.Get<T>((object) entityId);
    }

    public static OrderSerializableStructure GetSerializableStructure(Structure structure)
    {
      OrderSerializableStructure serializableStructure = new OrderSerializableStructure()
      {
        locationList = new List<LocationSerializableDTO>(),
        meterList = new List<MeterSerializableDTO>(),
        structureNodeList = new List<StructureNodeSerializableDTO>(),
        tenantList = new List<TenantSerializableDTO>(),
        minomatList = new List<MinomatSerializableDTO>(),
        structureNodesLinksList = new List<StructureNodeLinksSerializableDTO>(),
        meterReplacementHistoryList = new List<MeterReplacementHistorySerializableDTO>()
      };
      structure.Minomats.ForEach((Action<MSS.Core.Model.DataCollectors.Minomat>) (m =>
      {
        MinomatSerializableDTO minomatSerializableDto1 = new MinomatSerializableDTO();
        minomatSerializableDto1.Id = m.Id;
        minomatSerializableDto1.EndDate = m.EndDate;
        minomatSerializableDto1.IsDeactivated = m.IsDeactivated;
        minomatSerializableDto1.StartDate = m.StartDate;
        minomatSerializableDto1.AccessPoint = m.AccessPoint;
        minomatSerializableDto1.Challenge = m.Challenge;
        minomatSerializableDto1.CreatedBy = m.CreatedBy;
        minomatSerializableDto1.CreatedOn = m.CreatedOn;
        minomatSerializableDto1.GsmId = m.GsmId;
        minomatSerializableDto1.HostAndPort = m.HostAndPort;
        minomatSerializableDto1.IsInMasterPool = m.IsInMasterPool;
        minomatSerializableDto1.IsMaster = m.IsMaster;
        minomatSerializableDto1.LastUpdatedBy = m.LastUpdatedBy;
        minomatSerializableDto1.LastChangedOn = m.LastChangedOn;
        minomatSerializableDto1.RadioId = m.RadioId;
        MinomatSerializableDTO minomatSerializableDto2 = minomatSerializableDto1;
        Provider provider = m.Provider;
        Guid guid = provider != null ? provider.Id : Guid.Empty;
        minomatSerializableDto2.ProviderId = guid;
        minomatSerializableDto1.Polling = m.Polling;
        minomatSerializableDto1.ProviderName = m.ProviderName;
        minomatSerializableDto1.Registered = m.Registered;
        minomatSerializableDto1.SessionKey = m.SessionKey;
        minomatSerializableDto1.SimPin = m.SimPin;
        minomatSerializableDto1.Status = m.Status;
        serializableStructure.minomatList.Add(minomatSerializableDto1);
      }));
      structure.Links.ForEach((Action<StructureNodeLinks>) (l => serializableStructure.structureNodesLinksList.Add(new StructureNodeLinksSerializableDTO()
      {
        Id = l.Id,
        EndDate = l.EndDate,
        StartDate = l.StartDate,
        NodeId = l.Node.Id,
        ParentNodeId = l.ParentNodeId,
        RootNodeId = l.RootNode.Id,
        StructureType = l.StructureType,
        OrderNr = l.OrderNr,
        LastChangedOn = l.LastChangedOn
      })));
      structure.Nodes.ForEach((Action<StructureNode>) (s =>
      {
        StructureNodeSerializableDTO nodeSerializableDto1 = new StructureNodeSerializableDTO();
        nodeSerializableDto1.Id = s.Id;
        nodeSerializableDto1.Description = s.Description;
        nodeSerializableDto1.Name = s.Name;
        nodeSerializableDto1.EndDate = s.EndDate;
        nodeSerializableDto1.EntityId = s.EntityId;
        nodeSerializableDto1.EntityName = s.EntityName;
        StructureNodeSerializableDTO nodeSerializableDto2 = nodeSerializableDto1;
        StructureNodeType nodeType = s.NodeType;
        Guid guid = nodeType != null ? nodeType.Id : Guid.Empty;
        nodeSerializableDto2.NodeType = guid;
        nodeSerializableDto1.StartDate = s.StartDate;
        nodeSerializableDto1.LastChangedOn = s.LastChangedOn;
        serializableStructure.structureNodeList.Add(nodeSerializableDto1);
      }));
      structure.Locations.ForEach((Action<Location>) (l => serializableStructure.locationList.Add(new LocationSerializableDTO()
      {
        BuildingNr = l.BuildingNr,
        City = l.City,
        Description = l.Description,
        DueDate = l.DueDate,
        Generation = (int) l.Generation,
        HasMaster = l.HasMaster,
        Id = l.Id,
        ScenarioId = new Guid?(l.Scenario == null ? Guid.Empty : l.Scenario.Id),
        Street = l.Street,
        ZipCode = l.ZipCode,
        CountryId = l.Country != null ? l.Country.Id : Guid.Empty,
        LastChangedOn = l.LastChangedOn
      })));
      structure.Tenants.ForEach((Action<Tenant>) (t => serializableStructure.tenantList.Add(new TenantSerializableDTO()
      {
        ApartmentNr = t.ApartmentNr,
        CustomerTenantNo = t.CustomerTenantNo,
        Description = t.Description,
        Direction = t.Direction,
        FloorName = t.FloorName,
        FloorNr = t.FloorNr,
        Id = t.Id,
        IsDeactivated = t.IsDeactivated,
        Name = t.Name,
        TenantNr = t.TenantNr,
        Entrance = t.Entrance,
        LastChangedOn = t.LastChangedOn
      })));
      structure.Meters.ForEach((Action<Meter>) (m =>
      {
        MeterSerializableDTO meterSerializableDto1 = new MeterSerializableDTO();
        MeterSerializableDTO meterSerializableDto2 = meterSerializableDto1;
        Channel channel = m.Channel;
        Guid guid1 = channel != null ? channel.Id : Guid.Empty;
        meterSerializableDto2.ChannelId = guid1;
        meterSerializableDto1.CompletDevice = m.CompletDevice;
        meterSerializableDto1.ConnectedDeviceTypeId = m.ConnectedDeviceType == null ? Guid.Empty : m.ConnectedDeviceType.Id;
        meterSerializableDto1.DeviceType = m.DeviceType;
        meterSerializableDto1.Id = m.Id;
        meterSerializableDto1.EvaluationFactor = m.EvaluationFactor;
        meterSerializableDto1.ImpulsUnitCelestaCode = m.ImpulsUnit == null ? string.Empty : m.ImpulsUnit.CelestaCode;
        MeterSerializableDTO meterSerializableDto3 = meterSerializableDto1;
        MeasureUnit impulsUnit = m.ImpulsUnit;
        Guid guid2 = impulsUnit != null ? impulsUnit.Id : Guid.Empty;
        meterSerializableDto3.ImpulsUnitId = guid2;
        meterSerializableDto1.ImpulsValue = m.ImpulsValue;
        meterSerializableDto1.IsDeactivated = m.IsDeactivated;
        meterSerializableDto1.ReadingUnitCelestaCode = m.ReadingUnit == null ? string.Empty : m.ReadingUnit.CelestaCode;
        MeterSerializableDTO meterSerializableDto4 = meterSerializableDto1;
        MeasureUnit readingUnit = m.ReadingUnit;
        Guid guid3 = readingUnit != null ? readingUnit.Id : Guid.Empty;
        meterSerializableDto4.ReadingUnitId = guid3;
        meterSerializableDto1.RoomTypeCode = m.Room == null ? string.Empty : m.Room.Code;
        meterSerializableDto1.RoomTypeId = m.Room == null ? Guid.Empty : m.Room.Id;
        meterSerializableDto1.SerialNumber = m.SerialNumber;
        meterSerializableDto1.ShortDeviceNo = m.ShortDeviceNo;
        meterSerializableDto1.StartValue = m.StartValue;
        meterSerializableDto1.IsConfigured = m.IsConfigured;
        meterSerializableDto1.IsReplaced = m.IsReplaced;
        meterSerializableDto1.Manufacturer = m.Manufacturer;
        meterSerializableDto1.Medium = m.Medium;
        meterSerializableDto1.PrimaryAddress = m.PrimaryAddress;
        meterSerializableDto1.Generation = m.Generation;
        meterSerializableDto1.InputNumber = m.InputNumber;
        meterSerializableDto1.DeviceInfo = m.GMMAdditionalInfo;
        meterSerializableDto1.LastChangedOn = m.LastChangedOn;
        meterSerializableDto1.MbusRadioMeterId = m.MbusRadioMeter != null ? m.MbusRadioMeter.Id : Guid.Empty;
        meterSerializableDto1.City = m.MbusRadioMeter != null ? m.MbusRadioMeter.City : string.Empty;
        meterSerializableDto1.Street = m.MbusRadioMeter != null ? m.MbusRadioMeter.Street : string.Empty;
        meterSerializableDto1.HouseNumber = m.MbusRadioMeter != null ? m.MbusRadioMeter.HouseNumber : string.Empty;
        meterSerializableDto1.HouseNumberSupplement = m.MbusRadioMeter != null ? m.MbusRadioMeter.HouseNumberSupplement : string.Empty;
        meterSerializableDto1.ApartmentNumber = m.MbusRadioMeter != null ? m.MbusRadioMeter.ApartmentNumber : string.Empty;
        meterSerializableDto1.ZipCode = m.MbusRadioMeter != null ? m.MbusRadioMeter.ZipCode : string.Empty;
        meterSerializableDto1.FirstName = m.MbusRadioMeter != null ? m.MbusRadioMeter.FirstName : string.Empty;
        meterSerializableDto1.LastName = m.MbusRadioMeter != null ? m.MbusRadioMeter.LastName : string.Empty;
        meterSerializableDto1.Location = m.MbusRadioMeter != null ? m.MbusRadioMeter.Location : string.Empty;
        meterSerializableDto1.RadioSerialNumber = m.MbusRadioMeter != null ? m.MbusRadioMeter.RadioSerialNumber : string.Empty;
        meterSerializableDto1.ReadingEnabled = m.ReadingEnabled;
        serializableStructure.meterList.Add(meterSerializableDto1);
        if (!m.IsReplaced)
          return;
        TypeHelperExtensionMethods.ForEach<MeterReplacementHistorySerializableDTO>(structure.MeterReplacementHistory.Where<MeterReplacementHistorySerializableDTO>((Func<MeterReplacementHistorySerializableDTO, bool>) (h => h.CurrentMeterId == m.Id)), new Action<MeterReplacementHistorySerializableDTO>(serializableStructure.meterReplacementHistoryList.Add));
      }));
      return serializableStructure;
    }

    public static byte[] SerializeStructure(Structure structure)
    {
      OrderSerializableStructure serializableStructure = StructuresHelper.GetSerializableStructure(structure);
      XmlSerializer xmlSerializer = new XmlSerializer(serializableStructure.GetType());
      MemoryStream memoryStream = new MemoryStream();
      xmlSerializer.Serialize((Stream) memoryStream, (object) serializableStructure);
      return memoryStream.ToArray();
    }

    public static byte[] SerializeStructure(OrderSerializableStructure serializableStructure)
    {
      XmlSerializer xmlSerializer = new XmlSerializer(serializableStructure.GetType());
      MemoryStream memoryStream = new MemoryStream();
      xmlSerializer.Serialize((Stream) memoryStream, (object) serializableStructure);
      return memoryStream.ToArray();
    }

    public static byte[] SerializeStructure(
      ObservableCollection<StructureNodeDTO> nodeCollection,
      byte[] structureBytes)
    {
      OrderSerializableStructure serializableStructure;
      if (structureBytes != null)
        serializableStructure = StructuresHelper.DeserializeStructure(structureBytes);
      else
        serializableStructure = new OrderSerializableStructure()
        {
          locationList = new List<LocationSerializableDTO>(),
          meterList = new List<MeterSerializableDTO>(),
          tenantList = new List<TenantSerializableDTO>(),
          minomatList = new List<MinomatSerializableDTO>(),
          structureNodeList = new List<StructureNodeSerializableDTO>(),
          structureNodesLinksList = new List<StructureNodeLinksSerializableDTO>(),
          meterReplacementHistoryList = new List<MeterReplacementHistorySerializableDTO>()
        };
      List<Guid> guidList = new List<Guid>();
      foreach (StructureNodeDTO node in (Collection<StructureNodeDTO>) nodeCollection)
      {
        StructureNodeDTO structureNodeDTO = node;
        Guid entityId = Guid.Empty;
        string entityName = string.Empty;
        StructuresHelper.GetEntityIdAndentityName(structureNodeDTO, out entityId, out entityName);
        StructureNodeSerializableDTO nodeSerializableDto1 = serializableStructure.structureNodeList.FirstOrDefault<StructureNodeSerializableDTO>((Func<StructureNodeSerializableDTO, bool>) (n => n.Id == structureNodeDTO.Id));
        if (nodeSerializableDto1 != null)
        {
          nodeSerializableDto1.Description = structureNodeDTO.Description;
          nodeSerializableDto1.Name = structureNodeDTO.Name;
          nodeSerializableDto1.EntityId = entityId;
          nodeSerializableDto1.EntityName = entityName;
          nodeSerializableDto1.NodeType = structureNodeDTO.NodeType == null ? Guid.Empty : structureNodeDTO.NodeType.Id;
          nodeSerializableDto1.LastChangedOn = structureNodeDTO.LastChangedOn;
        }
        else
        {
          StructureNodeSerializableDTO nodeSerializableDto2 = new StructureNodeSerializableDTO();
          nodeSerializableDto2.Id = structureNodeDTO.Id;
          nodeSerializableDto2.Description = structureNodeDTO.Description;
          nodeSerializableDto2.Name = structureNodeDTO.Name;
          nodeSerializableDto2.EntityId = entityId;
          nodeSerializableDto2.EntityName = entityName;
          StructureNodeSerializableDTO nodeSerializableDto3 = nodeSerializableDto2;
          StructureNodeType nodeType = structureNodeDTO.NodeType;
          Guid guid = nodeType != null ? nodeType.Id : Guid.Empty;
          nodeSerializableDto3.NodeType = guid;
          nodeSerializableDto2.StartDate = new DateTime?(DateTime.Now);
          StructureNodeSerializableDTO nodeSerializableDto4 = nodeSerializableDto2;
          serializableStructure.structureNodeList.Add(nodeSerializableDto4);
        }
        StructureNodeLinksSerializableDTO linksSerializableDto1 = serializableStructure.structureNodesLinksList.FirstOrDefault<StructureNodeLinksSerializableDTO>((Func<StructureNodeLinksSerializableDTO, bool>) (l => l.NodeId == structureNodeDTO.Id));
        StructureTypeEnum? structureType;
        if (linksSerializableDto1 != null)
        {
          linksSerializableDto1.StartDate = new DateTime?(DateTime.Now);
          linksSerializableDto1.NodeId = structureNodeDTO.Id;
          linksSerializableDto1.ParentNodeId = structureNodeDTO.ParentNode != null ? structureNodeDTO.ParentNode.Id : Guid.Empty;
          linksSerializableDto1.RootNodeId = structureNodeDTO.RootNode != null ? structureNodeDTO.RootNode.Id : Guid.Empty;
          StructureNodeLinksSerializableDTO linksSerializableDto2 = linksSerializableDto1;
          structureType = structureNodeDTO.StructureType;
          int num = (int) structureType.Value;
          linksSerializableDto2.StructureType = (StructureTypeEnum) num;
          linksSerializableDto1.OrderNr = structureNodeDTO.OrderNr;
        }
        else
        {
          StructureNodeLinksSerializableDTO linksSerializableDto3 = new StructureNodeLinksSerializableDTO();
          linksSerializableDto3.Id = Guid.NewGuid();
          linksSerializableDto3.StartDate = new DateTime?(DateTime.Now);
          linksSerializableDto3.NodeId = structureNodeDTO.Id;
          linksSerializableDto3.ParentNodeId = structureNodeDTO.ParentNode != null ? structureNodeDTO.ParentNode.Id : Guid.Empty;
          linksSerializableDto3.RootNodeId = structureNodeDTO.RootNode != null ? structureNodeDTO.RootNode.Id : Guid.Empty;
          StructureNodeLinksSerializableDTO linksSerializableDto4 = linksSerializableDto3;
          structureType = structureNodeDTO.StructureType;
          int num = (int) structureType.Value;
          linksSerializableDto4.StructureType = (StructureTypeEnum) num;
          linksSerializableDto3.OrderNr = structureNodeDTO.OrderNr;
          StructureNodeLinksSerializableDTO linksSerializableDto5 = linksSerializableDto3;
          serializableStructure.structureNodesLinksList.Add(linksSerializableDto5);
        }
        if (structureNodeDTO.Entity != null)
        {
          switch ((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), structureNodeDTO.NodeType.Name, true))
          {
            case StructureNodeTypeEnum.Location:
              LocationDTO locationDTO = (LocationDTO) structureNodeDTO.Entity;
              LocationSerializableDTO locationSerializableDto1 = serializableStructure.locationList.FirstOrDefault<LocationSerializableDTO>((Func<LocationSerializableDTO, bool>) (l => l.Id == locationDTO.Id));
              if (locationSerializableDto1 != null)
              {
                locationSerializableDto1.BuildingNr = locationDTO.BuildingNr;
                locationSerializableDto1.City = locationDTO.City;
                locationSerializableDto1.Description = locationDTO.Description;
                locationSerializableDto1.DueDate = locationDTO.DueDate;
                locationSerializableDto1.Generation = (int) locationDTO.Generation;
                locationSerializableDto1.HasMaster = locationDTO.HasMaster;
                locationSerializableDto1.Id = locationDTO.Id;
                locationSerializableDto1.ScenarioId = new Guid?(locationDTO.Scenario == null ? Guid.Empty : locationDTO.Scenario.Id);
                locationSerializableDto1.Street = locationDTO.Street;
                locationSerializableDto1.ZipCode = locationDTO.ZipCode;
                locationSerializableDto1.LastChangedOn = locationDTO.LastChangedOn;
                break;
              }
              LocationSerializableDTO locationSerializableDto2 = new LocationSerializableDTO()
              {
                BuildingNr = locationDTO.BuildingNr,
                City = locationDTO.City,
                Description = locationDTO.Description,
                DueDate = locationDTO.DueDate,
                Generation = (int) locationDTO.Generation,
                HasMaster = locationDTO.HasMaster,
                Id = locationDTO.Id,
                ScenarioId = new Guid?(locationDTO.Scenario == null ? Guid.Empty : locationDTO.Scenario.Id),
                Street = locationDTO.Street,
                ZipCode = locationDTO.ZipCode,
                CountryId = MSS.Business.Utils.AppContext.Current.LoggedUser.Country.Id
              };
              serializableStructure.locationList.Add(locationSerializableDto2);
              break;
            case StructureNodeTypeEnum.Tenant:
              TenantDTO tenantDTO = (TenantDTO) structureNodeDTO.Entity;
              TenantSerializableDTO tenantSerializableDto1 = serializableStructure.tenantList.FirstOrDefault<TenantSerializableDTO>((Func<TenantSerializableDTO, bool>) (t => t.Id == tenantDTO.Id));
              if (tenantSerializableDto1 != null)
              {
                tenantSerializableDto1.ApartmentNr = tenantDTO.ApartmentNr;
                tenantSerializableDto1.CustomerTenantNo = tenantDTO.CustomerTenantNo;
                tenantSerializableDto1.Description = tenantDTO.Description;
                tenantSerializableDto1.Direction = tenantDTO.Direction;
                tenantSerializableDto1.FloorName = tenantDTO.FloorName;
                tenantSerializableDto1.FloorNr = tenantDTO.FloorNr;
                tenantSerializableDto1.IsDeactivated = tenantDTO.IsDeactivated;
                tenantSerializableDto1.Name = tenantDTO.Name;
                tenantSerializableDto1.TenantNr = tenantDTO.TenantNr;
                tenantSerializableDto1.Entrance = tenantDTO.Entrance;
                tenantSerializableDto1.LastChangedOn = tenantDTO.LastChangedOn;
                break;
              }
              TenantSerializableDTO tenantSerializableDto2 = new TenantSerializableDTO()
              {
                ApartmentNr = tenantDTO.ApartmentNr,
                CustomerTenantNo = tenantDTO.CustomerTenantNo,
                Description = tenantDTO.Description,
                Direction = tenantDTO.Direction,
                FloorName = tenantDTO.FloorName,
                FloorNr = tenantDTO.FloorNr,
                Id = tenantDTO.Id,
                IsDeactivated = tenantDTO.IsDeactivated,
                Name = tenantDTO.Name,
                TenantNr = tenantDTO.TenantNr,
                Entrance = tenantDTO.Entrance
              };
              serializableStructure.tenantList.Add(tenantSerializableDto2);
              break;
            case StructureNodeTypeEnum.Meter:
            case StructureNodeTypeEnum.RadioMeter:
              MeterDTO meterDTO = (MeterDTO) structureNodeDTO.Entity;
              MeterSerializableDTO meterSerializableDto1 = serializableStructure.meterList.FirstOrDefault<MeterSerializableDTO>((Func<MeterSerializableDTO, bool>) (m => m.Id == meterDTO.Id));
              if (meterSerializableDto1 != null)
              {
                meterSerializableDto1.ChannelId = meterDTO.Channel == null ? Guid.Empty : meterDTO.Channel.Id;
                meterSerializableDto1.CompletDevice = meterDTO.CompletDevice;
                meterSerializableDto1.ConnectedDeviceTypeId = meterDTO.ConnectedDeviceType == null ? Guid.Empty : meterDTO.ConnectedDeviceType.Id;
                meterSerializableDto1.DeviceType = meterDTO.DeviceType;
                meterSerializableDto1.Id = meterDTO.Id;
                meterSerializableDto1.EvaluationFactor = meterDTO.EvaluationFactor;
                meterSerializableDto1.ImpulsUnitCelestaCode = meterDTO.ImpulsUnit == null ? string.Empty : meterDTO.ImpulsUnit.CelestaCode;
                meterSerializableDto1.ImpulsUnitId = meterDTO.ImpulsUnit == null ? Guid.Empty : meterDTO.ImpulsUnit.Id;
                meterSerializableDto1.ImpulsValue = meterDTO.ImpulsValue;
                meterSerializableDto1.IsDeactivated = meterDTO.IsDeactivated;
                meterSerializableDto1.ReadingUnitCelestaCode = meterDTO.ReadingUnit == null ? string.Empty : meterDTO.ReadingUnit.CelestaCode;
                meterSerializableDto1.ReadingUnitId = meterDTO.ReadingUnit == null ? Guid.Empty : meterDTO.ReadingUnit.Id;
                meterSerializableDto1.RoomTypeCode = meterDTO.Room == null ? string.Empty : meterDTO.Room.Code;
                meterSerializableDto1.RoomTypeId = meterDTO.Room == null ? Guid.Empty : meterDTO.Room.Id;
                meterSerializableDto1.SerialNumber = meterDTO.SerialNumber;
                meterSerializableDto1.ShortDeviceNo = meterDTO.ShortDeviceNo;
                meterSerializableDto1.StartValue = meterDTO.StartValue;
                meterSerializableDto1.IsConfigured = meterDTO.IsConfigured;
              }
              else
              {
                MeterSerializableDTO meterSerializableDto2 = new MeterSerializableDTO();
                MeterSerializableDTO meterSerializableDto3 = meterSerializableDto2;
                Channel channel = meterDTO.Channel;
                Guid guid1 = channel != null ? channel.Id : Guid.Empty;
                meterSerializableDto3.ChannelId = guid1;
                meterSerializableDto2.CompletDevice = meterDTO.CompletDevice;
                MeterSerializableDTO meterSerializableDto4 = meterSerializableDto2;
                ConnectedDeviceType connectedDeviceType = meterDTO.ConnectedDeviceType;
                Guid guid2 = connectedDeviceType != null ? connectedDeviceType.Id : Guid.Empty;
                meterSerializableDto4.ConnectedDeviceTypeId = guid2;
                meterSerializableDto2.DeviceType = meterDTO.DeviceType;
                meterSerializableDto2.Id = meterDTO.Id;
                meterSerializableDto2.EvaluationFactor = meterDTO.EvaluationFactor;
                meterSerializableDto2.ImpulsUnitCelestaCode = meterDTO.ImpulsUnit == null ? string.Empty : meterDTO.ImpulsUnit.CelestaCode;
                MeterSerializableDTO meterSerializableDto5 = meterSerializableDto2;
                MeasureUnit impulsUnit = meterDTO.ImpulsUnit;
                Guid guid3 = impulsUnit != null ? impulsUnit.Id : Guid.Empty;
                meterSerializableDto5.ImpulsUnitId = guid3;
                meterSerializableDto2.ImpulsValue = meterDTO.ImpulsValue;
                meterSerializableDto2.IsDeactivated = meterDTO.IsDeactivated;
                meterSerializableDto2.ReadingUnitCelestaCode = meterDTO.ReadingUnit == null ? string.Empty : meterDTO.ReadingUnit.CelestaCode;
                MeterSerializableDTO meterSerializableDto6 = meterSerializableDto2;
                MeasureUnit readingUnit = meterDTO.ReadingUnit;
                Guid guid4 = readingUnit != null ? readingUnit.Id : Guid.Empty;
                meterSerializableDto6.ReadingUnitId = guid4;
                meterSerializableDto2.RoomTypeCode = meterDTO.Room == null ? string.Empty : meterDTO.Room.Code;
                MeterSerializableDTO meterSerializableDto7 = meterSerializableDto2;
                RoomType room = meterDTO.Room;
                Guid guid5 = room != null ? room.Id : Guid.Empty;
                meterSerializableDto7.RoomTypeId = guid5;
                meterSerializableDto2.SerialNumber = meterDTO.SerialNumber;
                meterSerializableDto2.ShortDeviceNo = meterDTO.ShortDeviceNo;
                meterSerializableDto2.StartValue = meterDTO.StartValue;
                meterSerializableDto2.IsConfigured = meterDTO.IsConfigured;
                meterSerializableDto2.IsReplaced = meterDTO.IsReplaced;
                meterSerializableDto2.LastChangedOn = meterDTO.LastChangedOn;
                MeterSerializableDTO meterSerializableDto8 = meterSerializableDto2;
                serializableStructure.meterList.Add(meterSerializableDto8);
              }
              Guid? replacedMeterId = meterDTO.ReplacedMeterId;
              if (replacedMeterId.HasValue)
              {
                Guid id = meterDTO.Id;
                replacedMeterId = meterDTO.ReplacedMeterId;
                Guid _replacedMeterId = replacedMeterId.Value;
                OrderSerializableStructure oldSerializableStructure = serializableStructure;
                List<MeterReplacementHistorySerializableDTO> historySerializableDtoList = StructuresHelper.UpdateMeterReplacementHistoryForReadingOrder(id, _replacedMeterId, oldSerializableStructure);
                serializableStructure.meterReplacementHistoryList = historySerializableDtoList;
                break;
              }
              break;
            case StructureNodeTypeEnum.MinomatMaster:
            case StructureNodeTypeEnum.MinomatSlave:
              MinomatSerializableDTO minomatDTO = (MinomatSerializableDTO) structureNodeDTO.Entity;
              MinomatSerializableDTO minomatSerializableDto = serializableStructure.minomatList.FirstOrDefault<MinomatSerializableDTO>((Func<MinomatSerializableDTO, bool>) (m => m.Id == minomatDTO.Id));
              if (minomatSerializableDto != null)
              {
                minomatSerializableDto.EndDate = minomatDTO.EndDate;
                minomatSerializableDto.IsDeactivated = minomatDTO.IsDeactivated;
                minomatSerializableDto.StartDate = minomatDTO.StartDate;
                minomatSerializableDto.AccessPoint = minomatDTO.AccessPoint;
                minomatSerializableDto.CelestaId = minomatDTO.CelestaId;
                minomatSerializableDto.Challenge = minomatDTO.Challenge;
                minomatSerializableDto.CreatedBy = minomatDTO.CreatedBy;
                minomatSerializableDto.CreatedOn = minomatDTO.CreatedOn;
                minomatSerializableDto.GsmId = minomatDTO.GsmId;
                minomatSerializableDto.HostAndPort = minomatDTO.HostAndPort;
                minomatSerializableDto.IsInMasterPool = minomatDTO.IsInMasterPool;
                minomatSerializableDto.IsMaster = minomatDTO.IsMaster;
                minomatSerializableDto.LastUpdatedBy = minomatDTO.LastUpdatedBy;
                minomatSerializableDto.LastChangedOn = minomatDTO.LastChangedOn;
                minomatSerializableDto.RadioId = minomatDTO.RadioId;
                minomatSerializableDto.ProviderId = minomatDTO.Id;
                minomatSerializableDto.Polling = minomatDTO.Polling;
                minomatSerializableDto.ProviderName = minomatDTO.ProviderName;
                minomatSerializableDto.Registered = minomatDTO.Registered;
                minomatSerializableDto.SessionKey = minomatDTO.SessionKey;
                minomatSerializableDto.SimPin = minomatDTO.SimPin;
                minomatSerializableDto.Status = minomatDTO.Status;
                break;
              }
              serializableStructure.minomatList.Add(minomatDTO);
              break;
          }
        }
        guidList.Add(structureNodeDTO.Id);
      }
      List<StructureNodeSerializableDTO> nodesToDelete = new List<StructureNodeSerializableDTO>();
      foreach (StructureNodeSerializableDTO structureNode in serializableStructure.structureNodeList)
      {
        if (!guidList.Contains(structureNode.Id))
          nodesToDelete.Add(structureNode);
      }
      StructuresHelper.RemoveNodesFromSerializableCollection(nodesToDelete, serializableStructure);
      structureBytes = StructuresHelper.SerializeStructure(serializableStructure);
      return structureBytes;
    }

    private static List<MeterReplacementHistorySerializableDTO> UpdateMeterReplacementHistoryForReadingOrder(
      Guid _currentMeterId,
      Guid _replacedMeterId,
      OrderSerializableStructure oldSerializableStructure)
    {
      List<MeterReplacementHistorySerializableDTO> replacementHistoryList = oldSerializableStructure.meterReplacementHistoryList;
      MeterSerializableDTO replacedMeterDTO = oldSerializableStructure.meterList.FirstOrDefault<MeterSerializableDTO>((Func<MeterSerializableDTO, bool>) (m => m.Id == _replacedMeterId));
      if (replacedMeterDTO != null)
      {
        MeterReplacementHistorySerializableDTO historySerializableDto1 = new MeterReplacementHistorySerializableDTO()
        {
          CurrentMeterId = _currentMeterId,
          ReplacedMeterId = replacedMeterDTO.Id,
          ReplacedMeterDeviceType = replacedMeterDTO.DeviceType,
          ReplacedMeterSerialNumber = replacedMeterDTO.SerialNumber,
          ReplacementDate = DateTime.Now,
          ReplacedByUserId = MSS.Business.Utils.AppContext.Current.LoggedUser.Id
        };
        replacementHistoryList.Add(historySerializableDto1);
        foreach (MeterReplacementHistorySerializableDTO historySerializableDto2 in replacementHistoryList.Where<MeterReplacementHistorySerializableDTO>((Func<MeterReplacementHistorySerializableDTO, bool>) (m => m.CurrentMeterId == replacedMeterDTO.Id)))
          historySerializableDto2.CurrentMeterId = _currentMeterId;
      }
      return replacementHistoryList;
    }

    private static void RemoveNodesFromSerializableCollection(
      List<StructureNodeSerializableDTO> nodesToDelete,
      OrderSerializableStructure serializableStructure)
    {
      foreach (StructureNodeSerializableDTO nodeSerializableDto in nodesToDelete)
      {
        StructureNodeSerializableDTO structureNodeSerializableDto = nodeSerializableDto;
        serializableStructure.structureNodeList.Remove(structureNodeSerializableDto);
        StructureNodeLinksSerializableDTO linksSerializableDto = serializableStructure.structureNodesLinksList.FirstOrDefault<StructureNodeLinksSerializableDTO>((Func<StructureNodeLinksSerializableDTO, bool>) (l => l.NodeId == structureNodeSerializableDto.Id));
        if (linksSerializableDto != null)
          serializableStructure.structureNodesLinksList.Remove(linksSerializableDto);
        if (!string.IsNullOrEmpty(structureNodeSerializableDto.EntityName))
        {
          switch (structureNodeSerializableDto.EntityName)
          {
            case "MeterDTO":
              MeterSerializableDTO meterSerializableDto = serializableStructure.meterList.FirstOrDefault<MeterSerializableDTO>((Func<MeterSerializableDTO, bool>) (m => m.Id == structureNodeSerializableDto.EntityId));
              serializableStructure.meterList.Remove(meterSerializableDto);
              break;
            case "TenantDTO":
              TenantSerializableDTO tenantSerializableDto = serializableStructure.tenantList.FirstOrDefault<TenantSerializableDTO>((Func<TenantSerializableDTO, bool>) (m => m.Id == structureNodeSerializableDto.EntityId));
              serializableStructure.tenantList.Remove(tenantSerializableDto);
              break;
            case "LocationDTO":
              LocationSerializableDTO locationSerializableDto = serializableStructure.locationList.FirstOrDefault<LocationSerializableDTO>((Func<LocationSerializableDTO, bool>) (m => m.Id == structureNodeSerializableDto.EntityId));
              serializableStructure.locationList.Remove(locationSerializableDto);
              break;
          }
        }
      }
    }

    private static void GetEntityIdAndentityName(
      StructureNodeDTO structureNodeDTO,
      out Guid entityId,
      out string entityName)
    {
      entityId = Guid.Empty;
      entityName = string.Empty;
      if (structureNodeDTO.Entity == null)
        return;
      switch ((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), structureNodeDTO.NodeType.Name, true))
      {
        case StructureNodeTypeEnum.Location:
          entityId = (structureNodeDTO.Entity as LocationDTO).Id;
          entityName = StructureNodeTypeEnum.Location.ToString();
          break;
        case StructureNodeTypeEnum.Tenant:
          entityId = (structureNodeDTO.Entity as TenantDTO).Id;
          entityName = StructureNodeTypeEnum.Tenant.ToString();
          break;
        case StructureNodeTypeEnum.Meter:
          entityId = (structureNodeDTO.Entity as MeterDTO).Id;
          entityName = StructureNodeTypeEnum.Meter.ToString();
          break;
        case StructureNodeTypeEnum.MinomatMaster:
          entityId = (structureNodeDTO.Entity as MinomatSerializableDTO).Id;
          entityName = StructureNodeTypeEnum.MinomatMaster.ToString();
          break;
        case StructureNodeTypeEnum.MinomatSlave:
          entityId = (structureNodeDTO.Entity as MinomatSerializableDTO).Id;
          entityName = StructureNodeTypeEnum.MinomatSlave.ToString();
          break;
        case StructureNodeTypeEnum.RadioMeter:
          entityId = (structureNodeDTO.Entity as MeterDTO).Id;
          entityName = StructureNodeTypeEnum.RadioMeter.ToString();
          break;
      }
    }

    public static StructureNodeDTO LoadStructureFromRootNodeId(
      IRepositoryFactory repositoryFactory,
      Guid rootNodeId)
    {
      Mapper.CreateMap<StructureNode, StructureNodeDTO>();
      StructureNodeDTO rootNodeDto = (StructureNodeDTO) null;
      StructureNodeLinks structureNodeLink = repositoryFactory.GetRepository<StructureNodeLinks>().FirstOrDefault((Expression<Func<StructureNodeLinks, bool>>) (item => item.Node.Id == rootNodeId));
      if (structureNodeLink != null)
      {
        Dictionary<Guid, StructureNodeType> dictionary = repositoryFactory.GetRepository<StructureNodeType>().GetAll().ToDictionary<StructureNodeType, Guid, StructureNodeType>((Func<StructureNodeType, Guid>) (item => item.Id), (Func<StructureNodeType, StructureNodeType>) (item => item));
        Dictionary<Guid, object> entitiesDictionary;
        repositoryFactory.GetStructureNodeRepository().GetStructureRootLinks(structureNodeLink.StructureType, out entitiesDictionary);
        rootNodeDto = StructuresHelper.CreateNewNode(structureNodeLink, (IDictionary<Guid, StructureNodeType>) dictionary, entitiesDictionary);
        rootNodeDto.RootNode = rootNodeDto;
        StructuresHelper.LoadSubNodesForRootNode(repositoryFactory, rootNodeDto, new StructuresManager(repositoryFactory));
      }
      return rootNodeDto;
    }

    public static void LoadSubNodesForRootNode(
      IRepositoryFactory repositoryFactory,
      StructureNodeDTO rootNodeDto,
      StructuresManager structuresManager)
    {
      IList<StructureNodeType> all1 = repositoryFactory.GetRepository<StructureNodeType>().GetAll();
      IList<MeterReplacementHistory> all2 = repositoryFactory.GetRepository<MeterReplacementHistory>().GetAll();
      StructureTypeEnum? structureType = rootNodeDto.StructureType;
      ObservableCollection<StructureNodeDTO> collectionWithChildren = structuresManager.GetNodeCollectionWithChildren(repositoryFactory.GetStructureNodeRepository(), structureType, all1, all2, rootNodeDto.Id);
      if (collectionWithChildren.Count <= 0)
        return;
      rootNodeDto.SubNodes = collectionWithChildren.First<StructureNodeDTO>().SubNodes;
    }

    public static OrderSerializableStructure DeserializeStructure(byte[] structureBytes)
    {
      return new XmlSerializer(typeof (OrderSerializableStructure)).Deserialize((Stream) new MemoryStream(structureBytes)) as OrderSerializableStructure;
    }

    public static Guid GetParentEntityIdForNode(Structure structure, Guid entityId)
    {
      StructureNode node = structure.Nodes.FirstOrDefault<StructureNode>((Func<StructureNode, bool>) (n => n.EntityId == entityId));
      if (node == null)
        return Guid.Empty;
      StructureNodeLinks link = structure.Links.FirstOrDefault<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (l => l.Node.Id == node.Id));
      if (link == null)
        return Guid.Empty;
      StructureNode structureNode = structure.Nodes.FirstOrDefault<StructureNode>((Func<StructureNode, bool>) (n => n.Id == link.ParentNodeId));
      return structureNode != null ? structureNode.EntityId : Guid.Empty;
    }

    public static Guid GetParentEntityIdForNode(OrderSerializableStructure structure, Guid entityId)
    {
      StructureNodeSerializableDTO node = structure.structureNodeList.FirstOrDefault<StructureNodeSerializableDTO>((Func<StructureNodeSerializableDTO, bool>) (n => n.EntityId == entityId));
      if (node == null)
        return Guid.Empty;
      StructureNodeLinksSerializableDTO link = structure.structureNodesLinksList.FirstOrDefault<StructureNodeLinksSerializableDTO>((Func<StructureNodeLinksSerializableDTO, bool>) (l => l.NodeId == node.Id));
      if (link == null)
        return Guid.Empty;
      StructureNodeSerializableDTO nodeSerializableDto = structure.structureNodeList.FirstOrDefault<StructureNodeSerializableDTO>((Func<StructureNodeSerializableDTO, bool>) (n => n.Id == link.ParentNodeId));
      return nodeSerializableDto != null ? nodeSerializableDto.EntityId : Guid.Empty;
    }

    public static int GetGroupNumber(DeviceTypeEnum deviceType, ConnectedDeviceType cdt)
    {
      switch (deviceType)
      {
        case DeviceTypeEnum.C5MBus:
        case DeviceTypeEnum.C5Radio:
        case DeviceTypeEnum.EDCRadio:
        case DeviceTypeEnum.MultidataS1:
        case DeviceTypeEnum.MultidataN1:
        case DeviceTypeEnum.WR3:
        case DeviceTypeEnum.Zelsius:
          return 100;
        case DeviceTypeEnum.M6:
          return 100;
        case DeviceTypeEnum.M7:
        case DeviceTypeEnum.MinomessMicroRadio3:
          return 100;
        case DeviceTypeEnum.MinotelContactRadio3:
          if (cdt != null)
          {
            switch (cdt.Code)
            {
              case "0":
              case "4":
              case "5":
                return 300;
              case "1":
                return 200;
              case "2":
              case "3":
                return 100;
            }
          }
          return 100;
        default:
          return 100;
      }
    }

    private static bool ValidateReadingMetersByTenantUniqueness(
      List<MeterDTO> meterList,
      out List<ReadingMeterUniqueIdentifier> duplicatesMeterIdentifier,
      KeyValuePair<object, ObservableCollection<StructureNodeDTO>> meterForTenant = default (KeyValuePair<object, ObservableCollection<StructureNodeDTO>>))
    {
      Dictionary<int, ReadingMeterUniqueIdentifier> meterUniqueIdentifierList = new Dictionary<int, ReadingMeterUniqueIdentifier>();
      int i = 1;
      meterList.ForEach((Action<MeterDTO>) (meter =>
      {
        MeterDTO meterDto = meter;
        int num;
        if (meterDto != null)
        {
          ReadingMeterUniqueIdentifier uniqueIdentifier1 = new ReadingMeterUniqueIdentifier()
          {
            GroupNumber = StructuresHelper.GetGroupNumber(meterDto.DeviceType, meterDto.ConnectedDeviceType),
            SerialNumber = meterDto.SerialNumber
          };
          if (meterForTenant.Key is TenantDTO)
          {
            ref ReadingMeterUniqueIdentifier local = ref uniqueIdentifier1;
            num = (meterForTenant.Key as TenantDTO).TenantNr;
            string str = num.ToString((IFormatProvider) CultureInfo.InvariantCulture);
            local.TenantNo = str;
            meterUniqueIdentifierList.Add(i, uniqueIdentifier1);
          }
          else
          {
            ReadingMeterUniqueIdentifier uniqueIdentifier2 = new ReadingMeterUniqueIdentifier()
            {
              GroupNumber = StructuresHelper.GetGroupNumber(meterDto.DeviceType, meterDto.ConnectedDeviceType),
              SerialNumber = meterDto.SerialNumber
            };
            if (meterForTenant.Key is StructureNodeDTO key2)
            {
              uniqueIdentifier2.TenantNo = key2.Name;
              meterUniqueIdentifierList.Add(i, uniqueIdentifier2);
            }
          }
        }
        num = i++;
      }));
      List<ReadingMeterUniqueIdentifier> duplicates = meterUniqueIdentifierList.GroupBy<KeyValuePair<int, ReadingMeterUniqueIdentifier>, ReadingMeterUniqueIdentifier>((Func<KeyValuePair<int, ReadingMeterUniqueIdentifier>, ReadingMeterUniqueIdentifier>) (x => x.Value)).Where<IGrouping<ReadingMeterUniqueIdentifier, KeyValuePair<int, ReadingMeterUniqueIdentifier>>>((Func<IGrouping<ReadingMeterUniqueIdentifier, KeyValuePair<int, ReadingMeterUniqueIdentifier>>, bool>) (g => g.Skip<KeyValuePair<int, ReadingMeterUniqueIdentifier>>(1).Any<KeyValuePair<int, ReadingMeterUniqueIdentifier>>())).SelectMany<IGrouping<ReadingMeterUniqueIdentifier, KeyValuePair<int, ReadingMeterUniqueIdentifier>>, KeyValuePair<int, ReadingMeterUniqueIdentifier>>((Func<IGrouping<ReadingMeterUniqueIdentifier, KeyValuePair<int, ReadingMeterUniqueIdentifier>>, IEnumerable<KeyValuePair<int, ReadingMeterUniqueIdentifier>>>) (g => (IEnumerable<KeyValuePair<int, ReadingMeterUniqueIdentifier>>) g)).Distinct<KeyValuePair<int, ReadingMeterUniqueIdentifier>>().Select<KeyValuePair<int, ReadingMeterUniqueIdentifier>, ReadingMeterUniqueIdentifier>((Func<KeyValuePair<int, ReadingMeterUniqueIdentifier>, ReadingMeterUniqueIdentifier>) (x => x.Value)).ToList<ReadingMeterUniqueIdentifier>();
      duplicatesMeterIdentifier = new List<ReadingMeterUniqueIdentifier>();
      List<ReadingMeterUniqueIdentifier> identifier = duplicatesMeterIdentifier;
      duplicates.ForEach((Action<ReadingMeterUniqueIdentifier>) (x =>
      {
        if (!duplicates.Any<ReadingMeterUniqueIdentifier>((Func<ReadingMeterUniqueIdentifier, bool>) (y => y.SerialNumber == x.SerialNumber && y.GroupNumber == x.GroupNumber)))
          return;
        identifier.Add(x);
      }));
      return !meterUniqueIdentifierList.GroupBy<KeyValuePair<int, ReadingMeterUniqueIdentifier>, ReadingMeterUniqueIdentifier>((Func<KeyValuePair<int, ReadingMeterUniqueIdentifier>, ReadingMeterUniqueIdentifier>) (x => x.Value)).Any<IGrouping<ReadingMeterUniqueIdentifier, KeyValuePair<int, ReadingMeterUniqueIdentifier>>>((Func<IGrouping<ReadingMeterUniqueIdentifier, KeyValuePair<int, ReadingMeterUniqueIdentifier>>, bool>) (x => x.Count<KeyValuePair<int, ReadingMeterUniqueIdentifier>>() > 1));
    }

    private static bool ValidateInstallationMetersByTenantUniqueness(
      List<MeterDTO> meterList,
      out List<InstallationMeterUniqueIdentifier> duplicatesMeterIdentifier,
      KeyValuePair<object, ObservableCollection<StructureNodeDTO>> meterForTenant)
    {
      Dictionary<int, InstallationMeterUniqueIdentifier> meterUniqueIdentifierList = new Dictionary<int, InstallationMeterUniqueIdentifier>();
      int i = 1;
      meterList.ForEach((Action<MeterDTO>) (meter =>
      {
        MeterDTO meterDto = meter;
        int num;
        if (meterDto != null)
        {
          InstallationMeterUniqueIdentifier uniqueIdentifier1 = new InstallationMeterUniqueIdentifier()
          {
            SerialNumber = meterDto.SerialNumber
          };
          if (meterForTenant.Key is TenantDTO)
          {
            ref InstallationMeterUniqueIdentifier local = ref uniqueIdentifier1;
            num = (meterForTenant.Key as TenantDTO).TenantNr;
            string str = num.ToString((IFormatProvider) CultureInfo.InvariantCulture);
            local.TenantNo = str;
            meterUniqueIdentifierList.Add(i, uniqueIdentifier1);
          }
          else
          {
            InstallationMeterUniqueIdentifier uniqueIdentifier2 = new InstallationMeterUniqueIdentifier()
            {
              SerialNumber = meterDto.SerialNumber
            };
            if (meterForTenant.Key is StructureNodeDTO key2)
            {
              uniqueIdentifier1.TenantNo = key2.Description;
              meterUniqueIdentifierList.Add(i, uniqueIdentifier2);
            }
          }
        }
        num = i++;
      }));
      List<InstallationMeterUniqueIdentifier> list = meterUniqueIdentifierList.GroupBy<KeyValuePair<int, InstallationMeterUniqueIdentifier>, InstallationMeterUniqueIdentifier>((Func<KeyValuePair<int, InstallationMeterUniqueIdentifier>, InstallationMeterUniqueIdentifier>) (x => x.Value)).Where<IGrouping<InstallationMeterUniqueIdentifier, KeyValuePair<int, InstallationMeterUniqueIdentifier>>>((Func<IGrouping<InstallationMeterUniqueIdentifier, KeyValuePair<int, InstallationMeterUniqueIdentifier>>, bool>) (g => g.Skip<KeyValuePair<int, InstallationMeterUniqueIdentifier>>(1).Any<KeyValuePair<int, InstallationMeterUniqueIdentifier>>())).SelectMany<IGrouping<InstallationMeterUniqueIdentifier, KeyValuePair<int, InstallationMeterUniqueIdentifier>>, KeyValuePair<int, InstallationMeterUniqueIdentifier>>((Func<IGrouping<InstallationMeterUniqueIdentifier, KeyValuePair<int, InstallationMeterUniqueIdentifier>>, IEnumerable<KeyValuePair<int, InstallationMeterUniqueIdentifier>>>) (g => (IEnumerable<KeyValuePair<int, InstallationMeterUniqueIdentifier>>) g)).Distinct<KeyValuePair<int, InstallationMeterUniqueIdentifier>>().Select<KeyValuePair<int, InstallationMeterUniqueIdentifier>, InstallationMeterUniqueIdentifier>((Func<KeyValuePair<int, InstallationMeterUniqueIdentifier>, InstallationMeterUniqueIdentifier>) (x => x.Value)).ToList<InstallationMeterUniqueIdentifier>();
      duplicatesMeterIdentifier = list;
      return !meterUniqueIdentifierList.GroupBy<KeyValuePair<int, InstallationMeterUniqueIdentifier>, InstallationMeterUniqueIdentifier>((Func<KeyValuePair<int, InstallationMeterUniqueIdentifier>, InstallationMeterUniqueIdentifier>) (x => x.Value)).Where<IGrouping<InstallationMeterUniqueIdentifier, KeyValuePair<int, InstallationMeterUniqueIdentifier>>>((Func<IGrouping<InstallationMeterUniqueIdentifier, KeyValuePair<int, InstallationMeterUniqueIdentifier>>, bool>) (x => x.Count<KeyValuePair<int, InstallationMeterUniqueIdentifier>>() > 1)).Any<IGrouping<InstallationMeterUniqueIdentifier, KeyValuePair<int, InstallationMeterUniqueIdentifier>>>();
    }

    public static bool ValidationMeterUniqueness(
      StructureNodeDTO rootNodeDTO,
      OrderTypeEnum orderType,
      out List<MeterDTO> notUniqueReadingMeters,
      out List<MeterDTO> notUniqueInstallationMeters)
    {
      bool flag = true;
      Dictionary<object, ObservableCollection<StructureNodeDTO>> tenantDictionary = StructuresHelper.GetMetersByTenantDictionary(rootNodeDTO);
      notUniqueReadingMeters = new List<MeterDTO>();
      notUniqueInstallationMeters = new List<MeterDTO>();
      foreach (KeyValuePair<object, ObservableCollection<StructureNodeDTO>> meterForTenant in tenantDictionary)
      {
        List<MeterDTO> meterList = new List<MeterDTO>();
        TypeHelperExtensionMethods.ForEach<StructureNodeDTO>((IEnumerable<StructureNodeDTO>) meterForTenant.Value, (Action<StructureNodeDTO>) (strNode =>
        {
          if (strNode.Entity == null)
            return;
          meterList.Add(strNode.Entity as MeterDTO);
        }));
        switch (orderType)
        {
          case OrderTypeEnum.ReadingOrder:
            List<ReadingMeterUniqueIdentifier> duplicatesMeterIdentifier1;
            if (!StructuresHelper.ValidateReadingMetersByTenantUniqueness(meterList, out duplicatesMeterIdentifier1, meterForTenant))
              flag = false;
            List<MeterDTO> meters1 = notUniqueReadingMeters;
            duplicatesMeterIdentifier1.ForEach((Action<ReadingMeterUniqueIdentifier>) (x =>
            {
              foreach (MeterDTO meterDto in meterList.Where<MeterDTO>((Func<MeterDTO, bool>) (y => y.SerialNumber == x.SerialNumber)).ToList<MeterDTO>())
              {
                MeterDTO duplicatedMeter = meterDto;
                duplicatedMeter.TenantNo = x.TenantNo;
                if (meters1.All<MeterDTO>((Func<MeterDTO, bool>) (m => m.SerialNumber != duplicatedMeter.SerialNumber)))
                  meters1.Add(duplicatedMeter);
              }
            }));
            notUniqueInstallationMeters = meters1;
            break;
          case OrderTypeEnum.InstallationOrder:
            List<InstallationMeterUniqueIdentifier> duplicatesMeterIdentifier2;
            if (!StructuresHelper.ValidateInstallationMetersByTenantUniqueness(meterList, out duplicatesMeterIdentifier2, meterForTenant))
              flag = false;
            List<MeterDTO> meters2 = notUniqueInstallationMeters;
            duplicatesMeterIdentifier2.ForEach((Action<InstallationMeterUniqueIdentifier>) (x =>
            {
              MeterDTO meterDto = meterList.FirstOrDefault<MeterDTO>((Func<MeterDTO, bool>) (y => y.SerialNumber == x.SerialNumber));
              if (meterDto == null)
                return;
              meterDto.TenantNo = x.TenantNo;
              meters2.Add(meterDto);
            }));
            notUniqueInstallationMeters = meters2;
            break;
        }
      }
      return flag;
    }

    public static bool ValidateTenantUniqueness(
      StructureNodeDTO rootNodeDTO,
      out List<TenantDTO> duplicates)
    {
      List<object> entity = StructuresHelper.GetEntityDictionary(rootNodeDTO)[FixedStructureNodeTypesEnum.Tenant];
      List<TenantDTO> tenantNoList = new List<TenantDTO>();
      entity.ForEach((Action<object>) (tenant =>
      {
        if (!(tenant is TenantDTO tenantDto2))
          return;
        tenantNoList.Add(tenantDto2);
      }));
      List<TenantDTO> list = tenantNoList.GroupBy<TenantDTO, int>((Func<TenantDTO, int>) (x => x.TenantNr)).Where<IGrouping<int, TenantDTO>>((Func<IGrouping<int, TenantDTO>, bool>) (g => g.Skip<TenantDTO>(1).Any<TenantDTO>())).SelectMany<IGrouping<int, TenantDTO>, TenantDTO>((Func<IGrouping<int, TenantDTO>, IEnumerable<TenantDTO>>) (g => (IEnumerable<TenantDTO>) g)).ToList<TenantDTO>();
      duplicates = new List<TenantDTO>();
      List<TenantDTO> dtos = duplicates;
      list.ForEach((Action<TenantDTO>) (x =>
      {
        if (!dtos.All<TenantDTO>((Func<TenantDTO, bool>) (y => y.TenantNr != x.TenantNr)))
          return;
        dtos.Add(x);
      }));
      return !dtos.Any<TenantDTO>();
    }

    public static bool ValidateMinomatUniqueness(
      StructureNodeDTO rootNodeDTO,
      out List<MinomatSerializableDTO> duplicates)
    {
      List<object> entity = StructuresHelper.GetEntityDictionary(rootNodeDTO)[FixedStructureNodeTypesEnum.Minomat];
      List<MinomatSerializableDTO> minomatNoList = new List<MinomatSerializableDTO>();
      entity.ForEach((Action<object>) (minomat =>
      {
        if (!(minomat is MinomatSerializableDTO minomatSerializableDto2))
          return;
        minomatNoList.Add(minomatSerializableDto2);
      }));
      List<MinomatSerializableDTO> list = minomatNoList.GroupBy<MinomatSerializableDTO, string>((Func<MinomatSerializableDTO, string>) (x => x.RadioId)).Where<IGrouping<string, MinomatSerializableDTO>>((Func<IGrouping<string, MinomatSerializableDTO>, bool>) (g => g.Count<MinomatSerializableDTO>() > 1)).SelectMany<IGrouping<string, MinomatSerializableDTO>, MinomatSerializableDTO>((Func<IGrouping<string, MinomatSerializableDTO>, IEnumerable<MinomatSerializableDTO>>) (g => (IEnumerable<MinomatSerializableDTO>) g)).ToList<MinomatSerializableDTO>();
      duplicates = new List<MinomatSerializableDTO>();
      List<MinomatSerializableDTO> dtos = duplicates;
      list.ForEach((Action<MinomatSerializableDTO>) (x =>
      {
        if (!dtos.All<MinomatSerializableDTO>((Func<MinomatSerializableDTO, bool>) (y => y.RadioId != x.RadioId)))
          return;
        dtos.Add(x);
      }));
      return !dtos.Any<MinomatSerializableDTO>();
    }

    public static Dictionary<FixedStructureNodeTypesEnum, List<object>> GetEntityDictionary(
      StructureNodeDTO selectedStructureNodeItem)
    {
      IEnumerable<StructureNodeDTO> structureNodeDtos = StructuresHelper.Descendants(selectedStructureNodeItem);
      List<TenantDTO> source1 = new List<TenantDTO>();
      List<MeterDTO> source2 = new List<MeterDTO>();
      List<LocationDTO> source3 = new List<LocationDTO>();
      List<MinomatSerializableDTO> source4 = new List<MinomatSerializableDTO>();
      Dictionary<FixedStructureNodeTypesEnum, List<object>> entityDictionary = new Dictionary<FixedStructureNodeTypesEnum, List<object>>();
      foreach (StructureNodeDTO structureNodeDto in structureNodeDtos)
      {
        object obj = new object();
        switch ((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), structureNodeDto.NodeType.Name, true))
        {
          case StructureNodeTypeEnum.Location:
            object entity1 = (object) (structureNodeDto.Entity as LocationDTO);
            source3.Add(entity1 as LocationDTO);
            break;
          case StructureNodeTypeEnum.Tenant:
            object entity2 = (object) (structureNodeDto.Entity as TenantDTO);
            source1.Add(entity2 as TenantDTO);
            break;
          case StructureNodeTypeEnum.Meter:
            object entity3 = (object) (structureNodeDto.Entity as MeterDTO);
            source2.Add(entity3 as MeterDTO);
            break;
          case StructureNodeTypeEnum.MinomatMaster:
          case StructureNodeTypeEnum.MinomatSlave:
            object entity4 = (object) (structureNodeDto.Entity as MinomatSerializableDTO);
            source4.Add(entity4 as MinomatSerializableDTO);
            break;
        }
      }
      entityDictionary.Add(FixedStructureNodeTypesEnum.Location, ((IEnumerable<object>) source3).ToList<object>());
      entityDictionary.Add(FixedStructureNodeTypesEnum.Tenant, ((IEnumerable<object>) source1).ToList<object>());
      entityDictionary.Add(FixedStructureNodeTypesEnum.Meter, ((IEnumerable<object>) source2).ToList<object>());
      entityDictionary.Add(FixedStructureNodeTypesEnum.Minomat, ((IEnumerable<object>) source4).ToList<object>());
      return entityDictionary;
    }

    public static Dictionary<object, ObservableCollection<StructureNodeDTO>> GetMetersByTenantDictionary(
      StructureNodeDTO selectedStructureNodeItem)
    {
      IEnumerable<StructureNodeDTO> structureNodeDtos = StructuresHelper.Descendants(selectedStructureNodeItem);
      Dictionary<object, ObservableCollection<StructureNodeDTO>> tenantDictionary = new Dictionary<object, ObservableCollection<StructureNodeDTO>>();
      foreach (StructureNodeDTO key in structureNodeDtos)
      {
        if ((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), key.NodeType.Name, true) == StructureNodeTypeEnum.Tenant)
        {
          object entity = (object) (key.Entity as TenantDTO);
          if (entity != null)
            tenantDictionary.Add((object) (entity as TenantDTO), key.SubNodes);
          else
            tenantDictionary.Add((object) key, key.SubNodes);
        }
      }
      return tenantDictionary;
    }

    public static List<StructureNodeDTO> GetMeters(
      ObservableCollection<StructureNodeDTO> nodeCollection)
    {
      IEnumerable<StructureNodeDTO> structureNodeDtos = StructuresHelper.Descendants(nodeCollection.First<StructureNodeDTO>());
      List<StructureNodeDTO> meters = new List<StructureNodeDTO>();
      foreach (StructureNodeDTO structureNodeDto in structureNodeDtos)
      {
        if ((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), structureNodeDto.NodeType.Name, true) == StructureNodeTypeEnum.Meter && (object) (structureNodeDto.Entity as MeterDTO) != null)
          meters.Add(structureNodeDto);
      }
      return meters;
    }

    public static List<StructureNodeDTO> GetRadioMeters(
      ObservableCollection<StructureNodeDTO> nodeCollection)
    {
      IEnumerable<StructureNodeDTO> structureNodeDtos = StructuresHelper.Descendants(nodeCollection.First<StructureNodeDTO>());
      List<StructureNodeDTO> radioMeters = new List<StructureNodeDTO>();
      foreach (StructureNodeDTO structureNodeDto in structureNodeDtos)
      {
        if ((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), structureNodeDto.NodeType.Name, true) == StructureNodeTypeEnum.RadioMeter && (object) (structureNodeDto.Entity as MeterDTO) != null)
          radioMeters.Add(structureNodeDto);
      }
      return radioMeters;
    }

    public static bool HasAny(List<StructureNodeTypeEnum> enumList, StructureNodeDTO rootNode)
    {
      if (rootNode == null)
        return false;
      foreach (StructureNodeDTO descendant in StructuresHelper.Descendants(rootNode))
      {
        StructureNodeTypeEnum structureNodeTypeEnum = (StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), descendant.NodeType.Name, true);
        if (enumList.Contains(structureNodeTypeEnum))
          return true;
      }
      return false;
    }

    public static void RemoveSelectedNodeFromStructure(
      StructureNodeDTO selectedNode,
      ObservableCollection<StructureNodeDTO> nodeCollection)
    {
      foreach (StructureNodeDTO node in (Collection<StructureNodeDTO>) nodeCollection)
      {
        if (node == selectedNode)
        {
          nodeCollection.Remove(node);
          break;
        }
        StructuresHelper.RemoveSelectedNodeFromStructure(selectedNode, node.SubNodes);
      }
    }

    public static StructureNodeDTO UnreferencedStructureNode(StructureNodeDTO node)
    {
      if (!node.SubNodes.Any<StructureNodeDTO>())
        return new StructureNodeDTO()
        {
          Image = node.Image,
          IsExpanded = node.IsExpanded,
          IsNewNode = node.IsNewNode,
          Name = node.Name,
          NodeType = node.NodeType,
          ParentNode = node.ParentNode,
          RootNode = node.RootNode,
          StructureType = node.StructureType,
          Entity = node.Entity,
          BackgroundColor = node.BackgroundColor,
          Description = node.Description,
          Id = node.Id
        };
      ObservableCollection<StructureNodeDTO> observableCollection = StructuresHelper.RecreateSubnodes((IEnumerable<StructureNodeDTO>) node.SubNodes);
      return new StructureNodeDTO()
      {
        Image = node.Image,
        IsExpanded = node.IsExpanded,
        IsNewNode = node.IsNewNode,
        Name = node.Name,
        NodeType = node.NodeType,
        ParentNode = node.ParentNode,
        RootNode = node.RootNode,
        StructureType = node.StructureType,
        Entity = node.Entity,
        BackgroundColor = node.BackgroundColor,
        Description = node.Description,
        Id = node.Id,
        SubNodes = observableCollection
      };
    }

    private static ObservableCollection<StructureNodeDTO> RecreateSubnodes(
      IEnumerable<StructureNodeDTO> subnodes)
    {
      ObservableCollection<StructureNodeDTO> newSubnodesList = new ObservableCollection<StructureNodeDTO>();
      TypeHelperExtensionMethods.ForEach<StructureNodeDTO>(subnodes, (Action<StructureNodeDTO>) (subnode => newSubnodesList.Add(StructuresHelper.UnreferencedStructureNode(subnode))));
      return newSubnodesList;
    }

    public static StructureNodeDTO GetStructureByDeviceType(
      StructureNodeDTO selectedNode,
      IEnumerable<DeviceTypeEnum> deviceTypes)
    {
      ObservableCollection<StructureNodeDTO> observableCollection1 = new ObservableCollection<StructureNodeDTO>();
      observableCollection1.Add(selectedNode);
      ObservableCollection<StructureNodeDTO> observableCollection2 = new ObservableCollection<StructureNodeDTO>();
      foreach (StructureNodeDTO subNode1 in (Collection<StructureNodeDTO>) selectedNode.SubNodes)
      {
        foreach (StructureNodeDTO subNode2 in (Collection<StructureNodeDTO>) subNode1.SubNodes)
        {
          if (subNode2.Entity != null)
          {
            MeterDTO entity = subNode2.Entity as MeterDTO;
            if (!deviceTypes.Contains<DeviceTypeEnum>(entity.DeviceType))
              observableCollection2.Add(subNode2);
          }
        }
      }
      foreach (StructureNodeDTO selectedNode1 in (Collection<StructureNodeDTO>) observableCollection2)
        StructuresHelper.RemoveSelectedNodeFromStructure(selectedNode1, observableCollection1);
      ObservableCollection<StructureNodeDTO> observableCollection3 = new ObservableCollection<StructureNodeDTO>();
      foreach (StructureNodeDTO subNode in (Collection<StructureNodeDTO>) observableCollection1.First<StructureNodeDTO>().SubNodes)
      {
        if (!subNode.SubNodes.Any<StructureNodeDTO>())
          observableCollection3.Add(subNode);
      }
      foreach (StructureNodeDTO selectedNode2 in (Collection<StructureNodeDTO>) observableCollection3)
        StructuresHelper.RemoveSelectedNodeFromStructure(selectedNode2, observableCollection1);
      return observableCollection1.First<StructureNodeDTO>();
    }

    public static DeviceTypeEnum? GetDeviceTypeEnumByDeviceModelName(string deviceModelName)
    {
      foreach (DeviceTypeEnum deviceTypeEnum in Enum.GetValues(typeof (DeviceTypeEnum)).Cast<DeviceTypeEnum>())
      {
        if (deviceTypeEnum.GetGMMDeviceModelName().Equals(deviceModelName))
          return new DeviceTypeEnum?(deviceTypeEnum);
      }
      return new DeviceTypeEnum?();
    }

    public static void SetNodesOrderNumber(
      this ObservableCollection<StructureNodeDTO> nodeCollection,
      StructureNodeDTO selectedStructureNode = null,
      StructureNodeDTO selectedNodeParent = null)
    {
      if (selectedNodeParent == null)
        StructuresHelper.SetOrderNrForCompleteStructure(nodeCollection);
      else
        StructuresHelper.SetOrderNrForPartialStructure(nodeCollection, selectedNodeParent, selectedStructureNode);
    }

    private static void SetOrderNrForCompleteStructure(
      ObservableCollection<StructureNodeDTO> nodeCollection)
    {
      foreach (StructureNodeDTO node in (Collection<StructureNodeDTO>) nodeCollection)
      {
        ObservableCollection<StructureNodeDTO> subNodes = node.SubNodes;
        int num = 1;
        foreach (StructureNodeDTO structureNodeDto in (Collection<StructureNodeDTO>) subNodes)
        {
          structureNodeDto.OrderNr = num;
          ++num;
        }
      }
    }

    private static void SetOrderNrForPartialStructure(
      ObservableCollection<StructureNodeDTO> nodeCollection,
      StructureNodeDTO selectedNodeParent,
      StructureNodeDTO selectedStructureNode)
    {
      ObservableCollection<StructureNodeDTO> subNodes = selectedNodeParent.SubNodes;
      StructureNodeDTO structureNodeDto1 = subNodes.FirstOrDefault<StructureNodeDTO>((Func<StructureNodeDTO, bool>) (n => n == selectedStructureNode));
      if (structureNodeDto1 == null)
        return;
      int previousOrderNr = structureNodeDto1.OrderNr;
      int num = previousOrderNr;
      foreach (StructureNodeDTO node in (Collection<StructureNodeDTO>) nodeCollection)
      {
        node.OrderNr = num;
        ++num;
      }
      foreach (StructureNodeDTO structureNodeDto2 in subNodes.Where<StructureNodeDTO>((Func<StructureNodeDTO, bool>) (n => n.OrderNr > previousOrderNr)))
      {
        structureNodeDto2.OrderNr = num;
        ++num;
      }
    }

    private static StructureNodeDTO GetParents(StructureNodeDTO node)
    {
      if (node.ParentNode == null)
        return node;
      StructureNodeDTO parentNode = node.ParentNode;
      StructureNodeDTO structureNodeDto = parentNode;
      ObservableCollection<StructureNodeDTO> observableCollection1 = new ObservableCollection<StructureNodeDTO>();
      observableCollection1.Add(node);
      ObservableCollection<StructureNodeDTO> observableCollection2 = observableCollection1;
      structureNodeDto.SubNodes = observableCollection2;
      StructuresHelper.GetParents(parentNode);
      return parentNode.RootNode;
    }

    public static StructureNodeDTO GetPartialStructureNodeDTO(
      ObservableCollection<StructureNodeDTO> selectedNodes)
    {
      ObservableCollection<StructureNodeDTO> observableCollection = new ObservableCollection<StructureNodeDTO>();
      ObservableCollection<StructureNodeDTO> source = new ObservableCollection<StructureNodeDTO>();
      foreach (StructureNodeDTO selectedNode in (Collection<StructureNodeDTO>) selectedNodes)
      {
        observableCollection.Add(selectedNode);
        foreach (StructureNodeDTO descendant in StructuresHelper.Descendants(selectedNode))
        {
          StructureNodeDTO child = descendant;
          if (!source.Any<StructureNodeDTO>((Func<StructureNodeDTO, bool>) (n => n.Equals((object) child))))
            source.Add(child);
          else
            observableCollection.Remove(child);
        }
      }
      StructureNodeDTO existingStructure = (StructureNodeDTO) null;
      foreach (StructureNodeDTO node in (Collection<StructureNodeDTO>) observableCollection)
        existingStructure = StructuresHelper.GetParentForMultipleSelectedNodes(node, existingStructure);
      return existingStructure;
    }

    private static StructureNodeDTO GetParentForMultipleSelectedNodes(
      StructureNodeDTO node,
      StructureNodeDTO existingStructure)
    {
      if (node.ParentNode == null)
        existingStructure = node;
      else if (existingStructure != null)
      {
        StructureNodeDTO parentNode = node.ParentNode;
        IEnumerable<StructureNodeDTO> structureNodeDtos = StructuresHelper.Descendants(existingStructure);
        bool flag = false;
        foreach (StructureNodeDTO structureNodeDto in structureNodeDtos)
        {
          if (structureNodeDto == parentNode)
          {
            structureNodeDto.SubNodes.Add(node);
            flag = true;
            break;
          }
        }
        if (!flag)
        {
          StructureNodeDTO structureNodeDto = parentNode;
          ObservableCollection<StructureNodeDTO> observableCollection1 = new ObservableCollection<StructureNodeDTO>();
          observableCollection1.Add(node);
          ObservableCollection<StructureNodeDTO> observableCollection2 = observableCollection1;
          structureNodeDto.SubNodes = observableCollection2;
          StructuresHelper.GetParentForMultipleSelectedNodes(parentNode, existingStructure);
        }
      }
      else
      {
        StructureNodeDTO parentNode = node.ParentNode;
        StructureNodeDTO structureNodeDto = parentNode;
        ObservableCollection<StructureNodeDTO> observableCollection3 = new ObservableCollection<StructureNodeDTO>();
        observableCollection3.Add(node);
        ObservableCollection<StructureNodeDTO> observableCollection4 = observableCollection3;
        structureNodeDto.SubNodes = observableCollection4;
        StructuresHelper.GetParents(parentNode);
        existingStructure = parentNode.RootNode;
      }
      return existingStructure;
    }

    public static bool IsMeterWithMeterParent(StructureNodeDTO node)
    {
      if (node != null && (node.NodeType.Name == "Meter" || node.NodeType.Name == "RadioMeter"))
      {
        StructureNodeDTO parentNode = node.ParentNode;
        if (parentNode != null && (parentNode.NodeType.Name == "Meter" || parentNode.NodeType.Name == "RadioMeter"))
          return true;
      }
      return false;
    }
  }
}


--- StructuresManager.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.StructuresManager
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

using AutoMapper;
using MSS.Business.DTO;
using MSS.Business.Errors;
using MSS.Core.Model.DataCollectors;
using MSS.Core.Model.Meters;
using MSS.Core.Model.MSSClient;
using MSS.Core.Model.Orders;
using MSS.Core.Model.Structures;
using MSS.Core.Model.UsersManagement;
using MSS.DTO.Meters;
using MSS.DTO.Orders;
using MSS.DTO.Structures;
using MSS.Interfaces;
using NHibernate;
using NHibernate.Linq;
using NHibernate.SqlCommand;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public class StructuresManager
  {
    private readonly IRepository<Channel> _channelRepository;
    private readonly IRepository<ConnectedDeviceType> _connectedDeviceTypeRepository;
    private readonly IRepository<Location> _locationRepository;
    private readonly IRepository<MeasureUnit> _measureUniteRepository;
    private readonly IRepository<Meter> _meterRepository;
    private readonly ISession _nhSession;
    private readonly IRepository<RoomType> _roomTypeRepository;
    private readonly IRepository<StructureNodeLinks> _structureNodeLinksRepository;
    private readonly IRepository<StructureNode> _structureNodeRepository;
    private readonly IRepository<StructureNodeType> _structureNodeTypeRepository;
    private readonly IRepository<Tenant> _tenantRepository;
    private readonly IRepositoryFactory _repositoryFactory;
    private readonly IRepository<Scenario> _repositoryScenario;
    private readonly IRepository<Minomat> _repositoryMinomats;
    private readonly IRepository<MeterReplacementHistory> _meterReplacementHistoryRepository;
    private static DateTime MinDateTime = new DateTime(1800, 1, 1);

    public StructuresManager(
      IRepositoryFactory repositoryFactory,
      bool isConstructorWithoutMappings)
    {
      this._repositoryFactory = repositoryFactory;
      this._meterRepository = repositoryFactory.GetRepository<Meter>();
      this._roomTypeRepository = repositoryFactory.GetRepository<RoomType>();
      this._measureUniteRepository = repositoryFactory.GetRepository<MeasureUnit>();
      this._channelRepository = repositoryFactory.GetRepository<Channel>();
      this._connectedDeviceTypeRepository = repositoryFactory.GetRepository<ConnectedDeviceType>();
      this._structureNodeRepository = repositoryFactory.GetRepository<StructureNode>();
      this._structureNodeTypeRepository = repositoryFactory.GetRepository<StructureNodeType>();
      this._structureNodeLinksRepository = repositoryFactory.GetRepository<StructureNodeLinks>();
      this._locationRepository = repositoryFactory.GetRepository<Location>();
      this._tenantRepository = repositoryFactory.GetRepository<Tenant>();
      this._repositoryScenario = repositoryFactory.GetRepository<Scenario>();
      this._repositoryMinomats = repositoryFactory.GetRepository<Minomat>();
      repositoryFactory.GetRepository<MeterReadingValue>();
      this._meterReplacementHistoryRepository = repositoryFactory.GetRepository<MeterReplacementHistory>();
      this._nhSession = repositoryFactory.GetSession();
    }

    public StructuresManager(IRepositoryFactory repositoryFactory)
    {
      this._repositoryFactory = repositoryFactory;
      this._meterRepository = repositoryFactory.GetRepository<Meter>();
      this._roomTypeRepository = repositoryFactory.GetRepository<RoomType>();
      this._measureUniteRepository = repositoryFactory.GetRepository<MeasureUnit>();
      this._channelRepository = repositoryFactory.GetRepository<Channel>();
      this._connectedDeviceTypeRepository = repositoryFactory.GetRepository<ConnectedDeviceType>();
      this._structureNodeRepository = repositoryFactory.GetRepository<StructureNode>();
      this._structureNodeTypeRepository = repositoryFactory.GetRepository<StructureNodeType>();
      this._structureNodeLinksRepository = repositoryFactory.GetRepository<StructureNodeLinks>();
      this._locationRepository = repositoryFactory.GetRepository<Location>();
      this._tenantRepository = repositoryFactory.GetRepository<Tenant>();
      this._repositoryScenario = repositoryFactory.GetRepository<Scenario>();
      this._repositoryMinomats = this._repositoryFactory.GetRepository<Minomat>();
      this._repositoryFactory.GetRepository<MeterReadingValue>();
      this._meterReplacementHistoryRepository = repositoryFactory.GetRepository<MeterReplacementHistory>();
      this._nhSession = repositoryFactory.GetSession();
      Mapper.CreateMap<MeterDTO, Meter>();
      Mapper.CreateMap<LocationDTO, Location>();
      Mapper.CreateMap<TenantDTO, Tenant>();
      Mapper.CreateMap<MinomatSerializableDTO, Minomat>().ForMember((Expression<Func<Minomat, object>>) (x => x.Provider), (Action<IMemberConfigurationExpression<MinomatSerializableDTO>>) (x => x.ResolveUsing((Func<MinomatSerializableDTO, object>) (y => (object) this._repositoryFactory.GetRepository<Provider>().GetById((object) y.ProviderId)))));
      Mapper.CreateMap<Minomat, MinomatSerializableDTO>().ForMember((Expression<Func<MinomatSerializableDTO, object>>) (x => (object) x.ProviderId), (Action<IMemberConfigurationExpression<Minomat>>) (x => x.ResolveUsing((Func<Minomat, object>) (y => y.Provider != null ? (object) y.Provider.Id : (object) Guid.Empty))));
      Mapper.CreateMap<StructureNodeDTO, StructureNode>().ForMember((Expression<Func<StructureNode, object>>) (strNode => strNode.Name), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.MapFrom<string>((Expression<Func<StructureNodeDTO, string>>) (strNodeDTO => strNodeDTO.Name)))).ForMember((Expression<Func<StructureNode, object>>) (strNode => strNode.Description), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.MapFrom<string>((Expression<Func<StructureNodeDTO, string>>) (strNodeDTO => strNodeDTO.Description)))).ForMember((Expression<Func<StructureNode, object>>) (strNode => (object) strNode.EntityId), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.ResolveUsing((Func<StructureNodeDTO, object>) (strNodeDTO => (object) this.GetEntityId(strNodeDTO))))).ForMember((Expression<Func<StructureNode, object>>) (strNode => strNode.EntityName), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.ResolveUsing((Func<StructureNodeDTO, object>) (strNodeDTO => (object) this.GetEntityName(strNodeDTO))))).ForMember((Expression<Func<StructureNode, object>>) (strNode => strNode.NodeType), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.MapFrom<StructureNodeType>((Expression<Func<StructureNodeDTO, StructureNodeType>>) (strNodeDTO => strNodeDTO.NodeType)))).ForMember((Expression<Func<StructureNode, object>>) (strNode => (object) strNode.StartDate), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.MapFrom<DateTime?>((Expression<Func<StructureNodeDTO, DateTime?>>) (strNodeDTO => strNodeDTO.StartDate)))).ForMember((Expression<Func<StructureNode, object>>) (strNode => (object) strNode.EndDate), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.MapFrom<DateTime?>((Expression<Func<StructureNodeDTO, DateTime?>>) (strNodeDTO => strNodeDTO.EndDate))));
      Mapper.CreateMap<StructureNodeDTO, StructureNodeLinks>().ForMember((Expression<Func<StructureNodeLinks, object>>) (strNodeLink => (object) strNodeLink.Id), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.Ignore())).ForMember((Expression<Func<StructureNodeLinks, object>>) (strNodeLink => strNodeLink.Node), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.Ignore())).ForMember((Expression<Func<StructureNodeLinks, object>>) (strNodeLink => (object) strNodeLink.ParentNodeId), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.ResolveUsing((Func<StructureNodeDTO, object>) (strNodeDTO => strNodeDTO.ParentNode != null ? (object) strNodeDTO.ParentNode.Id : (object) Guid.Empty)))).ForMember((Expression<Func<StructureNodeLinks, object>>) (strNodeLink => strNodeLink.RootNode), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.Ignore())).ForMember((Expression<Func<StructureNodeLinks, object>>) (strNodeLink => (object) strNodeLink.StructureType), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.Ignore())).ForMember((Expression<Func<StructureNodeLinks, object>>) (strNodeLink => (object) strNodeLink.StartDate), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.MapFrom<DateTime?>((Expression<Func<StructureNodeDTO, DateTime?>>) (strNodeDTO => strNodeDTO.StartDate)))).ForMember((Expression<Func<StructureNodeLinks, object>>) (strNodeLink => (object) strNodeLink.EndDate), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (s => s.MapFrom<DateTime?>((Expression<Func<StructureNodeDTO, DateTime?>>) (strNodeDTO => strNodeDTO.EndDate))));
      Mapper.CreateMap<StructureNodeLinks, StructureNodeLinks>().ForMember((Expression<Func<StructureNodeLinks, object>>) (l => (object) l.Id), (Action<IMemberConfigurationExpression<StructureNodeLinks>>) (s => s.Ignore()));
      Mapper.CreateMap<MeterSerializableDTO, Meter>().ForMember((Expression<Func<Meter, object>>) (x => x.ReadingUnit), (Action<IMemberConfigurationExpression<MeterSerializableDTO>>) (x => x.ResolveUsing((Func<MeterSerializableDTO, object>) (z => (object) this._measureUniteRepository.GetById((object) z.ReadingUnitId))))).ForMember((Expression<Func<Meter, object>>) (x => x.ImpulsUnit), (Action<IMemberConfigurationExpression<MeterSerializableDTO>>) (x => x.ResolveUsing((Func<MeterSerializableDTO, object>) (z => (object) this._measureUniteRepository.GetById((object) z.ImpulsUnitId))))).ForMember((Expression<Func<Meter, object>>) (x => x.Channel), (Action<IMemberConfigurationExpression<MeterSerializableDTO>>) (x => x.ResolveUsing((Func<MeterSerializableDTO, object>) (z => (object) this._channelRepository.GetById((object) z.ChannelId))))).ForMember((Expression<Func<Meter, object>>) (x => x.ConnectedDeviceType), (Action<IMemberConfigurationExpression<MeterSerializableDTO>>) (x => x.ResolveUsing((Func<MeterSerializableDTO, object>) (z => (object) this._connectedDeviceTypeRepository.GetById((object) z.ConnectedDeviceTypeId))))).ForMember((Expression<Func<Meter, object>>) (x => x.Room), (Action<IMemberConfigurationExpression<MeterSerializableDTO>>) (x => x.ResolveUsing((Func<MeterSerializableDTO, object>) (z => (object) this._roomTypeRepository.GetById((object) z.RoomTypeId)))));
      Mapper.CreateMap<LocationSerializableDTO, Location>().ForMember((Expression<Func<Location, object>>) (x => x.Scenario), (Action<IMemberConfigurationExpression<LocationSerializableDTO>>) (x => x.ResolveUsing((Func<LocationSerializableDTO, object>) (z => (object) this._repositoryScenario.GetById((object) z.ScenarioId))))).ForMember((Expression<Func<Location, object>>) (x => x.Country), (Action<IMemberConfigurationExpression<LocationSerializableDTO>>) (x => x.ResolveUsing((Func<LocationSerializableDTO, object>) (z => (object) this._repositoryFactory.GetRepository<Country>().GetById((object) z.CountryId)))));
      Mapper.CreateMap<TenantSerializableDTO, Tenant>();
      Mapper.CreateMap<StructureNodeSerializableDTO, StructureNode>().ForMember((Expression<Func<StructureNode, object>>) (x => x.NodeType), (Action<IMemberConfigurationExpression<StructureNodeSerializableDTO>>) (x => x.ResolveUsing((Func<StructureNodeSerializableDTO, object>) (z => (object) this._structureNodeTypeRepository.GetById((object) z.NodeType)))));
      Mapper.CreateMap<StructureNodeLinksSerializableDTO, StructureNodeLinks>();
      Mapper.CreateMap<MinomatSerializableDTO, Minomat>().ForMember((Expression<Func<Minomat, object>>) (x => x.Provider), (Action<IMemberConfigurationExpression<MinomatSerializableDTO>>) (x => x.ResolveUsing((Func<MinomatSerializableDTO, object>) (y => (object) this._repositoryFactory.GetRepository<Provider>().GetById((object) y.ProviderId))))).ForMember((Expression<Func<Minomat, object>>) (x => x.Country), (Action<IMemberConfigurationExpression<MinomatSerializableDTO>>) (x => x.ResolveUsing((Func<MinomatSerializableDTO, object>) (z => (object) this._repositoryFactory.GetRepository<Country>().GetById((object) z.CountryId)))));
    }

    private Meter TransactionalCreateMeter(MeterDTO meterDTO)
    {
      Meter meter = Mapper.Map<MeterDTO, Meter>(meterDTO);
      meter.CreatedBy = MSS.Business.Utils.AppContext.Current.LoggedUser.Id.ToString();
      if (meter.LastChangedOn.HasValue && meter.LastChangedOn.Value < StructuresManager.MinDateTime)
        meter.LastChangedOn = new DateTime?(StructuresManager.MinDateTime);
      this._meterRepository.TransactionalInsert(meter);
      if (meterDTO.MbusRadioMeter != null)
        this.TransactionalSaveOrUpdateMbusRadioMeter(meter);
      if (meterDTO.MeterRadioDetails != null && meterDTO.MeterRadioDetails.Count > 0)
        this.TransactionalSaveOrUpdateMeterRadioDetails(meter, meterDTO.MeterRadioDetails);
      return meter;
    }

    private Minomat TransactionalCreateMinomat(MinomatSerializableDTO minomatDTO)
    {
      Minomat entity = Mapper.Map<MinomatSerializableDTO, Minomat>(minomatDTO);
      entity.CreatedBy = MSS.Business.Utils.AppContext.Current.LoggedUser.Id.ToString();
      this._repositoryFactory.GetRepository<Minomat>().TransactionalInsert(entity);
      MessageHandler.LogDebug("Minomat created from structures or structures import. RadioId: " + minomatDTO.RadioId);
      return entity;
    }

    public Meter TransactionalEditMeter(MeterDTO meterDTO)
    {
      Meter meterAlias = (Meter) null;
      MeasureUnit impulsUnitAlias = (MeasureUnit) null;
      MeasureUnit readingUnitAlias = (MeasureUnit) null;
      Channel channelAlias = (Channel) null;
      RoomType roomAlias = (RoomType) null;
      Meter meter = this._repositoryFactory.GetSession().QueryOver<Meter>((Expression<Func<Meter>>) (() => meterAlias)).JoinAlias((Expression<Func<Meter, object>>) (x => x.ReadingUnit), (Expression<Func<object>>) (() => readingUnitAlias), JoinType.LeftOuterJoin).JoinAlias((Expression<Func<Meter, object>>) (x => x.ImpulsUnit), (Expression<Func<object>>) (() => impulsUnitAlias), JoinType.LeftOuterJoin).JoinAlias((Expression<Func<Meter, object>>) (x => x.Channel), (Expression<Func<object>>) (() => channelAlias), JoinType.LeftOuterJoin).JoinAlias((Expression<Func<Meter, object>>) (x => x.Room), (Expression<Func<object>>) (() => roomAlias), JoinType.LeftOuterJoin).WhereRestrictionOn((Expression<Func<object>>) (() => (object) meterAlias.Id)).IsLike((object) meterDTO.Id).List().FirstOrDefault<Meter>();
      Mapper.Map<MeterDTO, Meter>(meterDTO, meter);
      if (meter != null)
        meter.UpdatedBy = MSS.Business.Utils.AppContext.Current.LoggedUser.Id.ToString();
      this._meterRepository.TransactionalUpdate(meter);
      if (meterDTO.MbusRadioMeter != null)
        this.TransactionalSaveOrUpdateMbusRadioMeter(meter);
      if (meterDTO.MeterRadioDetails != null && meterDTO.MeterRadioDetails.Count > 0)
        this.TransactionalSaveOrUpdateMeterRadioDetails(meter, meterDTO.MeterRadioDetails);
      return meter;
    }

    private Minomat TransactionalEditMinomat(MinomatSerializableDTO minomatDTO)
    {
      Minomat byId = this._repositoryFactory.GetRepository<Minomat>().GetById((object) minomatDTO.Id);
      Mapper.Map<MinomatSerializableDTO, Minomat>(minomatDTO, byId);
      this._repositoryFactory.GetRepository<Minomat>().TransactionalUpdate(byId);
      return byId;
    }

    private Location TransactionalCreateLocation(LocationDTO locationDTO)
    {
      Location entity = Mapper.Map<LocationDTO, Location>(locationDTO);
      entity.CreatedBy = MSS.Business.Utils.AppContext.Current.LoggedUser.Id.ToString();
      DateTime? updateBuildingNo = entity.LastUpdateBuildingNo;
      DateTime minDateTime = StructuresManager.MinDateTime;
      if (updateBuildingNo.HasValue && updateBuildingNo.GetValueOrDefault() < minDateTime)
        entity.LastUpdateBuildingNo = new DateTime?(StructuresManager.MinDateTime);
      entity.Country = MSS.Business.Utils.AppContext.Current.LoggedUser.Country;
      entity.Office = MSS.Business.Utils.AppContext.Current.LoggedUser.Office;
      this._locationRepository.TransactionalInsert(entity);
      return entity;
    }

    private Location TransactionalEditLocation(LocationDTO locationDTO)
    {
      Location byId = this._locationRepository.GetById((object) locationDTO.Id);
      Mapper.Map<LocationDTO, Location>(locationDTO, byId);
      byId.UpdatedBy = MSS.Business.Utils.AppContext.Current.LoggedUser.Id.ToString();
      byId.LastUpdateBuildingNo = new DateTime?(DateTime.Now);
      this._locationRepository.TransactionalUpdate(byId);
      return byId;
    }

    private Tenant TransactionalCreateTenant(TenantDTO tenantDTO)
    {
      Tenant entity = Mapper.Map<TenantDTO, Tenant>(tenantDTO);
      entity.CreatedBy = MSS.Business.Utils.AppContext.Current.LoggedUser.Id.ToString();
      if (entity.LastChangedOn.HasValue && entity.LastChangedOn.Value < StructuresManager.MinDateTime)
        entity.LastChangedOn = new DateTime?(StructuresManager.MinDateTime);
      this._tenantRepository.TransactionalInsert(entity);
      return entity;
    }

    private Tenant TransactionalEditTenant(TenantDTO tenantDTO)
    {
      Tenant byId = this._tenantRepository.GetById((object) tenantDTO.Id);
      Mapper.Map<TenantDTO, Tenant>(tenantDTO, byId);
      byId.UpdatedBy = MSS.Business.Utils.AppContext.Current.LoggedUser.Id.ToString();
      this._tenantRepository.TransactionalUpdate(byId);
      return byId;
    }

    public Meter TransactionalSaveOrUpdateMeter(MeterDTO meterDTO)
    {
      Meter meter = new Meter();
      return !(meterDTO.Id == Guid.Empty) ? this.TransactionalEditMeter(meterDTO) : this.TransactionalCreateMeter(meterDTO);
    }

    private void TransactionalSaveOrUpdateMeterRadioDetails(
      Meter meter,
      List<MeterRadioDetails> meterRadioDetails)
    {
      IRepository<MeterRadioDetails> repository = this._repositoryFactory.GetRepository<MeterRadioDetails>();
      MeterRadioDetails entity1 = repository.FirstOrDefault((Expression<Func<MeterRadioDetails, bool>>) (m => m.Meter.Id == meter.Id));
      MeterRadioDetails entity2 = meterRadioDetails.FirstOrDefault<MeterRadioDetails>();
      if (entity2 == null)
        return;
      entity2.Meter = meter;
      if (entity1 == null)
      {
        repository.TransactionalInsert(entity2);
      }
      else
      {
        entity1.dgMessbereich = entity2.dgMessbereich;
        repository.TransactionalUpdate(entity1);
      }
    }

    public void TransactionalSaveOrUpdateMbusRadioMeter(Meter meter)
    {
      MbusRadioMeter mbusRadioMeter = this._repositoryFactory.GetRepository<MbusRadioMeter>().FirstOrDefault((Expression<Func<MbusRadioMeter, bool>>) (item => item.Meter.Id == meter.Id));
      if (mbusRadioMeter != null)
      {
        mbusRadioMeter.City = meter.MbusRadioMeter.City;
        mbusRadioMeter.Street = meter.MbusRadioMeter.Street;
        mbusRadioMeter.HouseNumber = meter.MbusRadioMeter.HouseNumber;
        mbusRadioMeter.HouseNumberSupplement = meter.MbusRadioMeter.HouseNumberSupplement;
        mbusRadioMeter.ApartmentNumber = meter.MbusRadioMeter.ApartmentNumber;
        mbusRadioMeter.ZipCode = meter.MbusRadioMeter.ZipCode;
        mbusRadioMeter.FirstName = meter.MbusRadioMeter.FirstName;
        mbusRadioMeter.LastName = meter.MbusRadioMeter.LastName;
        mbusRadioMeter.Location = meter.MbusRadioMeter.Location;
        mbusRadioMeter.RadioSerialNumber = meter.MbusRadioMeter.RadioSerialNumber;
        meter.MbusRadioMeter = mbusRadioMeter;
      }
      if (meter.MbusRadioMeter.Id == Guid.Empty)
      {
        meter.MbusRadioMeter.Meter = meter;
        this._repositoryFactory.GetRepository<MbusRadioMeter>().TransactionalInsert(meter.MbusRadioMeter);
      }
      else
        this._repositoryFactory.GetRepository<MbusRadioMeter>().TransactionalUpdate(meter.MbusRadioMeter);
    }

    public Minomat TransactionalSaveOrUpdateMinomat(MinomatSerializableDTO minomatDto)
    {
      Minomat minomat = new Minomat();
      return minomatDto.Id == Guid.Empty ? this.TransactionalCreateMinomat(minomatDto) : this.TransactionalEditMinomat(minomatDto);
    }

    public Location TransactionalSaveOrUpdateLocation(LocationDTO locationDTO)
    {
      Location location = new Location();
      return !(locationDTO.Id == Guid.Empty) ? this.TransactionalEditLocation(locationDTO) : this.TransactionalCreateLocation(locationDTO);
    }

    public Tenant TransactionalSaveOrUpdateTenant(TenantDTO tenantDTO)
    {
      Tenant tenant = new Tenant();
      return !(tenantDTO.Id == Guid.Empty) ? this.TransactionalEditTenant(tenantDTO) : this.TransactionalCreateTenant(tenantDTO);
    }

    private StructureNode TransactionalCreateStructureNode(StructureNodeDTO newNode)
    {
      StructureNode newStructureNode = Mapper.Map<StructureNodeDTO, StructureNode>(newNode);
      if (!newStructureNode.StartDate.HasValue)
        newStructureNode.StartDate = new DateTime?(DateTime.Now);
      this._structureNodeRepository.TransactionalInsert(newStructureNode);
      if (newNode.AssignedPicture != null)
        newNode.AssignedPicture.ForEach((Action<byte[]>) (_ => this._repositoryFactory.GetRepository<PhotoMeter>().TransactionalInsert(new PhotoMeter()
        {
          StructureNode = newStructureNode,
          Payload = _
        })));
      if (newNode.AssignedNotes != null)
        newNode.AssignedNotes.ForEach((Action<Note>) (_ => this._repositoryFactory.GetRepository<Note>().TransactionalInsert(new Note()
        {
          StructureNode = newStructureNode,
          NoteDescription = _.NoteDescription,
          NoteType = _.NoteType
        })));
      return newStructureNode;
    }

    private StructureNodeLinks TransactionalCreateStructureNodeLink(
      StructureNodeDTO structureNodeDTO,
      StructureTypeEnum structureType)
    {
      StructureNodeLinks entity = Mapper.Map<StructureNodeDTO, StructureNodeLinks>(structureNodeDTO);
      entity.Node = this._repositoryFactory.GetRepository<StructureNode>().SearchForInMemoryOrDb((Expression<Func<StructureNode, bool>>) (sn => sn.Id == structureNodeDTO.Id), (Func<StructureNode, bool>) (sn => sn.Id == structureNodeDTO.Id)).FirstOrDefault<StructureNode>();
      entity.RootNode = this._repositoryFactory.GetRepository<StructureNode>().SearchForInMemoryOrDb((Expression<Func<StructureNode, bool>>) (sn => sn.Id == structureNodeDTO.RootNode.Id), (Func<StructureNode, bool>) (sn => sn.Id == structureNodeDTO.RootNode.Id)).FirstOrDefault<StructureNode>();
      if (structureNodeDTO.ParentNode != null)
        entity.ParentNodeId = structureNodeDTO.ParentNode.Id;
      entity.StructureType = structureType;
      entity.StartDate = new DateTime?(DateTime.Now);
      this._structureNodeLinksRepository.TransactionalInsert(entity);
      return entity;
    }

    private void TransactionalUpdateStructureNode(StructureNodeDTO structureNodeDTO)
    {
      StructureNode structureNode = this._structureNodeRepository.GetById((object) structureNodeDTO.Id);
      Mapper.Map<StructureNodeDTO, StructureNode>(structureNodeDTO, structureNode);
      if (structureNodeDTO.AssignedPicture != null)
      {
        structureNode.Photos = (IList<PhotoMeter>) null;
        structureNode.Photos = (IList<PhotoMeter>) new List<PhotoMeter>();
        TypeHelperExtensionMethods.ForEach<PhotoMeter>(structureNodeDTO.AssignedPicture.Select<byte[], PhotoMeter>((Func<byte[], PhotoMeter>) (_ => new PhotoMeter()
        {
          Payload = _,
          StructureNode = structureNode
        })), (Action<PhotoMeter>) (_ => structureNode.Photos.Add(_)));
      }
      if (structureNodeDTO.AssignedNotes != null)
      {
        structureNode.Notes = (IList<Note>) new List<Note>();
        structureNodeDTO.AssignedNotes.ForEach((Action<Note>) (note =>
        {
          note.StructureNode = structureNode;
          structureNode.Notes.Add(note);
        }));
      }
      this._structureNodeRepository.TransactionalUpdate(structureNode);
    }

    private void TransactionalUpdateStructureNodeLink(StructureNodeDTO structureNodeDTO)
    {
      StructureNodeLinks structureNodeLinks = this._structureNodeLinksRepository.FirstOrDefault((Expression<Func<StructureNodeLinks, bool>>) (s => s.EndDate == new DateTime?() && s.Node.Id == structureNodeDTO.Id && (int?) s.StructureType == (int?) structureNodeDTO.StructureType));
      if (structureNodeLinks != null)
      {
        Mapper.Map<StructureNodeDTO, StructureNodeLinks>(structureNodeDTO, structureNodeLinks);
        structureNodeLinks.RootNode = this._structureNodeRepository.GetById((object) structureNodeDTO.RootNode.Id);
      }
      this._structureNodeLinksRepository.TransactionalUpdate(structureNodeLinks);
    }

    private void TransactionalCreateOrUpdateStructure(
      IList<StructureNodeDTO> nodeCollection,
      StructureTypeEnum structureType)
    {
      List<Guid> nodeIDs = new List<Guid>();
      foreach (StructureNodeDTO structureNodeDto in nodeCollection.Where<StructureNodeDTO>((Func<StructureNodeDTO, bool>) (structureNode => !nodeIDs.Contains(structureNode.Id))))
        nodeIDs.Add(structureNodeDto.Id);
      IEnumerable<StructureNodeLinks> source = (IEnumerable<StructureNodeLinks>) this._structureNodeLinksRepository.SearchFor((Expression<Func<StructureNodeLinks, bool>>) (l => (int) l.StructureType == (int) structureType && nodeIDs.Contains(l.Node.Id) && l.EndDate == new DateTime?()));
      foreach (StructureNodeDTO node in (IEnumerable<StructureNodeDTO>) nodeCollection)
      {
        StructureNodeDTO nodeDTO = node;
        if (nodeDTO.Id == Guid.Empty)
        {
          StructureNode structureNode = this.TransactionalCreateStructureNode(nodeDTO);
          nodeDTO.Id = structureNode.Id;
        }
        else
          this.TransactionalUpdateStructureNode(nodeDTO);
        StructureNodeLinks structureNodeLinks = source.FirstOrDefault<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (l =>
        {
          if (!(l.Node.Id == nodeDTO.Id) || l.EndDate.HasValue)
            return false;
          StructureTypeEnum structureType1 = l.StructureType;
          StructureTypeEnum? structureType2 = nodeDTO.StructureType;
          return structureType1 == structureType2.GetValueOrDefault() && structureType2.HasValue;
        }));
        if (structureNodeLinks == null)
          this.TransactionalCreateStructureNodeLink(nodeDTO, structureType);
        else if (this.HasLinkChanged(structureNodeLinks, nodeDTO))
        {
          StructureNodeLinks entity = Mapper.Map<StructureNodeLinks, StructureNodeLinks>(structureNodeLinks);
          entity.EndDate = new DateTime?(DateTime.Now);
          this._structureNodeLinksRepository.TransactionalInsert(entity);
          nodeDTO.StartDate = structureNodeLinks.StartDate;
          this.TransactionalUpdateStructureNodeLink(nodeDTO);
        }
      }
    }

    private bool HasLinkChanged(StructureNodeLinks nodeLink, StructureNodeDTO nodeDTO)
    {
      bool flag1 = false;
      bool flag2 = nodeDTO.ParentNode == null ? flag1 | nodeLink.ParentNodeId != Guid.Empty : flag1 | nodeDTO.ParentNode.Id != nodeLink.ParentNodeId;
      return (nodeDTO.RootNode == null ? flag2 | nodeLink.RootNode.Id != Guid.Empty : flag2 | nodeDTO.RootNode.Id != nodeLink.RootNode.Id) | nodeDTO.OrderNr != nodeLink.OrderNr;
    }

    public void TransactionalSaveNewStructure(
      IList<StructureNodeDTO> nodeCollection,
      StructureTypeEnum structureType)
    {
      foreach (StructureNodeDTO structureNodeDto in nodeCollection.Where<StructureNodeDTO>((Func<StructureNodeDTO, bool>) (n => n.Id == Guid.Empty)))
      {
        StructureNode structureNode = this.TransactionalCreateStructureNode(structureNodeDto);
        structureNodeDto.Id = structureNode.Id;
        this.TransactionalCreateStructureNodeLink(structureNodeDto, structureType);
      }
    }

    private void TransactionalCreateOrUpdateLogicalStructure(IList<StructureNodeDTO> nodeCollection)
    {
      foreach (StructureNodeDTO node in (IEnumerable<StructureNodeDTO>) nodeCollection)
      {
        if (node.IsNewNode)
        {
          StructureNode structureNode = this.TransactionalCreateStructureNode(node);
          node.Id = structureNode.Id;
          this.TransactionalCreateStructureNodeLink(node, StructureTypeEnum.Logical);
        }
        else
        {
          this.TransactionalUpdateStructureNode(node);
          this.TransactionalCreateStructureNodeLink(node, StructureTypeEnum.Logical);
        }
      }
    }

    public void UpdateStructureNodeLink(StructureNodeLinks structureNodeLink)
    {
      this._structureNodeLinksRepository.TransactionalUpdate(structureNodeLink);
    }

    public void TransactionalDeleteAffectedStructureNodes(
      IList<StructureNodeLinks> structureNodeLinks,
      IList<StructureNode> structureNodes)
    {
      if (structureNodeLinks != null)
        TypeHelperExtensionMethods.ForEach<StructureNodeLinks>((IEnumerable<StructureNodeLinks>) structureNodeLinks, (Action<StructureNodeLinks>) (structureNodeLink =>
        {
          structureNodeLink.EndDate = new DateTime?(DateTime.Now);
          this._structureNodeLinksRepository.TransactionalUpdate(structureNodeLink);
        }));
      if (structureNodes == null)
        return;
      foreach (StructureNode structureNode1 in structureNodes.Distinct<StructureNode>())
      {
        StructureNode structureNode = structureNode1;
        StructureNodeType byId = this._structureNodeTypeRepository.GetById((object) structureNode.NodeType.Id);
        if (byId != null)
        {
          StructureNodeTypeEnum structureNodeTypeEnum = (StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), byId.Name, true);
          if (structureNode.EntityId != Guid.Empty)
          {
            switch (structureNodeTypeEnum)
            {
              case StructureNodeTypeEnum.Location:
                Location entity1 = this.GetEntity<Location>(structureNode.EntityId);
                entity1.IsDeactivated = true;
                this._locationRepository.TransactionalUpdate(entity1);
                break;
              case StructureNodeTypeEnum.Tenant:
                Tenant entity2 = this.GetEntity<Tenant>(structureNode.EntityId);
                entity2.IsDeactivated = true;
                this._tenantRepository.TransactionalUpdate(entity2);
                break;
              case StructureNodeTypeEnum.Meter:
                if (structureNodeLinks != null && structureNodeLinks.Any<StructureNodeLinks>() && structureNodeLinks[0].StructureType != StructureTypeEnum.Fixed)
                {
                  IRepository<StructureNodeEquipmentSettings> repository = this._repositoryFactory.GetRepository<StructureNodeEquipmentSettings>();
                  StructureNodeEquipmentSettings entity3 = repository.FirstOrDefault((Expression<Func<StructureNodeEquipmentSettings, bool>>) (item => item.StructureNode.Id == structureNode.Id));
                  if (entity3 != null)
                    repository.TransactionalDelete(entity3);
                }
                Meter entity4 = this.GetEntity<Meter>(structureNode.EntityId);
                entity4.IsDeactivated = true;
                this._meterRepository.TransactionalUpdate(entity4);
                break;
              case StructureNodeTypeEnum.MinomatMaster:
              case StructureNodeTypeEnum.MinomatSlave:
                Minomat entity5 = this.GetEntity<Minomat>(structureNode.EntityId);
                entity5.IsDeactivated = true;
                this._repositoryFactory.GetRepository<Minomat>().TransactionalUpdate(entity5);
                break;
              case StructureNodeTypeEnum.RadioMeter:
                Meter entity6 = this.GetEntity<Meter>(structureNode.EntityId);
                entity6.IsDeactivated = true;
                this._meterRepository.TransactionalUpdate(entity6);
                break;
            }
          }
        }
        structureNode.EndDate = new DateTime?(DateTime.Now);
        this._structureNodeRepository.TransactionalUpdate(structureNode);
      }
    }

    public void TransactionalSaveEntity(IEnumerable<StructureNodeDTO> nodeCollection)
    {
      foreach (StructureNodeDTO node in nodeCollection)
      {
        if (node.Entity != null)
        {
          switch ((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), node.NodeType.Name, true))
          {
            case StructureNodeTypeEnum.Location:
              Location entityObj1 = this.TransactionalSaveOrUpdateLocation((LocationDTO) node.Entity);
              node.Entity = StructuresHelper.GetEntityDTO(StructureNodeTypeEnum.Location, (object) entityObj1);
              break;
            case StructureNodeTypeEnum.Tenant:
              Tenant entityObj2 = this.TransactionalSaveOrUpdateTenant((TenantDTO) node.Entity);
              node.Entity = StructuresHelper.GetEntityDTO(StructureNodeTypeEnum.Tenant, (object) entityObj2);
              break;
            case StructureNodeTypeEnum.Meter:
            case StructureNodeTypeEnum.RadioMeter:
              MeterDTO entity = (MeterDTO) node.Entity;
              Meter entityObj3 = this.TransactionalSaveOrUpdateMeter(entity);
              if (entity.ReplacedMeterId.HasValue)
                this.TransactionalSaveMeterReplacementHistory(entityObj3.Id, entity.ReplacedMeterId.Value);
              node.Entity = StructuresHelper.GetEntityDTO(StructureNodeTypeEnum.Meter, (object) entityObj3);
              break;
            case StructureNodeTypeEnum.MinomatMaster:
            case StructureNodeTypeEnum.MinomatSlave:
              Minomat entityObj4 = this.TransactionalSaveOrUpdateMinomat((MinomatSerializableDTO) node.Entity);
              node.Entity = StructuresHelper.GetEntityDTO(StructureNodeTypeEnum.MinomatMaster, (object) entityObj4);
              break;
          }
        }
      }
    }

    private Guid GetEntityId(StructureNodeDTO structureNodeDTO)
    {
      return structureNodeDTO.Entity != null ? (Guid) structureNodeDTO.Entity.GetType().GetProperty("Id").GetValue(structureNodeDTO.Entity) : Guid.Empty;
    }

    private string GetEntityName(StructureNodeDTO structureNodeDTO)
    {
      return structureNodeDTO.Entity != null ? structureNodeDTO.NodeType.Name : string.Empty;
    }

    public void UpdateStructureNode(StructureNode structureNode)
    {
      this._structureNodeRepository.TransactionalUpdate(structureNode);
    }

    public void GetAffectedPhysicalStructureNodes(
      StructureNodeDTO selectedNode,
      StructureTypeEnum structureType,
      out List<StructureNodeLinks> structureNodeLinks,
      out List<StructureNodeLinks> logicalStructureNodeLinks,
      out List<StructureNode> structureNodes,
      bool includeDescendants = true)
    {
      structureNodeLinks = new List<StructureNodeLinks>();
      logicalStructureNodeLinks = new List<StructureNodeLinks>();
      structureNodes = new List<StructureNode>();
      if (includeDescendants)
      {
        foreach (StructureNodeDTO descendant in StructuresHelper.Descendants(selectedNode))
          this.GetOwnNodesAndLinksForPhysicalStructure(structureType, structureNodeLinks, logicalStructureNodeLinks, structureNodes, descendant);
      }
      else
        this.GetOwnNodesAndLinksForPhysicalStructure(structureType, structureNodeLinks, logicalStructureNodeLinks, structureNodes, selectedNode);
    }

    public void GetFixedStructureNodes(
      StructureNodeDTO selectedNode,
      out List<StructureNodeLinks> structureNodeLinks,
      out List<StructureNode> structureNodes,
      bool includeDescendants = true)
    {
      structureNodes = new List<StructureNode>();
      structureNodeLinks = new List<StructureNodeLinks>();
      if (includeDescendants)
      {
        foreach (StructureNodeDTO descendant in StructuresHelper.Descendants(selectedNode))
          this.GetOwnNodesAndLinksForFixedStructure(descendant, structureNodeLinks, structureNodes);
      }
      else
        this.GetOwnNodesAndLinksForFixedStructure(selectedNode, structureNodeLinks, structureNodes);
    }

    public void GetLogicalStructureNodes(
      StructureNodeDTO selectedNode,
      out List<StructureNodeLinks> structureNodeLinks,
      out List<StructureNode> structureNodes,
      bool includeDescendants = true)
    {
      structureNodes = new List<StructureNode>();
      structureNodeLinks = new List<StructureNodeLinks>();
      if (includeDescendants)
      {
        foreach (StructureNodeDTO descendant in StructuresHelper.Descendants(selectedNode))
          this.GetOwnNodesAndLinksForLogicalStructure(structureNodeLinks, structureNodes, descendant);
      }
      else
        this.GetOwnNodesAndLinksForLogicalStructure(structureNodeLinks, structureNodes, selectedNode);
    }

    private void GetOwnNodesAndLinksForLogicalStructure(
      List<StructureNodeLinks> structureNodeLinks,
      List<StructureNode> structureNodes,
      StructureNodeDTO structureNodeDTO)
    {
      TypeHelperExtensionMethods.ForEach<StructureNodeLinks>((IEnumerable<StructureNodeLinks>) this._structureNodeLinksRepository.SearchFor((Expression<Func<StructureNodeLinks, bool>>) (s => s.Node.Id == structureNodeDTO.Id && (int) s.StructureType == 1 && s.EndDate == new DateTime?())), new Action<StructureNodeLinks>(structureNodeLinks.Add));
      IList<StructureNodeLinks> source = this._structureNodeLinksRepository.SearchFor((Expression<Func<StructureNodeLinks, bool>>) (s => s.Node.Id == structureNodeDTO.Id && (int) s.StructureType == 0 && s.EndDate == new DateTime?()));
      List<Guid> nodeIDs = new List<Guid>();
      foreach (StructureNodeLinks structureNodeLinks1 in source.Where<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (s => !nodeIDs.Contains(s.Node.Id))))
        nodeIDs.Add(structureNodeLinks1.Node.Id);
      TypeHelperExtensionMethods.ForEach<StructureNode>(this._structureNodeRepository.SearchFor((Expression<Func<StructureNode, bool>>) (s => s.Id == structureNodeDTO.Id && s.EndDate == new DateTime?())).Except<StructureNode>((IEnumerable<StructureNode>) this._structureNodeRepository.SearchFor((Expression<Func<StructureNode, bool>>) (s => nodeIDs.Contains(s.Id)))), new Action<StructureNode>(structureNodes.Add));
    }

    private void GetOwnNodesAndLinksForPhysicalStructure(
      StructureTypeEnum structureType,
      List<StructureNodeLinks> structureNodeLinks,
      List<StructureNodeLinks> logicalStructureNodeLinks,
      List<StructureNode> structureNodes,
      StructureNodeDTO selectedNode)
    {
      TypeHelperExtensionMethods.ForEach<StructureNodeLinks>((IEnumerable<StructureNodeLinks>) this._structureNodeLinksRepository.SearchFor((Expression<Func<StructureNodeLinks, bool>>) (s => s.Node.Id == selectedNode.Id && (int) s.StructureType == (int) structureType && s.EndDate == new DateTime?())), new Action<StructureNodeLinks>(structureNodeLinks.Add));
      if (structureType == StructureTypeEnum.Physical)
      {
        IRepository<StructureNodeLinks> nodeLinksRepository = this._structureNodeLinksRepository;
        Expression<Func<StructureNodeLinks, bool>> predicate = (Expression<Func<StructureNodeLinks, bool>>) (s => s.Node.Id == selectedNode.Id && (int) s.StructureType == 1 && s.EndDate == new DateTime?());
        foreach (StructureNodeLinks parentStructureNodeLink in (IEnumerable<StructureNodeLinks>) nodeLinksRepository.SearchFor(predicate))
          TypeHelperExtensionMethods.ForEach<StructureNodeLinks>(StructuresHelper.GetDescendantsForStructureNodeLink(this._structureNodeLinksRepository, parentStructureNodeLink), new Action<StructureNodeLinks>(logicalStructureNodeLinks.Add));
      }
      IList<StructureNode> second = this._structureNodeRepository.SearchFor((Expression<Func<StructureNode, bool>>) (s => s.Id == selectedNode.Id && s.EndDate == new DateTime?()));
      TypeHelperExtensionMethods.ForEach<StructureNode>((IEnumerable<StructureNode>) second, new Action<StructureNode>(structureNodes.Add));
      List<Guid> nodeIDs = new List<Guid>();
      foreach (StructureNodeLinks structureNodeLinks1 in logicalStructureNodeLinks.Where<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (structureNode => !nodeIDs.Contains(structureNode.Node.Id))))
      {
        StructureNodeLinks logicalStructureNode = structureNodeLinks1;
        if (!this._structureNodeLinksRepository.Exists((Expression<Func<StructureNodeLinks, bool>>) (l => l.Node.Id == logicalStructureNode.Node.Id && (int) l.StructureType == 0 && l.EndDate == new DateTime?())))
          nodeIDs.Add(logicalStructureNode.Node.Id);
      }
      TypeHelperExtensionMethods.ForEach<StructureNode>(this._structureNodeRepository.SearchFor((Expression<Func<StructureNode, bool>>) (s => nodeIDs.Contains(s.Id))).Except<StructureNode>((IEnumerable<StructureNode>) second), new Action<StructureNode>(structureNodes.Add));
    }

    private void GetOwnNodesAndLinksForFixedStructure(
      StructureNodeDTO structureNodeDTO,
      List<StructureNodeLinks> structureNodeLinks,
      List<StructureNode> structureNodes)
    {
      TypeHelperExtensionMethods.ForEach<StructureNodeLinks>((IEnumerable<StructureNodeLinks>) this._structureNodeLinksRepository.SearchFor((Expression<Func<StructureNodeLinks, bool>>) (s => s.Node.Id == structureNodeDTO.Id && (int) s.StructureType == 2 && s.EndDate == new DateTime?())), new Action<StructureNodeLinks>(structureNodeLinks.Add));
      TypeHelperExtensionMethods.ForEach<StructureNode>((IEnumerable<StructureNode>) this._structureNodeRepository.SearchFor((Expression<Func<StructureNode, bool>>) (s => s.Id == structureNodeDTO.Id && s.EndDate == new DateTime?())), new Action<StructureNode>(structureNodes.Add));
    }

    public IEnumerable<StructureNodeDTO> GetAffectedLogicalStructure(
      StructureNodeDTO selectedNode,
      StructureTypeEnum structureType)
    {
      IEnumerable<StructureNodeDTO> logicalStructure = (IEnumerable<StructureNodeDTO>) new ObservableCollection<StructureNodeDTO>();
      List<StructureNodeLinks> affectedStructureNodeLinks = new List<StructureNodeLinks>();
      foreach (StructureNodeDTO descendant in StructuresHelper.Descendants(selectedNode))
      {
        StructureNodeDTO structureNodeDTO = descendant;
        TypeHelperExtensionMethods.ForEach<StructureNodeLinks>((IEnumerable<StructureNodeLinks>) this._structureNodeLinksRepository.SearchFor((Expression<Func<StructureNodeLinks, bool>>) (s => s.Node.Id == structureNodeDTO.Id && (int) s.StructureType == 1 && s.EndDate == new DateTime?())), new Action<StructureNodeLinks>(affectedStructureNodeLinks.Add));
      }
      if (affectedStructureNodeLinks.Count != 0)
        logicalStructure = this.GetLogicalStructure(affectedStructureNodeLinks);
      return logicalStructure;
    }

    private IEnumerable<StructureNodeDTO> GetLogicalStructure(
      List<StructureNodeLinks> affectedStructureNodeLinks)
    {
      List<Guid> rootIDs = new List<Guid>();
      foreach (StructureNodeLinks structureNodeLinks in affectedStructureNodeLinks.Where<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (structureNode => !rootIDs.Contains(structureNode.RootNode.Id))))
        rootIDs.Add(structureNodeLinks.RootNode.Id);
      this._structureNodeRepository.GetAll();
      IList<StructureNodeLinks> structureNodeLinksList = this._structureNodeLinksRepository.SearchFor((Expression<Func<StructureNodeLinks, bool>>) (s => (rootIDs.Contains(s.RootNode.Id) || rootIDs.Contains(s.Node.Id)) && s.EndDate == new DateTime?()));
      IList<StructureNodeType> all = this._structureNodeTypeRepository.GetAll();
      Dictionary<Guid, object> entitiesDictionary = this.GetEntitiesDictionary();
      return (IEnumerable<StructureNodeDTO>) StructuresHelper.GetTreeFromList(all, structureNodeLinksList, entitiesDictionary);
    }

    public void InsertEntitiesGuid(
      ObservableCollection<StructureNodeDTO> nodeCollection)
    {
      foreach (StructureNodeDTO node in (Collection<StructureNodeDTO>) nodeCollection)
      {
        if (node.Entity != null)
        {
          switch ((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), node.NodeType.Name, true))
          {
            case StructureNodeTypeEnum.Location:
              LocationDTO entity1 = (LocationDTO) node.Entity;
              entity1.Id = entity1.Id != Guid.Empty ? entity1.Id : Guid.NewGuid();
              break;
            case StructureNodeTypeEnum.Tenant:
              TenantDTO entity2 = (TenantDTO) node.Entity;
              entity2.Id = entity2.Id != Guid.Empty ? entity2.Id : Guid.NewGuid();
              break;
            case StructureNodeTypeEnum.Meter:
            case StructureNodeTypeEnum.RadioMeter:
              MeterDTO entity3 = (MeterDTO) node.Entity;
              entity3.Id = entity3.Id != Guid.Empty ? entity3.Id : Guid.NewGuid();
              break;
            case StructureNodeTypeEnum.MinomatMaster:
            case StructureNodeTypeEnum.MinomatSlave:
              MinomatSerializableDTO entity4 = (MinomatSerializableDTO) node.Entity;
              entity4.Id = entity4.Id != Guid.Empty ? entity4.Id : Guid.NewGuid();
              break;
          }
        }
      }
    }

    public void InsertStructureNodesGuid(
      ObservableCollection<StructureNodeDTO> nodeCollection)
    {
      foreach (StructureNodeDTO node in (Collection<StructureNodeDTO>) nodeCollection)
      {
        if (node.Id == Guid.Empty)
          node.Id = Guid.NewGuid();
      }
    }

    public object GetEntity(
      StructureNodeTypeEnum structureNodeTypeName,
      StructureNode structureNode)
    {
      object entity = new object();
      switch (structureNodeTypeName)
      {
        case StructureNodeTypeEnum.Location:
          entity = (object) this.GetEntity<Location>(structureNode.EntityId);
          break;
        case StructureNodeTypeEnum.Tenant:
          entity = (object) this.GetEntity<Tenant>(structureNode.EntityId);
          break;
        case StructureNodeTypeEnum.Meter:
        case StructureNodeTypeEnum.RadioMeter:
          entity = (object) this.GetEntity<Meter>(structureNode.EntityId);
          break;
        case StructureNodeTypeEnum.MinomatMaster:
        case StructureNodeTypeEnum.MinomatSlave:
          entity = (object) this.GetEntity<Minomat>(structureNode.EntityId);
          break;
      }
      return entity;
    }

    private T GetEntity<T>(Guid entityId) => this._nhSession.Get<T>((object) entityId);

    public Dictionary<Guid, object> GetEntitiesDictionary()
    {
      Dictionary<Guid, object> entitiesDictionary = new Dictionary<Guid, object>();
      IList<Meter> all1 = this._meterRepository.GetAll();
      IList<Location> all2 = this._locationRepository.GetAll();
      IList<Tenant> all3 = this._tenantRepository.GetAll();
      IList<Minomat> all4 = this._repositoryFactory.GetRepository<Minomat>().GetAll();
      TypeHelperExtensionMethods.ForEach<Meter>((IEnumerable<Meter>) all1, (Action<Meter>) (m => entitiesDictionary.Add(m.Id, (object) m)));
      TypeHelperExtensionMethods.ForEach<Location>((IEnumerable<Location>) all2, (Action<Location>) (l => entitiesDictionary.Add(l.Id, (object) l)));
      TypeHelperExtensionMethods.ForEach<Tenant>((IEnumerable<Tenant>) all3, (Action<Tenant>) (t => entitiesDictionary.Add(t.Id, (object) t)));
      TypeHelperExtensionMethods.ForEach<Minomat>((IEnumerable<Minomat>) all4, (Action<Minomat>) (m => entitiesDictionary.Add(m.Id, (object) m)));
      return entitiesDictionary;
    }

    public ObservableCollection<StructureNodeDTO> GetStructures(
      string searchText,
      StructureTypeEnum structureTypeEnum)
    {
      List<Guid> metersWithSameSerialNumberAsSearchText = LinqExtensionMethods.Query<Meter>(this._repositoryFactory.GetSession()).Where<Meter>((Expression<Func<Meter, bool>>) (m => m.SerialNumber == searchText)).Select<Meter, Guid>((Expression<Func<Meter, Guid>>) (m => m.Id)).ToList<Guid>();
      List<StructureNodeLinks> list1 = ((IEnumerable<StructureNodeLinks>) EagerFetchingExtensionMethods.Fetch<StructureNodeLinks, StructureNode>((IQueryable<StructureNodeLinks>) EagerFetchingExtensionMethods.Fetch<StructureNodeLinks, StructureNode>(LinqExtensionMethods.Query<StructureNodeLinks>(this._repositoryFactory.GetSession()).Where<StructureNodeLinks>((Expression<Func<StructureNodeLinks, bool>>) (l => (l.Node.Name.Contains(searchText) || l.Node.Description.Contains(searchText) || metersWithSameSerialNumberAsSearchText.Contains(l.Node.EntityId)) && l.EndDate == new DateTime?())), (Expression<Func<StructureNodeLinks, StructureNode>>) (l => l.Node)), (Expression<Func<StructureNodeLinks, StructureNode>>) (l => l.RootNode))).ToList<StructureNodeLinks>();
      List<StructureNode> list2 = list1.Select<StructureNodeLinks, StructureNode>((Func<StructureNodeLinks, StructureNode>) (l => l.Node)).ToList<StructureNode>();
      IEnumerable<Guid> source = list1.Select<StructureNodeLinks, Guid>((Func<StructureNodeLinks, Guid>) (l => l.RootNode.Id));
      IList<StructureNodeType> all = this._repositoryFactory.GetRepository<StructureNodeType>().GetAll();
      ObservableCollection<StructureNodeDTO> structures = new ObservableCollection<StructureNodeDTO>();
      foreach (Guid rootNodeId in source.Distinct<Guid>())
      {
        Dictionary<Guid, object> entitiesDictionary;
        List<StructureNodeLinks> structureLinksWithNodes = this._repositoryFactory.GetStructureNodeRepository().GetStructureLinksWithNodes(new StructureTypeEnum?(structureTypeEnum), rootNodeId, out entitiesDictionary, out List<string> _);
        foreach (StructureNodeDTO treeFrom in (Collection<StructureNodeDTO>) StructuresHelper.GetTreeFromList((IEnumerable<StructureNodeType>) all, (IEnumerable<StructureNodeLinks>) structureLinksWithNodes, (IEnumerable<StructureNode>) list2, entitiesDictionary))
          structures.Add(treeFrom);
      }
      return structures;
    }

    public Structure GetStructure(
      OrderSerializableStructure orderserializablestructure)
    {
      Structure structure = new Structure()
      {
        Locations = new List<Location>(),
        Meters = new List<Meter>(),
        Nodes = new List<StructureNode>(),
        Links = new List<StructureNodeLinks>(),
        Tenants = new List<Tenant>(),
        Minomats = new List<Minomat>(),
        MeterReplacementHistory = new List<MeterReplacementHistorySerializableDTO>()
      };
      IList<StructureNodeType> nodeTypes = this._structureNodeTypeRepository.GetAll();
      IList<Channel> channels = this._channelRepository.GetAll();
      IList<MeasureUnit> measureUnits = this._measureUniteRepository.GetAll();
      IList<RoomType> roomTypes = this._roomTypeRepository.GetAll();
      IList<Provider> providers = this._repositoryFactory.GetRepository<Provider>().GetAll();
      IList<ConnectedDeviceType> connectedDeviceTypes = this._repositoryFactory.GetRepository<ConnectedDeviceType>().GetAll();
      orderserializablestructure.minomatList.ForEach((Action<MinomatSerializableDTO>) (m => structure.Minomats.Add(new Minomat()
      {
        Id = m.Id,
        EndDate = m.EndDate,
        IsDeactivated = m.IsDeactivated,
        StartDate = m.StartDate,
        AccessPoint = m.AccessPoint,
        Challenge = m.Challenge,
        CreatedBy = m.CreatedBy,
        CreatedOn = m.CreatedOn,
        GsmId = m.GsmId,
        HostAndPort = m.HostAndPort,
        IsInMasterPool = m.IsInMasterPool,
        IsMaster = m.IsMaster,
        LastUpdatedBy = m.LastUpdatedBy,
        LastChangedOn = m.LastChangedOn,
        RadioId = m.RadioId,
        Provider = providers.FirstOrDefault<Provider>((Func<Provider, bool>) (p => p.Id == m.ProviderId)),
        Polling = m.Polling,
        ProviderName = m.ProviderName,
        Registered = m.Registered,
        SessionKey = m.SessionKey,
        SimPin = m.SimPin,
        Status = m.Status
      })));
      orderserializablestructure.structureNodeList.ForEach((Action<StructureNodeSerializableDTO>) (s => structure.Nodes.Add(new StructureNode()
      {
        Id = s.Id,
        Description = s.Description,
        Name = s.Name,
        EndDate = s.EndDate,
        EntityId = s.EntityId,
        EntityName = s.EntityName,
        NodeType = nodeTypes.FirstOrDefault<StructureNodeType>((Func<StructureNodeType, bool>) (t => t.Id == s.NodeType)),
        StartDate = s.StartDate,
        LastChangedOn = s.LastChangedOn
      })));
      orderserializablestructure.structureNodesLinksList.ForEach((Action<StructureNodeLinksSerializableDTO>) (l => structure.Links.Add(new StructureNodeLinks()
      {
        Id = l.Id,
        EndDate = l.EndDate,
        StartDate = l.StartDate,
        Node = structure.Nodes.FirstOrDefault<StructureNode>((Func<StructureNode, bool>) (n => n.Id == l.NodeId)),
        ParentNodeId = l.ParentNodeId,
        RootNode = structure.Nodes.FirstOrDefault<StructureNode>((Func<StructureNode, bool>) (n => n.Id == l.RootNodeId)),
        StructureType = l.StructureType,
        OrderNr = l.OrderNr,
        LastChangedOn = l.LastChangedOn
      })));
      orderserializablestructure.locationList.ForEach((Action<LocationSerializableDTO>) (l => structure.Locations.Add(new Location()
      {
        BuildingNr = l.BuildingNr,
        City = l.City,
        Description = l.Description,
        DueDate = l.DueDate,
        Generation = (GenerationEnum) l.Generation,
        HasMaster = l.HasMaster,
        Id = l.Id,
        Scenario = this._repositoryFactory.GetRepository<Scenario>().GetById((object) l.ScenarioId),
        Street = l.Street,
        ZipCode = l.ZipCode,
        Country = l.CountryId != Guid.Empty ? this._repositoryFactory.GetRepository<Country>().GetById((object) l.CountryId) : (Country) null,
        LastChangedOn = l.LastChangedOn
      })));
      orderserializablestructure.tenantList.ForEach((Action<TenantSerializableDTO>) (t => structure.Tenants.Add(new Tenant()
      {
        ApartmentNr = t.ApartmentNr,
        CustomerTenantNo = t.CustomerTenantNo,
        Description = t.Description,
        Direction = t.Direction,
        FloorName = t.FloorName,
        FloorNr = t.FloorNr,
        Id = t.Id,
        IsDeactivated = t.IsDeactivated,
        Name = t.Name,
        TenantNr = t.TenantNr,
        Entrance = t.Entrance,
        LastChangedOn = t.LastChangedOn
      })));
      orderserializablestructure.meterList.ForEach((Action<MeterSerializableDTO>) (m => structure.Meters.Add(new Meter()
      {
        Channel = channels.FirstOrDefault<Channel>((Func<Channel, bool>) (c => c.Id == m.ChannelId)),
        CompletDevice = m.CompletDevice,
        ConnectedDeviceType = connectedDeviceTypes.FirstOrDefault<ConnectedDeviceType>((Func<ConnectedDeviceType, bool>) (c => c.Id == m.ConnectedDeviceTypeId)),
        DeviceType = m.DeviceType,
        Id = m.Id,
        EvaluationFactor = m.EvaluationFactor,
        ImpulsUnit = measureUnits.FirstOrDefault<MeasureUnit>((Func<MeasureUnit, bool>) (mu => mu.Id == m.ImpulsUnitId)),
        ImpulsValue = m.ImpulsValue,
        IsDeactivated = m.IsDeactivated,
        ReadingUnit = measureUnits.FirstOrDefault<MeasureUnit>((Func<MeasureUnit, bool>) (mu => mu.Id == m.ReadingUnitId)),
        Room = roomTypes.FirstOrDefault<RoomType>((Func<RoomType, bool>) (r => r.Id == m.RoomTypeId)),
        SerialNumber = m.SerialNumber,
        ShortDeviceNo = m.ShortDeviceNo,
        StartValue = m.StartValue,
        IsConfigured = m.IsConfigured,
        IsReplaced = m.IsReplaced,
        Manufacturer = m.Manufacturer,
        Medium = m.Medium,
        PrimaryAddress = m.PrimaryAddress,
        Generation = m.Generation,
        LastChangedOn = m.LastChangedOn
      })));
      orderserializablestructure.meterReplacementHistoryList.ForEach(new Action<MeterReplacementHistorySerializableDTO>(structure.MeterReplacementHistory.Add));
      orderserializablestructure.locationList.ForEach((Action<LocationSerializableDTO>) (locationDTO => structure.RootNodeId = orderserializablestructure.structureNodesLinksList == null || orderserializablestructure.structureNodesLinksList.Any<StructureNodeLinksSerializableDTO>() ? Guid.Empty : orderserializablestructure.structureNodesLinksList.First<StructureNodeLinksSerializableDTO>().RootNodeId));
      return structure;
    }

    public Structure GetStructure(
      ObservableCollection<StructureNodeDTO> nodeCollection)
    {
      Mapper.CreateMap<MeterDTO, Meter>();
      Mapper.CreateMap<LocationDTO, Location>();
      Mapper.CreateMap<TenantDTO, Tenant>();
      Mapper.CreateMap<MinomatSerializableDTO, Minomat>().ForMember((Expression<Func<Minomat, object>>) (x => x.Provider), (Action<IMemberConfigurationExpression<MinomatSerializableDTO>>) (x => x.ResolveUsing((Func<MinomatSerializableDTO, object>) (y => (object) this._repositoryFactory.GetRepository<Provider>().GetById((object) y.ProviderId)))));
      Mapper.CreateMap<StructureNodeDTO, StructureNode>().ForMember((Expression<Func<StructureNode, object>>) (x => x.NodeType), (Action<IMemberConfigurationExpression<StructureNodeDTO>>) (ign => ign.Ignore()));
      Mapper.CreateMap<StructureNodeDTO, StructureNodeLinks>();
      Structure structure = new Structure()
      {
        Locations = new List<Location>(),
        Meters = new List<Meter>(),
        Nodes = new List<StructureNode>(),
        Links = new List<StructureNodeLinks>(),
        Tenants = new List<Tenant>(),
        Minomats = new List<Minomat>(),
        MeterReplacementHistory = new List<MeterReplacementHistorySerializableDTO>(),
        RootNodeId = nodeCollection.First<StructureNodeDTO>().RootNode.Id
      };
      IList<StructureNodeType> all1 = this._structureNodeTypeRepository.GetAll();
      IList<Channel> all2 = this._channelRepository.GetAll();
      IList<MeasureUnit> all3 = this._measureUniteRepository.GetAll();
      IList<RoomType> all4 = this._roomTypeRepository.GetAll();
      StructureNode structureNode1;
      if (nodeCollection.Count <= 0)
        structureNode1 = (StructureNode) null;
      else
        structureNode1 = this._repositoryFactory.GetRepository<StructureNode>().SearchForInMemoryOrDb((Expression<Func<StructureNode, bool>>) (sn => sn.Id == nodeCollection[0].RootNode.Id), (Func<StructureNode, bool>) (sn => sn.Id == nodeCollection[0].RootNode.Id)).FirstOrDefault<StructureNode>();
      StructureNode structureNode2 = structureNode1;
      foreach (StructureNodeDTO node in (Collection<StructureNodeDTO>) nodeCollection)
      {
        StructureNodeDTO structureNodeDTO = node;
        StructureNode destination = new StructureNode();
        Mapper.Map<StructureNodeDTO, StructureNode>(structureNodeDTO, destination);
        destination.NodeType = all1.FirstOrDefault<StructureNodeType>((Func<StructureNodeType, bool>) (t => t.Id == structureNodeDTO.NodeType.Id));
        structure.Nodes.Add(destination);
        StructureNodeLinks structureNodeLinks1 = Mapper.Map<StructureNodeDTO, StructureNodeLinks>(structureNodeDTO);
        structureNodeLinks1.Id = Guid.NewGuid();
        structureNodeLinks1.Node = destination;
        structureNodeLinks1.RootNode = structureNode2;
        structureNodeLinks1.StartDate = new DateTime?(DateTime.Now);
        StructureTypeEnum? structureType = structureNodeDTO.StructureType;
        if (structureType.HasValue)
        {
          StructureNodeLinks structureNodeLinks2 = structureNodeLinks1;
          structureType = structureNodeDTO.StructureType;
          int num = (int) structureType.Value;
          structureNodeLinks2.StructureType = (StructureTypeEnum) num;
        }
        structure.Links.Add(structureNodeLinks1);
        if (structureNodeDTO.Entity != null)
        {
          switch ((StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), structureNodeDTO.NodeType.Name, true))
          {
            case StructureNodeTypeEnum.Location:
              LocationDTO entity = (LocationDTO) structureNodeDTO.Entity;
              Location location = Mapper.Map<LocationDTO, Location>(entity);
              location.Scenario = entity.Scenario != null ? this._repositoryScenario.GetById((object) entity.Scenario.Id) : (Scenario) null;
              location.Country = MSS.Business.Utils.AppContext.Current.LoggedUser.Country;
              structure.Locations.Add(location);
              break;
            case StructureNodeTypeEnum.Tenant:
              Tenant tenant = Mapper.Map<TenantDTO, Tenant>((TenantDTO) structureNodeDTO.Entity);
              structure.Tenants.Add(tenant);
              break;
            case StructureNodeTypeEnum.Meter:
            case StructureNodeTypeEnum.RadioMeter:
              MeterDTO meterDTO = (MeterDTO) structureNodeDTO.Entity;
              Meter meter = Mapper.Map<MeterDTO, Meter>(meterDTO);
              meter.Room = meterDTO.Room != null ? all4.FirstOrDefault<RoomType>((Func<RoomType, bool>) (r => r.Id == meterDTO.Room.Id)) : (RoomType) null;
              meter.ReadingUnit = meterDTO.ReadingUnit != null ? all3.FirstOrDefault<MeasureUnit>((Func<MeasureUnit, bool>) (m => m.Id == meterDTO.ReadingUnit.Id)) : (MeasureUnit) null;
              meter.ImpulsUnit = meterDTO.ImpulsUnit != null ? all3.FirstOrDefault<MeasureUnit>((Func<MeasureUnit, bool>) (m => m.Id == meterDTO.ImpulsUnit.Id)) : (MeasureUnit) null;
              meter.Channel = meterDTO.Channel != null ? all2.FirstOrDefault<Channel>((Func<Channel, bool>) (c => c.Id == meterDTO.Channel.Id)) : (Channel) null;
              structure.Meters.Add(meter);
              if (meterDTO.IsReplaced)
              {
                StructuresHelper.GetMeterReplacementHistorySerializableDTO(this._meterReplacementHistoryRepository.SearchFor((Expression<Func<MeterReplacementHistory, bool>>) (h => h.CurrentMeter.Id == meterDTO.Id))).ForEach(new Action<MeterReplacementHistorySerializableDTO>(structure.MeterReplacementHistory.Add));
                break;
              }
              break;
            case StructureNodeTypeEnum.MinomatMaster:
            case StructureNodeTypeEnum.MinomatSlave:
              Minomat minomat = Mapper.Map<MinomatSerializableDTO, Minomat>((MinomatSerializableDTO) structureNodeDTO.Entity);
              structure.Minomats.Add(minomat);
              break;
          }
        }
      }
      return structure;
    }

    public Structure LoadStructure(Guid rootNodeId)
    {
      Structure structure = (Structure) null;
      if (rootNodeId != Guid.Empty)
      {
        structure = new Structure();
        structure.RootNodeId = rootNodeId;
        structure.Links = this._structureNodeLinksRepository.SearchFor((Expression<Func<StructureNodeLinks, bool>>) (s => s.RootNode.Id == rootNodeId && s.EndDate == new DateTime?())).ToList<StructureNodeLinks>();
        List<Guid> nodeIDs = structure.Links.Select<StructureNodeLinks, Guid>((Func<StructureNodeLinks, Guid>) (l => l.Node.Id)).ToList<Guid>();
        structure.Nodes = this._structureNodeRepository.SearchFor((Expression<Func<StructureNode, bool>>) (s => nodeIDs.Contains(s.Id) && s.EndDate == new DateTime?())).ToList<StructureNode>();
        List<Guid> entityIds = structure.Nodes.Where<StructureNode>((Func<StructureNode, bool>) (n =>
        {
          Guid entityId = n.EntityId;
          return true;
        })).Select<StructureNode, Guid>((Func<StructureNode, Guid>) (n => n.EntityId)).ToList<Guid>();
        structure.Locations = this._locationRepository.SearchFor((Expression<Func<Location, bool>>) (l => entityIds.Contains(l.Id))).ToList<Location>();
        structure.Tenants = this._tenantRepository.SearchFor((Expression<Func<Tenant, bool>>) (l => entityIds.Contains(l.Id))).ToList<Tenant>();
        structure.Meters = this._meterRepository.SearchFor((Expression<Func<Meter, bool>>) (l => entityIds.Contains(l.Id))).ToList<Meter>();
        structure.Minomats = this._repositoryMinomats.SearchFor((Expression<Func<Minomat, bool>>) (l => entityIds.Contains(l.Id))).ToList<Minomat>();
      }
      return structure;
    }

    public void UnlockStructure(Guid rootStructureNode)
    {
      if (!(rootStructureNode != Guid.Empty))
        return;
      this._nhSession.FlushMode = FlushMode.Commit;
      ITransaction transaction = this._nhSession.BeginTransaction();
      IList<StructureNodeLinks> structureNodeLinks = this._structureNodeLinksRepository.SearchFor((Expression<Func<StructureNodeLinks, bool>>) (s => s.RootNode.Id == rootStructureNode && s.EndDate == new DateTime?()));
      List<Guid> nodeIDs = StructuresHelper.GetNodeIdList((IEnumerable<StructureNodeLinks>) structureNodeLinks);
      IList<StructureNode> structureNodeList = this._structureNodeRepository.SearchFor((Expression<Func<StructureNode, bool>>) (s => nodeIDs.Contains(s.Id) && s.EndDate == new DateTime?()));
      foreach (StructureNodeLinks structureNodeLink in (IEnumerable<StructureNodeLinks>) structureNodeLinks)
        this.UpdateStructureNodeLink(structureNodeLink);
      foreach (StructureNode structureNode in (IEnumerable<StructureNode>) structureNodeList)
        this.UpdateStructureNode(structureNode);
      transaction.Commit();
    }

    public void TransactionalSaveNewFixedStructure(
      IList<StructureNodeDTO> nodeCollection,
      StructureNodeEquipmentSettings equipmentSettings)
    {
      try
      {
        this._nhSession.FlushMode = FlushMode.Commit;
        ITransaction transaction = this._nhSession.BeginTransaction();
        this.TransactionalSaveEntity((IEnumerable<StructureNodeDTO>) nodeCollection);
        this.TransactionalSaveNewStructure(nodeCollection, StructureTypeEnum.Fixed);
        if (equipmentSettings != null)
        {
          equipmentSettings.StructureNode = this._repositoryFactory.GetRepository<StructureNode>().GetById((object) nodeCollection[0].RootNode.Id);
          this._repositoryFactory.GetRepository<StructureNodeEquipmentSettings>().TransactionalInsert(equipmentSettings);
        }
        transaction.Commit();
      }
      catch (Exception ex)
      {
        this._nhSession.Transaction.Rollback();
        throw;
      }
    }

    public void TransactionalSaveNewPhysicalStructure(
      IList<StructureNodeDTO> nodeCollection,
      StructureNodeEquipmentSettings equipmentSettings)
    {
      try
      {
        this._nhSession.FlushMode = FlushMode.Commit;
        ITransaction transaction = this._nhSession.BeginTransaction();
        this.TransactionalSaveEntity((IEnumerable<StructureNodeDTO>) nodeCollection);
        this.TransactionalSaveNewStructure(nodeCollection, StructureTypeEnum.Physical);
        if (equipmentSettings != null)
        {
          equipmentSettings.StructureNode = this._repositoryFactory.GetRepository<StructureNode>().GetById((object) nodeCollection[0].RootNode.Id);
          this._repositoryFactory.GetRepository<StructureNodeEquipmentSettings>().TransactionalInsert(equipmentSettings);
        }
        transaction.Commit();
      }
      catch (Exception ex)
      {
        this._nhSession.Transaction.Rollback();
        throw;
      }
    }

    public void TransactionalSaveNewLogicalStructure(IList<StructureNodeDTO> nodeCollection)
    {
      try
      {
        this._nhSession.FlushMode = FlushMode.Commit;
        ITransaction transaction = this._nhSession.BeginTransaction();
        this.TransactionalSaveEntity((IEnumerable<StructureNodeDTO>) nodeCollection);
        this.TransactionalCreateOrUpdateLogicalStructure(nodeCollection);
        transaction.Commit();
      }
      catch (Exception ex)
      {
        this._nhSession.Transaction.Rollback();
        throw;
      }
    }

    public void TransactionalUpdateStructure(
      IList<StructureNodeDTO> nodeCollection,
      StructureTypeEnum structureNodeType,
      StructureNodeEquipmentSettings equipmentSettings,
      IList<StructureNodeLinks> structureNodeLinksToBeDeleted = null,
      IList<StructureNode> structureNodesToBeDeleted = null)
    {
      try
      {
        this._nhSession.FlushMode = FlushMode.Commit;
        ITransaction transaction = this._nhSession.BeginTransaction();
        this.TransactionalDeleteAffectedStructureNodes(structureNodeLinksToBeDeleted, structureNodesToBeDeleted);
        this.TransactionalSaveEntity((IEnumerable<StructureNodeDTO>) nodeCollection);
        this.TransactionalCreateOrUpdateStructure(nodeCollection, structureNodeType);
        this.TransactionalUpdateOrderNrForPartialStructure(nodeCollection, structureNodeType);
        if (equipmentSettings != null && nodeCollection.Count > 0)
        {
          equipmentSettings.StructureNode = this._repositoryFactory.GetRepository<StructureNode>().GetById((object) nodeCollection[0].RootNode.Id);
          this._repositoryFactory.GetRepository<StructureNodeEquipmentSettings>().TransactionalUpdate(equipmentSettings);
        }
        transaction.Commit();
      }
      catch (Exception ex)
      {
        this._nhSession.Transaction.Rollback();
        throw;
      }
    }

    public void RemoveStructure(StructureNodeDTO selectedNode, StructureTypeEnum structureType)
    {
      try
      {
        this._nhSession.FlushMode = FlushMode.Commit;
        ITransaction transaction = this._nhSession.BeginTransaction();
        List<StructureNodeLinks> structureNodeLinks = new List<StructureNodeLinks>();
        List<StructureNodeLinks> logicalStructureNodeLinks = new List<StructureNodeLinks>();
        List<StructureNode> structureNodes = new List<StructureNode>();
        List<StructureNodeLinks> structureNodeLinksList = new List<StructureNodeLinks>();
        switch (structureType)
        {
          case StructureTypeEnum.Physical:
            this.GetAffectedPhysicalStructureNodes(selectedNode, structureType, out structureNodeLinks, out logicalStructureNodeLinks, out structureNodes);
            break;
          case StructureTypeEnum.Logical:
            this.GetLogicalStructureNodes(selectedNode, out structureNodeLinks, out structureNodes);
            break;
          case StructureTypeEnum.Fixed:
            this.GetFixedStructureNodes(selectedNode, out structureNodeLinks, out structureNodes);
            break;
        }
        structureNodeLinks.ForEach(new Action<StructureNodeLinks>(structureNodeLinksList.Add));
        logicalStructureNodeLinks.ForEach(new Action<StructureNodeLinks>(structureNodeLinksList.Add));
        foreach (StructureNodeLinks entity in structureNodeLinksList)
          this._structureNodeLinksRepository.TransactionalDelete(entity);
        IList<StructureNodeType> all = this._structureNodeTypeRepository.GetAll();
        foreach (StructureNode structureNode1 in structureNodes.Distinct<StructureNode>())
        {
          StructureNode structureNode = structureNode1;
          StructureNodeType structureNodeType = all.FirstOrDefault<StructureNodeType>((Func<StructureNodeType, bool>) (c => c.Id == structureNode.NodeType.Id));
          if (structureNodeType != null)
          {
            StructureNodeTypeEnum structureNodeTypeEnum = (StructureNodeTypeEnum) Enum.Parse(typeof (StructureNodeTypeEnum), structureNodeType.Name, true);
            if (structureNode.EntityId != Guid.Empty)
            {
              switch (structureNodeTypeEnum)
              {
                case StructureNodeTypeEnum.Location:
                  this._locationRepository.TransactionalUpdate(this.GetEntity<Location>(structureNode.EntityId));
                  this._locationRepository.TransactionalDelete(this.GetEntity<Location>(structureNode.EntityId));
                  break;
                case StructureNodeTypeEnum.Tenant:
                  this._tenantRepository.TransactionalUpdate(this.GetEntity<Tenant>(structureNode.EntityId));
                  this._tenantRepository.TransactionalDelete(this.GetEntity<Tenant>(structureNode.EntityId));
                  break;
                case StructureNodeTypeEnum.Meter:
                case StructureNodeTypeEnum.RadioMeter:
                  this._meterRepository.TransactionalUpdate(this.GetEntity<Meter>(structureNode.EntityId));
                  this._meterRepository.TransactionalDelete(this.GetEntity<Meter>(structureNode.EntityId));
                  break;
                case StructureNodeTypeEnum.MinomatMaster:
                case StructureNodeTypeEnum.MinomatSlave:
                  Minomat entity = this.GetEntity<Minomat>(structureNode.EntityId);
                  this._repositoryFactory.GetRepository<Minomat>().TransactionalUpdate(entity);
                  this._repositoryFactory.GetRepository<Minomat>().TransactionalDelete(this.GetEntity<Minomat>(structureNode.EntityId));
                  break;
              }
            }
          }
          this._structureNodeRepository.TransactionalUpdate(structureNode);
          this._structureNodeRepository.TransactionalDelete(structureNode);
        }
        transaction.Commit();
      }
      catch (Exception ex)
      {
        this._nhSession.Transaction.Rollback();
        throw;
      }
    }

    public void DeleteStructureNodeAndDescendants(StructureNodeDTO nodeDTO)
    {
      try
      {
        this._nhSession.FlushMode = FlushMode.Commit;
        ITransaction transaction = this._nhSession.BeginTransaction();
        List<StructureNodeLinks> structureNodeLinks1 = new List<StructureNodeLinks>();
        List<StructureNodeLinks> logicalStructureNodeLinks = new List<StructureNodeLinks>();
        List<StructureNode> structureNodes = new List<StructureNode>();
        List<StructureNodeLinks> structureNodeLinks2 = new List<StructureNodeLinks>();
        StructureTypeEnum? structureType = nodeDTO.StructureType;
        if (structureType.HasValue)
        {
          switch (structureType.GetValueOrDefault())
          {
            case StructureTypeEnum.Physical:
              this.GetAffectedPhysicalStructureNodes(nodeDTO, nodeDTO.StructureType.Value, out structureNodeLinks1, out logicalStructureNodeLinks, out structureNodes);
              break;
            case StructureTypeEnum.Logical:
              this.GetLogicalStructureNodes(nodeDTO, out structureNodeLinks1, out structureNodes);
              break;
            case StructureTypeEnum.Fixed:
              this.GetFixedStructureNodes(nodeDTO, out structureNodeLinks1, out structureNodes);
              break;
          }
        }
        structureNodeLinks1.ForEach(new Action<StructureNodeLinks>(structureNodeLinks2.Add));
        logicalStructureNodeLinks.ForEach(new Action<StructureNodeLinks>(structureNodeLinks2.Add));
        this.TransactionalDeleteAffectedStructureNodes((IList<StructureNodeLinks>) structureNodeLinks2, (IList<StructureNode>) structureNodes);
        transaction.Commit();
      }
      catch (Exception ex)
      {
        this._nhSession.Transaction.Rollback();
        throw;
      }
    }

    public void DeleteStructure(
      StructureNodeDTO selectedNode,
      StructureTypeEnum structureType,
      bool includeDescendants = true)
    {
      try
      {
        this._nhSession.FlushMode = FlushMode.Commit;
        ITransaction transaction = this._nhSession.BeginTransaction();
        List<StructureNodeLinks> structureNodeLinks1 = new List<StructureNodeLinks>();
        List<StructureNodeLinks> logicalStructureNodeLinks = new List<StructureNodeLinks>();
        List<StructureNode> structureNodes = new List<StructureNode>();
        List<StructureNodeLinks> structureNodeLinks2 = new List<StructureNodeLinks>();
        switch (structureType)
        {
          case StructureTypeEnum.Physical:
            this.GetAffectedPhysicalStructureNodes(selectedNode, structureType, out structureNodeLinks1, out logicalStructureNodeLinks, out structureNodes, includeDescendants);
            break;
          case StructureTypeEnum.Logical:
            this.GetLogicalStructureNodes(selectedNode, out structureNodeLinks1, out structureNodes, includeDescendants);
            break;
          case StructureTypeEnum.Fixed:
            this.GetFixedStructureNodes(selectedNode, out structureNodeLinks1, out structureNodes, includeDescendants);
            break;
        }
        structureNodeLinks1.ForEach(new Action<StructureNodeLinks>(structureNodeLinks2.Add));
        logicalStructureNodeLinks.ForEach(new Action<StructureNodeLinks>(structureNodeLinks2.Add));
        IRepository<Order> orderRepository = this._repositoryFactory.GetRepository<Order>();
        List<Order> orderList = new List<Order>();
        foreach (StructureNode structureNode in structureNodes)
        {
          StructureNode currentStructureNode = structureNode;
          orderList.AddRange((IEnumerable<Order>) orderRepository.SearchFor((Expression<Func<Order, bool>>) (item => item.RootStructureNodeId == currentStructureNode.Id)));
        }
        orderList.ForEach((Action<Order>) (x =>
        {
          Guid? lockedBy = x.LockedBy;
          Guid empty = Guid.Empty;
          int num;
          if ((lockedBy.HasValue ? (lockedBy.HasValue ? (lockedBy.GetValueOrDefault() == empty ? 1 : 0) : 1) : 0) == 0)
          {
            lockedBy = x.LockedBy;
            num = !lockedBy.HasValue ? 1 : 0;
          }
          else
            num = 1;
          if (num == 0)
            return;
          x.IsDeactivated = true;
          orderRepository.TransactionalUpdate(x);
        }));
        this.TransactionalDeleteAffectedStructureNodes((IList<StructureNodeLinks>) structureNodeLinks2, (IList<StructureNode>) structureNodes);
        transaction.Commit();
      }
      catch (Exception ex)
      {
        this._nhSession.Transaction.Rollback();
        throw;
      }
    }

    public ObservableCollection<StructureNodeDTO> GetStructureNodesCollection(
      StructureTypeEnum structureType,
      bool loadOnDemand = false)
    {
      this._repositoryFactory.GetSession().Clear();
      IStructureNodeRepository structureNodeRepository = this._repositoryFactory.GetStructureNodeRepository();
      IList<StructureNodeType> all1 = this._repositoryFactory.GetRepository<StructureNodeType>().GetAll();
      IList<MeterReplacementHistory> all2 = this._repositoryFactory.GetRepository<MeterReplacementHistory>().GetAll();
      ObservableCollection<StructureNodeDTO> observableCollection = new ObservableCollection<StructureNodeDTO>();
      ObservableCollection<StructureNodeDTO> structureNodesCollection;
      if (loadOnDemand)
      {
        Dictionary<Guid, object> entitiesDictionary;
        List<StructureNodeLinks> structureRootLinks = structureNodeRepository.GetStructureRootLinks(structureType, out entitiesDictionary);
        structureNodesCollection = StructuresHelper.GetTreeFromList(all1, (IList<StructureNodeLinks>) structureRootLinks, entitiesDictionary, loadOnDemand: loadOnDemand);
      }
      else
        structureNodesCollection = this.GetNodeCollectionWithChildren(structureNodeRepository, new StructureTypeEnum?(structureType), all1, all2);
      return structureNodesCollection;
    }

    public ObservableCollection<StructureNodeDTO> GetNodeCollectionWithChildren(
      IStructureNodeRepository structRepository,
      StructureTypeEnum? structureType,
      IList<StructureNodeType> structureNodeTypeList,
      IList<MeterReplacementHistory> meterReplacementHistoryList,
      Guid rootNodeId = default (Guid))
    {
      Dictionary<Guid, object> entitiesDictionary;
      List<string> duplicateMeterSerialNumbers;
      List<StructureNodeLinks> structureLinksWithNodes = structRepository.GetStructureLinksWithNodes(structureType, rootNodeId, out entitiesDictionary, out duplicateMeterSerialNumbers);
      List<MeterReplacementHistorySerializableDTO> historySerializableDto = StructuresHelper.GetMeterReplacementHistorySerializableDTO(meterReplacementHistoryList);
      return StructuresHelper.GetTreeFromList(structureNodeTypeList, (IList<StructureNodeLinks>) structureLinksWithNodes, entitiesDictionary, duplicateMeterSerialNumbers, (IList<MeterReplacementHistorySerializableDTO>) historySerializableDto);
    }

    public string GetNameAndDescriptionForRootNodeID(Guid rootNodeId)
    {
      StructureNode structureNode = this._structureNodeRepository.FirstOrDefault((Expression<Func<StructureNode, bool>>) (n => n.Id == rootNodeId));
      return structureNode != null ? structureNode.Name + "\n" + structureNode.Description : string.Empty;
    }

    public string GetNameAndDescriptionRootForStructureBytes(byte[] structureBytes)
    {
      OrderSerializableStructure orderSerializableStructure = StructuresHelper.DeserializeStructure(structureBytes);
      if (orderSerializableStructure.structureNodesLinksList == null || orderSerializableStructure.structureNodesLinksList.Count <= 0 || !(orderSerializableStructure.structureNodesLinksList[0].RootNodeId != Guid.Empty))
        return string.Empty;
      StructureNodeSerializableDTO nodeSerializableDto = orderSerializableStructure.structureNodeList.FirstOrDefault<StructureNodeSerializableDTO>((Func<StructureNodeSerializableDTO, bool>) (sn => sn.Id == orderSerializableStructure.structureNodesLinksList[0].RootNodeId));
      return nodeSerializableDto != null ? nodeSerializableDto.Name + "\n" + nodeSerializableDto.Description : string.Empty;
    }

    public DateTime? GetStructureDueDate(Guid rootNodeId)
    {
      StructureNode structureNode = this._structureNodeRepository.FirstOrDefault((Expression<Func<StructureNode, bool>>) (n => n.Id == rootNodeId));
      if (structureNode != null)
      {
        Location location = this._locationRepository.FirstOrDefault((Expression<Func<Location, bool>>) (l => l.Id == structureNode.EntityId));
        if (location != null)
          return location.DueDate;
      }
      return new DateTime?(DateTime.MinValue);
    }

    public DateTime? GetStructureDueDate(byte[] structureBytes)
    {
      OrderSerializableStructure serializableStructure = StructuresHelper.DeserializeStructure(structureBytes);
      return serializableStructure.locationList != null && serializableStructure.locationList.Count > 0 ? serializableStructure.locationList[0].DueDate : new DateTime?(DateTime.MinValue);
    }

    public DateTime? GetStructureDueDate(Structure structure)
    {
      StructureNodeLinks rootNode = structure.Links.FirstOrDefault<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (l => l.ParentNodeId == Guid.Empty && l.RootNode.Id == l.Node.Id));
      if (rootNode != null)
      {
        StructureNode node = structure.Nodes.FirstOrDefault<StructureNode>((Func<StructureNode, bool>) (n => n.Id == rootNode.Node.Id));
        if (node != null)
        {
          Location location = structure.Locations.FirstOrDefault<Location>((Func<Location, bool>) (l => l.Id == node.EntityId));
          if (location != null)
            return location.DueDate;
        }
      }
      return new DateTime?(DateTime.MinValue);
    }

    public ObservableCollection<StructureNodeDTO> GetStructureNodeDTO(byte[] structureBytes)
    {
      ObservableCollection<StructureNodeDTO> structureNodeDto = new ObservableCollection<StructureNodeDTO>();
      if (structureBytes != null)
      {
        Structure structure = this.GetStructure(StructuresHelper.DeserializeStructure(structureBytes));
        Dictionary<Guid, object> entitiesDictionary = new Dictionary<Guid, object>();
        structure.Locations.ForEach((Action<Location>) (l => entitiesDictionary.Add(l.Id, (object) l)));
        structure.Tenants.ForEach((Action<Tenant>) (t => entitiesDictionary.Add(t.Id, (object) t)));
        structure.Meters.ForEach((Action<Meter>) (m => entitiesDictionary.Add(m.Id, (object) m)));
        structure.Minomats.ForEach((Action<Minomat>) (m => entitiesDictionary.Add(m.Id, (object) m)));
        structureNodeDto = StructuresHelper.GetTreeFromList(this._structureNodeTypeRepository.GetAll(), (IList<StructureNodeLinks>) structure.Links, entitiesDictionary, meterReplacementHistoryList: (IList<MeterReplacementHistorySerializableDTO>) structure.MeterReplacementHistory);
      }
      return structureNodeDto;
    }

    public byte[] CreateStructureBytes(
      ObservableCollection<StructureNodeDTO> actualNodeCollection,
      byte[] structureBytes)
    {
      this.InsertEntitiesGuid(actualNodeCollection);
      this.InsertStructureNodesGuid(actualNodeCollection);
      structureBytes = StructuresHelper.SerializeStructure(actualNodeCollection, structureBytes);
      return structureBytes;
    }

    public void UpdateReplacedMeter(StructureNodeDTO replacedMeter)
    {
      StructureNode byId1 = this._structureNodeRepository.GetById((object) replacedMeter.Id);
      byId1.Name = replacedMeter.Name;
      byId1.Description = replacedMeter.Description;
      this._structureNodeRepository.Update(byId1);
      MeterDTO entity = replacedMeter.Entity as MeterDTO;
      Meter byId2 = this._meterRepository.GetById((object) entity.Id);
      Mapper.Map<MeterDTO, Meter>(entity, byId2);
      this._meterRepository.Update(byId2);
    }

    public byte[] UpdateReplacedMeter(
      List<StructureNodeDTO> replacedMeterList,
      byte[] structureBytes)
    {
      foreach (StructureNodeDTO replacedMeter1 in replacedMeterList)
      {
        StructureNodeDTO replacedMeter = replacedMeter1;
        OrderSerializableStructure serializableStructure = StructuresHelper.DeserializeStructure(structureBytes);
        serializableStructure.meterReplacementHistoryList.ForEach((Action<MeterReplacementHistorySerializableDTO>) (h =>
        {
          if (!(replacedMeter.Entity is MeterDTO entity2) || !(h.ReplacedMeterId == entity2.Id))
            return;
          h.ReplacedMeterSerialNumber = entity2.SerialNumber;
          h.ReplacedMeterDeviceType = entity2.DeviceType;
        }));
        structureBytes = StructuresHelper.SerializeStructure(serializableStructure);
      }
      return structureBytes;
    }

    public void ReplacePhysicalMeterInLogicalStructure(StructureNodeDTO replacedMeter)
    {
      IRepository<MeterReplacementHistory> repository = this._repositoryFactory.GetRepository<MeterReplacementHistory>();
      MeterDTO brokenMeterDTO = replacedMeter.Entity as MeterDTO;
      if (brokenMeterDTO == null)
        return;
      MeterReplacementHistory replacementHistory = repository.FirstOrDefault((Expression<Func<MeterReplacementHistory, bool>>) (m => m.ReplacedMeter.Id == brokenMeterDTO.Id));
      if (replacementHistory != null)
      {
        Meter currentMeter = replacementHistory.CurrentMeter;
        StructureNode brokeMeterNode = this._structureNodeRepository.FirstOrDefault((Expression<Func<StructureNode, bool>>) (n => n.EntityId == brokenMeterDTO.Id && n.EndDate != new DateTime?()));
        StructureNode structureNode = this._structureNodeRepository.FirstOrDefault((Expression<Func<StructureNode, bool>>) (n => n.EntityId == currentMeter.Id && n.EndDate == new DateTime?()));
        IRepository<StructureNodeLinks> nodeLinksRepository = this._structureNodeLinksRepository;
        Expression<Func<StructureNodeLinks, bool>> predicate = (Expression<Func<StructureNodeLinks, bool>>) (l => l.Node.Id == brokeMeterNode.Id && (int) l.StructureType == 1 && l.EndDate != new DateTime?());
        foreach (StructureNodeLinks source in (IEnumerable<StructureNodeLinks>) nodeLinksRepository.SearchFor(predicate))
        {
          StructureNodeLinks entity = Mapper.Map<StructureNodeLinks, StructureNodeLinks>(source);
          entity.Node = structureNode;
          entity.EndDate = new DateTime?();
          this._structureNodeLinksRepository.Insert(entity);
        }
      }
    }

    public void TransactionalSaveMeterReplacementHistory(Guid currentMeterId, Guid replacedMeterId)
    {
      Meter byId = this._meterRepository.GetById((object) currentMeterId);
      MeterReplacementHistory entity1 = new MeterReplacementHistory()
      {
        CurrentMeter = byId,
        ReplacedMeter = this._meterRepository.GetById((object) replacedMeterId),
        ReplacementDate = DateTime.Now,
        ReplacedByUser = MSS.Business.Utils.AppContext.Current.LoggedUser
      };
      IRepository<MeterReplacementHistory> repository1 = this._repositoryFactory.GetRepository<MeterReplacementHistory>();
      repository1.TransactionalInsert(entity1);
      IRepository<MeterReplacementHistory> repository2 = repository1;
      Expression<Func<MeterReplacementHistory, bool>> predicate = (Expression<Func<MeterReplacementHistory, bool>>) (m => m.CurrentMeter.Id == replacedMeterId);
      foreach (MeterReplacementHistory entity2 in (IEnumerable<MeterReplacementHistory>) repository2.SearchFor(predicate))
      {
        entity2.CurrentMeter = byId;
        repository1.TransactionalUpdate(entity2);
      }
    }

    public void TransactionalUpdateOrderNrForPartialStructure(
      IList<StructureNodeDTO> nodeCollection,
      StructureTypeEnum structureType)
    {
      if (nodeCollection.Count <= 0 || nodeCollection.First<StructureNodeDTO>().ParentNode == null)
        return;
      ObservableCollection<StructureNodeDTO> subNodes = nodeCollection.First<StructureNodeDTO>().ParentNode.SubNodes;
      List<Guid> nodeIDs = new List<Guid>();
      foreach (StructureNodeDTO structureNodeDto in subNodes.Where<StructureNodeDTO>((Func<StructureNodeDTO, bool>) (structureNode => !nodeIDs.Contains(structureNode.Id))))
        nodeIDs.Add(structureNodeDto.Id);
      IEnumerable<StructureNodeLinks> source1 = (IEnumerable<StructureNodeLinks>) this._structureNodeLinksRepository.SearchFor((Expression<Func<StructureNodeLinks, bool>>) (l => (int) l.StructureType == (int) structureType && nodeIDs.Contains(l.Node.Id)));
      foreach (StructureNodeDTO structureNodeDto1 in (Collection<StructureNodeDTO>) subNodes)
      {
        StructureNodeDTO structureNodeDto = structureNodeDto1;
        StructureNodeLinks source2 = source1.FirstOrDefault<StructureNodeLinks>((Func<StructureNodeLinks, bool>) (l => l.Node.Id == structureNodeDto.Id && !l.EndDate.HasValue));
        if (source2 != null && structureNodeDto.OrderNr != source2.OrderNr)
        {
          StructureNodeLinks entity = Mapper.Map<StructureNodeLinks, StructureNodeLinks>(source2);
          entity.EndDate = new DateTime?(DateTime.Now);
          this._structureNodeLinksRepository.TransactionalInsert(entity);
          this.TransactionalUpdateStructureNodeLink(structureNodeDto);
        }
      }
    }
  }
}


--- TenantManager.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: MSS.Business.Modules.StructuresManagement.TenantManager
// Assembly: MSS.Business, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 64DA76B1-4684-48DF-AFDA-4106EF3D1AF4
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\MSS.Business.dll

using MSS.Core.Model.MSSClient;
using MSS.Core.Model.Structures;
using MSS.Interfaces;
using MSS.Localisation;
using Ninject;
using System;
using System.Collections.Generic;
using System.Linq;

#nullable disable
namespace MSS.Business.Modules.StructuresManagement
{
  public class TenantManager
  {
    private readonly IRepository<Location> _locationRepository;
    private readonly IRepository<Scenario> _scenarioRepository;
    private readonly IRepository<Tenant> _tenantRepository;
    private readonly IRepositoryFactory _repositoryFactory;

    [Inject]
    public TenantManager(IRepositoryFactory repositoryFactory)
    {
      this._repositoryFactory = repositoryFactory;
      this._tenantRepository = repositoryFactory.GetRepository<Tenant>();
      this._locationRepository = repositoryFactory.GetRepository<Location>();
      this._scenarioRepository = repositoryFactory.GetRepository<Scenario>();
    }

    public IEnumerable<string> GetFloorNames()
    {
      return (IEnumerable<string>) ((IEnumerable<string>) Enum.GetNames(typeof (FloorNamesEnum))).ToList<string>();
    }

    public IEnumerable<string> GetDirections()
    {
      return (IEnumerable<string>) ((IEnumerable<string>) Enum.GetNames(typeof (DirectionsEnum))).ToList<string>();
    }

    public void CreateTenant(Tenant tenantToBeAdded, Guid locationGuid)
    {
      this._tenantRepository.Insert(tenantToBeAdded);
    }

    public void EditTenant(Tenant tenantToBeEdited)
    {
      this._tenantRepository.Update(tenantToBeEdited);
    }

    public void DeleteTenant(Guid tenantGuid)
    {
      this._tenantRepository.Delete(this._tenantRepository.GetById((object) tenantGuid));
    }

    public IEnumerable<Tenant> GetTenants()
    {
      return (IEnumerable<Tenant>) this._tenantRepository.GetAll();
    }

    private LocationManager GetLocationManagerInstance()
    {
      return new LocationManager(this._repositoryFactory);
    }

    public bool ValidateTenantNr(
      int tenantNr,
      List<int> localStructureTenantNrs,
      Guid selectedTenantGuid,
      out ICollection<string> validationErrors)
    {
      validationErrors = (ICollection<string>) new List<string>();
      if (localStructureTenantNrs.Contains(tenantNr))
        validationErrors.Add(Resources.MSS_Client_Structures_TenantNrExisting);
      return validationErrors.Count == 0;
    }
  }
}

