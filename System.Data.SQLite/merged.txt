
--- AssemblyInfo.cs ---

﻿using System;
using System.Data.SQLite;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.ConstrainedExecution;
using System.Runtime.InteropServices;
using System.Security;

[assembly: AssemblyFileVersion("1.0.103.0")]
[assembly: SecurityRules(SecurityRuleSet.Level1)]
[assembly: AssemblySourceId("21536d0960daa6f6db17a617e09aa1d61d2b2c27")]
[assembly: AssemblySourceTimeStamp("2016-09-14 04:27:36 UTC")]
[assembly: AssemblyTitle("System.Data.SQLite Core")]
[assembly: AssemblyDescription("ADO.NET Data Provider for SQLite")]
[assembly: AssemblyCompany("https://system.data.sqlite.org/")]
[assembly: AssemblyProduct("System.Data.SQLite")]
[assembly: AssemblyCopyright("Public Domain")]
[assembly: AssemblyConfiguration("Release")]
[assembly: ComVisible(false)]
[assembly: CLSCompliant(true)]
[assembly: InternalsVisibleTo("System.Data.SQLite.Linq, PublicKey=002400000480000094000000060200000024000052534131000400000100010005a288de5687c4e1b621ddff5d844727418956997f475eb829429e411aff3e93f97b70de698b972640925bdd44280df0a25a843266973704137cbb0e7441c1fe7cae4e2440ae91ab8cde3933febcb1ac48dd33b40e13c421d8215c18a4349a436dd499e3c385cc683015f886f6c10bd90115eb2bd61b67750839e3a19941dc9c")]
[assembly: InternalsVisibleTo("System.Data.SQLite.EF6, PublicKey=002400000480000094000000060200000024000052534131000400000100010005a288de5687c4e1b621ddff5d844727418956997f475eb829429e411aff3e93f97b70de698b972640925bdd44280df0a25a843266973704137cbb0e7441c1fe7cae4e2440ae91ab8cde3933febcb1ac48dd33b40e13c421d8215c18a4349a436dd499e3c385cc683015f886f6c10bd90115eb2bd61b67750839e3a19941dc9c")]
[assembly: NeutralResourcesLanguage("en")]
[assembly: ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]
[assembly: AssemblyVersion("1.0.103.0")]


--- AssemblySourceIdAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.AssemblySourceIdAttribute
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  [AttributeUsage(AttributeTargets.Assembly, Inherited = false)]
  public sealed class AssemblySourceIdAttribute : Attribute
  {
    private string sourceId;

    public AssemblySourceIdAttribute(string value) => this.sourceId = value;

    public string SourceId => this.sourceId;
  }
}


--- AssemblySourceTimeStampAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.AssemblySourceTimeStampAttribute
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  [AttributeUsage(AttributeTargets.Assembly, Inherited = false)]
  public sealed class AssemblySourceTimeStampAttribute : Attribute
  {
    private string sourceTimeStamp;

    public AssemblySourceTimeStampAttribute(string value) => this.sourceTimeStamp = value;

    public string SourceTimeStamp => this.sourceTimeStamp;
  }
}


--- AuthorizerEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.AuthorizerEventArgs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public class AuthorizerEventArgs : EventArgs
  {
    public readonly IntPtr UserData;
    public readonly SQLiteAuthorizerActionCode ActionCode;
    public readonly string Argument1;
    public readonly string Argument2;
    public readonly string Database;
    public readonly string Context;
    public SQLiteAuthorizerReturnCode ReturnCode;

    private AuthorizerEventArgs()
    {
      this.UserData = IntPtr.Zero;
      this.ActionCode = SQLiteAuthorizerActionCode.None;
      this.Argument1 = (string) null;
      this.Argument2 = (string) null;
      this.Database = (string) null;
      this.Context = (string) null;
      this.ReturnCode = SQLiteAuthorizerReturnCode.Ok;
    }

    internal AuthorizerEventArgs(
      IntPtr pUserData,
      SQLiteAuthorizerActionCode actionCode,
      string argument1,
      string argument2,
      string database,
      string context,
      SQLiteAuthorizerReturnCode returnCode)
      : this()
    {
      this.UserData = pUserData;
      this.ActionCode = actionCode;
      this.Argument1 = argument1;
      this.Argument2 = argument2;
      this.Database = database;
      this.Context = context;
      this.ReturnCode = returnCode;
    }
  }
}


--- CollationEncodingEnum.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.CollationEncodingEnum
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum CollationEncodingEnum
  {
    UTF8 = 1,
    UTF16LE = 2,
    UTF16BE = 3,
  }
}


--- CollationSequence.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.CollationSequence
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public struct CollationSequence
  {
    public string Name;
    public CollationTypeEnum Type;
    public CollationEncodingEnum Encoding;
    internal SQLiteFunction _func;

    public int Compare(string s1, string s2)
    {
      return this._func._base.ContextCollateCompare(this.Encoding, this._func._context, s1, s2);
    }

    public int Compare(char[] c1, char[] c2)
    {
      return this._func._base.ContextCollateCompare(this.Encoding, this._func._context, c1, c2);
    }
  }
}


--- CollationTypeEnum.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.CollationTypeEnum
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum CollationTypeEnum
  {
    Custom,
    Binary,
    NoCase,
    Reverse,
  }
}


--- CommitEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.CommitEventArgs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public class CommitEventArgs : EventArgs
  {
    public bool AbortTransaction;

    internal CommitEventArgs()
    {
    }
  }
}


--- ConnectionEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.ConnectionEventArgs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  public class ConnectionEventArgs : System.EventArgs
  {
    public readonly SQLiteConnectionEventType EventType;
    public readonly StateChangeEventArgs EventArgs;
    public readonly IDbTransaction Transaction;
    public readonly IDbCommand Command;
    public readonly IDataReader DataReader;
    public readonly CriticalHandle CriticalHandle;
    public readonly string Text;
    public readonly object Data;

    internal ConnectionEventArgs(
      SQLiteConnectionEventType eventType,
      StateChangeEventArgs eventArgs,
      IDbTransaction transaction,
      IDbCommand command,
      IDataReader dataReader,
      CriticalHandle criticalHandle,
      string text,
      object data)
    {
      this.EventType = eventType;
      this.EventArgs = eventArgs;
      this.Transaction = transaction;
      this.Command = command;
      this.DataReader = dataReader;
      this.CriticalHandle = criticalHandle;
      this.Text = text;
      this.Data = data;
    }
  }
}


--- FunctionType.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.FunctionType
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum FunctionType
  {
    Scalar,
    Aggregate,
    Collation,
  }
}


--- HelperMethods.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.HelperMethods
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  internal static class HelperMethods
  {
    private static readonly object staticSyncRoot = new object();
    private static readonly string MonoRuntimeType = "Mono.Runtime";
    private static bool? isMono = new bool?();

    private static bool IsMono()
    {
      try
      {
        lock (HelperMethods.staticSyncRoot)
        {
          if (!HelperMethods.isMono.HasValue)
            HelperMethods.isMono = new bool?(Type.GetType(HelperMethods.MonoRuntimeType) != (Type) null);
          return HelperMethods.isMono.Value;
        }
      }
      catch
      {
      }
      return false;
    }

    internal static bool IsWindows()
    {
      switch (Environment.OSVersion.Platform)
      {
        case PlatformID.Win32S:
        case PlatformID.Win32Windows:
        case PlatformID.Win32NT:
        case PlatformID.WinCE:
          return true;
        default:
          return false;
      }
    }

    internal static string StringFormat(
      IFormatProvider provider,
      string format,
      params object[] args)
    {
      return HelperMethods.IsMono() ? string.Format(format, args) : string.Format(provider, format, args);
    }
  }
}


--- ISQLiteConnectionPool.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.ISQLiteConnectionPool
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;

#nullable disable
namespace System.Data.SQLite
{
  public interface ISQLiteConnectionPool
  {
    void GetCounts(
      string fileName,
      ref Dictionary<string, int> counts,
      ref int openCount,
      ref int closeCount,
      ref int totalCount);

    void ClearPool(string fileName);

    void ClearAllPools();

    void Add(string fileName, object handle, int version);

    object Remove(string fileName, int maxPoolSize, out int version);
  }
}


--- ISQLiteManagedModule.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.ISQLiteManagedModule
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public interface ISQLiteManagedModule
  {
    bool Declared { get; }

    string Name { get; }

    SQLiteErrorCode Create(
      SQLiteConnection connection,
      IntPtr pClientData,
      string[] arguments,
      ref SQLiteVirtualTable table,
      ref string error);

    SQLiteErrorCode Connect(
      SQLiteConnection connection,
      IntPtr pClientData,
      string[] arguments,
      ref SQLiteVirtualTable table,
      ref string error);

    SQLiteErrorCode BestIndex(SQLiteVirtualTable table, SQLiteIndex index);

    SQLiteErrorCode Disconnect(SQLiteVirtualTable table);

    SQLiteErrorCode Destroy(SQLiteVirtualTable table);

    SQLiteErrorCode Open(SQLiteVirtualTable table, ref SQLiteVirtualTableCursor cursor);

    SQLiteErrorCode Close(SQLiteVirtualTableCursor cursor);

    SQLiteErrorCode Filter(
      SQLiteVirtualTableCursor cursor,
      int indexNumber,
      string indexString,
      SQLiteValue[] values);

    SQLiteErrorCode Next(SQLiteVirtualTableCursor cursor);

    bool Eof(SQLiteVirtualTableCursor cursor);

    SQLiteErrorCode Column(SQLiteVirtualTableCursor cursor, SQLiteContext context, int index);

    SQLiteErrorCode RowId(SQLiteVirtualTableCursor cursor, ref long rowId);

    SQLiteErrorCode Update(SQLiteVirtualTable table, SQLiteValue[] values, ref long rowId);

    SQLiteErrorCode Begin(SQLiteVirtualTable table);

    SQLiteErrorCode Sync(SQLiteVirtualTable table);

    SQLiteErrorCode Commit(SQLiteVirtualTable table);

    SQLiteErrorCode Rollback(SQLiteVirtualTable table);

    bool FindFunction(
      SQLiteVirtualTable table,
      int argumentCount,
      string name,
      ref SQLiteFunction function,
      ref IntPtr pClientData);

    SQLiteErrorCode Rename(SQLiteVirtualTable table, string newName);

    SQLiteErrorCode Savepoint(SQLiteVirtualTable table, int savepoint);

    SQLiteErrorCode Release(SQLiteVirtualTable table, int savepoint);

    SQLiteErrorCode RollbackTo(SQLiteVirtualTable table, int savepoint);
  }
}


--- ISQLiteNativeHandle.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.ISQLiteNativeHandle
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public interface ISQLiteNativeHandle
  {
    IntPtr NativeHandle { get; }
  }
}


--- ISQLiteNativeModule.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.ISQLiteNativeModule
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public interface ISQLiteNativeModule
  {
    SQLiteErrorCode xCreate(
      IntPtr pDb,
      IntPtr pAux,
      int argc,
      IntPtr argv,
      ref IntPtr pVtab,
      ref IntPtr pError);

    SQLiteErrorCode xConnect(
      IntPtr pDb,
      IntPtr pAux,
      int argc,
      IntPtr argv,
      ref IntPtr pVtab,
      ref IntPtr pError);

    SQLiteErrorCode xBestIndex(IntPtr pVtab, IntPtr pIndex);

    SQLiteErrorCode xDisconnect(IntPtr pVtab);

    SQLiteErrorCode xDestroy(IntPtr pVtab);

    SQLiteErrorCode xOpen(IntPtr pVtab, ref IntPtr pCursor);

    SQLiteErrorCode xClose(IntPtr pCursor);

    SQLiteErrorCode xFilter(IntPtr pCursor, int idxNum, IntPtr idxStr, int argc, IntPtr argv);

    SQLiteErrorCode xNext(IntPtr pCursor);

    int xEof(IntPtr pCursor);

    SQLiteErrorCode xColumn(IntPtr pCursor, IntPtr pContext, int index);

    SQLiteErrorCode xRowId(IntPtr pCursor, ref long rowId);

    SQLiteErrorCode xUpdate(IntPtr pVtab, int argc, IntPtr argv, ref long rowId);

    SQLiteErrorCode xBegin(IntPtr pVtab);

    SQLiteErrorCode xSync(IntPtr pVtab);

    SQLiteErrorCode xCommit(IntPtr pVtab);

    SQLiteErrorCode xRollback(IntPtr pVtab);

    int xFindFunction(
      IntPtr pVtab,
      int nArg,
      IntPtr zName,
      ref SQLiteCallback callback,
      ref IntPtr pClientData);

    SQLiteErrorCode xRename(IntPtr pVtab, IntPtr zNew);

    SQLiteErrorCode xSavepoint(IntPtr pVtab, int iSavepoint);

    SQLiteErrorCode xRelease(IntPtr pVtab, int iSavepoint);

    SQLiteErrorCode xRollbackTo(IntPtr pVtab, int iSavepoint);
  }
}


--- ISQLiteSchemaExtensions.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.ISQLiteSchemaExtensions
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public interface ISQLiteSchemaExtensions
  {
    void BuildTempSchema(SQLiteConnection connection);
  }
}


--- LogEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.LogEventArgs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public class LogEventArgs : EventArgs
  {
    public readonly object ErrorCode;
    public readonly string Message;
    public readonly object Data;

    internal LogEventArgs(IntPtr pUserData, object errorCode, string message, object data)
    {
      this.ErrorCode = errorCode;
      this.Message = message;
      this.Data = data;
    }
  }
}


--- NativeLibraryHelper.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.NativeLibraryHelper
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  internal static class NativeLibraryHelper
  {
    private static IntPtr LoadLibraryWin32(string fileName)
    {
      return UnsafeNativeMethodsWin32.LoadLibrary(fileName);
    }

    private static IntPtr LoadLibraryPosix(string fileName)
    {
      return UnsafeNativeMethodsPosix.dlopen(fileName, 258);
    }

    public static IntPtr LoadLibrary(string fileName)
    {
      NativeLibraryHelper.LoadLibraryCallback loadLibraryCallback = new NativeLibraryHelper.LoadLibraryCallback(NativeLibraryHelper.LoadLibraryWin32);
      if (!HelperMethods.IsWindows())
        loadLibraryCallback = new NativeLibraryHelper.LoadLibraryCallback(NativeLibraryHelper.LoadLibraryPosix);
      return loadLibraryCallback(fileName);
    }

    private delegate IntPtr LoadLibraryCallback(string fileName);
  }
}


--- ProgressEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.ProgressEventArgs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public class ProgressEventArgs : EventArgs
  {
    public readonly IntPtr UserData;
    public SQLiteProgressReturnCode ReturnCode;

    private ProgressEventArgs()
    {
      this.UserData = IntPtr.Zero;
      this.ReturnCode = SQLiteProgressReturnCode.Continue;
    }

    internal ProgressEventArgs(IntPtr pUserData, SQLiteProgressReturnCode returnCode)
      : this()
    {
      this.UserData = pUserData;
      this.ReturnCode = returnCode;
    }
  }
}


--- SQLite3.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLite3
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;

#nullable disable
namespace System.Data.SQLite
{
  internal class SQLite3 : SQLiteBase
  {
    internal const string PublicKey = "002400000480000094000000060200000024000052534131000400000100010005a288de5687c4e1b621ddff5d844727418956997f475eb829429e411aff3e93f97b70de698b972640925bdd44280df0a25a843266973704137cbb0e7441c1fe7cae4e2440ae91ab8cde3933febcb1ac48dd33b40e13c421d8215c18a4349a436dd499e3c385cc683015f886f6c10bd90115eb2bd61b67750839e3a19941dc9c";
    internal const string DesignerVersion = "1.0.103.0";
    private static object syncRoot = new object();
    protected internal SQLiteConnectionHandle _sql;
    protected string _fileName;
    protected SQLiteConnectionFlags _flags;
    protected bool _usePool;
    protected int _poolVersion;
    private int _cancelCount;
    private bool _buildingSchema;
    protected Dictionary<SQLiteFunctionAttribute, SQLiteFunction> _functions;
    protected string _shimExtensionFileName;
    protected bool? _shimIsLoadNeeded = new bool?();
    protected string _shimExtensionProcName = "sqlite3_vtshim_init";
    protected Dictionary<string, SQLiteModule> _modules;
    private bool disposed;
    private static bool? have_errstr = new bool?();
    private static bool? have_stmt_readonly = new bool?();
    private static bool? forceLogPrepare = new bool?();

    internal SQLite3(
      SQLiteDateFormats fmt,
      DateTimeKind kind,
      string fmtString,
      IntPtr db,
      string fileName,
      bool ownHandle)
      : base(fmt, kind, fmtString)
    {
      if (!(db != IntPtr.Zero))
        return;
      this._sql = new SQLiteConnectionHandle(db, ownHandle);
      this._fileName = fileName;
      SQLiteConnection.OnChanged((SQLiteConnection) null, new ConnectionEventArgs(SQLiteConnectionEventType.NewCriticalHandle, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) this._sql, fileName, (object) new object[7]
      {
        (object) typeof (SQLite3),
        (object) fmt,
        (object) kind,
        (object) fmtString,
        (object) db,
        (object) fileName,
        (object) ownHandle
      }));
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLite3).Name);
    }

    protected override void Dispose(bool disposing)
    {
      try
      {
        if (this.disposed)
          return;
        this.DisposeModules();
        this.Close(false);
      }
      finally
      {
        base.Dispose(disposing);
        this.disposed = true;
      }
    }

    private void DisposeModules()
    {
      if (this._modules == null)
        return;
      foreach (KeyValuePair<string, SQLiteModule> module in this._modules)
        module.Value?.Dispose();
      this._modules.Clear();
    }

    internal override void Close(bool canThrow)
    {
      if (this._sql == null)
        return;
      if (!this._sql.OwnHandle)
      {
        this._sql = (SQLiteConnectionHandle) null;
      }
      else
      {
        bool flag = (this._flags & SQLiteConnectionFlags.UnbindFunctionsOnClose) == SQLiteConnectionFlags.UnbindFunctionsOnClose;
        if (this._usePool)
        {
          if (SQLiteBase.ResetConnection(this._sql, (IntPtr) this._sql, canThrow))
          {
            if (flag)
              SQLiteFunction.UnbindAllFunctions((SQLiteBase) this, this._flags, false);
            this.DisposeModules();
            SQLiteConnectionPool.Add(this._fileName, this._sql, this._poolVersion);
            SQLiteConnection.OnChanged((SQLiteConnection) null, new ConnectionEventArgs(SQLiteConnectionEventType.ClosedToPool, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) this._sql, this._fileName, (object) new object[4]
            {
              (object) typeof (SQLite3),
              (object) canThrow,
              (object) this._fileName,
              (object) this._poolVersion
            }));
          }
        }
        else
        {
          if (flag)
            SQLiteFunction.UnbindAllFunctions((SQLiteBase) this, this._flags, false);
          this._sql.Dispose();
        }
        this._sql = (SQLiteConnectionHandle) null;
      }
    }

    private int GetCancelCount() => Interlocked.CompareExchange(ref this._cancelCount, 0, 0);

    private bool ShouldThrowForCancel() => this.GetCancelCount() > 0;

    private int ResetCancelCount()
    {
      return Interlocked.CompareExchange(ref this._cancelCount, 0, this._cancelCount);
    }

    internal override void Cancel()
    {
      try
      {
      }
      finally
      {
        Interlocked.Increment(ref this._cancelCount);
        UnsafeNativeMethods.sqlite3_interrupt((IntPtr) this._sql);
      }
    }

    internal override void BindFunction(
      SQLiteFunctionAttribute functionAttribute,
      SQLiteFunction function,
      SQLiteConnectionFlags flags)
    {
      if (functionAttribute == null)
        throw new ArgumentNullException(nameof (functionAttribute));
      if (function == null)
        throw new ArgumentNullException(nameof (function));
      SQLiteFunction.BindFunction((SQLiteBase) this, functionAttribute, function, flags);
      if (this._functions == null)
        this._functions = new Dictionary<SQLiteFunctionAttribute, SQLiteFunction>();
      this._functions[functionAttribute] = function;
    }

    internal override bool UnbindFunction(
      SQLiteFunctionAttribute functionAttribute,
      SQLiteConnectionFlags flags)
    {
      if (functionAttribute == null)
        throw new ArgumentNullException(nameof (functionAttribute));
      SQLiteFunction function;
      return this._functions != null && this._functions.TryGetValue(functionAttribute, out function) && SQLiteFunction.UnbindFunction((SQLiteBase) this, functionAttribute, function, flags) && this._functions.Remove(functionAttribute);
    }

    internal override string Version => SQLite3.SQLiteVersion;

    internal override int VersionNumber => SQLite3.SQLiteVersionNumber;

    internal static string DefineConstants
    {
      get
      {
        StringBuilder stringBuilder = new StringBuilder();
        IList<string> optionList = SQLiteDefineConstants.OptionList;
        if (optionList != null)
        {
          foreach (string str in (IEnumerable<string>) optionList)
          {
            if (str != null)
            {
              if (stringBuilder.Length > 0)
                stringBuilder.Append(' ');
              stringBuilder.Append(str);
            }
          }
        }
        return stringBuilder.ToString();
      }
    }

    internal static string SQLiteVersion
    {
      get => SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_libversion(), -1);
    }

    internal static int SQLiteVersionNumber => UnsafeNativeMethods.sqlite3_libversion_number();

    internal static string SQLiteSourceId
    {
      get => SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_sourceid(), -1);
    }

    internal static string SQLiteCompileOptions
    {
      get
      {
        StringBuilder stringBuilder = new StringBuilder();
        int N = 0;
        int num = N + 1;
        for (IntPtr nativestring = UnsafeNativeMethods.sqlite3_compileoption_get(N); nativestring != IntPtr.Zero; nativestring = UnsafeNativeMethods.sqlite3_compileoption_get(num++))
        {
          if (stringBuilder.Length > 0)
            stringBuilder.Append(' ');
          stringBuilder.Append(SQLiteConvert.UTF8ToString(nativestring, -1));
        }
        return stringBuilder.ToString();
      }
    }

    internal static string InteropVersion
    {
      get => SQLiteConvert.UTF8ToString(UnsafeNativeMethods.interop_libversion(), -1);
    }

    internal static string InteropSourceId
    {
      get => SQLiteConvert.UTF8ToString(UnsafeNativeMethods.interop_sourceid(), -1);
    }

    internal static string InteropCompileOptions
    {
      get
      {
        StringBuilder stringBuilder = new StringBuilder();
        int N = 0;
        int num = N + 1;
        for (IntPtr nativestring = UnsafeNativeMethods.interop_compileoption_get(N); nativestring != IntPtr.Zero; nativestring = UnsafeNativeMethods.interop_compileoption_get(num++))
        {
          if (stringBuilder.Length > 0)
            stringBuilder.Append(' ');
          stringBuilder.Append(SQLiteConvert.UTF8ToString(nativestring, -1));
        }
        return stringBuilder.ToString();
      }
    }

    internal override bool AutoCommit => SQLiteBase.IsAutocommit(this._sql, (IntPtr) this._sql);

    internal override bool IsReadOnly(string name)
    {
      IntPtr num1 = IntPtr.Zero;
      try
      {
        if (name != null)
          num1 = SQLiteString.Utf8IntPtrFromString(name);
        int num2;
        switch (UnsafeNativeMethods.sqlite3_db_readonly((IntPtr) this._sql, num1))
        {
          case -1:
            throw new SQLiteException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "database \"{0}\" not found", (object) name));
          case 0:
            num2 = 0;
            break;
          default:
            num2 = 1;
            break;
        }
        return num2 != 0;
      }
      finally
      {
        if (num1 != IntPtr.Zero)
        {
          SQLiteMemory.Free(num1);
          IntPtr zero = IntPtr.Zero;
        }
      }
    }

    internal override long LastInsertRowId
    {
      get => UnsafeNativeMethods.sqlite3_last_insert_rowid((IntPtr) this._sql);
    }

    internal override int Changes
    {
      get => UnsafeNativeMethods.sqlite3_changes_interop((IntPtr) this._sql);
    }

    internal override long MemoryUsed => SQLite3.StaticMemoryUsed;

    internal static long StaticMemoryUsed => UnsafeNativeMethods.sqlite3_memory_used();

    internal override long MemoryHighwater => SQLite3.StaticMemoryHighwater;

    internal static long StaticMemoryHighwater => UnsafeNativeMethods.sqlite3_memory_highwater(0);

    internal override bool OwnHandle
    {
      get
      {
        return this._sql != null ? this._sql.OwnHandle : throw new SQLiteException("no connection handle available");
      }
    }

    internal override IDictionary<SQLiteFunctionAttribute, SQLiteFunction> Functions
    {
      get => (IDictionary<SQLiteFunctionAttribute, SQLiteFunction>) this._functions;
    }

    internal override SQLiteErrorCode SetMemoryStatus(bool value)
    {
      return SQLite3.StaticSetMemoryStatus(value);
    }

    internal static SQLiteErrorCode StaticSetMemoryStatus(bool value)
    {
      return UnsafeNativeMethods.sqlite3_config_int(SQLiteConfigOpsEnum.SQLITE_CONFIG_MEMSTATUS, value ? 1 : 0);
    }

    internal override SQLiteErrorCode ReleaseMemory()
    {
      return UnsafeNativeMethods.sqlite3_db_release_memory((IntPtr) this._sql);
    }

    internal static SQLiteErrorCode StaticReleaseMemory(
      int nBytes,
      bool reset,
      bool compact,
      ref int nFree,
      ref bool resetOk,
      ref uint nLargest)
    {
      SQLiteErrorCode sqLiteErrorCode = SQLiteErrorCode.Ok;
      int num = UnsafeNativeMethods.sqlite3_release_memory(nBytes);
      uint largest = 0;
      bool flag = false;
      if (HelperMethods.IsWindows())
      {
        if (sqLiteErrorCode == SQLiteErrorCode.Ok && reset)
        {
          sqLiteErrorCode = UnsafeNativeMethods.sqlite3_win32_reset_heap();
          if (sqLiteErrorCode == SQLiteErrorCode.Ok)
            flag = true;
        }
        if (sqLiteErrorCode == SQLiteErrorCode.Ok && compact)
          sqLiteErrorCode = UnsafeNativeMethods.sqlite3_win32_compact_heap(ref largest);
      }
      else if (reset || compact)
        sqLiteErrorCode = SQLiteErrorCode.NotFound;
      nFree = num;
      nLargest = largest;
      resetOk = flag;
      return sqLiteErrorCode;
    }

    internal override SQLiteErrorCode Shutdown() => SQLite3.StaticShutdown(false);

    internal static SQLiteErrorCode StaticShutdown(bool directories)
    {
      SQLiteErrorCode sqLiteErrorCode = SQLiteErrorCode.Ok;
      if (directories && HelperMethods.IsWindows())
      {
        if (sqLiteErrorCode == SQLiteErrorCode.Ok)
          sqLiteErrorCode = UnsafeNativeMethods.sqlite3_win32_set_directory(1U, (string) null);
        if (sqLiteErrorCode == SQLiteErrorCode.Ok)
          sqLiteErrorCode = UnsafeNativeMethods.sqlite3_win32_set_directory(2U, (string) null);
      }
      if (sqLiteErrorCode == SQLiteErrorCode.Ok)
        sqLiteErrorCode = UnsafeNativeMethods.sqlite3_shutdown();
      return sqLiteErrorCode;
    }

    internal override bool IsOpen()
    {
      return this._sql != null && !this._sql.IsInvalid && !this._sql.IsClosed;
    }

    internal override string GetFileName(string dbName)
    {
      return this._sql == null ? (string) null : SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_db_filename_bytes((IntPtr) this._sql, SQLiteConvert.ToUTF8(dbName)), -1);
    }

    internal override void Open(
      string strFilename,
      string vfsName,
      SQLiteConnectionFlags connectionFlags,
      SQLiteOpenFlagsEnum openFlags,
      int maxPoolSize,
      bool usePool)
    {
      if (this._sql != null)
        this.Close(true);
      if (this._sql != null)
        throw new SQLiteException("connection handle is still active");
      this._usePool = usePool;
      this._fileName = strFilename;
      this._flags = connectionFlags;
      if (usePool)
      {
        this._sql = SQLiteConnectionPool.Remove(strFilename, maxPoolSize, out this._poolVersion);
        SQLiteConnection.OnChanged((SQLiteConnection) null, new ConnectionEventArgs(SQLiteConnectionEventType.OpenedFromPool, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) this._sql, strFilename, (object) new object[8]
        {
          (object) typeof (SQLite3),
          (object) strFilename,
          (object) vfsName,
          (object) connectionFlags,
          (object) openFlags,
          (object) maxPoolSize,
          (object) usePool,
          (object) this._poolVersion
        }));
      }
      if (this._sql == null)
      {
        try
        {
        }
        finally
        {
          IntPtr zero = IntPtr.Zero;
          int extFuncs = (connectionFlags & SQLiteConnectionFlags.NoExtensionFunctions) != SQLiteConnectionFlags.NoExtensionFunctions ? 1 : 0;
          SQLiteErrorCode errorCode = extFuncs == 0 ? UnsafeNativeMethods.sqlite3_open_v2(SQLiteConvert.ToUTF8(strFilename), ref zero, openFlags, SQLiteConvert.ToUTF8(vfsName)) : UnsafeNativeMethods.sqlite3_open_interop(SQLiteConvert.ToUTF8(strFilename), SQLiteConvert.ToUTF8(vfsName), openFlags, extFuncs, ref zero);
          if (errorCode != SQLiteErrorCode.Ok)
            throw new SQLiteException(errorCode, (string) null);
          this._sql = new SQLiteConnectionHandle(zero, true);
        }
        lock (this._sql)
          ;
        SQLiteConnection.OnChanged((SQLiteConnection) null, new ConnectionEventArgs(SQLiteConnectionEventType.NewCriticalHandle, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) this._sql, strFilename, (object) new object[7]
        {
          (object) typeof (SQLite3),
          (object) strFilename,
          (object) vfsName,
          (object) connectionFlags,
          (object) openFlags,
          (object) maxPoolSize,
          (object) usePool
        }));
      }
      if ((connectionFlags & SQLiteConnectionFlags.NoBindFunctions) != SQLiteConnectionFlags.NoBindFunctions)
      {
        if (this._functions == null)
          this._functions = new Dictionary<SQLiteFunctionAttribute, SQLiteFunction>();
        foreach (KeyValuePair<SQLiteFunctionAttribute, SQLiteFunction> bindFunction in (IEnumerable<KeyValuePair<SQLiteFunctionAttribute, SQLiteFunction>>) SQLiteFunction.BindFunctions((SQLiteBase) this, connectionFlags))
          this._functions[bindFunction.Key] = bindFunction.Value;
      }
      this.SetTimeout(0);
      GC.KeepAlive((object) this._sql);
    }

    internal override void ClearPool() => SQLiteConnectionPool.ClearPool(this._fileName);

    internal override int CountPool()
    {
      Dictionary<string, int> counts = (Dictionary<string, int>) null;
      int openCount = 0;
      int closeCount = 0;
      int totalCount = 0;
      SQLiteConnectionPool.GetCounts(this._fileName, ref counts, ref openCount, ref closeCount, ref totalCount);
      return totalCount;
    }

    internal override void SetTimeout(int nTimeoutMS)
    {
      IntPtr sql = (IntPtr) this._sql;
      SQLiteErrorCode errorCode = !(sql == IntPtr.Zero) ? UnsafeNativeMethods.sqlite3_busy_timeout(sql, nTimeoutMS) : throw new SQLiteException("no connection handle available");
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override bool Step(SQLiteStatement stmt)
    {
      Random random = (Random) null;
      uint tickCount = (uint) Environment.TickCount;
      uint num = (uint) (stmt._command._commandTimeout * 1000);
      this.ResetCancelCount();
      SQLiteErrorCode errorCode1;
      while (true)
      {
        do
        {
          SQLiteErrorCode errorCode2;
          try
          {
          }
          finally
          {
            errorCode2 = UnsafeNativeMethods.sqlite3_step((IntPtr) stmt._sqlite_stmt);
          }
          if (this.ShouldThrowForCancel())
          {
            errorCode2 = errorCode2 == SQLiteErrorCode.Ok || errorCode2 == SQLiteErrorCode.Row || errorCode2 == SQLiteErrorCode.Done ? SQLiteErrorCode.Interrupt : throw new SQLiteException(errorCode2, (string) null);
          }
          else
          {
            switch (errorCode2)
            {
              case SQLiteErrorCode.Ok:
                continue;
              case SQLiteErrorCode.Interrupt:
                return false;
              case SQLiteErrorCode.Row:
                return true;
              case SQLiteErrorCode.Done:
                return false;
              default:
                errorCode1 = this.Reset(stmt);
                switch (errorCode1)
                {
                  case SQLiteErrorCode.Ok:
                    throw new SQLiteException(errorCode2, this.GetLastError());
                  case SQLiteErrorCode.Busy:
                  case SQLiteErrorCode.Locked:
                    continue;
                  default:
                    continue;
                }
            }
          }
        }
        while (stmt._command == null);
        if (random == null)
          random = new Random();
        if ((uint) Environment.TickCount - tickCount <= num)
          Thread.Sleep(random.Next(1, 150));
        else
          break;
      }
      throw new SQLiteException(errorCode1, this.GetLastError());
    }

    internal static string GetErrorString(SQLiteErrorCode rc)
    {
      try
      {
        if (!SQLite3.have_errstr.HasValue)
          SQLite3.have_errstr = new bool?(SQLite3.SQLiteVersionNumber >= 3007015);
        if (SQLite3.have_errstr.Value)
        {
          IntPtr ptr = UnsafeNativeMethods.sqlite3_errstr(rc);
          if (ptr != IntPtr.Zero)
            return Marshal.PtrToStringAnsi(ptr);
        }
      }
      catch (EntryPointNotFoundException ex)
      {
      }
      return SQLiteBase.FallbackGetErrorString(rc);
    }

    internal override bool IsReadOnly(SQLiteStatement stmt)
    {
      try
      {
        if (!SQLite3.have_stmt_readonly.HasValue)
          SQLite3.have_stmt_readonly = new bool?(SQLite3.SQLiteVersionNumber >= 3007004);
        if (SQLite3.have_stmt_readonly.Value)
          return UnsafeNativeMethods.sqlite3_stmt_readonly((IntPtr) stmt._sqlite_stmt) != 0;
      }
      catch (EntryPointNotFoundException ex)
      {
      }
      return false;
    }

    internal override SQLiteErrorCode Reset(SQLiteStatement stmt)
    {
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_reset_interop((IntPtr) stmt._sqlite_stmt);
      switch (errorCode)
      {
        case SQLiteErrorCode.Ok:
          return errorCode;
        case SQLiteErrorCode.Busy:
        case SQLiteErrorCode.Locked:
          return errorCode;
        case SQLiteErrorCode.Schema:
          string strRemain = (string) null;
          using (SQLiteStatement sqLiteStatement = this.Prepare((SQLiteConnection) null, stmt._sqlStatement, (SQLiteStatement) null, (uint) (stmt._command._commandTimeout * 1000), ref strRemain))
          {
            stmt._sqlite_stmt.Dispose();
            if (sqLiteStatement != null)
            {
              stmt._sqlite_stmt = sqLiteStatement._sqlite_stmt;
              sqLiteStatement._sqlite_stmt = (SQLiteStatementHandle) null;
            }
            stmt.BindParameters();
          }
          return SQLiteErrorCode.Unknown;
        default:
          throw new SQLiteException(errorCode, this.GetLastError());
      }
    }

    internal override string GetLastError() => this.GetLastError((string) null);

    internal override string GetLastError(string defValue)
    {
      string lastError = SQLiteBase.GetLastError(this._sql, (IntPtr) this._sql);
      if (string.IsNullOrEmpty(lastError))
        lastError = defValue;
      return lastError;
    }

    private static bool ForceLogPrepare()
    {
      lock (SQLite3.syncRoot)
      {
        if (!SQLite3.forceLogPrepare.HasValue)
          SQLite3.forceLogPrepare = UnsafeNativeMethods.GetSettingValue("SQLite_ForceLogPrepare", (string) null) == null ? new bool?(false) : new bool?(true);
        return SQLite3.forceLogPrepare.Value;
      }
    }

    internal override SQLiteStatement Prepare(
      SQLiteConnection cnn,
      string strSql,
      SQLiteStatement previous,
      uint timeoutMS,
      ref string strRemain)
    {
      if (!string.IsNullOrEmpty(strSql))
        strSql = strSql.Trim();
      if (!string.IsNullOrEmpty(strSql))
      {
        string baseSchemaName = cnn?._baseSchemaName;
        if (!string.IsNullOrEmpty(baseSchemaName))
        {
          strSql = strSql.Replace(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "[{0}].", (object) baseSchemaName), string.Empty);
          strSql = strSql.Replace(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "{0}.", (object) baseSchemaName), string.Empty);
        }
      }
      SQLiteConnectionFlags flags = cnn != null ? cnn.Flags : SQLiteConnectionFlags.Default;
      if (SQLite3.ForceLogPrepare() || (flags & SQLiteConnectionFlags.LogPrepare) == SQLiteConnectionFlags.LogPrepare)
      {
        if (strSql == null || strSql.Length == 0 || strSql.Trim().Length == 0)
          SQLiteLog.LogMessage("Preparing {<nothing>}...");
        else
          SQLiteLog.LogMessage(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Preparing {{{0}}}...", (object) strSql));
      }
      IntPtr zero1 = IntPtr.Zero;
      IntPtr zero2 = IntPtr.Zero;
      int nRemain = 0;
      SQLiteErrorCode errorCode = SQLiteErrorCode.Schema;
      int num1 = 0;
      int num2 = cnn != null ? cnn._prepareRetries : 3;
      byte[] utF8 = SQLiteConvert.ToUTF8(strSql);
      SQLiteStatement sqLiteStatement = (SQLiteStatement) null;
      Random random = (Random) null;
      uint tickCount = (uint) Environment.TickCount;
      this.ResetCancelCount();
      GCHandle gcHandle = GCHandle.Alloc((object) utF8, GCHandleType.Pinned);
      IntPtr pSql = gcHandle.AddrOfPinnedObject();
      SQLiteStatementHandle stmt = (SQLiteStatementHandle) null;
      try
      {
        while (errorCode == SQLiteErrorCode.Schema || errorCode == SQLiteErrorCode.Locked || errorCode == SQLiteErrorCode.Busy)
        {
          if (num1 < num2)
          {
            try
            {
            }
            finally
            {
              IntPtr zero3 = IntPtr.Zero;
              zero2 = IntPtr.Zero;
              nRemain = 0;
              errorCode = UnsafeNativeMethods.sqlite3_prepare_interop((IntPtr) this._sql, pSql, utF8.Length - 1, ref zero3, ref zero2, ref nRemain);
              if (errorCode == SQLiteErrorCode.Ok && zero3 != IntPtr.Zero)
              {
                stmt?.Dispose();
                stmt = new SQLiteStatementHandle(this._sql, zero3);
              }
            }
            if (stmt != null)
              SQLiteConnection.OnChanged((SQLiteConnection) null, new ConnectionEventArgs(SQLiteConnectionEventType.NewCriticalHandle, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) stmt, strSql, (object) new object[5]
              {
                (object) typeof (SQLite3),
                (object) cnn,
                (object) strSql,
                (object) previous,
                (object) timeoutMS
              }));
            if (this.ShouldThrowForCancel())
            {
              errorCode = errorCode == SQLiteErrorCode.Ok || errorCode == SQLiteErrorCode.Row || errorCode == SQLiteErrorCode.Done ? SQLiteErrorCode.Interrupt : throw new SQLiteException(errorCode, (string) null);
            }
            else
            {
              switch (errorCode)
              {
                case SQLiteErrorCode.Error:
                  if (string.Compare(this.GetLastError(), "near \"TYPES\": syntax error", StringComparison.OrdinalIgnoreCase) == 0)
                  {
                    int num3 = strSql.IndexOf(';');
                    if (num3 == -1)
                      num3 = strSql.Length - 1;
                    string typedefs = strSql.Substring(0, num3 + 1);
                    strSql = strSql.Substring(num3 + 1);
                    strRemain = string.Empty;
                    for (; sqLiteStatement == null && strSql.Length > 0; strSql = strRemain)
                      sqLiteStatement = this.Prepare(cnn, strSql, previous, timeoutMS, ref strRemain);
                    sqLiteStatement?.SetTypes(typedefs);
                    return sqLiteStatement;
                  }
                  if (!this._buildingSchema && string.Compare(this.GetLastError(), 0, "no such table: TEMP.SCHEMA", 0, 26, StringComparison.OrdinalIgnoreCase) == 0)
                  {
                    strRemain = string.Empty;
                    this._buildingSchema = true;
                    try
                    {
                      if (((IServiceProvider) SQLiteFactory.Instance).GetService(typeof (ISQLiteSchemaExtensions)) is ISQLiteSchemaExtensions service)
                        service.BuildTempSchema(cnn);
                      for (; sqLiteStatement == null && strSql.Length > 0; strSql = strRemain)
                        sqLiteStatement = this.Prepare(cnn, strSql, previous, timeoutMS, ref strRemain);
                      return sqLiteStatement;
                    }
                    finally
                    {
                      this._buildingSchema = false;
                    }
                  }
                  else
                    continue;
                case SQLiteErrorCode.Interrupt:
                  goto label_50;
                case SQLiteErrorCode.Schema:
                  ++num1;
                  continue;
                default:
                  if (errorCode == SQLiteErrorCode.Locked || errorCode == SQLiteErrorCode.Busy)
                  {
                    if (random == null)
                      random = new Random();
                    if ((uint) Environment.TickCount - tickCount > timeoutMS)
                      throw new SQLiteException(errorCode, this.GetLastError());
                    Thread.Sleep(random.Next(1, 150));
                    continue;
                  }
                  continue;
              }
            }
          }
          else
            break;
        }
label_50:
        if (this.ShouldThrowForCancel())
        {
          errorCode = errorCode == SQLiteErrorCode.Ok || errorCode == SQLiteErrorCode.Row || errorCode == SQLiteErrorCode.Done ? SQLiteErrorCode.Interrupt : throw new SQLiteException(errorCode, (string) null);
        }
        else
        {
          if (errorCode == SQLiteErrorCode.Interrupt)
            return (SQLiteStatement) null;
          if (errorCode != SQLiteErrorCode.Ok)
            throw new SQLiteException(errorCode, this.GetLastError());
          strRemain = SQLiteConvert.UTF8ToString(zero2, nRemain);
          if (stmt != null)
            sqLiteStatement = new SQLiteStatement((SQLiteBase) this, flags, stmt, strSql.Substring(0, strSql.Length - strRemain.Length), previous);
          return sqLiteStatement;
        }
      }
      finally
      {
        gcHandle.Free();
      }
    }

    protected static void LogBind(SQLiteStatementHandle handle, int index)
    {
      SQLiteLog.LogMessage(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Binding statement {0} paramter #{1} as NULL...", (object) (IntPtr) handle, (object) index));
    }

    protected static void LogBind(SQLiteStatementHandle handle, int index, System.ValueType value)
    {
      SQLiteLog.LogMessage(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Binding statement {0} paramter #{1} as type {2} with value {{{3}}}...", (object) (IntPtr) handle, (object) index, (object) value.GetType(), (object) value));
    }

    private static string FormatDateTime(DateTime value)
    {
      StringBuilder stringBuilder = new StringBuilder();
      stringBuilder.Append(value.ToString("yyyy-MM-ddTHH:mm:ss.FFFFFFFK"));
      stringBuilder.Append(' ');
      stringBuilder.Append((object) value.Kind);
      stringBuilder.Append(' ');
      stringBuilder.Append(value.Ticks);
      return stringBuilder.ToString();
    }

    protected static void LogBind(SQLiteStatementHandle handle, int index, DateTime value)
    {
      SQLiteLog.LogMessage(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Binding statement {0} paramter #{1} as type {2} with value {{{3}}}...", (object) (IntPtr) handle, (object) index, (object) typeof (DateTime), (object) SQLite3.FormatDateTime(value)));
    }

    protected static void LogBind(SQLiteStatementHandle handle, int index, string value)
    {
      SQLiteLog.LogMessage(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Binding statement {0} paramter #{1} as type {2} with value {{{3}}}...", (object) (IntPtr) handle, (object) index, (object) typeof (string), value != null ? (object) value : (object) "<null>"));
    }

    private static string ToHexadecimalString(byte[] array)
    {
      if (array == null)
        return (string) null;
      StringBuilder stringBuilder = new StringBuilder(array.Length * 2);
      int length = array.Length;
      for (int index = 0; index < length; ++index)
        stringBuilder.Append(array[index].ToString("x2"));
      return stringBuilder.ToString();
    }

    protected static void LogBind(SQLiteStatementHandle handle, int index, byte[] value)
    {
      SQLiteLog.LogMessage(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Binding statement {0} paramter #{1} as type {2} with value {{{3}}}...", (object) (IntPtr) handle, (object) index, (object) typeof (byte[]), value != null ? (object) SQLite3.ToHexadecimalString(value) : (object) "<null>"));
    }

    internal override void Bind_Double(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      double value)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLite3.LogBind(sqliteStmt, index, (System.ValueType) value);
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_bind_double((IntPtr) sqliteStmt, index, value);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override void Bind_Int32(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      int value)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLite3.LogBind(sqliteStmt, index, (System.ValueType) value);
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_bind_int((IntPtr) sqliteStmt, index, value);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override void Bind_UInt32(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      uint value)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLite3.LogBind(sqliteStmt, index, (System.ValueType) value);
      SQLiteErrorCode errorCode;
      if ((flags & SQLiteConnectionFlags.BindUInt32AsInt64) == SQLiteConnectionFlags.BindUInt32AsInt64)
      {
        long num = (long) value;
        errorCode = UnsafeNativeMethods.sqlite3_bind_int64((IntPtr) sqliteStmt, index, num);
      }
      else
        errorCode = UnsafeNativeMethods.sqlite3_bind_uint((IntPtr) sqliteStmt, index, value);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override void Bind_Int64(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      long value)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLite3.LogBind(sqliteStmt, index, (System.ValueType) value);
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_bind_int64((IntPtr) sqliteStmt, index, value);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override void Bind_UInt64(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      ulong value)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLite3.LogBind(sqliteStmt, index, (System.ValueType) value);
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_bind_uint64((IntPtr) sqliteStmt, index, value);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override void Bind_Boolean(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      bool value)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLite3.LogBind(sqliteStmt, index, (System.ValueType) value);
      int num = value ? 1 : 0;
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_bind_int((IntPtr) sqliteStmt, index, num);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override void Bind_Text(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      string value)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLite3.LogBind(sqliteStmt, index, value);
      byte[] utF8 = SQLiteConvert.ToUTF8(value);
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLite3.LogBind(sqliteStmt, index, utF8);
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_bind_text((IntPtr) sqliteStmt, index, utF8, utF8.Length - 1, (IntPtr) -1);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override void Bind_DateTime(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      DateTime dt)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLite3.LogBind(sqliteStmt, index, dt);
      if ((flags & SQLiteConnectionFlags.BindDateTimeWithKind) == SQLiteConnectionFlags.BindDateTimeWithKind && this._datetimeKind != DateTimeKind.Unspecified && dt.Kind != DateTimeKind.Unspecified && dt.Kind != this._datetimeKind)
      {
        if (this._datetimeKind == DateTimeKind.Utc)
          dt = dt.ToUniversalTime();
        else if (this._datetimeKind == DateTimeKind.Local)
          dt = dt.ToLocalTime();
      }
      switch (this._datetimeFormat)
      {
        case SQLiteDateFormats.Ticks:
          long ticks = dt.Ticks;
          if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
            SQLite3.LogBind(sqliteStmt, index, (System.ValueType) ticks);
          SQLiteErrorCode errorCode1 = UnsafeNativeMethods.sqlite3_bind_int64((IntPtr) sqliteStmt, index, ticks);
          if (errorCode1 == SQLiteErrorCode.Ok)
            break;
          throw new SQLiteException(errorCode1, this.GetLastError());
        case SQLiteDateFormats.JulianDay:
          double julianDay = SQLiteConvert.ToJulianDay(dt);
          if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
            SQLite3.LogBind(sqliteStmt, index, (System.ValueType) julianDay);
          SQLiteErrorCode errorCode2 = UnsafeNativeMethods.sqlite3_bind_double((IntPtr) sqliteStmt, index, julianDay);
          if (errorCode2 == SQLiteErrorCode.Ok)
            break;
          throw new SQLiteException(errorCode2, this.GetLastError());
        case SQLiteDateFormats.UnixEpoch:
          long int64 = Convert.ToInt64(dt.Subtract(SQLiteConvert.UnixEpoch).TotalSeconds);
          if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
            SQLite3.LogBind(sqliteStmt, index, (System.ValueType) int64);
          SQLiteErrorCode errorCode3 = UnsafeNativeMethods.sqlite3_bind_int64((IntPtr) sqliteStmt, index, int64);
          if (errorCode3 == SQLiteErrorCode.Ok)
            break;
          throw new SQLiteException(errorCode3, this.GetLastError());
        default:
          byte[] utF8 = this.ToUTF8(dt);
          if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
            SQLite3.LogBind(sqliteStmt, index, utF8);
          SQLiteErrorCode errorCode4 = UnsafeNativeMethods.sqlite3_bind_text((IntPtr) sqliteStmt, index, utF8, utF8.Length - 1, (IntPtr) -1);
          if (errorCode4 == SQLiteErrorCode.Ok)
            break;
          throw new SQLiteException(errorCode4, this.GetLastError());
      }
    }

    internal override void Bind_Blob(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      byte[] blobData)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLite3.LogBind(sqliteStmt, index, blobData);
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_bind_blob((IntPtr) sqliteStmt, index, blobData, blobData.Length, (IntPtr) -1);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override void Bind_Null(SQLiteStatement stmt, SQLiteConnectionFlags flags, int index)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLite3.LogBind(sqliteStmt, index);
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_bind_null((IntPtr) sqliteStmt, index);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override int Bind_ParamCount(SQLiteStatement stmt, SQLiteConnectionFlags flags)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      int num = UnsafeNativeMethods.sqlite3_bind_parameter_count((IntPtr) sqliteStmt);
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLiteLog.LogMessage(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Statement {0} paramter count is {1}.", (object) (IntPtr) sqliteStmt, (object) num));
      return num;
    }

    internal override string Bind_ParamName(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      int len = 0;
      string str = SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_bind_parameter_name_interop((IntPtr) sqliteStmt, index, ref len), len);
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLiteLog.LogMessage(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Statement {0} paramter #{1} name is {{{2}}}.", (object) (IntPtr) sqliteStmt, (object) index, (object) str));
      return str;
    }

    internal override int Bind_ParamIndex(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      string paramName)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      int num = UnsafeNativeMethods.sqlite3_bind_parameter_index((IntPtr) sqliteStmt, SQLiteConvert.ToUTF8(paramName));
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLiteLog.LogMessage(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Statement {0} paramter index of name {{{1}}} is #{2}.", (object) (IntPtr) sqliteStmt, (object) paramName, (object) num));
      return num;
    }

    internal override int ColumnCount(SQLiteStatement stmt)
    {
      return UnsafeNativeMethods.sqlite3_column_count((IntPtr) stmt._sqlite_stmt);
    }

    internal override string ColumnName(SQLiteStatement stmt, int index)
    {
      int len = 0;
      IntPtr nativestring = UnsafeNativeMethods.sqlite3_column_name_interop((IntPtr) stmt._sqlite_stmt, index, ref len);
      return !(nativestring == IntPtr.Zero) ? SQLiteConvert.UTF8ToString(nativestring, len) : throw new SQLiteException(SQLiteErrorCode.NoMem, this.GetLastError());
    }

    internal override TypeAffinity ColumnAffinity(SQLiteStatement stmt, int index)
    {
      return UnsafeNativeMethods.sqlite3_column_type((IntPtr) stmt._sqlite_stmt, index);
    }

    internal override string ColumnType(
      SQLiteStatement stmt,
      int index,
      ref TypeAffinity nAffinity)
    {
      int len = 0;
      IntPtr nativestring = UnsafeNativeMethods.sqlite3_column_decltype_interop((IntPtr) stmt._sqlite_stmt, index, ref len);
      nAffinity = this.ColumnAffinity(stmt, index);
      if (nativestring != IntPtr.Zero && (len > 0 || len == -1))
      {
        string str = SQLiteConvert.UTF8ToString(nativestring, len);
        if (!string.IsNullOrEmpty(str))
          return str;
      }
      string[] typeDefinitions = stmt.TypeDefinitions;
      return typeDefinitions != null && index < typeDefinitions.Length && typeDefinitions[index] != null ? typeDefinitions[index] : string.Empty;
    }

    internal override int ColumnIndex(SQLiteStatement stmt, string columnName)
    {
      int num = this.ColumnCount(stmt);
      for (int index = 0; index < num; ++index)
      {
        if (string.Compare(columnName, this.ColumnName(stmt, index), StringComparison.OrdinalIgnoreCase) == 0)
          return index;
      }
      return -1;
    }

    internal override string ColumnOriginalName(SQLiteStatement stmt, int index)
    {
      int len = 0;
      return SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_column_origin_name_interop((IntPtr) stmt._sqlite_stmt, index, ref len), len);
    }

    internal override string ColumnDatabaseName(SQLiteStatement stmt, int index)
    {
      int len = 0;
      return SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_column_database_name_interop((IntPtr) stmt._sqlite_stmt, index, ref len), len);
    }

    internal override string ColumnTableName(SQLiteStatement stmt, int index)
    {
      int len = 0;
      return SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_column_table_name_interop((IntPtr) stmt._sqlite_stmt, index, ref len), len);
    }

    internal override void ColumnMetaData(
      string dataBase,
      string table,
      string column,
      ref string dataType,
      ref string collateSequence,
      ref bool notNull,
      ref bool primaryKey,
      ref bool autoIncrement)
    {
      IntPtr zero1 = IntPtr.Zero;
      IntPtr zero2 = IntPtr.Zero;
      int notNull1 = 0;
      int primaryKey1 = 0;
      int autoInc = 0;
      int dtLen = 0;
      int csLen = 0;
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_table_column_metadata_interop((IntPtr) this._sql, SQLiteConvert.ToUTF8(dataBase), SQLiteConvert.ToUTF8(table), SQLiteConvert.ToUTF8(column), ref zero1, ref zero2, ref notNull1, ref primaryKey1, ref autoInc, ref dtLen, ref csLen);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
      dataType = SQLiteConvert.UTF8ToString(zero1, dtLen);
      collateSequence = SQLiteConvert.UTF8ToString(zero2, csLen);
      notNull = notNull1 == 1;
      primaryKey = primaryKey1 == 1;
      autoIncrement = autoInc == 1;
    }

    internal override object GetObject(SQLiteStatement stmt, int index)
    {
      switch (this.ColumnAffinity(stmt, index))
      {
        case TypeAffinity.Int64:
          return (object) this.GetInt64(stmt, index);
        case TypeAffinity.Double:
          return (object) this.GetDouble(stmt, index);
        case TypeAffinity.Text:
          return (object) this.GetText(stmt, index);
        case TypeAffinity.Blob:
          long bytes = this.GetBytes(stmt, index, 0, (byte[]) null, 0, 0);
          if (bytes > 0L && bytes <= (long) int.MaxValue)
          {
            byte[] bDest = new byte[(int) bytes];
            this.GetBytes(stmt, index, 0, bDest, 0, (int) bytes);
            return (object) bDest;
          }
          break;
        case TypeAffinity.Null:
          return (object) DBNull.Value;
      }
      throw new NotImplementedException();
    }

    internal override double GetDouble(SQLiteStatement stmt, int index)
    {
      return UnsafeNativeMethods.sqlite3_column_double((IntPtr) stmt._sqlite_stmt, index);
    }

    internal override bool GetBoolean(SQLiteStatement stmt, int index)
    {
      return SQLiteConvert.ToBoolean(this.GetObject(stmt, index), (IFormatProvider) CultureInfo.InvariantCulture, false);
    }

    internal override sbyte GetSByte(SQLiteStatement stmt, int index)
    {
      return (sbyte) (this.GetInt32(stmt, index) & (int) byte.MaxValue);
    }

    internal override byte GetByte(SQLiteStatement stmt, int index)
    {
      return (byte) (this.GetInt32(stmt, index) & (int) byte.MaxValue);
    }

    internal override short GetInt16(SQLiteStatement stmt, int index)
    {
      return (short) (this.GetInt32(stmt, index) & (int) ushort.MaxValue);
    }

    internal override ushort GetUInt16(SQLiteStatement stmt, int index)
    {
      return (ushort) (this.GetInt32(stmt, index) & (int) ushort.MaxValue);
    }

    internal override int GetInt32(SQLiteStatement stmt, int index)
    {
      return UnsafeNativeMethods.sqlite3_column_int((IntPtr) stmt._sqlite_stmt, index);
    }

    internal override uint GetUInt32(SQLiteStatement stmt, int index)
    {
      return (uint) this.GetInt32(stmt, index);
    }

    internal override long GetInt64(SQLiteStatement stmt, int index)
    {
      return UnsafeNativeMethods.sqlite3_column_int64((IntPtr) stmt._sqlite_stmt, index);
    }

    internal override ulong GetUInt64(SQLiteStatement stmt, int index)
    {
      return (ulong) this.GetInt64(stmt, index);
    }

    internal override string GetText(SQLiteStatement stmt, int index)
    {
      int len = 0;
      return SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_column_text_interop((IntPtr) stmt._sqlite_stmt, index, ref len), len);
    }

    internal override DateTime GetDateTime(SQLiteStatement stmt, int index)
    {
      if (this._datetimeFormat == SQLiteDateFormats.Ticks)
        return SQLiteConvert.TicksToDateTime(this.GetInt64(stmt, index), this._datetimeKind);
      if (this._datetimeFormat == SQLiteDateFormats.JulianDay)
        return SQLiteConvert.ToDateTime(this.GetDouble(stmt, index), this._datetimeKind);
      if (this._datetimeFormat == SQLiteDateFormats.UnixEpoch)
        return SQLiteConvert.UnixEpochToDateTime(this.GetInt64(stmt, index), this._datetimeKind);
      int len = 0;
      return this.ToDateTime(UnsafeNativeMethods.sqlite3_column_text_interop((IntPtr) stmt._sqlite_stmt, index, ref len), len);
    }

    internal override long GetBytes(
      SQLiteStatement stmt,
      int index,
      int nDataOffset,
      byte[] bDest,
      int nStart,
      int nLength)
    {
      int bytes = UnsafeNativeMethods.sqlite3_column_bytes((IntPtr) stmt._sqlite_stmt, index);
      if (bDest == null)
        return (long) bytes;
      int length = nLength;
      if (length + nStart > bDest.Length)
        length = bDest.Length - nStart;
      if (length + nDataOffset > bytes)
        length = bytes - nDataOffset;
      if (length > 0)
        Marshal.Copy((IntPtr) (UnsafeNativeMethods.sqlite3_column_blob((IntPtr) stmt._sqlite_stmt, index).ToInt64() + (long) nDataOffset), bDest, nStart, length);
      else
        length = 0;
      return (long) length;
    }

    internal override long GetChars(
      SQLiteStatement stmt,
      int index,
      int nDataOffset,
      char[] bDest,
      int nStart,
      int nLength)
    {
      int count = nLength;
      string text = this.GetText(stmt, index);
      int length = text.Length;
      if (bDest == null)
        return (long) length;
      if (count + nStart > bDest.Length)
        count = bDest.Length - nStart;
      if (count + nDataOffset > length)
        count = length - nDataOffset;
      if (count > 0)
        text.CopyTo(nDataOffset, bDest, nStart, count);
      else
        count = 0;
      return (long) count;
    }

    internal override bool IsNull(SQLiteStatement stmt, int index)
    {
      return this.ColumnAffinity(stmt, index) == TypeAffinity.Null;
    }

    internal override int AggregateCount(IntPtr context)
    {
      return UnsafeNativeMethods.sqlite3_aggregate_count(context);
    }

    internal override SQLiteErrorCode CreateFunction(
      string strFunction,
      int nArgs,
      bool needCollSeq,
      SQLiteCallback func,
      SQLiteCallback funcstep,
      SQLiteFinalCallback funcfinal,
      bool canThrow)
    {
      SQLiteErrorCode functionInterop = UnsafeNativeMethods.sqlite3_create_function_interop((IntPtr) this._sql, SQLiteConvert.ToUTF8(strFunction), nArgs, 4, IntPtr.Zero, func, funcstep, funcfinal, needCollSeq ? 1 : 0);
      if (functionInterop == SQLiteErrorCode.Ok)
        functionInterop = UnsafeNativeMethods.sqlite3_create_function_interop((IntPtr) this._sql, SQLiteConvert.ToUTF8(strFunction), nArgs, 1, IntPtr.Zero, func, funcstep, funcfinal, needCollSeq ? 1 : 0);
      return !canThrow || functionInterop == SQLiteErrorCode.Ok ? functionInterop : throw new SQLiteException(functionInterop, this.GetLastError());
    }

    internal override SQLiteErrorCode CreateCollation(
      string strCollation,
      SQLiteCollation func,
      SQLiteCollation func16,
      bool canThrow)
    {
      SQLiteErrorCode collation = UnsafeNativeMethods.sqlite3_create_collation((IntPtr) this._sql, SQLiteConvert.ToUTF8(strCollation), 2, IntPtr.Zero, func16);
      if (collation == SQLiteErrorCode.Ok)
        collation = UnsafeNativeMethods.sqlite3_create_collation((IntPtr) this._sql, SQLiteConvert.ToUTF8(strCollation), 1, IntPtr.Zero, func);
      return !canThrow || collation == SQLiteErrorCode.Ok ? collation : throw new SQLiteException(collation, this.GetLastError());
    }

    internal override int ContextCollateCompare(
      CollationEncodingEnum enc,
      IntPtr context,
      string s1,
      string s2)
    {
      Encoding encoding = (Encoding) null;
      switch (enc)
      {
        case CollationEncodingEnum.UTF8:
          encoding = Encoding.UTF8;
          break;
        case CollationEncodingEnum.UTF16LE:
          encoding = Encoding.Unicode;
          break;
        case CollationEncodingEnum.UTF16BE:
          encoding = Encoding.BigEndianUnicode;
          break;
      }
      byte[] bytes1 = encoding.GetBytes(s1);
      byte[] bytes2 = encoding.GetBytes(s2);
      return UnsafeNativeMethods.sqlite3_context_collcompare_interop(context, bytes1, bytes1.Length, bytes2, bytes2.Length);
    }

    internal override int ContextCollateCompare(
      CollationEncodingEnum enc,
      IntPtr context,
      char[] c1,
      char[] c2)
    {
      Encoding encoding = (Encoding) null;
      switch (enc)
      {
        case CollationEncodingEnum.UTF8:
          encoding = Encoding.UTF8;
          break;
        case CollationEncodingEnum.UTF16LE:
          encoding = Encoding.Unicode;
          break;
        case CollationEncodingEnum.UTF16BE:
          encoding = Encoding.BigEndianUnicode;
          break;
      }
      byte[] bytes1 = encoding.GetBytes(c1);
      byte[] bytes2 = encoding.GetBytes(c2);
      return UnsafeNativeMethods.sqlite3_context_collcompare_interop(context, bytes1, bytes1.Length, bytes2, bytes2.Length);
    }

    internal override CollationSequence GetCollationSequence(SQLiteFunction func, IntPtr context)
    {
      CollationSequence collationSequence = new CollationSequence();
      int len = 0;
      int type = 0;
      int enc = 0;
      IntPtr nativestring = UnsafeNativeMethods.sqlite3_context_collseq_interop(context, ref type, ref enc, ref len);
      collationSequence.Name = SQLiteConvert.UTF8ToString(nativestring, len);
      collationSequence.Type = (CollationTypeEnum) type;
      collationSequence._func = func;
      collationSequence.Encoding = (CollationEncodingEnum) enc;
      return collationSequence;
    }

    internal override long GetParamValueBytes(
      IntPtr p,
      int nDataOffset,
      byte[] bDest,
      int nStart,
      int nLength)
    {
      int paramValueBytes = UnsafeNativeMethods.sqlite3_value_bytes(p);
      if (bDest == null)
        return (long) paramValueBytes;
      int length = nLength;
      if (length + nStart > bDest.Length)
        length = bDest.Length - nStart;
      if (length + nDataOffset > paramValueBytes)
        length = paramValueBytes - nDataOffset;
      if (length > 0)
        Marshal.Copy((IntPtr) (UnsafeNativeMethods.sqlite3_value_blob(p).ToInt64() + (long) nDataOffset), bDest, nStart, length);
      else
        length = 0;
      return (long) length;
    }

    internal override double GetParamValueDouble(IntPtr ptr)
    {
      return UnsafeNativeMethods.sqlite3_value_double(ptr);
    }

    internal override int GetParamValueInt32(IntPtr ptr)
    {
      return UnsafeNativeMethods.sqlite3_value_int(ptr);
    }

    internal override long GetParamValueInt64(IntPtr ptr)
    {
      return UnsafeNativeMethods.sqlite3_value_int64(ptr);
    }

    internal override string GetParamValueText(IntPtr ptr)
    {
      int len = 0;
      return SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_value_text_interop(ptr, ref len), len);
    }

    internal override TypeAffinity GetParamValueType(IntPtr ptr)
    {
      return UnsafeNativeMethods.sqlite3_value_type(ptr);
    }

    internal override void ReturnBlob(IntPtr context, byte[] value)
    {
      UnsafeNativeMethods.sqlite3_result_blob(context, value, value.Length, (IntPtr) -1);
    }

    internal override void ReturnDouble(IntPtr context, double value)
    {
      UnsafeNativeMethods.sqlite3_result_double(context, value);
    }

    internal override void ReturnError(IntPtr context, string value)
    {
      UnsafeNativeMethods.sqlite3_result_error(context, SQLiteConvert.ToUTF8(value), value.Length);
    }

    internal override void ReturnInt32(IntPtr context, int value)
    {
      UnsafeNativeMethods.sqlite3_result_int(context, value);
    }

    internal override void ReturnInt64(IntPtr context, long value)
    {
      UnsafeNativeMethods.sqlite3_result_int64(context, value);
    }

    internal override void ReturnNull(IntPtr context)
    {
      UnsafeNativeMethods.sqlite3_result_null(context);
    }

    internal override void ReturnText(IntPtr context, string value)
    {
      byte[] utF8 = SQLiteConvert.ToUTF8(value);
      UnsafeNativeMethods.sqlite3_result_text(context, SQLiteConvert.ToUTF8(value), utF8.Length - 1, (IntPtr) -1);
    }

    private string GetShimExtensionFileName(ref bool isLoadNeeded)
    {
      isLoadNeeded = !this._shimIsLoadNeeded.HasValue ? HelperMethods.IsWindows() : this._shimIsLoadNeeded.Value;
      return this._shimExtensionFileName ?? UnsafeNativeMethods.GetNativeLibraryFileNameOnly();
    }

    internal override void CreateModule(SQLiteModule module, SQLiteConnectionFlags flags)
    {
      if (module == null)
        throw new ArgumentNullException(nameof (module));
      if ((flags & SQLiteConnectionFlags.NoLogModule) != SQLiteConnectionFlags.NoLogModule)
      {
        module.LogErrors = (flags & SQLiteConnectionFlags.LogModuleError) == SQLiteConnectionFlags.LogModuleError;
        module.LogExceptions = (flags & SQLiteConnectionFlags.LogModuleException) == SQLiteConnectionFlags.LogModuleException;
      }
      if (this._sql == null)
        throw new SQLiteException("connection has an invalid handle");
      bool isLoadNeeded = false;
      string extensionFileName = this.GetShimExtensionFileName(ref isLoadNeeded);
      if (isLoadNeeded)
      {
        if (extensionFileName == null)
          throw new SQLiteException("the file name for the \"vtshim\" extension is unknown");
        if (this._shimExtensionProcName == null)
          throw new SQLiteException("the entry point for the \"vtshim\" extension is unknown");
        this.SetLoadExtension(true);
        this.LoadExtension(extensionFileName, this._shimExtensionProcName);
      }
      if (!module.CreateDisposableModule((IntPtr) this._sql))
        throw new SQLiteException(this.GetLastError());
      if (this._modules == null)
        this._modules = new Dictionary<string, SQLiteModule>();
      this._modules.Add(module.Name, module);
      if (!this._usePool)
        return;
      this._usePool = false;
    }

    internal override void DisposeModule(SQLiteModule module, SQLiteConnectionFlags flags)
    {
      if (module == null)
        throw new ArgumentNullException(nameof (module));
      module.Dispose();
    }

    internal override IntPtr AggregateContext(IntPtr context)
    {
      return UnsafeNativeMethods.sqlite3_aggregate_context(context, 1);
    }

    internal override SQLiteErrorCode DeclareVirtualTable(
      SQLiteModule module,
      string strSql,
      ref string error)
    {
      if (this._sql == null)
      {
        error = "connection has an invalid handle";
        return SQLiteErrorCode.Error;
      }
      IntPtr num = IntPtr.Zero;
      try
      {
        num = SQLiteString.Utf8IntPtrFromString(strSql);
        SQLiteErrorCode sqLiteErrorCode = UnsafeNativeMethods.sqlite3_declare_vtab((IntPtr) this._sql, num);
        if (sqLiteErrorCode == SQLiteErrorCode.Ok && module != null)
          module.Declared = true;
        if (sqLiteErrorCode != SQLiteErrorCode.Ok)
          error = this.GetLastError();
        return sqLiteErrorCode;
      }
      finally
      {
        if (num != IntPtr.Zero)
        {
          SQLiteMemory.Free(num);
          IntPtr zero = IntPtr.Zero;
        }
      }
    }

    internal override SQLiteErrorCode DeclareVirtualFunction(
      SQLiteModule module,
      int argumentCount,
      string name,
      ref string error)
    {
      if (this._sql == null)
      {
        error = "connection has an invalid handle";
        return SQLiteErrorCode.Error;
      }
      IntPtr num = IntPtr.Zero;
      try
      {
        num = SQLiteString.Utf8IntPtrFromString(name);
        SQLiteErrorCode sqLiteErrorCode = UnsafeNativeMethods.sqlite3_overload_function((IntPtr) this._sql, num, argumentCount);
        if (sqLiteErrorCode != SQLiteErrorCode.Ok)
          error = this.GetLastError();
        return sqLiteErrorCode;
      }
      finally
      {
        if (num != IntPtr.Zero)
        {
          SQLiteMemory.Free(num);
          IntPtr zero = IntPtr.Zero;
        }
      }
    }

    internal override SQLiteErrorCode SetConfigurationOption(
      SQLiteConfigDbOpsEnum option,
      bool bOnOff)
    {
      if (option < SQLiteConfigDbOpsEnum.SQLITE_DBCONFIG_ENABLE_FKEY || option > SQLiteConfigDbOpsEnum.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION)
        throw new SQLiteException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "unsupported configuration option, must be: {0}, {1}, {2}, or {3}", (object) SQLiteConfigDbOpsEnum.SQLITE_DBCONFIG_ENABLE_FKEY, (object) SQLiteConfigDbOpsEnum.SQLITE_DBCONFIG_ENABLE_TRIGGER, (object) SQLiteConfigDbOpsEnum.SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER, (object) SQLiteConfigDbOpsEnum.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION));
      int result = 0;
      return UnsafeNativeMethods.sqlite3_db_config_int_refint((IntPtr) this._sql, option, bOnOff ? 1 : 0, ref result);
    }

    internal override void SetLoadExtension(bool bOnOff)
    {
      SQLiteErrorCode errorCode = SQLite3.SQLiteVersionNumber < 3013000 ? UnsafeNativeMethods.sqlite3_enable_load_extension((IntPtr) this._sql, bOnOff ? -1 : 0) : this.SetConfigurationOption(SQLiteConfigDbOpsEnum.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION, bOnOff);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override void LoadExtension(string fileName, string procName)
    {
      if (fileName == null)
        throw new ArgumentNullException(nameof (fileName));
      IntPtr zero1 = IntPtr.Zero;
      try
      {
        byte[] bytes = Encoding.UTF8.GetBytes(fileName + (object) char.MinValue);
        byte[] procName1 = (byte[]) null;
        if (procName != null)
          procName1 = Encoding.UTF8.GetBytes(procName + (object) char.MinValue);
        SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_load_extension((IntPtr) this._sql, bytes, procName1, ref zero1);
        if (errorCode != SQLiteErrorCode.Ok)
          throw new SQLiteException(errorCode, SQLiteConvert.UTF8ToString(zero1, -1));
      }
      finally
      {
        if (zero1 != IntPtr.Zero)
        {
          UnsafeNativeMethods.sqlite3_free(zero1);
          IntPtr zero2 = IntPtr.Zero;
        }
      }
    }

    internal override void SetExtendedResultCodes(bool bOnOff)
    {
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_extended_result_codes((IntPtr) this._sql, bOnOff ? -1 : 0);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override SQLiteErrorCode ResultCode()
    {
      return UnsafeNativeMethods.sqlite3_errcode((IntPtr) this._sql);
    }

    internal override SQLiteErrorCode ExtendedResultCode()
    {
      return UnsafeNativeMethods.sqlite3_extended_errcode((IntPtr) this._sql);
    }

    internal override void LogMessage(SQLiteErrorCode iErrCode, string zMessage)
    {
      SQLite3.StaticLogMessage(iErrCode, zMessage);
    }

    internal static void StaticLogMessage(SQLiteErrorCode iErrCode, string zMessage)
    {
      UnsafeNativeMethods.sqlite3_log(iErrCode, SQLiteConvert.ToUTF8(zMessage));
    }

    internal override void SetPassword(byte[] passwordBytes)
    {
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_key((IntPtr) this._sql, passwordBytes, passwordBytes.Length);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
      if (!this._usePool)
        return;
      this._usePool = false;
    }

    internal override void ChangePassword(byte[] newPasswordBytes)
    {
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_rekey((IntPtr) this._sql, newPasswordBytes, newPasswordBytes == null ? 0 : newPasswordBytes.Length);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
      if (!this._usePool)
        return;
      this._usePool = false;
    }

    internal override void SetProgressHook(int nOps, SQLiteProgressCallback func)
    {
      UnsafeNativeMethods.sqlite3_progress_handler((IntPtr) this._sql, nOps, func, IntPtr.Zero);
    }

    internal override void SetAuthorizerHook(SQLiteAuthorizerCallback func)
    {
      UnsafeNativeMethods.sqlite3_set_authorizer((IntPtr) this._sql, func, IntPtr.Zero);
    }

    internal override void SetUpdateHook(SQLiteUpdateCallback func)
    {
      UnsafeNativeMethods.sqlite3_update_hook((IntPtr) this._sql, func, IntPtr.Zero);
    }

    internal override void SetCommitHook(SQLiteCommitCallback func)
    {
      UnsafeNativeMethods.sqlite3_commit_hook((IntPtr) this._sql, func, IntPtr.Zero);
    }

    internal override void SetTraceCallback(SQLiteTraceCallback func)
    {
      UnsafeNativeMethods.sqlite3_trace((IntPtr) this._sql, func, IntPtr.Zero);
    }

    internal override void SetRollbackHook(SQLiteRollbackCallback func)
    {
      UnsafeNativeMethods.sqlite3_rollback_hook((IntPtr) this._sql, func, IntPtr.Zero);
    }

    internal override SQLiteErrorCode SetLogCallback(SQLiteLogCallback func)
    {
      return UnsafeNativeMethods.sqlite3_config_log(SQLiteConfigOpsEnum.SQLITE_CONFIG_LOG, func, IntPtr.Zero);
    }

    internal override SQLiteBackup InitializeBackup(
      SQLiteConnection destCnn,
      string destName,
      string sourceName)
    {
      if (destCnn == null)
        throw new ArgumentNullException(nameof (destCnn));
      if (destName == null)
        throw new ArgumentNullException(nameof (destName));
      if (sourceName == null)
        throw new ArgumentNullException(nameof (sourceName));
      if (!(destCnn._sql is SQLite3 sql1))
        throw new ArgumentException("Destination connection has no wrapper.", nameof (destCnn));
      SQLiteConnectionHandle sql2 = sql1._sql;
      if (sql2 == null)
        throw new ArgumentException("Destination connection has an invalid handle.", nameof (destCnn));
      SQLiteConnectionHandle sql3 = this._sql;
      if (sql3 == null)
        throw new InvalidOperationException("Source connection has an invalid handle.");
      byte[] utF8_1 = SQLiteConvert.ToUTF8(destName);
      byte[] utF8_2 = SQLiteConvert.ToUTF8(sourceName);
      SQLiteBackupHandle backup1 = (SQLiteBackupHandle) null;
      try
      {
      }
      finally
      {
        IntPtr backup2 = UnsafeNativeMethods.sqlite3_backup_init((IntPtr) sql2, utF8_1, (IntPtr) sql3, utF8_2);
        if (backup2 == IntPtr.Zero)
        {
          SQLiteErrorCode errorCode = this.ResultCode();
          if (errorCode != SQLiteErrorCode.Ok)
            throw new SQLiteException(errorCode, this.GetLastError());
          throw new SQLiteException("failed to initialize backup");
        }
        backup1 = new SQLiteBackupHandle(sql2, backup2);
      }
      SQLiteConnection.OnChanged((SQLiteConnection) null, new ConnectionEventArgs(SQLiteConnectionEventType.NewCriticalHandle, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) backup1, (string) null, (object) new object[4]
      {
        (object) typeof (SQLite3),
        (object) destCnn,
        (object) destName,
        (object) sourceName
      }));
      return new SQLiteBackup((SQLiteBase) this, backup1, (IntPtr) sql2, utF8_1, (IntPtr) sql3, utF8_2);
    }

    internal override bool StepBackup(SQLiteBackup backup, int nPage, ref bool retry)
    {
      retry = false;
      IntPtr backup1 = (IntPtr) ((backup != null ? backup._sqlite_backup : throw new ArgumentNullException(nameof (backup))) ?? throw new InvalidOperationException("Backup object has an invalid handle."));
      SQLiteErrorCode errorCode = !(backup1 == IntPtr.Zero) ? UnsafeNativeMethods.sqlite3_backup_step(backup1, nPage) : throw new InvalidOperationException("Backup object has an invalid handle pointer.");
      backup._stepResult = errorCode;
      switch (errorCode)
      {
        case SQLiteErrorCode.Ok:
          return true;
        case SQLiteErrorCode.Busy:
          retry = true;
          return true;
        case SQLiteErrorCode.Locked:
          retry = true;
          return true;
        case SQLiteErrorCode.Done:
          return false;
        default:
          throw new SQLiteException(errorCode, this.GetLastError());
      }
    }

    internal override int RemainingBackup(SQLiteBackup backup)
    {
      IntPtr backup1 = (IntPtr) ((backup != null ? backup._sqlite_backup : throw new ArgumentNullException(nameof (backup))) ?? throw new InvalidOperationException("Backup object has an invalid handle."));
      return !(backup1 == IntPtr.Zero) ? UnsafeNativeMethods.sqlite3_backup_remaining(backup1) : throw new InvalidOperationException("Backup object has an invalid handle pointer.");
    }

    internal override int PageCountBackup(SQLiteBackup backup)
    {
      IntPtr backup1 = (IntPtr) ((backup != null ? backup._sqlite_backup : throw new ArgumentNullException(nameof (backup))) ?? throw new InvalidOperationException("Backup object has an invalid handle."));
      return !(backup1 == IntPtr.Zero) ? UnsafeNativeMethods.sqlite3_backup_pagecount(backup1) : throw new InvalidOperationException("Backup object has an invalid handle pointer.");
    }

    internal override void FinishBackup(SQLiteBackup backup)
    {
      SQLiteBackupHandle liteBackupHandle = backup != null ? backup._sqlite_backup : throw new ArgumentNullException(nameof (backup));
      IntPtr backup1 = liteBackupHandle != null ? (IntPtr) liteBackupHandle : throw new InvalidOperationException("Backup object has an invalid handle.");
      SQLiteErrorCode errorCode = !(backup1 == IntPtr.Zero) ? UnsafeNativeMethods.sqlite3_backup_finish_interop(backup1) : throw new InvalidOperationException("Backup object has an invalid handle pointer.");
      liteBackupHandle.SetHandleAsInvalid();
      if (errorCode != SQLiteErrorCode.Ok && errorCode != backup._stepResult)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override bool IsInitialized() => SQLite3.StaticIsInitialized();

    internal static bool StaticIsInitialized()
    {
      lock (SQLite3.syncRoot)
      {
        bool enabled = SQLiteLog.Enabled;
        SQLiteLog.Enabled = false;
        try
        {
          return UnsafeNativeMethods.sqlite3_config_none(SQLiteConfigOpsEnum.SQLITE_CONFIG_NONE) == SQLiteErrorCode.Misuse;
        }
        finally
        {
          SQLiteLog.Enabled = enabled;
        }
      }
    }

    internal override object GetValue(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      SQLiteType typ)
    {
      TypeAffinity affinity = typ.Affinity;
      if (affinity == TypeAffinity.Null)
        return (object) DBNull.Value;
      Type type = (Type) null;
      if (typ.Type != DbType.Object)
      {
        type = SQLiteConvert.SQLiteTypeToType(typ);
        affinity = SQLiteConvert.TypeToAffinity(type);
      }
      if ((flags & SQLiteConnectionFlags.GetAllAsText) == SQLiteConnectionFlags.GetAllAsText)
        return (object) this.GetText(stmt, index);
      switch (affinity)
      {
        case TypeAffinity.Int64:
          if (type == (Type) null)
            return (object) this.GetInt64(stmt, index);
          if (type == typeof (bool))
            return (object) this.GetBoolean(stmt, index);
          if (type == typeof (sbyte))
            return (object) this.GetSByte(stmt, index);
          if (type == typeof (byte))
            return (object) this.GetByte(stmt, index);
          if (type == typeof (short))
            return (object) this.GetInt16(stmt, index);
          if (type == typeof (ushort))
            return (object) this.GetUInt16(stmt, index);
          if (type == typeof (int))
            return (object) this.GetInt32(stmt, index);
          if (type == typeof (uint))
            return (object) this.GetUInt32(stmt, index);
          if (type == typeof (long))
            return (object) this.GetInt64(stmt, index);
          return type == typeof (ulong) ? (object) this.GetUInt64(stmt, index) : Convert.ChangeType((object) this.GetInt64(stmt, index), type, (IFormatProvider) null);
        case TypeAffinity.Double:
          return type == (Type) null ? (object) this.GetDouble(stmt, index) : Convert.ChangeType((object) this.GetDouble(stmt, index), type, (IFormatProvider) null);
        case TypeAffinity.Blob:
          if (typ.Type == DbType.Guid && typ.Affinity == TypeAffinity.Text)
            return (object) new Guid(this.GetText(stmt, index));
          int bytes = (int) this.GetBytes(stmt, index, 0, (byte[]) null, 0, 0);
          byte[] numArray = new byte[bytes];
          this.GetBytes(stmt, index, 0, numArray, 0, bytes);
          return typ.Type == DbType.Guid && bytes == 16 ? (object) new Guid(numArray) : (object) numArray;
        case TypeAffinity.DateTime:
          return (object) this.GetDateTime(stmt, index);
        default:
          return (object) this.GetText(stmt, index);
      }
    }

    internal override int GetCursorForTable(SQLiteStatement stmt, int db, int rootPage)
    {
      return UnsafeNativeMethods.sqlite3_table_cursor_interop((IntPtr) stmt._sqlite_stmt, db, rootPage);
    }

    internal override long GetRowIdForCursor(SQLiteStatement stmt, int cursor)
    {
      long rowid = 0;
      return UnsafeNativeMethods.sqlite3_cursor_rowid_interop((IntPtr) stmt._sqlite_stmt, cursor, ref rowid) == SQLiteErrorCode.Ok ? rowid : 0L;
    }

    internal override void GetIndexColumnExtendedInfo(
      string database,
      string index,
      string column,
      ref int sortMode,
      ref int onError,
      ref string collationSequence)
    {
      IntPtr zero = IntPtr.Zero;
      int colllen = 0;
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_index_column_info_interop((IntPtr) this._sql, SQLiteConvert.ToUTF8(database), SQLiteConvert.ToUTF8(index), SQLiteConvert.ToUTF8(column), ref sortMode, ref onError, ref zero, ref colllen);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, (string) null);
      collationSequence = SQLiteConvert.UTF8ToString(zero, colllen);
    }

    internal override SQLiteErrorCode FileControl(string zDbName, int op, IntPtr pArg)
    {
      return UnsafeNativeMethods.sqlite3_file_control((IntPtr) this._sql, zDbName != null ? SQLiteConvert.ToUTF8(zDbName) : (byte[]) null, op, pArg);
    }
  }
}


--- SQLite3_UTF16.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLite3_UTF16
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLite3_UTF16 : SQLite3
  {
    private bool disposed;

    internal SQLite3_UTF16(
      SQLiteDateFormats fmt,
      DateTimeKind kind,
      string fmtString,
      IntPtr db,
      string fileName,
      bool ownHandle)
      : base(fmt, kind, fmtString, db, fileName, ownHandle)
    {
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLite3_UTF16).Name);
    }

    protected override void Dispose(bool disposing)
    {
      try
      {
        int num = this.disposed ? 1 : 0;
      }
      finally
      {
        base.Dispose(disposing);
        this.disposed = true;
      }
    }

    public override string ToString(IntPtr b, int nbytelen)
    {
      this.CheckDisposed();
      return SQLite3_UTF16.UTF16ToString(b, nbytelen);
    }

    public static string UTF16ToString(IntPtr b, int nbytelen)
    {
      if (nbytelen == 0 || b == IntPtr.Zero)
        return string.Empty;
      return nbytelen == -1 ? Marshal.PtrToStringUni(b) : Marshal.PtrToStringUni(b, nbytelen / 2);
    }

    internal override void Open(
      string strFilename,
      string vfsName,
      SQLiteConnectionFlags connectionFlags,
      SQLiteOpenFlagsEnum openFlags,
      int maxPoolSize,
      bool usePool)
    {
      if (this._sql != null)
        this.Close(true);
      if (this._sql != null)
        throw new SQLiteException("connection handle is still active");
      this._usePool = usePool;
      this._fileName = strFilename;
      this._flags = connectionFlags;
      if (usePool)
      {
        this._sql = SQLiteConnectionPool.Remove(strFilename, maxPoolSize, out this._poolVersion);
        SQLiteConnection.OnChanged((SQLiteConnection) null, new ConnectionEventArgs(SQLiteConnectionEventType.OpenedFromPool, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) this._sql, strFilename, (object) new object[8]
        {
          (object) typeof (SQLite3_UTF16),
          (object) strFilename,
          (object) vfsName,
          (object) connectionFlags,
          (object) openFlags,
          (object) maxPoolSize,
          (object) usePool,
          (object) this._poolVersion
        }));
      }
      if (this._sql == null)
      {
        try
        {
        }
        finally
        {
          IntPtr zero = IntPtr.Zero;
          int extFuncs = (connectionFlags & SQLiteConnectionFlags.NoExtensionFunctions) != SQLiteConnectionFlags.NoExtensionFunctions ? 1 : 0;
          SQLiteErrorCode errorCode;
          if (vfsName != null || extFuncs != 0)
          {
            errorCode = UnsafeNativeMethods.sqlite3_open16_interop(SQLiteConvert.ToUTF8(strFilename), SQLiteConvert.ToUTF8(vfsName), openFlags, extFuncs, ref zero);
          }
          else
          {
            if ((openFlags & SQLiteOpenFlagsEnum.Create) != SQLiteOpenFlagsEnum.Create && !File.Exists(strFilename))
              throw new SQLiteException(SQLiteErrorCode.CantOpen, strFilename);
            if (vfsName != null)
              throw new SQLiteException(SQLiteErrorCode.CantOpen, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "cannot open using UTF-16 and VFS \"{0}\": need interop assembly", (object) vfsName));
            errorCode = UnsafeNativeMethods.sqlite3_open16(strFilename, ref zero);
          }
          if (errorCode != SQLiteErrorCode.Ok)
            throw new SQLiteException(errorCode, (string) null);
          this._sql = new SQLiteConnectionHandle(zero, true);
        }
        lock (this._sql)
          ;
        SQLiteConnection.OnChanged((SQLiteConnection) null, new ConnectionEventArgs(SQLiteConnectionEventType.NewCriticalHandle, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) this._sql, strFilename, (object) new object[7]
        {
          (object) typeof (SQLite3_UTF16),
          (object) strFilename,
          (object) vfsName,
          (object) connectionFlags,
          (object) openFlags,
          (object) maxPoolSize,
          (object) usePool
        }));
      }
      if ((connectionFlags & SQLiteConnectionFlags.NoBindFunctions) != SQLiteConnectionFlags.NoBindFunctions)
      {
        if (this._functions == null)
          this._functions = new Dictionary<SQLiteFunctionAttribute, SQLiteFunction>();
        foreach (KeyValuePair<SQLiteFunctionAttribute, SQLiteFunction> bindFunction in (IEnumerable<KeyValuePair<SQLiteFunctionAttribute, SQLiteFunction>>) SQLiteFunction.BindFunctions((SQLiteBase) this, connectionFlags))
          this._functions[bindFunction.Key] = bindFunction.Value;
      }
      this.SetTimeout(0);
      GC.KeepAlive((object) this._sql);
    }

    internal override void Bind_DateTime(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      DateTime dt)
    {
      switch (this._datetimeFormat)
      {
        case SQLiteDateFormats.Ticks:
        case SQLiteDateFormats.JulianDay:
        case SQLiteDateFormats.UnixEpoch:
          base.Bind_DateTime(stmt, flags, index, dt);
          break;
        default:
          if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
            SQLite3.LogBind(stmt?._sqlite_stmt, index, dt);
          this.Bind_Text(stmt, flags, index, this.ToString(dt));
          break;
      }
    }

    internal override void Bind_Text(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      string value)
    {
      SQLiteStatementHandle sqliteStmt = stmt._sqlite_stmt;
      if ((flags & SQLiteConnectionFlags.LogBind) == SQLiteConnectionFlags.LogBind)
        SQLite3.LogBind(sqliteStmt, index, value);
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_bind_text16((IntPtr) sqliteStmt, index, value, value.Length * 2, (IntPtr) -1);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this.GetLastError());
    }

    internal override DateTime GetDateTime(SQLiteStatement stmt, int index)
    {
      if (this._datetimeFormat == SQLiteDateFormats.Ticks)
        return SQLiteConvert.TicksToDateTime(this.GetInt64(stmt, index), this._datetimeKind);
      if (this._datetimeFormat == SQLiteDateFormats.JulianDay)
        return SQLiteConvert.ToDateTime(this.GetDouble(stmt, index), this._datetimeKind);
      return this._datetimeFormat == SQLiteDateFormats.UnixEpoch ? SQLiteConvert.UnixEpochToDateTime(this.GetInt64(stmt, index), this._datetimeKind) : this.ToDateTime(this.GetText(stmt, index));
    }

    internal override string ColumnName(SQLiteStatement stmt, int index)
    {
      int len = 0;
      IntPtr b = UnsafeNativeMethods.sqlite3_column_name16_interop((IntPtr) stmt._sqlite_stmt, index, ref len);
      return !(b == IntPtr.Zero) ? SQLite3_UTF16.UTF16ToString(b, len) : throw new SQLiteException(SQLiteErrorCode.NoMem, this.GetLastError());
    }

    internal override string GetText(SQLiteStatement stmt, int index)
    {
      int len = 0;
      return SQLite3_UTF16.UTF16ToString(UnsafeNativeMethods.sqlite3_column_text16_interop((IntPtr) stmt._sqlite_stmt, index, ref len), len);
    }

    internal override string ColumnOriginalName(SQLiteStatement stmt, int index)
    {
      int len = 0;
      return SQLite3_UTF16.UTF16ToString(UnsafeNativeMethods.sqlite3_column_origin_name16_interop((IntPtr) stmt._sqlite_stmt, index, ref len), len);
    }

    internal override string ColumnDatabaseName(SQLiteStatement stmt, int index)
    {
      int len = 0;
      return SQLite3_UTF16.UTF16ToString(UnsafeNativeMethods.sqlite3_column_database_name16_interop((IntPtr) stmt._sqlite_stmt, index, ref len), len);
    }

    internal override string ColumnTableName(SQLiteStatement stmt, int index)
    {
      int len = 0;
      return SQLite3_UTF16.UTF16ToString(UnsafeNativeMethods.sqlite3_column_table_name16_interop((IntPtr) stmt._sqlite_stmt, index, ref len), len);
    }

    internal override string GetParamValueText(IntPtr ptr)
    {
      int len = 0;
      return SQLite3_UTF16.UTF16ToString(UnsafeNativeMethods.sqlite3_value_text16_interop(ptr, ref len), len);
    }

    internal override void ReturnError(IntPtr context, string value)
    {
      UnsafeNativeMethods.sqlite3_result_error16(context, value, value.Length * 2);
    }

    internal override void ReturnText(IntPtr context, string value)
    {
      UnsafeNativeMethods.sqlite3_result_text16(context, value, value.Length * 2, (IntPtr) -1);
    }
  }
}


--- SQLiteAuthorizerActionCode.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteAuthorizerActionCode
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum SQLiteAuthorizerActionCode
  {
    None = -1, // 0xFFFFFFFF
    Copy = 0,
    CreateIndex = 1,
    CreateTable = 2,
    CreateTempIndex = 3,
    CreateTempTable = 4,
    CreateTempTrigger = 5,
    CreateTempView = 6,
    CreateTrigger = 7,
    CreateView = 8,
    Delete = 9,
    DropIndex = 10, // 0x0000000A
    DropTable = 11, // 0x0000000B
    DropTempIndex = 12, // 0x0000000C
    DropTempTable = 13, // 0x0000000D
    DropTempTrigger = 14, // 0x0000000E
    DropTempView = 15, // 0x0000000F
    DropTrigger = 16, // 0x00000010
    DropView = 17, // 0x00000011
    Insert = 18, // 0x00000012
    Pragma = 19, // 0x00000013
    Read = 20, // 0x00000014
    Select = 21, // 0x00000015
    Transaction = 22, // 0x00000016
    Update = 23, // 0x00000017
    Attach = 24, // 0x00000018
    Detach = 25, // 0x00000019
    AlterTable = 26, // 0x0000001A
    Reindex = 27, // 0x0000001B
    Analyze = 28, // 0x0000001C
    CreateVtable = 29, // 0x0000001D
    DropVtable = 30, // 0x0000001E
    Function = 31, // 0x0000001F
    Savepoint = 32, // 0x00000020
    Recursive = 33, // 0x00000021
  }
}


--- SQLiteAuthorizerCallback.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteAuthorizerCallback
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  internal delegate SQLiteAuthorizerReturnCode SQLiteAuthorizerCallback(
    IntPtr pUserData,
    SQLiteAuthorizerActionCode actionCode,
    IntPtr pArgument1,
    IntPtr pArgument2,
    IntPtr pDatabase,
    IntPtr pAuthContext);
}


--- SQLiteAuthorizerEventHandler.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteAuthorizerEventHandler
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate void SQLiteAuthorizerEventHandler(object sender, AuthorizerEventArgs e);
}


--- SQLiteAuthorizerReturnCode.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteAuthorizerReturnCode
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum SQLiteAuthorizerReturnCode
  {
    Ok,
    Deny,
    Ignore,
  }
}


--- SQLiteBackup.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteBackup
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLiteBackup : IDisposable
  {
    internal SQLiteBase _sql;
    internal SQLiteBackupHandle _sqlite_backup;
    internal IntPtr _destDb;
    internal byte[] _zDestName;
    internal IntPtr _sourceDb;
    internal byte[] _zSourceName;
    internal SQLiteErrorCode _stepResult;
    private bool disposed;

    internal SQLiteBackup(
      SQLiteBase sqlbase,
      SQLiteBackupHandle backup,
      IntPtr destDb,
      byte[] zDestName,
      IntPtr sourceDb,
      byte[] zSourceName)
    {
      this._sql = sqlbase;
      this._sqlite_backup = backup;
      this._destDb = destDb;
      this._zDestName = zDestName;
      this._sourceDb = sourceDb;
      this._zSourceName = zSourceName;
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteBackup).Name);
    }

    private void Dispose(bool disposing)
    {
      if (this.disposed)
        return;
      if (disposing)
      {
        if (this._sqlite_backup != null)
        {
          this._sqlite_backup.Dispose();
          this._sqlite_backup = (SQLiteBackupHandle) null;
        }
        this._zSourceName = (byte[]) null;
        this._sourceDb = IntPtr.Zero;
        this._zDestName = (byte[]) null;
        this._destDb = IntPtr.Zero;
        this._sql = (SQLiteBase) null;
      }
      this.disposed = true;
    }

    ~SQLiteBackup() => this.Dispose(false);
  }
}


--- SQLiteBackupCallback.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteBackupCallback
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate bool SQLiteBackupCallback(
    SQLiteConnection source,
    string sourceName,
    SQLiteConnection destination,
    string destinationName,
    int pages,
    int remainingPages,
    int totalPages,
    bool retry);
}


--- SQLiteBackupHandle.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteBackupHandle
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;
using System.Threading;

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLiteBackupHandle : CriticalHandle
  {
    private SQLiteConnectionHandle cnn;

    public static implicit operator IntPtr(SQLiteBackupHandle backup)
    {
      return backup != null ? backup.handle : IntPtr.Zero;
    }

    internal SQLiteBackupHandle(SQLiteConnectionHandle cnn, IntPtr backup)
      : this()
    {
      this.cnn = cnn;
      this.SetHandle(backup);
    }

    private SQLiteBackupHandle()
      : base(IntPtr.Zero)
    {
    }

    protected override bool ReleaseHandle()
    {
      try
      {
        IntPtr backup = Interlocked.Exchange(ref this.handle, IntPtr.Zero);
        if (backup != IntPtr.Zero)
          SQLiteBase.FinishBackup(this.cnn, backup);
      }
      catch (SQLiteException ex)
      {
      }
      finally
      {
        this.SetHandleAsInvalid();
      }
      return true;
    }

    public override bool IsInvalid => this.handle == IntPtr.Zero;
  }
}


--- SQLiteBase.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteBase
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;

#nullable disable
namespace System.Data.SQLite
{
  internal abstract class SQLiteBase : SQLiteConvert, IDisposable
  {
    internal const int COR_E_EXCEPTION = -2146233088;
    private bool disposed;
    private static string[] _errorMessages = new string[29]
    {
      "not an error",
      "SQL logic error or missing database",
      "internal logic error",
      "access permission denied",
      "callback requested query abort",
      "database is locked",
      "database table is locked",
      "out of memory",
      "attempt to write a readonly database",
      "interrupted",
      "disk I/O error",
      "database disk image is malformed",
      "unknown operation",
      "database or disk is full",
      "unable to open database file",
      "locking protocol",
      "table contains no data",
      "database schema has changed",
      "string or blob too big",
      "constraint failed",
      "datatype mismatch",
      "library routine called out of sequence",
      "large file support is disabled",
      "authorization denied",
      "auxiliary database format error",
      "bind or column index out of range",
      "file is encrypted or is not a database",
      "notification message",
      "warning message"
    };

    internal SQLiteBase(SQLiteDateFormats fmt, DateTimeKind kind, string fmtString)
      : base(fmt, kind, fmtString)
    {
    }

    internal abstract string Version { get; }

    internal abstract int VersionNumber { get; }

    internal abstract bool IsReadOnly(string name);

    internal abstract long LastInsertRowId { get; }

    internal abstract int Changes { get; }

    internal abstract long MemoryUsed { get; }

    internal abstract long MemoryHighwater { get; }

    internal abstract bool OwnHandle { get; }

    internal abstract IDictionary<SQLiteFunctionAttribute, SQLiteFunction> Functions { get; }

    internal abstract SQLiteErrorCode SetMemoryStatus(bool value);

    internal abstract SQLiteErrorCode ReleaseMemory();

    internal abstract SQLiteErrorCode Shutdown();

    internal abstract bool IsOpen();

    internal abstract string GetFileName(string dbName);

    internal abstract void Open(
      string strFilename,
      string vfsName,
      SQLiteConnectionFlags connectionFlags,
      SQLiteOpenFlagsEnum openFlags,
      int maxPoolSize,
      bool usePool);

    internal abstract void Close(bool canThrow);

    internal abstract void SetTimeout(int nTimeoutMS);

    internal abstract string GetLastError();

    internal abstract string GetLastError(string defValue);

    internal abstract void ClearPool();

    internal abstract int CountPool();

    internal abstract SQLiteStatement Prepare(
      SQLiteConnection cnn,
      string strSql,
      SQLiteStatement previous,
      uint timeoutMS,
      ref string strRemain);

    internal abstract bool Step(SQLiteStatement stmt);

    internal abstract bool IsReadOnly(SQLiteStatement stmt);

    internal abstract SQLiteErrorCode Reset(SQLiteStatement stmt);

    internal abstract void Cancel();

    internal abstract void BindFunction(
      SQLiteFunctionAttribute functionAttribute,
      SQLiteFunction function,
      SQLiteConnectionFlags flags);

    internal abstract bool UnbindFunction(
      SQLiteFunctionAttribute functionAttribute,
      SQLiteConnectionFlags flags);

    internal abstract void Bind_Double(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      double value);

    internal abstract void Bind_Int32(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      int value);

    internal abstract void Bind_UInt32(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      uint value);

    internal abstract void Bind_Int64(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      long value);

    internal abstract void Bind_UInt64(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      ulong value);

    internal abstract void Bind_Boolean(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      bool value);

    internal abstract void Bind_Text(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      string value);

    internal abstract void Bind_Blob(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      byte[] blobData);

    internal abstract void Bind_DateTime(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      DateTime dt);

    internal abstract void Bind_Null(SQLiteStatement stmt, SQLiteConnectionFlags flags, int index);

    internal abstract int Bind_ParamCount(SQLiteStatement stmt, SQLiteConnectionFlags flags);

    internal abstract string Bind_ParamName(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index);

    internal abstract int Bind_ParamIndex(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      string paramName);

    internal abstract int ColumnCount(SQLiteStatement stmt);

    internal abstract string ColumnName(SQLiteStatement stmt, int index);

    internal abstract TypeAffinity ColumnAffinity(SQLiteStatement stmt, int index);

    internal abstract string ColumnType(
      SQLiteStatement stmt,
      int index,
      ref TypeAffinity nAffinity);

    internal abstract int ColumnIndex(SQLiteStatement stmt, string columnName);

    internal abstract string ColumnOriginalName(SQLiteStatement stmt, int index);

    internal abstract string ColumnDatabaseName(SQLiteStatement stmt, int index);

    internal abstract string ColumnTableName(SQLiteStatement stmt, int index);

    internal abstract void ColumnMetaData(
      string dataBase,
      string table,
      string column,
      ref string dataType,
      ref string collateSequence,
      ref bool notNull,
      ref bool primaryKey,
      ref bool autoIncrement);

    internal abstract void GetIndexColumnExtendedInfo(
      string database,
      string index,
      string column,
      ref int sortMode,
      ref int onError,
      ref string collationSequence);

    internal abstract object GetObject(SQLiteStatement stmt, int index);

    internal abstract double GetDouble(SQLiteStatement stmt, int index);

    internal abstract bool GetBoolean(SQLiteStatement stmt, int index);

    internal abstract sbyte GetSByte(SQLiteStatement stmt, int index);

    internal abstract byte GetByte(SQLiteStatement stmt, int index);

    internal abstract short GetInt16(SQLiteStatement stmt, int index);

    internal abstract ushort GetUInt16(SQLiteStatement stmt, int index);

    internal abstract int GetInt32(SQLiteStatement stmt, int index);

    internal abstract uint GetUInt32(SQLiteStatement stmt, int index);

    internal abstract long GetInt64(SQLiteStatement stmt, int index);

    internal abstract ulong GetUInt64(SQLiteStatement stmt, int index);

    internal abstract string GetText(SQLiteStatement stmt, int index);

    internal abstract long GetBytes(
      SQLiteStatement stmt,
      int index,
      int nDataoffset,
      byte[] bDest,
      int nStart,
      int nLength);

    internal abstract long GetChars(
      SQLiteStatement stmt,
      int index,
      int nDataoffset,
      char[] bDest,
      int nStart,
      int nLength);

    internal abstract DateTime GetDateTime(SQLiteStatement stmt, int index);

    internal abstract bool IsNull(SQLiteStatement stmt, int index);

    internal abstract SQLiteErrorCode CreateCollation(
      string strCollation,
      SQLiteCollation func,
      SQLiteCollation func16,
      bool @throw);

    internal abstract SQLiteErrorCode CreateFunction(
      string strFunction,
      int nArgs,
      bool needCollSeq,
      SQLiteCallback func,
      SQLiteCallback funcstep,
      SQLiteFinalCallback funcfinal,
      bool @throw);

    internal abstract CollationSequence GetCollationSequence(SQLiteFunction func, IntPtr context);

    internal abstract int ContextCollateCompare(
      CollationEncodingEnum enc,
      IntPtr context,
      string s1,
      string s2);

    internal abstract int ContextCollateCompare(
      CollationEncodingEnum enc,
      IntPtr context,
      char[] c1,
      char[] c2);

    internal abstract int AggregateCount(IntPtr context);

    internal abstract IntPtr AggregateContext(IntPtr context);

    internal abstract long GetParamValueBytes(
      IntPtr ptr,
      int nDataOffset,
      byte[] bDest,
      int nStart,
      int nLength);

    internal abstract double GetParamValueDouble(IntPtr ptr);

    internal abstract int GetParamValueInt32(IntPtr ptr);

    internal abstract long GetParamValueInt64(IntPtr ptr);

    internal abstract string GetParamValueText(IntPtr ptr);

    internal abstract TypeAffinity GetParamValueType(IntPtr ptr);

    internal abstract void ReturnBlob(IntPtr context, byte[] value);

    internal abstract void ReturnDouble(IntPtr context, double value);

    internal abstract void ReturnError(IntPtr context, string value);

    internal abstract void ReturnInt32(IntPtr context, int value);

    internal abstract void ReturnInt64(IntPtr context, long value);

    internal abstract void ReturnNull(IntPtr context);

    internal abstract void ReturnText(IntPtr context, string value);

    internal abstract void CreateModule(SQLiteModule module, SQLiteConnectionFlags flags);

    internal abstract void DisposeModule(SQLiteModule module, SQLiteConnectionFlags flags);

    internal abstract SQLiteErrorCode DeclareVirtualTable(
      SQLiteModule module,
      string strSql,
      ref string error);

    internal abstract SQLiteErrorCode DeclareVirtualFunction(
      SQLiteModule module,
      int argumentCount,
      string name,
      ref string error);

    internal abstract SQLiteErrorCode SetConfigurationOption(
      SQLiteConfigDbOpsEnum option,
      bool bOnOff);

    internal abstract void SetLoadExtension(bool bOnOff);

    internal abstract void LoadExtension(string fileName, string procName);

    internal abstract void SetExtendedResultCodes(bool bOnOff);

    internal abstract SQLiteErrorCode ResultCode();

    internal abstract SQLiteErrorCode ExtendedResultCode();

    internal abstract void LogMessage(SQLiteErrorCode iErrCode, string zMessage);

    internal abstract void SetPassword(byte[] passwordBytes);

    internal abstract void ChangePassword(byte[] newPasswordBytes);

    internal abstract void SetProgressHook(int nOps, SQLiteProgressCallback func);

    internal abstract void SetAuthorizerHook(SQLiteAuthorizerCallback func);

    internal abstract void SetUpdateHook(SQLiteUpdateCallback func);

    internal abstract void SetCommitHook(SQLiteCommitCallback func);

    internal abstract void SetTraceCallback(SQLiteTraceCallback func);

    internal abstract void SetRollbackHook(SQLiteRollbackCallback func);

    internal abstract SQLiteErrorCode SetLogCallback(SQLiteLogCallback func);

    internal abstract bool IsInitialized();

    internal abstract int GetCursorForTable(SQLiteStatement stmt, int database, int rootPage);

    internal abstract long GetRowIdForCursor(SQLiteStatement stmt, int cursor);

    internal abstract object GetValue(
      SQLiteStatement stmt,
      SQLiteConnectionFlags flags,
      int index,
      SQLiteType typ);

    internal abstract bool AutoCommit { get; }

    internal abstract SQLiteErrorCode FileControl(string zDbName, int op, IntPtr pArg);

    internal abstract SQLiteBackup InitializeBackup(
      SQLiteConnection destCnn,
      string destName,
      string sourceName);

    internal abstract bool StepBackup(SQLiteBackup backup, int nPage, ref bool retry);

    internal abstract int RemainingBackup(SQLiteBackup backup);

    internal abstract int PageCountBackup(SQLiteBackup backup);

    internal abstract void FinishBackup(SQLiteBackup backup);

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteBase).Name);
    }

    protected virtual void Dispose(bool disposing)
    {
      if (this.disposed)
        return;
      this.disposed = true;
    }

    ~SQLiteBase() => this.Dispose(false);

    protected static string FallbackGetErrorString(SQLiteErrorCode rc)
    {
      if (SQLiteBase._errorMessages == null)
        return (string) null;
      int index = (int) rc;
      if (index < 0 || index >= SQLiteBase._errorMessages.Length)
        index = 1;
      return SQLiteBase._errorMessages[index];
    }

    internal static string GetLastError(SQLiteConnectionHandle hdl, IntPtr db)
    {
      if (hdl == null || db == IntPtr.Zero)
        return "null connection or database handle";
      string lastError = (string) null;
      try
      {
      }
      finally
      {
        lock (hdl)
        {
          if (!hdl.IsInvalid && !hdl.IsClosed)
          {
            int len = 0;
            lastError = SQLiteConvert.UTF8ToString(UnsafeNativeMethods.sqlite3_errmsg_interop(db, ref len), len);
          }
          else
            lastError = "closed or invalid connection handle";
        }
      }
      GC.KeepAlive((object) hdl);
      return lastError;
    }

    internal static void FinishBackup(SQLiteConnectionHandle hdl, IntPtr backup)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static void CloseBlob(SQLiteConnectionHandle hdl, IntPtr blob)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static void FinalizeStatement(SQLiteConnectionHandle hdl, IntPtr stmt)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static void CloseConnection(SQLiteConnectionHandle hdl, IntPtr db)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static void CloseConnectionV2(SQLiteConnectionHandle hdl, IntPtr db)
    {
      // ISSUE: unable to decompile the method.
    }

    internal static bool ResetConnection(SQLiteConnectionHandle hdl, IntPtr db, bool canThrow)
    {
      if (hdl == null || db == IntPtr.Zero)
        return false;
      bool flag = false;
      try
      {
      }
      finally
      {
        lock (hdl)
        {
          if (canThrow && hdl.IsInvalid)
            throw new InvalidOperationException("The connection handle is invalid.");
          if (canThrow && hdl.IsClosed)
            throw new InvalidOperationException("The connection handle is closed.");
          if (!hdl.IsInvalid)
          {
            if (!hdl.IsClosed)
            {
              IntPtr errMsg = IntPtr.Zero;
              do
              {
                errMsg = UnsafeNativeMethods.sqlite3_next_stmt(db, errMsg);
                if (errMsg != IntPtr.Zero)
                  UnsafeNativeMethods.sqlite3_reset_interop(errMsg);
              }
              while (errMsg != IntPtr.Zero);
              if (SQLiteBase.IsAutocommit(hdl, db))
              {
                flag = true;
              }
              else
              {
                SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_exec(db, SQLiteConvert.ToUTF8("ROLLBACK"), IntPtr.Zero, IntPtr.Zero, ref errMsg);
                if (errorCode == SQLiteErrorCode.Ok)
                  flag = true;
                else if (canThrow)
                  throw new SQLiteException(errorCode, SQLiteBase.GetLastError(hdl, db));
              }
            }
          }
        }
      }
      GC.KeepAlive((object) hdl);
      return flag;
    }

    internal static bool IsAutocommit(SQLiteConnectionHandle hdl, IntPtr db)
    {
      if (hdl == null || db == IntPtr.Zero)
        return false;
      bool flag = false;
      try
      {
      }
      finally
      {
        lock (hdl)
        {
          if (!hdl.IsInvalid)
          {
            if (!hdl.IsClosed)
              flag = UnsafeNativeMethods.sqlite3_get_autocommit(db) == 1;
          }
        }
      }
      GC.KeepAlive((object) hdl);
      return flag;
    }
  }
}


--- SQLiteBindValueCallback.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteBindValueCallback
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate void SQLiteBindValueCallback(
    SQLiteConvert convert,
    SQLiteCommand command,
    SQLiteConnectionFlags flags,
    SQLiteParameter parameter,
    string typeName,
    int index,
    object userData,
    out bool complete);
}


--- SQLiteBlob.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteBlob
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteBlob : IDisposable
  {
    internal SQLiteBase _sql;
    internal SQLiteBlobHandle _sqlite_blob;
    private bool disposed;

    private SQLiteBlob(SQLiteBase sqlbase, SQLiteBlobHandle blob)
    {
      this._sql = sqlbase;
      this._sqlite_blob = blob;
    }

    public static SQLiteBlob Create(SQLiteDataReader dataReader, int i, bool readOnly)
    {
      SQLiteConnection connection = SQLiteDataReader.GetConnection(dataReader);
      if (connection == null)
        throw new InvalidOperationException("Connection not available");
      if (!(connection._sql is SQLite3 sql1))
        throw new InvalidOperationException("Connection has no wrapper");
      SQLiteConnectionHandle sql2 = sql1._sql;
      if (sql2 == null)
        throw new InvalidOperationException("Connection has an invalid handle.");
      long? rowId = dataReader.GetRowId(i);
      if (!rowId.HasValue)
        throw new InvalidOperationException("No RowId is available");
      SQLiteBlobHandle blob = (SQLiteBlobHandle) null;
      try
      {
      }
      finally
      {
        IntPtr zero = IntPtr.Zero;
        SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_blob_open((IntPtr) sql1._sql, SQLiteConvert.ToUTF8(dataReader.GetDatabaseName(i)), SQLiteConvert.ToUTF8(dataReader.GetTableName(i)), SQLiteConvert.ToUTF8(dataReader.GetName(i)), rowId.Value, readOnly ? 0 : 1, ref zero);
        if (errorCode != SQLiteErrorCode.Ok)
          throw new SQLiteException(errorCode, (string) null);
        blob = new SQLiteBlobHandle(sql2, zero);
      }
      SQLiteConnection.OnChanged((SQLiteConnection) null, new ConnectionEventArgs(SQLiteConnectionEventType.NewCriticalHandle, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) dataReader, (CriticalHandle) blob, (string) null, (object) new object[4]
      {
        (object) typeof (SQLiteBlob),
        (object) dataReader,
        (object) i,
        (object) readOnly
      }));
      return new SQLiteBlob((SQLiteBase) sql1, blob);
    }

    private void CheckOpen()
    {
      if ((IntPtr) this._sqlite_blob == IntPtr.Zero)
        throw new InvalidOperationException("Blob is not open");
    }

    private void VerifyParameters(byte[] buffer, int count, int offset)
    {
      if (buffer == null)
        throw new ArgumentNullException(nameof (buffer));
      if (offset < 0)
        throw new ArgumentException("Negative offset not allowed.");
      if (count < 0)
        throw new ArgumentException("Negative count not allowed.");
      if (count > buffer.Length)
        throw new ArgumentException("Buffer is too small.");
    }

    public void Reopen(long rowId)
    {
      this.CheckDisposed();
      this.CheckOpen();
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_blob_reopen((IntPtr) this._sqlite_blob, rowId);
      if (errorCode != SQLiteErrorCode.Ok)
      {
        this.Dispose();
        throw new SQLiteException(errorCode, (string) null);
      }
    }

    public int GetCount()
    {
      this.CheckDisposed();
      this.CheckOpen();
      return UnsafeNativeMethods.sqlite3_blob_bytes((IntPtr) this._sqlite_blob);
    }

    public void Read(byte[] buffer, int count, int offset)
    {
      this.CheckDisposed();
      this.CheckOpen();
      this.VerifyParameters(buffer, count, offset);
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_blob_read((IntPtr) this._sqlite_blob, buffer, count, offset);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, (string) null);
    }

    public void Write(byte[] buffer, int count, int offset)
    {
      this.CheckDisposed();
      this.CheckOpen();
      this.VerifyParameters(buffer, count, offset);
      SQLiteErrorCode errorCode = UnsafeNativeMethods.sqlite3_blob_write((IntPtr) this._sqlite_blob, buffer, count, offset);
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, (string) null);
    }

    public void Close() => this.Dispose();

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteBlob).Name);
    }

    private void Dispose(bool disposing)
    {
      if (this.disposed)
        return;
      if (disposing)
      {
        if (this._sqlite_blob != null)
        {
          this._sqlite_blob.Dispose();
          this._sqlite_blob = (SQLiteBlobHandle) null;
        }
        this._sql = (SQLiteBase) null;
      }
      this.disposed = true;
    }

    ~SQLiteBlob() => this.Dispose(false);
  }
}


--- SQLiteBlobHandle.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteBlobHandle
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;
using System.Threading;

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLiteBlobHandle : CriticalHandle
  {
    private SQLiteConnectionHandle cnn;

    public static implicit operator IntPtr(SQLiteBlobHandle blob)
    {
      return blob != null ? blob.handle : IntPtr.Zero;
    }

    internal SQLiteBlobHandle(SQLiteConnectionHandle cnn, IntPtr blob)
      : this()
    {
      this.cnn = cnn;
      this.SetHandle(blob);
    }

    private SQLiteBlobHandle()
      : base(IntPtr.Zero)
    {
    }

    protected override bool ReleaseHandle()
    {
      try
      {
        IntPtr blob = Interlocked.Exchange(ref this.handle, IntPtr.Zero);
        if (blob != IntPtr.Zero)
          SQLiteBase.CloseBlob(this.cnn, blob);
      }
      catch (SQLiteException ex)
      {
      }
      finally
      {
        this.SetHandleAsInvalid();
      }
      return true;
    }

    public override bool IsInvalid => this.handle == IntPtr.Zero;
  }
}


--- SQLiteBytes.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteBytes
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  internal static class SQLiteBytes
  {
    public static byte[] FromIntPtr(IntPtr pValue, int length)
    {
      if (pValue == IntPtr.Zero)
        return (byte[]) null;
      if (length == 0)
        return new byte[0];
      byte[] destination = new byte[length];
      Marshal.Copy(pValue, destination, 0, length);
      return destination;
    }

    public static IntPtr ToIntPtr(byte[] value)
    {
      if (value == null)
        return IntPtr.Zero;
      int length = value.Length;
      if (length == 0)
        return IntPtr.Zero;
      IntPtr destination = SQLiteMemory.Allocate(length);
      if (destination == IntPtr.Zero)
        return IntPtr.Zero;
      Marshal.Copy(value, 0, destination, length);
      return destination;
    }
  }
}


--- SQLiteCallback.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteCallback
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  public delegate void SQLiteCallback(IntPtr context, int argc, IntPtr argv);
}


--- SQLiteCollation.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteCollation
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  internal delegate int SQLiteCollation(IntPtr puser, int len1, IntPtr pv1, int len2, IntPtr pv2);
}


--- SQLiteCommand.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteCommand
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;
using System.ComponentModel;
using System.Data.Common;
using System.Diagnostics;
using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  [Designer("SQLite.Designer.SQLiteCommandDesigner, SQLite.Designer, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139")]
  [ToolboxItem(true)]
  public sealed class SQLiteCommand : DbCommand, ICloneable
  {
    private static readonly string DefaultConnectionString = "Data Source=:memory:;";
    private string _commandText;
    private SQLiteConnection _cnn;
    private int _version;
    private WeakReference _activeReader;
    internal int _commandTimeout;
    private bool _designTimeVisible;
    private UpdateRowSource _updateRowSource;
    private SQLiteParameterCollection _parameterCollection;
    internal List<SQLiteStatement> _statementList;
    internal string _remainingText;
    private SQLiteTransaction _transaction;
    private bool disposed;

    public SQLiteCommand()
      : this((string) null, (SQLiteConnection) null)
    {
    }

    public SQLiteCommand(string commandText)
      : this(commandText, (SQLiteConnection) null, (SQLiteTransaction) null)
    {
    }

    public SQLiteCommand(string commandText, SQLiteConnection connection)
      : this(commandText, connection, (SQLiteTransaction) null)
    {
    }

    public SQLiteCommand(SQLiteConnection connection)
      : this((string) null, connection, (SQLiteTransaction) null)
    {
    }

    private SQLiteCommand(SQLiteCommand source)
      : this(source.CommandText, source.Connection, source.Transaction)
    {
      this.CommandTimeout = source.CommandTimeout;
      this.DesignTimeVisible = source.DesignTimeVisible;
      this.UpdatedRowSource = source.UpdatedRowSource;
      foreach (SQLiteParameter parameter in (DbParameterCollection) source._parameterCollection)
        this.Parameters.Add(parameter.Clone());
    }

    public SQLiteCommand(
      string commandText,
      SQLiteConnection connection,
      SQLiteTransaction transaction)
    {
      this._commandTimeout = 30;
      this._parameterCollection = new SQLiteParameterCollection(this);
      this._designTimeVisible = true;
      this._updateRowSource = UpdateRowSource.None;
      if (commandText != null)
        this.CommandText = commandText;
      if (connection != null)
      {
        this.DbConnection = (DbConnection) connection;
        this._commandTimeout = connection.DefaultTimeout;
      }
      if (transaction != null)
        this.Transaction = transaction;
      SQLiteConnection.OnChanged(connection, new ConnectionEventArgs(SQLiteConnectionEventType.NewCommand, (StateChangeEventArgs) null, (IDbTransaction) transaction, (IDbCommand) this, (IDataReader) null, (CriticalHandle) null, (string) null, (object) null));
    }

    [Conditional("CHECK_STATE")]
    internal static void Check(SQLiteCommand command)
    {
      if (command == null)
        throw new ArgumentNullException(nameof (command));
      command.CheckDisposed();
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteCommand).Name);
    }

    protected override void Dispose(bool disposing)
    {
      SQLiteConnection.OnChanged(this._cnn, new ConnectionEventArgs(SQLiteConnectionEventType.DisposingCommand, (StateChangeEventArgs) null, (IDbTransaction) this._transaction, (IDbCommand) this, (IDataReader) null, (CriticalHandle) null, (string) null, (object) new object[2]
      {
        (object) disposing,
        (object) this.disposed
      }));
      bool flag = false;
      try
      {
        if (this.disposed || !disposing)
          return;
        SQLiteDataReader sqLiteDataReader = (SQLiteDataReader) null;
        if (this._activeReader != null)
        {
          try
          {
            sqLiteDataReader = this._activeReader.Target as SQLiteDataReader;
          }
          catch (InvalidOperationException ex)
          {
          }
        }
        if (sqLiteDataReader != null)
        {
          sqLiteDataReader._disposeCommand = true;
          this._activeReader = (WeakReference) null;
          flag = true;
        }
        else
        {
          this.Connection = (SQLiteConnection) null;
          this._parameterCollection.Clear();
          this._commandText = (string) null;
        }
      }
      finally
      {
        if (!flag)
        {
          base.Dispose(disposing);
          this.disposed = true;
        }
      }
    }

    internal static SQLiteConnectionFlags GetFlags(SQLiteCommand command)
    {
      try
      {
        if (command != null)
        {
          SQLiteConnection cnn = command._cnn;
          if (cnn != null)
            return cnn.Flags;
        }
      }
      catch (ObjectDisposedException ex)
      {
      }
      return SQLiteConnectionFlags.Default;
    }

    private void DisposeStatements()
    {
      if (this._statementList == null)
        return;
      int count = this._statementList.Count;
      for (int index = 0; index < count; ++index)
        this._statementList[index]?.Dispose();
      this._statementList = (List<SQLiteStatement>) null;
    }

    private void ClearDataReader()
    {
      if (this._activeReader == null)
        return;
      SQLiteDataReader sqLiteDataReader = (SQLiteDataReader) null;
      try
      {
        sqLiteDataReader = this._activeReader.Target as SQLiteDataReader;
      }
      catch (InvalidOperationException ex)
      {
      }
      sqLiteDataReader?.Close();
      this._activeReader = (WeakReference) null;
    }

    internal void ClearCommands()
    {
      this.ClearDataReader();
      this.DisposeStatements();
      this._parameterCollection.Unbind();
    }

    internal SQLiteStatement BuildNextCommand()
    {
      SQLiteStatement activeStatement = (SQLiteStatement) null;
      try
      {
        if (this._cnn != null && this._cnn._sql != null)
        {
          if (this._statementList == null)
            this._remainingText = this._commandText;
          activeStatement = this._cnn._sql.Prepare(this._cnn, this._remainingText, this._statementList == null ? (SQLiteStatement) null : this._statementList[this._statementList.Count - 1], (uint) (this._commandTimeout * 1000), ref this._remainingText);
          if (activeStatement != null)
          {
            activeStatement._command = this;
            if (this._statementList == null)
              this._statementList = new List<SQLiteStatement>();
            this._statementList.Add(activeStatement);
            this._parameterCollection.MapParameters(activeStatement);
            activeStatement.BindParameters();
          }
        }
        return activeStatement;
      }
      catch (Exception ex)
      {
        if (activeStatement != null)
        {
          if (this._statementList != null && this._statementList.Contains(activeStatement))
            this._statementList.Remove(activeStatement);
          activeStatement.Dispose();
        }
        this._remainingText = (string) null;
        throw;
      }
    }

    internal SQLiteStatement GetStatement(int index)
    {
      if (this._statementList == null)
        return this.BuildNextCommand();
      if (index == this._statementList.Count)
        return !string.IsNullOrEmpty(this._remainingText) ? this.BuildNextCommand() : (SQLiteStatement) null;
      SQLiteStatement statement = this._statementList[index];
      statement.BindParameters();
      return statement;
    }

    public override void Cancel()
    {
      this.CheckDisposed();
      if (this._activeReader == null || !(this._activeReader.Target is SQLiteDataReader target))
        return;
      target.Cancel();
    }

    [Editor("Microsoft.VSDesigner.Data.SQL.Design.SqlCommandTextEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [DefaultValue("")]
    [RefreshProperties(RefreshProperties.All)]
    public override string CommandText
    {
      get
      {
        this.CheckDisposed();
        return this._commandText;
      }
      set
      {
        this.CheckDisposed();
        if (this._commandText == value)
          return;
        if (this._activeReader != null && this._activeReader.IsAlive)
          throw new InvalidOperationException("Cannot set CommandText while a DataReader is active");
        this.ClearCommands();
        this._commandText = value;
        SQLiteConnection cnn = this._cnn;
      }
    }

    [DefaultValue(30)]
    public override int CommandTimeout
    {
      get
      {
        this.CheckDisposed();
        return this._commandTimeout;
      }
      set
      {
        this.CheckDisposed();
        this._commandTimeout = value;
      }
    }

    [DefaultValue(CommandType.Text)]
    [RefreshProperties(RefreshProperties.All)]
    public override CommandType CommandType
    {
      get
      {
        this.CheckDisposed();
        return CommandType.Text;
      }
      set
      {
        this.CheckDisposed();
        if (value != CommandType.Text)
          throw new NotSupportedException();
      }
    }

    protected override DbParameter CreateDbParameter() => (DbParameter) this.CreateParameter();

    public SQLiteParameter CreateParameter()
    {
      this.CheckDisposed();
      return new SQLiteParameter((IDbCommand) this);
    }

    [DefaultValue(null)]
    [Editor("Microsoft.VSDesigner.Data.Design.DbConnectionEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    public SQLiteConnection Connection
    {
      get
      {
        this.CheckDisposed();
        return this._cnn;
      }
      set
      {
        this.CheckDisposed();
        if (this._activeReader != null && this._activeReader.IsAlive)
          throw new InvalidOperationException("Cannot set Connection while a DataReader is active");
        if (this._cnn != null)
          this.ClearCommands();
        this._cnn = value;
        if (this._cnn == null)
          return;
        this._version = this._cnn._version;
      }
    }

    protected override DbConnection DbConnection
    {
      get => (DbConnection) this.Connection;
      set => this.Connection = (SQLiteConnection) value;
    }

    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    public SQLiteParameterCollection Parameters
    {
      get
      {
        this.CheckDisposed();
        return this._parameterCollection;
      }
    }

    protected override DbParameterCollection DbParameterCollection
    {
      get => (DbParameterCollection) this.Parameters;
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public SQLiteTransaction Transaction
    {
      get
      {
        this.CheckDisposed();
        return this._transaction;
      }
      set
      {
        this.CheckDisposed();
        if (this._cnn != null)
        {
          if (this._activeReader != null && this._activeReader.IsAlive)
            throw new InvalidOperationException("Cannot set Transaction while a DataReader is active");
          if (value != null && value._cnn != this._cnn)
            throw new ArgumentException("Transaction is not associated with the command's connection");
          this._transaction = value;
        }
        else
        {
          if (value != null)
            this.Connection = value.Connection;
          this._transaction = value;
        }
      }
    }

    protected override DbTransaction DbTransaction
    {
      get => (DbTransaction) this.Transaction;
      set => this.Transaction = (SQLiteTransaction) value;
    }

    public void VerifyOnly()
    {
      this.CheckDisposed();
      SQLiteConnection cnn = this._cnn;
      SQLiteBase sql = cnn._sql;
      if (cnn == null || sql == null)
        throw new SQLiteException("invalid or unusable connection");
      List<SQLiteStatement> sqLiteStatementList = (List<SQLiteStatement>) null;
      SQLiteStatement sqLiteStatement1 = (SQLiteStatement) null;
      try
      {
        string strRemain = this._commandText;
        uint timeoutMS = (uint) (this._commandTimeout * 1000);
        SQLiteStatement previous = (SQLiteStatement) null;
        while (strRemain != null && strRemain.Length > 0)
        {
          sqLiteStatement1 = sql.Prepare(cnn, strRemain, previous, timeoutMS, ref strRemain);
          previous = sqLiteStatement1;
          if (sqLiteStatement1 != null)
          {
            if (sqLiteStatementList == null)
              sqLiteStatementList = new List<SQLiteStatement>();
            sqLiteStatementList.Add(sqLiteStatement1);
            sqLiteStatement1 = (SQLiteStatement) null;
          }
          if (strRemain != null)
            strRemain = strRemain.Trim();
        }
      }
      finally
      {
        sqLiteStatement1?.Dispose();
        if (sqLiteStatementList != null)
        {
          foreach (SQLiteStatement sqLiteStatement2 in sqLiteStatementList)
            sqLiteStatement2?.Dispose();
          sqLiteStatementList.Clear();
        }
      }
    }

    private void InitializeForReader()
    {
      if (this._activeReader != null && this._activeReader.IsAlive)
        throw new InvalidOperationException("DataReader already active on this command");
      if (this._cnn == null)
        throw new InvalidOperationException("No connection associated with this command");
      if (this._cnn.State != ConnectionState.Open)
        throw new InvalidOperationException("Database is not open");
      if (this._cnn._version != this._version)
      {
        this._version = this._cnn._version;
        this.ClearCommands();
      }
      this._parameterCollection.MapParameters((SQLiteStatement) null);
    }

    protected override DbDataReader ExecuteDbDataReader(CommandBehavior behavior)
    {
      return (DbDataReader) this.ExecuteReader(behavior);
    }

    public static object Execute(
      string commandText,
      SQLiteExecuteType executeType,
      string connectionString,
      params object[] args)
    {
      return SQLiteCommand.Execute(commandText, executeType, CommandBehavior.Default, connectionString, args);
    }

    public static object Execute(
      string commandText,
      SQLiteExecuteType executeType,
      CommandBehavior commandBehavior,
      string connectionString,
      params object[] args)
    {
      SQLiteConnection sqLiteConnection = (SQLiteConnection) null;
      try
      {
        if (connectionString == null)
          connectionString = SQLiteCommand.DefaultConnectionString;
        using (sqLiteConnection = new SQLiteConnection(connectionString))
        {
          sqLiteConnection.Open();
          using (SQLiteCommand command = sqLiteConnection.CreateCommand())
          {
            command.CommandText = commandText;
            if (args != null)
            {
              foreach (object obj in args)
              {
                if (!(obj is SQLiteParameter parameter))
                {
                  parameter = command.CreateParameter();
                  parameter.DbType = DbType.Object;
                  parameter.Value = obj;
                }
                command.Parameters.Add(parameter);
              }
            }
            switch (executeType)
            {
              case SQLiteExecuteType.NonQuery:
                return (object) command.ExecuteNonQuery(commandBehavior);
              case SQLiteExecuteType.Scalar:
                return command.ExecuteScalar(commandBehavior);
              case SQLiteExecuteType.Reader:
                bool flag = true;
                try
                {
                  return (object) command.ExecuteReader(commandBehavior | CommandBehavior.CloseConnection);
                }
                catch
                {
                  flag = false;
                  throw;
                }
                finally
                {
                  if (flag)
                    sqLiteConnection._noDispose = true;
                }
            }
          }
        }
      }
      finally
      {
        if (sqLiteConnection != null)
          sqLiteConnection._noDispose = false;
      }
      return (object) null;
    }

    public SQLiteDataReader ExecuteReader(CommandBehavior behavior)
    {
      this.CheckDisposed();
      this.InitializeForReader();
      SQLiteDataReader target = new SQLiteDataReader(this, behavior);
      this._activeReader = new WeakReference((object) target, false);
      return target;
    }

    public SQLiteDataReader ExecuteReader()
    {
      this.CheckDisposed();
      return this.ExecuteReader(CommandBehavior.Default);
    }

    internal void ResetDataReader() => this._activeReader = (WeakReference) null;

    public override int ExecuteNonQuery()
    {
      this.CheckDisposed();
      return this.ExecuteNonQuery(CommandBehavior.Default);
    }

    public int ExecuteNonQuery(CommandBehavior behavior)
    {
      this.CheckDisposed();
      using (SQLiteDataReader sqLiteDataReader = this.ExecuteReader(behavior | CommandBehavior.SingleRow | CommandBehavior.SingleResult))
      {
        do
          ;
        while (sqLiteDataReader.NextResult());
        return sqLiteDataReader.RecordsAffected;
      }
    }

    public override object ExecuteScalar()
    {
      this.CheckDisposed();
      return this.ExecuteScalar(CommandBehavior.Default);
    }

    public object ExecuteScalar(CommandBehavior behavior)
    {
      this.CheckDisposed();
      using (SQLiteDataReader sqLiteDataReader = this.ExecuteReader(behavior | CommandBehavior.SingleRow | CommandBehavior.SingleResult))
      {
        if (sqLiteDataReader.Read())
        {
          if (sqLiteDataReader.FieldCount > 0)
            return sqLiteDataReader[0];
        }
      }
      return (object) null;
    }

    public void Reset()
    {
      this.CheckDisposed();
      this.Reset(true, false);
    }

    public void Reset(bool clearBindings, bool ignoreErrors)
    {
      this.CheckDisposed();
      if (clearBindings && this._parameterCollection != null)
        this._parameterCollection.Unbind();
      this.ClearDataReader();
      if (this._statementList == null)
        return;
      SQLiteBase sql = this._cnn._sql;
      foreach (SQLiteStatement statement in this._statementList)
      {
        if (statement != null)
        {
          SQLiteStatementHandle sqliteStmt = statement._sqlite_stmt;
          if (sqliteStmt != null)
          {
            SQLiteErrorCode errorCode = sql.Reset(statement);
            if (errorCode == SQLiteErrorCode.Ok && clearBindings && SQLite3.SQLiteVersionNumber >= 3003007)
              errorCode = UnsafeNativeMethods.sqlite3_clear_bindings((IntPtr) sqliteStmt);
            if (!ignoreErrors && errorCode != SQLiteErrorCode.Ok)
              throw new SQLiteException(errorCode, sql.GetLastError());
          }
        }
      }
    }

    public override void Prepare() => this.CheckDisposed();

    [DefaultValue(UpdateRowSource.None)]
    public override UpdateRowSource UpdatedRowSource
    {
      get
      {
        this.CheckDisposed();
        return this._updateRowSource;
      }
      set
      {
        this.CheckDisposed();
        this._updateRowSource = value;
      }
    }

    [DefaultValue(true)]
    [DesignOnly(true)]
    [Browsable(false)]
    [EditorBrowsable(EditorBrowsableState.Never)]
    public override bool DesignTimeVisible
    {
      get
      {
        this.CheckDisposed();
        return this._designTimeVisible;
      }
      set
      {
        this.CheckDisposed();
        this._designTimeVisible = value;
        TypeDescriptor.Refresh((object) this);
      }
    }

    public object Clone()
    {
      this.CheckDisposed();
      return (object) new SQLiteCommand(this);
    }
  }
}


--- SQLiteCommandBuilder.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteCommandBuilder
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.ComponentModel;
using System.Data.Common;
using System.Globalization;

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteCommandBuilder : DbCommandBuilder
  {
    private bool disposed;

    public SQLiteCommandBuilder()
      : this((SQLiteDataAdapter) null)
    {
    }

    public SQLiteCommandBuilder(SQLiteDataAdapter adp)
    {
      this.QuotePrefix = "[";
      this.QuoteSuffix = "]";
      this.DataAdapter = adp;
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteCommandBuilder).Name);
    }

    protected override void Dispose(bool disposing)
    {
      try
      {
        int num = this.disposed ? 1 : 0;
      }
      finally
      {
        base.Dispose(disposing);
        this.disposed = true;
      }
    }

    protected override void ApplyParameterInfo(
      DbParameter parameter,
      DataRow row,
      StatementType statementType,
      bool whereClause)
    {
      parameter.DbType = (DbType) row[SchemaTableColumn.ProviderType];
    }

    protected override string GetParameterName(string parameterName)
    {
      return HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "@{0}", (object) parameterName);
    }

    protected override string GetParameterName(int parameterOrdinal)
    {
      return HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "@param{0}", (object) parameterOrdinal);
    }

    protected override string GetParameterPlaceholder(int parameterOrdinal)
    {
      return this.GetParameterName(parameterOrdinal);
    }

    protected override void SetRowUpdatingHandler(DbDataAdapter adapter)
    {
      if (adapter == base.DataAdapter)
        ((SQLiteDataAdapter) adapter).RowUpdating -= new EventHandler<RowUpdatingEventArgs>(this.RowUpdatingEventHandler);
      else
        ((SQLiteDataAdapter) adapter).RowUpdating += new EventHandler<RowUpdatingEventArgs>(this.RowUpdatingEventHandler);
    }

    private void RowUpdatingEventHandler(object sender, RowUpdatingEventArgs e)
    {
      this.RowUpdatingHandler(e);
    }

    public SQLiteDataAdapter DataAdapter
    {
      get
      {
        this.CheckDisposed();
        return (SQLiteDataAdapter) base.DataAdapter;
      }
      set
      {
        this.CheckDisposed();
        this.DataAdapter = (DbDataAdapter) value;
      }
    }

    public SQLiteCommand GetDeleteCommand()
    {
      this.CheckDisposed();
      return (SQLiteCommand) base.GetDeleteCommand();
    }

    public SQLiteCommand GetDeleteCommand(bool useColumnsForParameterNames)
    {
      this.CheckDisposed();
      return (SQLiteCommand) base.GetDeleteCommand(useColumnsForParameterNames);
    }

    public SQLiteCommand GetUpdateCommand()
    {
      this.CheckDisposed();
      return (SQLiteCommand) base.GetUpdateCommand();
    }

    public SQLiteCommand GetUpdateCommand(bool useColumnsForParameterNames)
    {
      this.CheckDisposed();
      return (SQLiteCommand) base.GetUpdateCommand(useColumnsForParameterNames);
    }

    public SQLiteCommand GetInsertCommand()
    {
      this.CheckDisposed();
      return (SQLiteCommand) base.GetInsertCommand();
    }

    public SQLiteCommand GetInsertCommand(bool useColumnsForParameterNames)
    {
      this.CheckDisposed();
      return (SQLiteCommand) base.GetInsertCommand(useColumnsForParameterNames);
    }

    [Browsable(false)]
    public override CatalogLocation CatalogLocation
    {
      get
      {
        this.CheckDisposed();
        return base.CatalogLocation;
      }
      set
      {
        this.CheckDisposed();
        base.CatalogLocation = value;
      }
    }

    [Browsable(false)]
    public override string CatalogSeparator
    {
      get
      {
        this.CheckDisposed();
        return base.CatalogSeparator;
      }
      set
      {
        this.CheckDisposed();
        base.CatalogSeparator = value;
      }
    }

    [DefaultValue("[")]
    [Browsable(false)]
    public override string QuotePrefix
    {
      get
      {
        this.CheckDisposed();
        return base.QuotePrefix;
      }
      set
      {
        this.CheckDisposed();
        base.QuotePrefix = value;
      }
    }

    [Browsable(false)]
    public override string QuoteSuffix
    {
      get
      {
        this.CheckDisposed();
        return base.QuoteSuffix;
      }
      set
      {
        this.CheckDisposed();
        base.QuoteSuffix = value;
      }
    }

    public override string QuoteIdentifier(string unquotedIdentifier)
    {
      this.CheckDisposed();
      return string.IsNullOrEmpty(this.QuotePrefix) || string.IsNullOrEmpty(this.QuoteSuffix) || string.IsNullOrEmpty(unquotedIdentifier) ? unquotedIdentifier : this.QuotePrefix + unquotedIdentifier.Replace(this.QuoteSuffix, this.QuoteSuffix + this.QuoteSuffix) + this.QuoteSuffix;
    }

    public override string UnquoteIdentifier(string quotedIdentifier)
    {
      this.CheckDisposed();
      return string.IsNullOrEmpty(this.QuotePrefix) || string.IsNullOrEmpty(this.QuoteSuffix) || string.IsNullOrEmpty(quotedIdentifier) || !quotedIdentifier.StartsWith(this.QuotePrefix, StringComparison.OrdinalIgnoreCase) || !quotedIdentifier.EndsWith(this.QuoteSuffix, StringComparison.OrdinalIgnoreCase) ? quotedIdentifier : quotedIdentifier.Substring(this.QuotePrefix.Length, quotedIdentifier.Length - (this.QuotePrefix.Length + this.QuoteSuffix.Length)).Replace(this.QuoteSuffix + this.QuoteSuffix, this.QuoteSuffix);
    }

    [Browsable(false)]
    public override string SchemaSeparator
    {
      get
      {
        this.CheckDisposed();
        return base.SchemaSeparator;
      }
      set
      {
        this.CheckDisposed();
        base.SchemaSeparator = value;
      }
    }

    protected override DataTable GetSchemaTable(DbCommand sourceCommand)
    {
      using (IDataReader dataReader = (IDataReader) sourceCommand.ExecuteReader(CommandBehavior.SchemaOnly | CommandBehavior.KeyInfo))
      {
        DataTable schemaTable = dataReader.GetSchemaTable();
        if (this.HasSchemaPrimaryKey(schemaTable))
          this.ResetIsUniqueSchemaColumn(schemaTable);
        return schemaTable;
      }
    }

    private bool HasSchemaPrimaryKey(DataTable schema)
    {
      DataColumn column = schema.Columns[SchemaTableColumn.IsKey];
      foreach (DataRow row in (InternalDataCollectionBase) schema.Rows)
      {
        if ((bool) row[column])
          return true;
      }
      return false;
    }

    private void ResetIsUniqueSchemaColumn(DataTable schema)
    {
      DataColumn column1 = schema.Columns[SchemaTableColumn.IsUnique];
      DataColumn column2 = schema.Columns[SchemaTableColumn.IsKey];
      foreach (DataRow row in (InternalDataCollectionBase) schema.Rows)
      {
        if (!(bool) row[column2])
          row[column1] = (object) false;
      }
      schema.AcceptChanges();
    }
  }
}


--- SQLiteCommitCallback.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteCommitCallback
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  internal delegate int SQLiteCommitCallback(IntPtr puser);
}


--- SQLiteCommitHandler.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteCommitHandler
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate void SQLiteCommitHandler(object sender, CommitEventArgs e);
}


--- SQLiteCompareDelegate.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteCompareDelegate
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate int SQLiteCompareDelegate(string param0, string param1, string param2);
}


--- SQLiteConfigDbOpsEnum.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteConfigDbOpsEnum
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum SQLiteConfigDbOpsEnum
  {
    SQLITE_DBCONFIG_NONE = 0,
    SQLITE_DBCONFIG_LOOKASIDE = 1001, // 0x000003E9
    SQLITE_DBCONFIG_ENABLE_FKEY = 1002, // 0x000003EA
    SQLITE_DBCONFIG_ENABLE_TRIGGER = 1003, // 0x000003EB
    SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER = 1004, // 0x000003EC
    SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION = 1005, // 0x000003ED
  }
}


--- SQLiteConfigOpsEnum.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteConfigOpsEnum
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  internal enum SQLiteConfigOpsEnum
  {
    SQLITE_CONFIG_NONE = 0,
    SQLITE_CONFIG_SINGLETHREAD = 1,
    SQLITE_CONFIG_MULTITHREAD = 2,
    SQLITE_CONFIG_SERIALIZED = 3,
    SQLITE_CONFIG_MALLOC = 4,
    SQLITE_CONFIG_GETMALLOC = 5,
    SQLITE_CONFIG_SCRATCH = 6,
    SQLITE_CONFIG_PAGECACHE = 7,
    SQLITE_CONFIG_HEAP = 8,
    SQLITE_CONFIG_MEMSTATUS = 9,
    SQLITE_CONFIG_MUTEX = 10, // 0x0000000A
    SQLITE_CONFIG_GETMUTEX = 11, // 0x0000000B
    SQLITE_CONFIG_LOOKASIDE = 13, // 0x0000000D
    SQLITE_CONFIG_PCACHE = 14, // 0x0000000E
    SQLITE_CONFIG_GETPCACHE = 15, // 0x0000000F
    SQLITE_CONFIG_LOG = 16, // 0x00000010
    SQLITE_CONFIG_URI = 17, // 0x00000011
    SQLITE_CONFIG_PCACHE2 = 18, // 0x00000012
    SQLITE_CONFIG_GETPCACHE2 = 19, // 0x00000013
    SQLITE_CONFIG_COVERING_INDEX_SCAN = 20, // 0x00000014
    SQLITE_CONFIG_SQLLOG = 21, // 0x00000015
    SQLITE_CONFIG_MMAP_SIZE = 22, // 0x00000016
    SQLITE_CONFIG_WIN32_HEAPSIZE = 23, // 0x00000017
    SQLITE_CONFIG_PCACHE_HDRSZ = 24, // 0x00000018
    SQLITE_CONFIG_PMASZ = 25, // 0x00000019
  }
}


--- SQLiteConnection.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteConnection
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data.Common;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Transactions;

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteConnection : DbConnection, ICloneable, IDisposable
  {
    internal const DbType BadDbType = ~DbType.AnsiString;
    internal const string DefaultBaseSchemaName = "sqlite_default_schema";
    private const string MemoryFileName = ":memory:";
    internal const System.Data.IsolationLevel DeferredIsolationLevel = System.Data.IsolationLevel.ReadCommitted;
    internal const System.Data.IsolationLevel ImmediateIsolationLevel = System.Data.IsolationLevel.Serializable;
    private const SQLiteConnectionFlags FallbackDefaultFlags = SQLiteConnectionFlags.Default;
    private const SQLiteSynchronousEnum DefaultSynchronous = SQLiteSynchronousEnum.Default;
    private const SQLiteJournalModeEnum DefaultJournalMode = SQLiteJournalModeEnum.Default;
    private const System.Data.IsolationLevel DefaultIsolationLevel = System.Data.IsolationLevel.Serializable;
    internal const SQLiteDateFormats DefaultDateTimeFormat = SQLiteDateFormats.ISO8601;
    internal const DateTimeKind DefaultDateTimeKind = DateTimeKind.Unspecified;
    internal const string DefaultDateTimeFormatString = null;
    private const string DefaultDataSource = null;
    private const string DefaultUri = null;
    private const string DefaultFullUri = null;
    private const string DefaultHexPassword = null;
    private const string DefaultPassword = null;
    private const int DefaultVersion = 3;
    private const int DefaultPageSize = 4096;
    private const int DefaultMaxPageCount = 0;
    private const int DefaultCacheSize = -2000;
    private const int DefaultMaxPoolSize = 100;
    private const int DefaultConnectionTimeout = 30;
    private const int DefaultBusyTimeout = 0;
    private const bool DefaultNoDefaultFlags = false;
    private const bool DefaultNoSharedFlags = false;
    private const bool DefaultFailIfMissing = false;
    private const bool DefaultReadOnly = false;
    internal const bool DefaultBinaryGUID = true;
    private const bool DefaultUseUTF16Encoding = false;
    private const bool DefaultToFullPath = true;
    private const bool DefaultPooling = false;
    private const bool DefaultLegacyFormat = false;
    private const bool DefaultForeignKeys = false;
    private const bool DefaultRecursiveTriggers = false;
    private const bool DefaultEnlist = true;
    private const bool DefaultSetDefaults = true;
    internal const int DefaultPrepareRetries = 3;
    private const string DefaultVfsName = null;
    private const int DefaultProgressOps = 0;
    private const int SQLITE_FCNTL_CHUNK_SIZE = 6;
    private const int SQLITE_FCNTL_WIN32_AV_RETRY = 9;
    private const string _dataDirectory = "|DataDirectory|";
    private const string _masterdb = "sqlite_master";
    private const string _tempmasterdb = "sqlite_temp_master";
    private static readonly Assembly _assembly = typeof (SQLiteConnection).Assembly;
    private static readonly object _syncRoot = new object();
    private static SQLiteConnectionFlags _sharedFlags;
    [ThreadStatic]
    private static SQLiteConnection _lastConnectionInOpen;
    private ConnectionState _connectionState;
    private string _connectionString;
    internal int _transactionLevel;
    internal bool _noDispose;
    private bool _disposing;
    private System.Data.IsolationLevel _defaultIsolation;
    internal SQLiteEnlistment _enlistment;
    internal SQLiteDbTypeMap _typeNames;
    private SQLiteTypeCallbacksMap _typeCallbacks;
    internal SQLiteBase _sql;
    private string _dataSource;
    private byte[] _password;
    internal string _baseSchemaName;
    private SQLiteConnectionFlags _flags;
    private Dictionary<string, object> _cachedSettings;
    private DbType? _defaultDbType;
    private string _defaultTypeName;
    private string _vfsName;
    private int _defaultTimeout = 30;
    private int _busyTimeout;
    internal int _prepareRetries = 3;
    private int _progressOps;
    private bool _parseViaFramework;
    internal bool _binaryGuid;
    internal int _version;
    private SQLiteProgressCallback _progressCallback;
    private SQLiteAuthorizerCallback _authorizerCallback;
    private SQLiteUpdateCallback _updateCallback;
    private SQLiteCommitCallback _commitCallback;
    private SQLiteTraceCallback _traceCallback;
    private SQLiteRollbackCallback _rollbackCallback;
    private bool disposed;

    private static event SQLiteConnectionEventHandler _handlers;

    private event SQLiteProgressEventHandler _progressHandler;

    private event SQLiteAuthorizerEventHandler _authorizerHandler;

    private event SQLiteUpdateEventHandler _updateHandler;

    private event SQLiteCommitHandler _commitHandler;

    private event SQLiteTraceEventHandler _traceHandler;

    private event EventHandler _rollbackHandler;

    public override event StateChangeEventHandler StateChange;

    public SQLiteConnection()
      : this((string) null)
    {
    }

    public SQLiteConnection(string connectionString)
      : this(connectionString, false)
    {
    }

    internal SQLiteConnection(IntPtr db, string fileName, bool ownHandle)
      : this()
    {
      this._sql = (SQLiteBase) new SQLite3(SQLiteDateFormats.ISO8601, DateTimeKind.Unspecified, (string) null, db, fileName, ownHandle);
      this._flags = SQLiteConnectionFlags.None;
      this._connectionState = db != IntPtr.Zero ? ConnectionState.Open : ConnectionState.Closed;
      this._connectionString = (string) null;
    }

    public SQLiteConnection(string connectionString, bool parseViaFramework)
    {
      this._noDispose = false;
      UnsafeNativeMethods.Initialize();
      SQLiteLog.Initialize();
      this._cachedSettings = new Dictionary<string, object>((IEqualityComparer<string>) new TypeNameStringComparer());
      this._typeNames = new SQLiteDbTypeMap();
      this._typeCallbacks = new SQLiteTypeCallbacksMap();
      this._parseViaFramework = parseViaFramework;
      this._flags = SQLiteConnectionFlags.None;
      this._defaultDbType = new DbType?();
      this._defaultTypeName = (string) null;
      this._vfsName = (string) null;
      this._connectionState = ConnectionState.Closed;
      this._connectionString = (string) null;
      if (connectionString == null)
        return;
      this.ConnectionString = connectionString;
    }

    public SQLiteConnection(SQLiteConnection connection)
      : this(connection.ConnectionString, connection.ParseViaFramework)
    {
      if (connection.State != ConnectionState.Open)
        return;
      this.Open();
      using (DataTable schema = connection.GetSchema("Catalogs"))
      {
        foreach (DataRow row in (InternalDataCollectionBase) schema.Rows)
        {
          string strA = row[0].ToString();
          if (string.Compare(strA, "main", StringComparison.OrdinalIgnoreCase) != 0 && string.Compare(strA, "temp", StringComparison.OrdinalIgnoreCase) != 0)
          {
            using (SQLiteCommand command = this.CreateCommand())
            {
              command.CommandText = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "ATTACH DATABASE '{0}' AS [{1}]", row[1], row[0]);
              command.ExecuteNonQuery();
            }
          }
        }
      }
    }

    internal static void OnChanged(SQLiteConnection connection, ConnectionEventArgs e)
    {
      if (connection != null && !connection.CanRaiseEvents)
        return;
      SQLiteConnectionEventHandler connectionEventHandler;
      lock (SQLiteConnection._syncRoot)
        connectionEventHandler = SQLiteConnection._handlers == null ? (SQLiteConnectionEventHandler) null : SQLiteConnection._handlers.Clone() as SQLiteConnectionEventHandler;
      if (connectionEventHandler == null)
        return;
      connectionEventHandler((object) connection, e);
    }

    public static event SQLiteConnectionEventHandler Changed
    {
      add
      {
        lock (SQLiteConnection._syncRoot)
        {
          SQLiteConnection._handlers -= value;
          SQLiteConnection._handlers += value;
        }
      }
      remove
      {
        lock (SQLiteConnection._syncRoot)
          SQLiteConnection._handlers -= value;
      }
    }

    public static ISQLiteConnectionPool ConnectionPool
    {
      get => SQLiteConnectionPool.GetConnectionPool();
      set => SQLiteConnectionPool.SetConnectionPool(value);
    }

    public static object CreateHandle(IntPtr nativeHandle)
    {
      SQLiteConnectionHandle handle;
      try
      {
      }
      finally
      {
        handle = nativeHandle != IntPtr.Zero ? new SQLiteConnectionHandle(nativeHandle, true) : (SQLiteConnectionHandle) null;
      }
      if (handle != null)
        SQLiteConnection.OnChanged((SQLiteConnection) null, new ConnectionEventArgs(SQLiteConnectionEventType.NewCriticalHandle, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) handle, (string) null, (object) new object[2]
        {
          (object) typeof (SQLiteConnection),
          (object) nativeHandle
        }));
      return (object) handle;
    }

    public void BackupDatabase(
      SQLiteConnection destination,
      string destinationName,
      string sourceName,
      int pages,
      SQLiteBackupCallback callback,
      int retryMilliseconds)
    {
      this.CheckDisposed();
      if (this._connectionState != ConnectionState.Open)
        throw new InvalidOperationException("Source database is not open.");
      if (destination == null)
        throw new ArgumentNullException(nameof (destination));
      if (destination._connectionState != ConnectionState.Open)
        throw new ArgumentException("Destination database is not open.", nameof (destination));
      if (destinationName == null)
        throw new ArgumentNullException(nameof (destinationName));
      if (sourceName == null)
        throw new ArgumentNullException(nameof (sourceName));
      SQLiteBase sql = this._sql;
      if (sql == null)
        throw new InvalidOperationException("Connection object has an invalid handle.");
      SQLiteBackup backup = (SQLiteBackup) null;
      try
      {
        backup = sql.InitializeBackup(destination, destinationName, sourceName);
        bool retry = false;
        while (sql.StepBackup(backup, pages, ref retry) && (callback == null || callback(this, sourceName, destination, destinationName, pages, sql.RemainingBackup(backup), sql.PageCountBackup(backup), retry)))
        {
          if (retry && retryMilliseconds >= 0)
            Thread.Sleep(retryMilliseconds);
          if (pages == 0)
            break;
        }
      }
      catch (Exception ex)
      {
        if ((this._flags & SQLiteConnectionFlags.LogBackup) == SQLiteConnectionFlags.LogBackup)
          SQLiteLog.LogMessage(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception while backing up database: {0}", (object) ex));
        throw;
      }
      finally
      {
        if (backup != null)
          sql.FinishBackup(backup);
      }
    }

    public int ClearCachedSettings()
    {
      this.CheckDisposed();
      int num = -1;
      if (this._cachedSettings != null)
      {
        num = this._cachedSettings.Count;
        this._cachedSettings.Clear();
      }
      return num;
    }

    internal bool TryGetCachedSetting(string name, object @default, out object value)
    {
      if (name != null && this._cachedSettings != null)
        return this._cachedSettings.TryGetValue(name, out value);
      value = @default;
      return false;
    }

    internal void SetCachedSetting(string name, object value)
    {
      if (name == null || this._cachedSettings == null)
        return;
      this._cachedSettings[name] = value;
    }

    public int ClearTypeMappings()
    {
      this.CheckDisposed();
      int num = -1;
      if (this._typeNames != null)
        num = this._typeNames.Clear();
      return num;
    }

    public Dictionary<string, object> GetTypeMappings()
    {
      this.CheckDisposed();
      Dictionary<string, object> typeMappings = (Dictionary<string, object>) null;
      if (this._typeNames != null)
      {
        typeMappings = new Dictionary<string, object>(this._typeNames.Count, this._typeNames.Comparer);
        foreach (KeyValuePair<string, SQLiteDbTypeMapping> typeName in (Dictionary<string, SQLiteDbTypeMapping>) this._typeNames)
        {
          SQLiteDbTypeMapping liteDbTypeMapping = typeName.Value;
          object obj1 = (object) null;
          object obj2 = (object) null;
          object obj3 = (object) null;
          if (liteDbTypeMapping != null)
          {
            obj1 = (object) liteDbTypeMapping.typeName;
            obj2 = (object) liteDbTypeMapping.dataType;
            obj3 = (object) liteDbTypeMapping.primary;
          }
          typeMappings.Add(typeName.Key, (object) new object[3]
          {
            obj1,
            obj2,
            obj3
          });
        }
      }
      return typeMappings;
    }

    public int AddTypeMapping(string typeName, DbType dataType, bool primary)
    {
      this.CheckDisposed();
      if (typeName == null)
        throw new ArgumentNullException(nameof (typeName));
      int num = -1;
      if (this._typeNames != null)
      {
        num = 0;
        if (primary && this._typeNames.ContainsKey(dataType))
          num += this._typeNames.Remove(dataType) ? 1 : 0;
        if (this._typeNames.ContainsKey(typeName))
          num += this._typeNames.Remove(typeName) ? 1 : 0;
        this._typeNames.Add(new SQLiteDbTypeMapping(typeName, dataType, primary));
      }
      return num;
    }

    public int ClearTypeCallbacks()
    {
      this.CheckDisposed();
      int num = -1;
      if (this._typeCallbacks != null)
      {
        num = this._typeCallbacks.Count;
        this._typeCallbacks.Clear();
      }
      return num;
    }

    public bool TryGetTypeCallbacks(string typeName, out SQLiteTypeCallbacks callbacks)
    {
      this.CheckDisposed();
      if (typeName == null)
        throw new ArgumentNullException(nameof (typeName));
      if (this._typeCallbacks != null)
        return this._typeCallbacks.TryGetValue(typeName, out callbacks);
      callbacks = (SQLiteTypeCallbacks) null;
      return false;
    }

    public bool SetTypeCallbacks(string typeName, SQLiteTypeCallbacks callbacks)
    {
      this.CheckDisposed();
      if (typeName == null)
        throw new ArgumentNullException(nameof (typeName));
      if (this._typeCallbacks == null)
        return false;
      if (callbacks == null)
        return this._typeCallbacks.Remove(typeName);
      callbacks.TypeName = typeName;
      this._typeCallbacks[typeName] = callbacks;
      return true;
    }

    public void BindFunction(SQLiteFunctionAttribute functionAttribute, SQLiteFunction function)
    {
      this.CheckDisposed();
      if (this._sql == null)
        throw new InvalidOperationException("Database connection not valid for binding functions.");
      this._sql.BindFunction(functionAttribute, function, this._flags);
    }

    public void BindFunction(
      SQLiteFunctionAttribute functionAttribute,
      Delegate callback1,
      Delegate callback2)
    {
      this.CheckDisposed();
      if (this._sql == null)
        throw new InvalidOperationException("Database connection not valid for binding functions.");
      this._sql.BindFunction(functionAttribute, (SQLiteFunction) new SQLiteDelegateFunction(callback1, callback2), this._flags);
    }

    public bool UnbindFunction(SQLiteFunctionAttribute functionAttribute)
    {
      this.CheckDisposed();
      if (this._sql == null)
        throw new InvalidOperationException("Database connection not valid for unbinding functions.");
      return this._sql.UnbindFunction(functionAttribute, this._flags);
    }

    public bool UnbindAllFunctions(bool registered)
    {
      this.CheckDisposed();
      if (this._sql == null)
        throw new InvalidOperationException("Database connection not valid for unbinding functions.");
      return SQLiteFunction.UnbindAllFunctions(this._sql, this._flags, registered);
    }

    [Conditional("CHECK_STATE")]
    internal static void Check(SQLiteConnection connection)
    {
      if (connection == null)
        throw new ArgumentNullException(nameof (connection));
      connection.CheckDisposed();
      if (connection._connectionState != ConnectionState.Open)
        throw new InvalidOperationException("The connection is not open.");
      if (!(connection._sql is SQLite3 sql1))
        throw new InvalidOperationException("The connection handle wrapper is null.");
      SQLiteConnectionHandle sql2 = sql1._sql;
      if (sql2 == null)
        throw new InvalidOperationException("The connection handle is null.");
      if (sql2.IsInvalid)
        throw new InvalidOperationException("The connection handle is invalid.");
      if (sql2.IsClosed)
        throw new InvalidOperationException("The connection handle is closed.");
    }

    internal static SortedList<string, string> ParseConnectionString(
      string connectionString,
      bool parseViaFramework,
      bool allowNameOnly)
    {
      return SQLiteConnection.ParseConnectionString((SQLiteConnection) null, connectionString, parseViaFramework, allowNameOnly);
    }

    private static SortedList<string, string> ParseConnectionString(
      SQLiteConnection connection,
      string connectionString,
      bool parseViaFramework,
      bool allowNameOnly)
    {
      return !parseViaFramework ? SQLiteConnection.ParseConnectionString(connection, connectionString, allowNameOnly) : SQLiteConnection.ParseConnectionStringViaFramework(connection, connectionString, false);
    }

    private void SetupSQLiteBase(SortedList<string, string> opts)
    {
      SQLiteDateFormats fmt = SQLiteConnection.TryParseEnum(typeof (SQLiteDateFormats), SQLiteConnection.FindKey(opts, "DateTimeFormat", SQLiteDateFormats.ISO8601.ToString()), true) is SQLiteDateFormats sqLiteDateFormats ? sqLiteDateFormats : SQLiteDateFormats.ISO8601;
      DateTimeKind kind = SQLiteConnection.TryParseEnum(typeof (DateTimeKind), SQLiteConnection.FindKey(opts, "DateTimeKind", DateTimeKind.Unspecified.ToString()), true) is DateTimeKind dateTimeKind ? dateTimeKind : DateTimeKind.Unspecified;
      string key = SQLiteConnection.FindKey(opts, "DateTimeFormatString", (string) null);
      if (SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(opts, "UseUTF16Encoding", false.ToString())))
        this._sql = (SQLiteBase) new SQLite3_UTF16(fmt, kind, key, IntPtr.Zero, (string) null, false);
      else
        this._sql = (SQLiteBase) new SQLite3(fmt, kind, key, IntPtr.Zero, (string) null, false);
    }

    public new void Dispose()
    {
      if (this._noDispose)
        return;
      base.Dispose();
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteConnection).Name);
    }

    protected override void Dispose(bool disposing)
    {
      if ((this._flags & SQLiteConnectionFlags.TraceWarning) == SQLiteConnectionFlags.TraceWarning && this._noDispose)
        System.Diagnostics.Trace.WriteLine(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "WARNING: Disposing of connection \"{0}\" with the no-dispose flag set.", (object) this._connectionString));
      this._disposing = true;
      try
      {
        if (this.disposed)
          return;
        this.Close();
      }
      finally
      {
        base.Dispose(disposing);
        this.disposed = true;
      }
    }

    public object Clone()
    {
      this.CheckDisposed();
      return (object) new SQLiteConnection(this);
    }

    public static void CreateFile(string databaseFileName) => File.Create(databaseFileName).Close();

    internal void OnStateChange(ConnectionState newState, ref StateChangeEventArgs eventArgs)
    {
      ConnectionState connectionState = this._connectionState;
      this._connectionState = newState;
      if (this.StateChange == null || newState == connectionState)
        return;
      StateChangeEventArgs e = new StateChangeEventArgs(connectionState, newState);
      this.StateChange((object) this, e);
      eventArgs = e;
    }

    private static System.Data.IsolationLevel GetFallbackDefaultIsolationLevel()
    {
      return System.Data.IsolationLevel.Serializable;
    }

    internal System.Data.IsolationLevel GetDefaultIsolationLevel() => this._defaultIsolation;

    [Obsolete("Use one of the standard BeginTransaction methods, this one will be removed soon")]
    public SQLiteTransaction BeginTransaction(System.Data.IsolationLevel isolationLevel, bool deferredLock)
    {
      this.CheckDisposed();
      return (SQLiteTransaction) this.BeginDbTransaction(!deferredLock ? System.Data.IsolationLevel.Serializable : System.Data.IsolationLevel.ReadCommitted);
    }

    [Obsolete("Use one of the standard BeginTransaction methods, this one will be removed soon")]
    public SQLiteTransaction BeginTransaction(bool deferredLock)
    {
      this.CheckDisposed();
      return (SQLiteTransaction) this.BeginDbTransaction(!deferredLock ? System.Data.IsolationLevel.Serializable : System.Data.IsolationLevel.ReadCommitted);
    }

    public SQLiteTransaction BeginTransaction(System.Data.IsolationLevel isolationLevel)
    {
      this.CheckDisposed();
      return (SQLiteTransaction) this.BeginDbTransaction(isolationLevel);
    }

    public SQLiteTransaction BeginTransaction()
    {
      this.CheckDisposed();
      return (SQLiteTransaction) this.BeginDbTransaction(this._defaultIsolation);
    }

    protected override DbTransaction BeginDbTransaction(System.Data.IsolationLevel isolationLevel)
    {
      if (this._connectionState != ConnectionState.Open)
        throw new InvalidOperationException();
      if (isolationLevel == System.Data.IsolationLevel.Unspecified)
        isolationLevel = this._defaultIsolation;
      isolationLevel = this.GetEffectiveIsolationLevel(isolationLevel);
      SQLiteTransaction transaction = isolationLevel == System.Data.IsolationLevel.Serializable || isolationLevel == System.Data.IsolationLevel.ReadCommitted ? new SQLiteTransaction(this, isolationLevel != System.Data.IsolationLevel.Serializable) : throw new ArgumentException(nameof (isolationLevel));
      SQLiteConnection.OnChanged(this, new ConnectionEventArgs(SQLiteConnectionEventType.NewTransaction, (StateChangeEventArgs) null, (IDbTransaction) transaction, (IDbCommand) null, (IDataReader) null, (CriticalHandle) null, (string) null, (object) null));
      return (DbTransaction) transaction;
    }

    public override void ChangeDatabase(string databaseName)
    {
      this.CheckDisposed();
      SQLiteConnection.OnChanged(this, new ConnectionEventArgs(SQLiteConnectionEventType.ChangeDatabase, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) null, databaseName, (object) null));
      throw new NotImplementedException();
    }

    public override void Close()
    {
      this.CheckDisposed();
      SQLiteConnection.OnChanged(this, new ConnectionEventArgs(SQLiteConnectionEventType.Closing, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) null, (string) null, (object) null));
      if (this._sql != null)
      {
        if (this._enlistment != null)
        {
          SQLiteConnection sqLiteConnection = new SQLiteConnection()
          {
            _sql = this._sql,
            _transactionLevel = this._transactionLevel,
            _enlistment = this._enlistment,
            _connectionState = this._connectionState,
            _version = this._version
          };
          sqLiteConnection._enlistment._transaction._cnn = sqLiteConnection;
          sqLiteConnection._enlistment._disposeConnection = true;
          this._sql = (SQLiteBase) null;
          this._enlistment = (SQLiteEnlistment) null;
        }
        if (this._sql != null)
        {
          this._sql.Close(!this._disposing);
          this._sql = (SQLiteBase) null;
        }
        this._transactionLevel = 0;
      }
      StateChangeEventArgs eventArgs = (StateChangeEventArgs) null;
      this.OnStateChange(ConnectionState.Closed, ref eventArgs);
      SQLiteConnection.OnChanged(this, new ConnectionEventArgs(SQLiteConnectionEventType.Closed, eventArgs, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) null, (string) null, (object) null));
    }

    public int PoolCount => this._sql == null ? 0 : this._sql.CountPool();

    public static void ClearPool(SQLiteConnection connection)
    {
      if (connection._sql == null)
        return;
      connection._sql.ClearPool();
    }

    public static void ClearAllPools() => SQLiteConnectionPool.ClearAllPools();

    [Editor("SQLite.Designer.SQLiteConnectionStringEditor, SQLite.Designer, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [RefreshProperties(RefreshProperties.All)]
    [DefaultValue("")]
    public override string ConnectionString
    {
      get
      {
        this.CheckDisposed();
        return this._connectionString;
      }
      set
      {
        this.CheckDisposed();
        if (value == null)
          throw new ArgumentNullException();
        if (this._connectionState != ConnectionState.Closed)
          throw new InvalidOperationException();
        this._connectionString = value;
      }
    }

    public SQLiteCommand CreateCommand()
    {
      this.CheckDisposed();
      return new SQLiteCommand(this);
    }

    protected override DbCommand CreateDbCommand() => (DbCommand) this.CreateCommand();

    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public override string DataSource
    {
      get
      {
        this.CheckDisposed();
        return this._dataSource;
      }
    }

    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public string FileName
    {
      get
      {
        this.CheckDisposed();
        return this._sql != null ? this._sql.GetFileName("main") : throw new InvalidOperationException("Database connection not valid for getting file name.");
      }
    }

    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public override string Database
    {
      get
      {
        this.CheckDisposed();
        return "main";
      }
    }

    internal static string MapUriPath(string path)
    {
      if (path.StartsWith("file://", StringComparison.OrdinalIgnoreCase))
        return path.Substring(7);
      if (path.StartsWith("file:", StringComparison.OrdinalIgnoreCase))
        return path.Substring(5);
      return path.StartsWith("/", StringComparison.OrdinalIgnoreCase) ? path : throw new InvalidOperationException("Invalid connection string: invalid URI");
    }

    private static bool ShouldUseLegacyConnectionStringParser(SQLiteConnection connection)
    {
      string name = "No_SQLiteConnectionNewParser";
      object obj;
      return connection != null && connection.TryGetCachedSetting(name, (object) null, out obj) || connection == null && SQLiteConnection.TryGetLastCachedSetting(name, (object) null, out obj) || UnsafeNativeMethods.GetSettingValue(name, (string) null) != null;
    }

    private static SortedList<string, string> ParseConnectionString(
      string connectionString,
      bool allowNameOnly)
    {
      return SQLiteConnection.ParseConnectionString((SQLiteConnection) null, connectionString, allowNameOnly);
    }

    private static SortedList<string, string> ParseConnectionString(
      SQLiteConnection connection,
      string connectionString,
      bool allowNameOnly)
    {
      string source = connectionString;
      SortedList<string, string> connectionString1 = new SortedList<string, string>((IComparer<string>) StringComparer.OrdinalIgnoreCase);
      string error = (string) null;
      string[] strArray = !SQLiteConnection.ShouldUseLegacyConnectionStringParser(connection) ? SQLiteConvert.NewSplit(source, ';', true, ref error) : SQLiteConvert.Split(source, ';');
      if (strArray == null)
        throw new ArgumentException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Invalid ConnectionString format, cannot parse: {0}", (object) (error ?? "could not split connection string into properties")));
      int length1 = strArray != null ? strArray.Length : 0;
      for (int index = 0; index < length1; ++index)
      {
        if (strArray[index] != null)
        {
          strArray[index] = strArray[index].Trim();
          if (strArray[index].Length != 0)
          {
            int length2 = strArray[index].IndexOf('=');
            if (length2 != -1)
              connectionString1.Add(SQLiteConnection.UnwrapString(strArray[index].Substring(0, length2).Trim()), SQLiteConnection.UnwrapString(strArray[index].Substring(length2 + 1).Trim()));
            else if (allowNameOnly)
              connectionString1.Add(SQLiteConnection.UnwrapString(strArray[index].Trim()), string.Empty);
            else
              throw new ArgumentException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Invalid ConnectionString format for part \"{0}\", no equal sign found", (object) strArray[index]));
          }
        }
      }
      return connectionString1;
    }

    private static SortedList<string, string> ParseConnectionStringViaFramework(
      SQLiteConnection connection,
      string connectionString,
      bool strict)
    {
      DbConnectionStringBuilder connectionStringBuilder = new DbConnectionStringBuilder();
      connectionStringBuilder.ConnectionString = connectionString;
      SortedList<string, string> stringViaFramework = new SortedList<string, string>((IComparer<string>) StringComparer.OrdinalIgnoreCase);
      foreach (string key in (IEnumerable) connectionStringBuilder.Keys)
      {
        object obj = connectionStringBuilder[key];
        string str = (string) null;
        if (obj is string)
        {
          str = (string) obj;
        }
        else
        {
          if (strict)
            throw new ArgumentException("connection property value is not a string", key);
          if (obj != null)
            str = obj.ToString();
        }
        stringViaFramework.Add(key, str);
      }
      return stringViaFramework;
    }

    public override void EnlistTransaction(Transaction transaction)
    {
      this.CheckDisposed();
      if (this._enlistment != null && transaction == this._enlistment._scope)
        return;
      if (this._enlistment != null)
        throw new ArgumentException("Already enlisted in a transaction");
      if (this._transactionLevel > 0 && transaction != (Transaction) null)
        throw new ArgumentException("Unable to enlist in transaction, a local transaction already exists");
      if (transaction == (Transaction) null)
        throw new ArgumentNullException("Unable to enlist in transaction, it is null");
      bool flag = (this._flags & SQLiteConnectionFlags.StrictEnlistment) == SQLiteConnectionFlags.StrictEnlistment;
      this._enlistment = new SQLiteEnlistment(this, transaction, SQLiteConnection.GetFallbackDefaultIsolationLevel(), flag, flag);
      SQLiteConnection.OnChanged(this, new ConnectionEventArgs(SQLiteConnectionEventType.EnlistTransaction, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) null, (string) null, (object) new object[1]
      {
        (object) this._enlistment
      }));
    }

    internal static string FindKey(SortedList<string, string> items, string key, string defValue)
    {
      string str;
      return string.IsNullOrEmpty(key) || !items.TryGetValue(key, out str) && !items.TryGetValue(key.Replace(" ", string.Empty), out str) && !items.TryGetValue(key.Replace(" ", "_"), out str) ? defValue : str;
    }

    internal static object TryParseEnum(Type type, string value, bool ignoreCase)
    {
      if (!string.IsNullOrEmpty(value))
      {
        try
        {
          return Enum.Parse(type, value, ignoreCase);
        }
        catch
        {
        }
      }
      return (object) null;
    }

    private static bool TryParseByte(string value, NumberStyles style, out byte result)
    {
      return byte.TryParse(value, style, (IFormatProvider) null, out result);
    }

    public void SetConfigurationOption(SQLiteConfigDbOpsEnum option, bool enable)
    {
      this.CheckDisposed();
      if (this._sql == null)
        throw new InvalidOperationException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Database connection not valid for {0} a configuration option.", enable ? (object) "enabling" : (object) "disabling"));
      if (option == SQLiteConfigDbOpsEnum.SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION && (this._flags & SQLiteConnectionFlags.NoLoadExtension) == SQLiteConnectionFlags.NoLoadExtension)
        throw new SQLiteException("Loading extensions is disabled for this database connection.");
      int num = (int) this._sql.SetConfigurationOption(option, enable);
    }

    public void EnableExtensions(bool enable)
    {
      this.CheckDisposed();
      if (this._sql == null)
        throw new InvalidOperationException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Database connection not valid for {0} extensions.", enable ? (object) "enabling" : (object) "disabling"));
      if ((this._flags & SQLiteConnectionFlags.NoLoadExtension) == SQLiteConnectionFlags.NoLoadExtension)
        throw new SQLiteException("Loading extensions is disabled for this database connection.");
      this._sql.SetLoadExtension(enable);
    }

    public void LoadExtension(string fileName)
    {
      this.CheckDisposed();
      this.LoadExtension(fileName, (string) null);
    }

    public void LoadExtension(string fileName, string procName)
    {
      this.CheckDisposed();
      if (this._sql == null)
        throw new InvalidOperationException("Database connection not valid for loading extensions.");
      if ((this._flags & SQLiteConnectionFlags.NoLoadExtension) == SQLiteConnectionFlags.NoLoadExtension)
        throw new SQLiteException("Loading extensions is disabled for this database connection.");
      this._sql.LoadExtension(fileName, procName);
    }

    public void CreateModule(SQLiteModule module)
    {
      this.CheckDisposed();
      if (this._sql == null)
        throw new InvalidOperationException("Database connection not valid for creating modules.");
      if ((this._flags & SQLiteConnectionFlags.NoCreateModule) == SQLiteConnectionFlags.NoCreateModule)
        throw new SQLiteException("Creating modules is disabled for this database connection.");
      this._sql.CreateModule(module, this._flags);
    }

    internal static byte[] FromHexString(string text)
    {
      string error = (string) null;
      return SQLiteConnection.FromHexString(text, ref error);
    }

    internal static string ToHexString(byte[] array)
    {
      if (array == null)
        return (string) null;
      StringBuilder stringBuilder = new StringBuilder();
      int length = array.Length;
      for (int index = 0; index < length; ++index)
        stringBuilder.AppendFormat("{0:x2}", (object) array[index]);
      return stringBuilder.ToString();
    }

    private static byte[] FromHexString(string text, ref string error)
    {
      if (text == null)
      {
        error = "string is null";
        return (byte[]) null;
      }
      if (text.Length % 2 != 0)
      {
        error = "string contains an odd number of characters";
        return (byte[]) null;
      }
      byte[] numArray = new byte[text.Length / 2];
      for (int startIndex = 0; startIndex < text.Length; startIndex += 2)
      {
        string str = text.Substring(startIndex, 2);
        if (!SQLiteConnection.TryParseByte(str, NumberStyles.HexNumber, out numArray[startIndex / 2]))
        {
          error = HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "string contains \"{0}\", which cannot be converted to a byte value", (object) str);
          return (byte[]) null;
        }
      }
      return numArray;
    }

    private bool GetDefaultPooling()
    {
      bool defaultPooling = false;
      if (defaultPooling)
      {
        if ((this._flags & SQLiteConnectionFlags.NoConnectionPool) == SQLiteConnectionFlags.NoConnectionPool)
          defaultPooling = false;
        if ((this._flags & SQLiteConnectionFlags.UseConnectionPool) == SQLiteConnectionFlags.UseConnectionPool)
          defaultPooling = true;
      }
      else
      {
        if ((this._flags & SQLiteConnectionFlags.UseConnectionPool) == SQLiteConnectionFlags.UseConnectionPool)
          defaultPooling = true;
        if ((this._flags & SQLiteConnectionFlags.NoConnectionPool) == SQLiteConnectionFlags.NoConnectionPool)
          defaultPooling = false;
      }
      return defaultPooling;
    }

    private System.Data.IsolationLevel GetEffectiveIsolationLevel(System.Data.IsolationLevel isolationLevel)
    {
      if ((this._flags & SQLiteConnectionFlags.MapIsolationLevels) != SQLiteConnectionFlags.MapIsolationLevels)
        return isolationLevel;
      switch (isolationLevel)
      {
        case System.Data.IsolationLevel.Unspecified:
        case System.Data.IsolationLevel.Chaos:
        case System.Data.IsolationLevel.ReadUncommitted:
        case System.Data.IsolationLevel.ReadCommitted:
          return System.Data.IsolationLevel.ReadCommitted;
        case System.Data.IsolationLevel.RepeatableRead:
        case System.Data.IsolationLevel.Serializable:
        case System.Data.IsolationLevel.Snapshot:
          return System.Data.IsolationLevel.Serializable;
        default:
          return SQLiteConnection.GetFallbackDefaultIsolationLevel();
      }
    }

    public override void Open()
    {
      this.CheckDisposed();
      SQLiteConnection._lastConnectionInOpen = this;
      SQLiteConnection.OnChanged(this, new ConnectionEventArgs(SQLiteConnectionEventType.Opening, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) null, (string) null, (object) null));
      if (this._connectionState != ConnectionState.Closed)
        throw new InvalidOperationException();
      this.Close();
      SortedList<string, string> connectionString = SQLiteConnection.ParseConnectionString(this, this._connectionString, this._parseViaFramework, false);
      SQLiteConnection.OnChanged(this, new ConnectionEventArgs(SQLiteConnectionEventType.ConnectionString, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) null, this._connectionString, (object) new object[1]
      {
        (object) connectionString
      }));
      object obj = SQLiteConnection.TryParseEnum(typeof (SQLiteConnectionFlags), SQLiteConnection.FindKey(connectionString, "Flags", (string) null), true);
      bool boolean1 = SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(connectionString, "NoDefaultFlags", false.ToString()));
      if (obj is SQLiteConnectionFlags liteConnectionFlags)
        this._flags |= liteConnectionFlags;
      else if (!boolean1)
        this._flags |= SQLiteConnection.DefaultFlags;
      if (!SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(connectionString, "NoSharedFlags", false.ToString())))
      {
        lock (SQLiteConnection._syncRoot)
          this._flags |= SQLiteConnection._sharedFlags;
      }
      this._defaultDbType = SQLiteConnection.TryParseEnum(typeof (DbType), SQLiteConnection.FindKey(connectionString, "DefaultDbType", (string) null), true) is DbType dbType ? new DbType?(dbType) : new DbType?();
      if (this._defaultDbType.HasValue && this._defaultDbType.Value == ~DbType.AnsiString)
        this._defaultDbType = new DbType?();
      this._defaultTypeName = SQLiteConnection.FindKey(connectionString, "DefaultTypeName", (string) null);
      this._vfsName = SQLiteConnection.FindKey(connectionString, "VfsName", (string) null);
      bool flag1 = false;
      bool flag2 = false;
      string str = Convert.ToInt32(SQLiteConnection.FindKey(connectionString, "Version", 3.ToString()), (IFormatProvider) CultureInfo.InvariantCulture) == 3 ? SQLiteConnection.FindKey(connectionString, "Data Source", (string) null) : throw new NotSupportedException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Only SQLite Version {0} is supported at this time", (object) 3));
      if (string.IsNullOrEmpty(str))
      {
        string key = SQLiteConnection.FindKey(connectionString, "Uri", (string) null);
        if (string.IsNullOrEmpty(key))
        {
          str = SQLiteConnection.FindKey(connectionString, "FullUri", (string) null);
          if (string.IsNullOrEmpty(str))
            throw new ArgumentException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Data Source cannot be empty.  Use {0} to open an in-memory database", (object) ":memory:"));
          flag2 = true;
        }
        else
        {
          str = SQLiteConnection.MapUriPath(key);
          flag1 = true;
        }
      }
      bool flag3 = string.Compare(str, ":memory:", StringComparison.OrdinalIgnoreCase) == 0;
      if ((this._flags & SQLiteConnectionFlags.TraceWarning) == SQLiteConnectionFlags.TraceWarning && !flag1 && !flag2 && !flag3 && !string.IsNullOrEmpty(str) && str.StartsWith("\\", StringComparison.OrdinalIgnoreCase) && !str.StartsWith("\\\\", StringComparison.OrdinalIgnoreCase))
        System.Diagnostics.Trace.WriteLine(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "WARNING: Detected a possibly malformed UNC database file name \"{0}\" that may have originally started with two backslashes; however, four leading backslashes may be required, e.g.: \"Data Source=\\\\\\{0};\"", (object) str));
      if (!flag2)
      {
        if (flag3)
        {
          str = ":memory:";
        }
        else
        {
          bool boolean2 = SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(connectionString, "ToFullPath", true.ToString()));
          str = SQLiteConnection.ExpandFileName(str, boolean2);
        }
      }
      try
      {
        bool boolean3 = SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(connectionString, "Pooling", this.GetDefaultPooling().ToString()));
        int int32_1 = Convert.ToInt32(SQLiteConnection.FindKey(connectionString, "Max Pool Size", 100.ToString()), (IFormatProvider) CultureInfo.InvariantCulture);
        this._defaultTimeout = Convert.ToInt32(SQLiteConnection.FindKey(connectionString, "Default Timeout", 30.ToString()), (IFormatProvider) CultureInfo.InvariantCulture);
        this._busyTimeout = Convert.ToInt32(SQLiteConnection.FindKey(connectionString, "BusyTimeout", 0.ToString()), (IFormatProvider) CultureInfo.InvariantCulture);
        this._prepareRetries = Convert.ToInt32(SQLiteConnection.FindKey(connectionString, "PrepareRetries", 3.ToString()), (IFormatProvider) CultureInfo.InvariantCulture);
        this._progressOps = Convert.ToInt32(SQLiteConnection.FindKey(connectionString, "ProgressOps", 0.ToString()), (IFormatProvider) CultureInfo.InvariantCulture);
        this._defaultIsolation = SQLiteConnection.TryParseEnum(typeof (System.Data.IsolationLevel), SQLiteConnection.FindKey(connectionString, "Default IsolationLevel", System.Data.IsolationLevel.Serializable.ToString()), true) is System.Data.IsolationLevel isolationLevel ? isolationLevel : System.Data.IsolationLevel.Serializable;
        this._defaultIsolation = this.GetEffectiveIsolationLevel(this._defaultIsolation);
        if (this._defaultIsolation != System.Data.IsolationLevel.Serializable && this._defaultIsolation != System.Data.IsolationLevel.ReadCommitted)
          throw new NotSupportedException("Invalid Default IsolationLevel specified");
        this._baseSchemaName = SQLiteConnection.FindKey(connectionString, "BaseSchemaName", "sqlite_default_schema");
        if (this._sql == null)
          this.SetupSQLiteBase(connectionString);
        SQLiteOpenFlagsEnum liteOpenFlagsEnum = SQLiteOpenFlagsEnum.None;
        if (!SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(connectionString, "FailIfMissing", false.ToString())))
          liteOpenFlagsEnum |= SQLiteOpenFlagsEnum.Create;
        SQLiteOpenFlagsEnum openFlags = !SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(connectionString, "Read Only", false.ToString())) ? liteOpenFlagsEnum | SQLiteOpenFlagsEnum.ReadWrite : (liteOpenFlagsEnum | SQLiteOpenFlagsEnum.ReadOnly) & ~SQLiteOpenFlagsEnum.Create;
        if (flag2)
          openFlags |= SQLiteOpenFlagsEnum.Uri;
        this._sql.Open(str, this._vfsName, this._flags, openFlags, int32_1, boolean3);
        this._binaryGuid = SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(connectionString, "BinaryGUID", true.ToString()));
        string key1 = SQLiteConnection.FindKey(connectionString, "HexPassword", (string) null);
        if (key1 != null)
        {
          string error = (string) null;
          this._sql.SetPassword(SQLiteConnection.FromHexString(key1, ref error) ?? throw new FormatException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Cannot parse 'HexPassword' property value into byte values: {0}", (object) error)));
        }
        else
        {
          string key2 = SQLiteConnection.FindKey(connectionString, "Password", (string) null);
          if (key2 != null)
            this._sql.SetPassword(Encoding.UTF8.GetBytes(key2));
          else if (this._password != null)
            this._sql.SetPassword(this._password);
        }
        this._password = (byte[]) null;
        this._dataSource = flag2 ? str : Path.GetFileNameWithoutExtension(str);
        ++this._version;
        ConnectionState connectionState = this._connectionState;
        this._connectionState = ConnectionState.Open;
        try
        {
          if (SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(connectionString, "SetDefaults", true.ToString())))
          {
            using (SQLiteCommand command = this.CreateCommand())
            {
              if (this._busyTimeout != 0)
              {
                command.CommandText = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA busy_timeout={0}", (object) this._busyTimeout);
                command.ExecuteNonQuery();
              }
              if (!flag2 && !flag3)
              {
                int int32_2 = Convert.ToInt32(SQLiteConnection.FindKey(connectionString, "Page Size", 4096.ToString()), (IFormatProvider) CultureInfo.InvariantCulture);
                if (int32_2 != 4096)
                {
                  command.CommandText = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA page_size={0}", (object) int32_2);
                  command.ExecuteNonQuery();
                }
              }
              int int32_3 = Convert.ToInt32(SQLiteConnection.FindKey(connectionString, "Max Page Count", 0.ToString()), (IFormatProvider) CultureInfo.InvariantCulture);
              if (int32_3 != 0)
              {
                command.CommandText = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA max_page_count={0}", (object) int32_3);
                command.ExecuteNonQuery();
              }
              bool boolean4 = SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(connectionString, "Legacy Format", false.ToString()));
              if (boolean4)
              {
                command.CommandText = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA legacy_file_format={0}", boolean4 ? (object) "ON" : (object) "OFF");
                command.ExecuteNonQuery();
              }
              string key3 = SQLiteConnection.FindKey(connectionString, "Synchronous", SQLiteSynchronousEnum.Default.ToString());
              if (!(SQLiteConnection.TryParseEnum(typeof (SQLiteSynchronousEnum), key3, true) is SQLiteSynchronousEnum.Default))
              {
                command.CommandText = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA synchronous={0}", (object) key3);
                command.ExecuteNonQuery();
              }
              int int32_4 = Convert.ToInt32(SQLiteConnection.FindKey(connectionString, "Cache Size", -2000.ToString()), (IFormatProvider) CultureInfo.InvariantCulture);
              if (int32_4 != -2000)
              {
                command.CommandText = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA cache_size={0}", (object) int32_4);
                command.ExecuteNonQuery();
              }
              string key4 = SQLiteConnection.FindKey(connectionString, "Journal Mode", SQLiteJournalModeEnum.Default.ToString());
              if (!(SQLiteConnection.TryParseEnum(typeof (SQLiteJournalModeEnum), key4, true) is SQLiteJournalModeEnum.Default))
              {
                string format = "PRAGMA journal_mode={0}";
                command.CommandText = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, format, (object) key4);
                command.ExecuteNonQuery();
              }
              bool boolean5 = SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(connectionString, "Foreign Keys", false.ToString()));
              if (boolean5)
              {
                command.CommandText = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA foreign_keys={0}", boolean5 ? (object) "ON" : (object) "OFF");
                command.ExecuteNonQuery();
              }
              bool boolean6 = SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(connectionString, "Recursive Triggers", false.ToString()));
              if (boolean6)
              {
                command.CommandText = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA recursive_triggers={0}", boolean6 ? (object) "ON" : (object) "OFF");
                command.ExecuteNonQuery();
              }
            }
          }
          if (this._progressHandler != null)
            this._sql.SetProgressHook(this._progressOps, this._progressCallback);
          if (this._authorizerHandler != null)
            this._sql.SetAuthorizerHook(this._authorizerCallback);
          if (this._commitHandler != null)
            this._sql.SetCommitHook(this._commitCallback);
          if (this._updateHandler != null)
            this._sql.SetUpdateHook(this._updateCallback);
          if (this._rollbackHandler != null)
            this._sql.SetRollbackHook(this._rollbackCallback);
          Transaction current = Transaction.Current;
          if (current != (Transaction) null && SQLiteConvert.ToBoolean(SQLiteConnection.FindKey(connectionString, "Enlist", true.ToString())))
            this.EnlistTransaction(current);
          this._connectionState = connectionState;
          StateChangeEventArgs eventArgs = (StateChangeEventArgs) null;
          this.OnStateChange(ConnectionState.Open, ref eventArgs);
          SQLiteConnection.OnChanged(this, new ConnectionEventArgs(SQLiteConnectionEventType.Opened, eventArgs, (IDbTransaction) null, (IDbCommand) null, (IDataReader) null, (CriticalHandle) null, (string) null, (object) null));
        }
        catch
        {
          this._connectionState = connectionState;
          throw;
        }
      }
      catch (SQLiteException ex)
      {
        this.Close();
        throw;
      }
    }

    public SQLiteConnection OpenAndReturn()
    {
      this.CheckDisposed();
      this.Open();
      return this;
    }

    public int DefaultTimeout
    {
      get
      {
        this.CheckDisposed();
        return this._defaultTimeout;
      }
      set
      {
        this.CheckDisposed();
        this._defaultTimeout = value;
      }
    }

    public int BusyTimeout
    {
      get
      {
        this.CheckDisposed();
        return this._busyTimeout;
      }
      set
      {
        this.CheckDisposed();
        this._busyTimeout = value;
      }
    }

    public int PrepareRetries
    {
      get
      {
        this.CheckDisposed();
        return this._prepareRetries;
      }
      set
      {
        this.CheckDisposed();
        this._prepareRetries = value;
      }
    }

    public int ProgressOps
    {
      get
      {
        this.CheckDisposed();
        return this._progressOps;
      }
      set
      {
        this.CheckDisposed();
        this._progressOps = value;
      }
    }

    public bool ParseViaFramework
    {
      get
      {
        this.CheckDisposed();
        return this._parseViaFramework;
      }
      set
      {
        this.CheckDisposed();
        this._parseViaFramework = value;
      }
    }

    public SQLiteConnectionFlags Flags
    {
      get
      {
        this.CheckDisposed();
        return this._flags;
      }
      set
      {
        this.CheckDisposed();
        this._flags = value;
      }
    }

    public DbType? DefaultDbType
    {
      get
      {
        this.CheckDisposed();
        return this._defaultDbType;
      }
      set
      {
        this.CheckDisposed();
        this._defaultDbType = value;
      }
    }

    public string DefaultTypeName
    {
      get
      {
        this.CheckDisposed();
        return this._defaultTypeName;
      }
      set
      {
        this.CheckDisposed();
        this._defaultTypeName = value;
      }
    }

    public string VfsName
    {
      get
      {
        this.CheckDisposed();
        return this._vfsName;
      }
      set
      {
        this.CheckDisposed();
        this._vfsName = value;
      }
    }

    public bool OwnHandle
    {
      get
      {
        this.CheckDisposed();
        return this._sql != null ? this._sql.OwnHandle : throw new InvalidOperationException("Database connection not valid for checking handle.");
      }
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public override string ServerVersion
    {
      get
      {
        this.CheckDisposed();
        return SQLiteConnection.SQLiteVersion;
      }
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public long LastInsertRowId
    {
      get
      {
        this.CheckDisposed();
        return this._sql != null ? this._sql.LastInsertRowId : throw new InvalidOperationException("Database connection not valid for getting last insert rowid.");
      }
    }

    public void Cancel()
    {
      this.CheckDisposed();
      if (this._sql == null)
        throw new InvalidOperationException("Database connection not valid for query cancellation.");
      this._sql.Cancel();
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public int Changes
    {
      get
      {
        this.CheckDisposed();
        return this._sql != null ? this._sql.Changes : throw new InvalidOperationException("Database connection not valid for getting number of changes.");
      }
    }

    public bool IsReadOnly(string name)
    {
      this.CheckDisposed();
      return this._sql != null ? this._sql.IsReadOnly(name) : throw new InvalidOperationException("Database connection not valid for checking read-only status.");
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public bool AutoCommit
    {
      get
      {
        this.CheckDisposed();
        return this._sql != null ? this._sql.AutoCommit : throw new InvalidOperationException("Database connection not valid for getting autocommit mode.");
      }
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public long MemoryUsed
    {
      get
      {
        this.CheckDisposed();
        return this._sql != null ? this._sql.MemoryUsed : throw new InvalidOperationException("Database connection not valid for getting memory used.");
      }
    }

    [Browsable(false)]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    public long MemoryHighwater
    {
      get
      {
        this.CheckDisposed();
        return this._sql != null ? this._sql.MemoryHighwater : throw new InvalidOperationException("Database connection not valid for getting maximum memory used.");
      }
    }

    public static void GetMemoryStatistics(ref IDictionary<string, long> statistics)
    {
      if (statistics == null)
        statistics = (IDictionary<string, long>) new Dictionary<string, long>();
      statistics["MemoryUsed"] = SQLite3.StaticMemoryUsed;
      statistics["MemoryHighwater"] = SQLite3.StaticMemoryHighwater;
    }

    public void ReleaseMemory()
    {
      this.CheckDisposed();
      SQLiteErrorCode errorCode = this._sql != null ? this._sql.ReleaseMemory() : throw new InvalidOperationException("Database connection not valid for releasing memory.");
      if (errorCode != SQLiteErrorCode.Ok)
        throw new SQLiteException(errorCode, this._sql.GetLastError("Could not release connection memory."));
    }

    public static SQLiteErrorCode ReleaseMemory(
      int nBytes,
      bool reset,
      bool compact,
      ref int nFree,
      ref bool resetOk,
      ref uint nLargest)
    {
      return SQLite3.StaticReleaseMemory(nBytes, reset, compact, ref nFree, ref resetOk, ref nLargest);
    }

    public static SQLiteErrorCode SetMemoryStatus(bool value)
    {
      return SQLite3.StaticSetMemoryStatus(value);
    }

    public static string DefineConstants => SQLite3.DefineConstants;

    public static string SQLiteVersion => SQLite3.SQLiteVersion;

    public static string SQLiteSourceId => SQLite3.SQLiteSourceId;

    public static string SQLiteCompileOptions => SQLite3.SQLiteCompileOptions;

    public static string InteropVersion => SQLite3.InteropVersion;

    public static string InteropSourceId => SQLite3.InteropSourceId;

    public static string InteropCompileOptions => SQLite3.InteropCompileOptions;

    public static string ProviderVersion
    {
      get
      {
        return !(SQLiteConnection._assembly != (Assembly) null) ? (string) null : SQLiteConnection._assembly.GetName().Version.ToString();
      }
    }

    public static string ProviderSourceId
    {
      get
      {
        if (SQLiteConnection._assembly == (Assembly) null)
          return (string) null;
        string str1 = (string) null;
        if (SQLiteConnection._assembly.IsDefined(typeof (AssemblySourceIdAttribute), false))
          str1 = ((AssemblySourceIdAttribute) SQLiteConnection._assembly.GetCustomAttributes(typeof (AssemblySourceIdAttribute), false)[0]).SourceId;
        string str2 = (string) null;
        if (SQLiteConnection._assembly.IsDefined(typeof (AssemblySourceTimeStampAttribute), false))
          str2 = ((AssemblySourceTimeStampAttribute) SQLiteConnection._assembly.GetCustomAttributes(typeof (AssemblySourceTimeStampAttribute), false)[0]).SourceTimeStamp;
        if (str1 == null && str2 == null)
          return (string) null;
        if (str1 == null)
          str1 = "0000000000000000000000000000000000000000";
        if (str2 == null)
          str2 = "0000-00-00 00:00:00 UTC";
        return HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "{0} {1}", (object) str1, (object) str2);
      }
    }

    private static bool TryGetLastCachedSetting(string name, object @default, out object value)
    {
      if (SQLiteConnection._lastConnectionInOpen != null)
        return SQLiteConnection._lastConnectionInOpen.TryGetCachedSetting(name, @default, out value);
      value = @default;
      return false;
    }

    public static SQLiteConnectionFlags DefaultFlags
    {
      get
      {
        string name = "DefaultFlags_SQLiteConnection";
        object settingValue;
        if (!SQLiteConnection.TryGetLastCachedSetting(name, (object) null, out settingValue))
          settingValue = (object) UnsafeNativeMethods.GetSettingValue(name, (string) null);
        return settingValue == null || !(SQLiteConnection.TryParseEnum(typeof (SQLiteConnectionFlags), settingValue.ToString(), true) is SQLiteConnectionFlags liteConnectionFlags) ? SQLiteConnectionFlags.Default : liteConnectionFlags;
      }
    }

    public static SQLiteConnectionFlags SharedFlags
    {
      get
      {
        lock (SQLiteConnection._syncRoot)
          return SQLiteConnection._sharedFlags;
      }
      set
      {
        lock (SQLiteConnection._syncRoot)
          SQLiteConnection._sharedFlags = value;
      }
    }

    [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    [Browsable(false)]
    public override ConnectionState State
    {
      get
      {
        this.CheckDisposed();
        return this._connectionState;
      }
    }

    public SQLiteErrorCode Shutdown()
    {
      this.CheckDisposed();
      if (this._sql == null)
        throw new InvalidOperationException("Database connection not valid for shutdown.");
      this._sql.Close(true);
      return this._sql.Shutdown();
    }

    public static void Shutdown(bool directories, bool noThrow)
    {
      SQLiteErrorCode errorCode = SQLite3.StaticShutdown(directories);
      if (errorCode != SQLiteErrorCode.Ok && !noThrow)
        throw new SQLiteException(errorCode, (string) null);
    }

    public void SetExtendedResultCodes(bool bOnOff)
    {
      this.CheckDisposed();
      if (this._sql == null)
        return;
      this._sql.SetExtendedResultCodes(bOnOff);
    }

    public SQLiteErrorCode ResultCode()
    {
      this.CheckDisposed();
      return this._sql != null ? this._sql.ResultCode() : throw new InvalidOperationException("Database connection not valid for getting result code.");
    }

    public SQLiteErrorCode ExtendedResultCode()
    {
      this.CheckDisposed();
      return this._sql != null ? this._sql.ExtendedResultCode() : throw new InvalidOperationException("Database connection not valid for getting extended result code.");
    }

    public void LogMessage(SQLiteErrorCode iErrCode, string zMessage)
    {
      this.CheckDisposed();
      if (this._sql == null)
        throw new InvalidOperationException("Database connection not valid for logging message.");
      this._sql.LogMessage(iErrCode, zMessage);
    }

    public void LogMessage(int iErrCode, string zMessage)
    {
      this.CheckDisposed();
      if (this._sql == null)
        throw new InvalidOperationException("Database connection not valid for logging message.");
      this._sql.LogMessage((SQLiteErrorCode) iErrCode, zMessage);
    }

    public void ChangePassword(string newPassword)
    {
      this.CheckDisposed();
      this.ChangePassword(string.IsNullOrEmpty(newPassword) ? (byte[]) null : Encoding.UTF8.GetBytes(newPassword));
    }

    public void ChangePassword(byte[] newPassword)
    {
      this.CheckDisposed();
      if (this._connectionState != ConnectionState.Open)
        throw new InvalidOperationException("Database must be opened before changing the password.");
      this._sql.ChangePassword(newPassword);
    }

    public void SetPassword(string databasePassword)
    {
      this.CheckDisposed();
      this.SetPassword(string.IsNullOrEmpty(databasePassword) ? (byte[]) null : Encoding.UTF8.GetBytes(databasePassword));
    }

    public void SetPassword(byte[] databasePassword)
    {
      this.CheckDisposed();
      if (this._connectionState != ConnectionState.Closed)
        throw new InvalidOperationException("Password can only be set before the database is opened.");
      if (databasePassword != null && databasePassword.Length == 0)
        databasePassword = (byte[]) null;
      this._password = databasePassword;
    }

    public SQLiteErrorCode SetAvRetry(ref int count, ref int interval)
    {
      this.CheckDisposed();
      if (this._connectionState != ConnectionState.Open)
        throw new InvalidOperationException("Database must be opened before changing the AV retry parameters.");
      IntPtr num = IntPtr.Zero;
      SQLiteErrorCode sqLiteErrorCode;
      try
      {
        num = Marshal.AllocHGlobal(8);
        Marshal.WriteInt32(num, 0, count);
        Marshal.WriteInt32(num, 4, interval);
        sqLiteErrorCode = this._sql.FileControl((string) null, 9, num);
        if (sqLiteErrorCode == SQLiteErrorCode.Ok)
        {
          count = Marshal.ReadInt32(num, 0);
          interval = Marshal.ReadInt32(num, 4);
        }
      }
      finally
      {
        if (num != IntPtr.Zero)
          Marshal.FreeHGlobal(num);
      }
      return sqLiteErrorCode;
    }

    public SQLiteErrorCode SetChunkSize(int size)
    {
      this.CheckDisposed();
      if (this._connectionState != ConnectionState.Open)
        throw new InvalidOperationException("Database must be opened before changing the chunk size.");
      IntPtr num = IntPtr.Zero;
      try
      {
        num = Marshal.AllocHGlobal(4);
        Marshal.WriteInt32(num, 0, size);
        return this._sql.FileControl((string) null, 6, num);
      }
      finally
      {
        if (num != IntPtr.Zero)
          Marshal.FreeHGlobal(num);
      }
    }

    private static string UnwrapString(string value)
    {
      if (string.IsNullOrEmpty(value))
        return value;
      int length = value.Length;
      return value[0] == '\'' && value[length - 1] == '\'' || value[0] == '"' && value[length - 1] == '"' ? value.Substring(1, length - 2) : value;
    }

    private static string GetDataDirectory()
    {
      string dataDirectory = AppDomain.CurrentDomain.GetData("DataDirectory") as string;
      if (string.IsNullOrEmpty(dataDirectory))
        dataDirectory = AppDomain.CurrentDomain.BaseDirectory;
      return dataDirectory;
    }

    private static string ExpandFileName(string sourceFile, bool toFullPath)
    {
      if (string.IsNullOrEmpty(sourceFile))
        return sourceFile;
      if (sourceFile.StartsWith("|DataDirectory|", StringComparison.OrdinalIgnoreCase))
      {
        string dataDirectory = SQLiteConnection.GetDataDirectory();
        if (sourceFile.Length > "|DataDirectory|".Length && ((int) sourceFile["|DataDirectory|".Length] == (int) Path.DirectorySeparatorChar || (int) sourceFile["|DataDirectory|".Length] == (int) Path.AltDirectorySeparatorChar))
          sourceFile = sourceFile.Remove("|DataDirectory|".Length, 1);
        sourceFile = Path.Combine(dataDirectory, sourceFile.Substring("|DataDirectory|".Length));
      }
      if (toFullPath)
        sourceFile = Path.GetFullPath(sourceFile);
      return sourceFile;
    }

    public override DataTable GetSchema()
    {
      this.CheckDisposed();
      return this.GetSchema("MetaDataCollections", (string[]) null);
    }

    public override DataTable GetSchema(string collectionName)
    {
      this.CheckDisposed();
      return this.GetSchema(collectionName, new string[0]);
    }

    public override DataTable GetSchema(string collectionName, string[] restrictionValues)
    {
      this.CheckDisposed();
      if (this._connectionState != ConnectionState.Open)
        throw new InvalidOperationException();
      string[] strArray = new string[5];
      if (restrictionValues == null)
        restrictionValues = new string[0];
      restrictionValues.CopyTo((Array) strArray, 0);
      switch (collectionName.ToUpper(CultureInfo.InvariantCulture))
      {
        case "METADATACOLLECTIONS":
          return SQLiteConnection.Schema_MetaDataCollections();
        case "DATASOURCEINFORMATION":
          return this.Schema_DataSourceInformation();
        case "DATATYPES":
          return this.Schema_DataTypes();
        case "COLUMNS":
        case "TABLECOLUMNS":
          return this.Schema_Columns(strArray[0], strArray[2], strArray[3]);
        case "INDEXES":
          return this.Schema_Indexes(strArray[0], strArray[2], strArray[3]);
        case "TRIGGERS":
          return this.Schema_Triggers(strArray[0], strArray[2], strArray[3]);
        case "INDEXCOLUMNS":
          return this.Schema_IndexColumns(strArray[0], strArray[2], strArray[3], strArray[4]);
        case "TABLES":
          return this.Schema_Tables(strArray[0], strArray[2], strArray[3]);
        case "VIEWS":
          return this.Schema_Views(strArray[0], strArray[2]);
        case "VIEWCOLUMNS":
          return this.Schema_ViewColumns(strArray[0], strArray[2], strArray[3]);
        case "FOREIGNKEYS":
          return this.Schema_ForeignKeys(strArray[0], strArray[2], strArray[3]);
        case "CATALOGS":
          return this.Schema_Catalogs(strArray[0]);
        case "RESERVEDWORDS":
          return SQLiteConnection.Schema_ReservedWords();
        default:
          throw new NotSupportedException();
      }
    }

    private static DataTable Schema_ReservedWords()
    {
      DataTable dataTable = new DataTable("ReservedWords");
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add("ReservedWord", typeof (string));
      dataTable.Columns.Add("MaximumVersion", typeof (string));
      dataTable.Columns.Add("MinimumVersion", typeof (string));
      dataTable.BeginLoadData();
      string keywords = SR.Keywords;
      char[] chArray = new char[1]{ ',' };
      foreach (string str in keywords.Split(chArray))
      {
        DataRow row = dataTable.NewRow();
        row[0] = (object) str;
        dataTable.Rows.Add(row);
      }
      dataTable.AcceptChanges();
      dataTable.EndLoadData();
      return dataTable;
    }

    private static DataTable Schema_MetaDataCollections()
    {
      DataTable dataTable = new DataTable("MetaDataCollections");
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add("CollectionName", typeof (string));
      dataTable.Columns.Add("NumberOfRestrictions", typeof (int));
      dataTable.Columns.Add("NumberOfIdentifierParts", typeof (int));
      dataTable.BeginLoadData();
      StringReader reader = new StringReader(SR.MetaDataCollections);
      int num = (int) dataTable.ReadXml((TextReader) reader);
      reader.Close();
      dataTable.AcceptChanges();
      dataTable.EndLoadData();
      return dataTable;
    }

    private DataTable Schema_DataSourceInformation()
    {
      DataTable dataTable = new DataTable("DataSourceInformation");
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add(DbMetaDataColumnNames.CompositeIdentifierSeparatorPattern, typeof (string));
      dataTable.Columns.Add(DbMetaDataColumnNames.DataSourceProductName, typeof (string));
      dataTable.Columns.Add(DbMetaDataColumnNames.DataSourceProductVersion, typeof (string));
      dataTable.Columns.Add(DbMetaDataColumnNames.DataSourceProductVersionNormalized, typeof (string));
      dataTable.Columns.Add(DbMetaDataColumnNames.GroupByBehavior, typeof (int));
      dataTable.Columns.Add(DbMetaDataColumnNames.IdentifierPattern, typeof (string));
      dataTable.Columns.Add(DbMetaDataColumnNames.IdentifierCase, typeof (int));
      dataTable.Columns.Add(DbMetaDataColumnNames.OrderByColumnsInSelect, typeof (bool));
      dataTable.Columns.Add(DbMetaDataColumnNames.ParameterMarkerFormat, typeof (string));
      dataTable.Columns.Add(DbMetaDataColumnNames.ParameterMarkerPattern, typeof (string));
      dataTable.Columns.Add(DbMetaDataColumnNames.ParameterNameMaxLength, typeof (int));
      dataTable.Columns.Add(DbMetaDataColumnNames.ParameterNamePattern, typeof (string));
      dataTable.Columns.Add(DbMetaDataColumnNames.QuotedIdentifierPattern, typeof (string));
      dataTable.Columns.Add(DbMetaDataColumnNames.QuotedIdentifierCase, typeof (int));
      dataTable.Columns.Add(DbMetaDataColumnNames.StatementSeparatorPattern, typeof (string));
      dataTable.Columns.Add(DbMetaDataColumnNames.StringLiteralPattern, typeof (string));
      dataTable.Columns.Add(DbMetaDataColumnNames.SupportedJoinOperators, typeof (int));
      dataTable.BeginLoadData();
      DataRow row = dataTable.NewRow();
      row.ItemArray = new object[17]
      {
        null,
        (object) "SQLite",
        (object) this._sql.Version,
        (object) this._sql.Version,
        (object) 3,
        (object) "(^\\[\\p{Lo}\\p{Lu}\\p{Ll}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Nd}@$#_]*$)|(^\\[[^\\]\\0]|\\]\\]+\\]$)|(^\\\"[^\\\"\\0]|\\\"\\\"+\\\"$)",
        (object) 1,
        (object) false,
        (object) "{0}",
        (object) "@[\\p{Lo}\\p{Lu}\\p{Ll}\\p{Lm}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Lm}\\p{Nd}\\uff3f_@#\\$]*(?=\\s+|$)",
        (object) (int) byte.MaxValue,
        (object) "^[\\p{Lo}\\p{Lu}\\p{Ll}\\p{Lm}_@#][\\p{Lo}\\p{Lu}\\p{Ll}\\p{Lm}\\p{Nd}\\uff3f_@#\\$]*(?=\\s+|$)",
        (object) "(([^\\[]|\\]\\])*)",
        (object) 1,
        (object) ";",
        (object) "'(([^']|'')*)'",
        (object) 15
      };
      dataTable.Rows.Add(row);
      dataTable.AcceptChanges();
      dataTable.EndLoadData();
      return dataTable;
    }

    private DataTable Schema_Columns(string strCatalog, string strTable, string strColumn)
    {
      DataTable dataTable = new DataTable("Columns");
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add("TABLE_CATALOG", typeof (string));
      dataTable.Columns.Add("TABLE_SCHEMA", typeof (string));
      dataTable.Columns.Add("TABLE_NAME", typeof (string));
      dataTable.Columns.Add("COLUMN_NAME", typeof (string));
      dataTable.Columns.Add("COLUMN_GUID", typeof (Guid));
      dataTable.Columns.Add("COLUMN_PROPID", typeof (long));
      dataTable.Columns.Add("ORDINAL_POSITION", typeof (int));
      dataTable.Columns.Add("COLUMN_HASDEFAULT", typeof (bool));
      dataTable.Columns.Add("COLUMN_DEFAULT", typeof (string));
      dataTable.Columns.Add("COLUMN_FLAGS", typeof (long));
      dataTable.Columns.Add("IS_NULLABLE", typeof (bool));
      dataTable.Columns.Add("DATA_TYPE", typeof (string));
      dataTable.Columns.Add("TYPE_GUID", typeof (Guid));
      dataTable.Columns.Add("CHARACTER_MAXIMUM_LENGTH", typeof (int));
      dataTable.Columns.Add("CHARACTER_OCTET_LENGTH", typeof (int));
      dataTable.Columns.Add("NUMERIC_PRECISION", typeof (int));
      dataTable.Columns.Add("NUMERIC_SCALE", typeof (int));
      dataTable.Columns.Add("DATETIME_PRECISION", typeof (long));
      dataTable.Columns.Add("CHARACTER_SET_CATALOG", typeof (string));
      dataTable.Columns.Add("CHARACTER_SET_SCHEMA", typeof (string));
      dataTable.Columns.Add("CHARACTER_SET_NAME", typeof (string));
      dataTable.Columns.Add("COLLATION_CATALOG", typeof (string));
      dataTable.Columns.Add("COLLATION_SCHEMA", typeof (string));
      dataTable.Columns.Add("COLLATION_NAME", typeof (string));
      dataTable.Columns.Add("DOMAIN_CATALOG", typeof (string));
      dataTable.Columns.Add("DOMAIN_NAME", typeof (string));
      dataTable.Columns.Add("DESCRIPTION", typeof (string));
      dataTable.Columns.Add("PRIMARY_KEY", typeof (bool));
      dataTable.Columns.Add("EDM_TYPE", typeof (string));
      dataTable.Columns.Add("AUTOINCREMENT", typeof (bool));
      dataTable.Columns.Add("UNIQUE", typeof (bool));
      dataTable.BeginLoadData();
      if (string.IsNullOrEmpty(strCatalog))
        strCatalog = "main";
      string str = string.Compare(strCatalog, "temp", StringComparison.OrdinalIgnoreCase) == 0 ? "sqlite_temp_master" : "sqlite_master";
      using (SQLiteCommand sqLiteCommand1 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT * FROM [{0}].[{1}] WHERE [type] LIKE 'table' OR [type] LIKE 'view'", (object) strCatalog, (object) str), this))
      {
        using (SQLiteDataReader sqLiteDataReader1 = sqLiteCommand1.ExecuteReader())
        {
          while (sqLiteDataReader1.Read())
          {
            if (!string.IsNullOrEmpty(strTable))
            {
              if (string.Compare(strTable, sqLiteDataReader1.GetString(2), StringComparison.OrdinalIgnoreCase) != 0)
                continue;
            }
            try
            {
              using (SQLiteCommand sqLiteCommand2 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT * FROM [{0}].[{1}]", (object) strCatalog, (object) sqLiteDataReader1.GetString(2)), this))
              {
                using (SQLiteDataReader sqLiteDataReader2 = sqLiteCommand2.ExecuteReader(CommandBehavior.SchemaOnly))
                {
                  using (DataTable schemaTable = sqLiteDataReader2.GetSchemaTable(true, true))
                  {
                    foreach (DataRow row1 in (InternalDataCollectionBase) schemaTable.Rows)
                    {
                      if (string.Compare(row1[SchemaTableColumn.ColumnName].ToString(), strColumn, StringComparison.OrdinalIgnoreCase) == 0 || strColumn == null)
                      {
                        DataRow row2 = dataTable.NewRow();
                        row2["NUMERIC_PRECISION"] = row1[SchemaTableColumn.NumericPrecision];
                        row2["NUMERIC_SCALE"] = row1[SchemaTableColumn.NumericScale];
                        row2["TABLE_NAME"] = (object) sqLiteDataReader1.GetString(2);
                        row2["COLUMN_NAME"] = row1[SchemaTableColumn.ColumnName];
                        row2["TABLE_CATALOG"] = (object) strCatalog;
                        row2["ORDINAL_POSITION"] = row1[SchemaTableColumn.ColumnOrdinal];
                        row2["COLUMN_HASDEFAULT"] = (object) (row1[SchemaTableOptionalColumn.DefaultValue] != DBNull.Value);
                        row2["COLUMN_DEFAULT"] = row1[SchemaTableOptionalColumn.DefaultValue];
                        row2["IS_NULLABLE"] = row1[SchemaTableColumn.AllowDBNull];
                        row2["DATA_TYPE"] = (object) row1["DataTypeName"].ToString().ToLower(CultureInfo.InvariantCulture);
                        row2["EDM_TYPE"] = (object) SQLiteConvert.DbTypeToTypeName(this, (DbType) row1[SchemaTableColumn.ProviderType], this._flags).ToString().ToLower(CultureInfo.InvariantCulture);
                        row2["CHARACTER_MAXIMUM_LENGTH"] = row1[SchemaTableColumn.ColumnSize];
                        row2["TABLE_SCHEMA"] = row1[SchemaTableColumn.BaseSchemaName];
                        row2["PRIMARY_KEY"] = row1[SchemaTableColumn.IsKey];
                        row2["AUTOINCREMENT"] = row1[SchemaTableOptionalColumn.IsAutoIncrement];
                        row2["COLLATION_NAME"] = row1["CollationType"];
                        row2["UNIQUE"] = row1[SchemaTableColumn.IsUnique];
                        dataTable.Rows.Add(row2);
                      }
                    }
                  }
                }
              }
            }
            catch (SQLiteException ex)
            {
            }
          }
        }
      }
      dataTable.AcceptChanges();
      dataTable.EndLoadData();
      return dataTable;
    }

    private DataTable Schema_Indexes(string strCatalog, string strTable, string strIndex)
    {
      DataTable dataTable = new DataTable("Indexes");
      List<int> intList = new List<int>();
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add("TABLE_CATALOG", typeof (string));
      dataTable.Columns.Add("TABLE_SCHEMA", typeof (string));
      dataTable.Columns.Add("TABLE_NAME", typeof (string));
      dataTable.Columns.Add("INDEX_CATALOG", typeof (string));
      dataTable.Columns.Add("INDEX_SCHEMA", typeof (string));
      dataTable.Columns.Add("INDEX_NAME", typeof (string));
      dataTable.Columns.Add("PRIMARY_KEY", typeof (bool));
      dataTable.Columns.Add("UNIQUE", typeof (bool));
      dataTable.Columns.Add("CLUSTERED", typeof (bool));
      dataTable.Columns.Add("TYPE", typeof (int));
      dataTable.Columns.Add("FILL_FACTOR", typeof (int));
      dataTable.Columns.Add("INITIAL_SIZE", typeof (int));
      dataTable.Columns.Add("NULLS", typeof (int));
      dataTable.Columns.Add("SORT_BOOKMARKS", typeof (bool));
      dataTable.Columns.Add("AUTO_UPDATE", typeof (bool));
      dataTable.Columns.Add("NULL_COLLATION", typeof (int));
      dataTable.Columns.Add("ORDINAL_POSITION", typeof (int));
      dataTable.Columns.Add("COLUMN_NAME", typeof (string));
      dataTable.Columns.Add("COLUMN_GUID", typeof (Guid));
      dataTable.Columns.Add("COLUMN_PROPID", typeof (long));
      dataTable.Columns.Add("COLLATION", typeof (short));
      dataTable.Columns.Add("CARDINALITY", typeof (Decimal));
      dataTable.Columns.Add("PAGES", typeof (int));
      dataTable.Columns.Add("FILTER_CONDITION", typeof (string));
      dataTable.Columns.Add("INTEGRATED", typeof (bool));
      dataTable.Columns.Add("INDEX_DEFINITION", typeof (string));
      dataTable.BeginLoadData();
      if (string.IsNullOrEmpty(strCatalog))
        strCatalog = "main";
      string str = string.Compare(strCatalog, "temp", StringComparison.OrdinalIgnoreCase) == 0 ? "sqlite_temp_master" : "sqlite_master";
      using (SQLiteCommand sqLiteCommand1 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT * FROM [{0}].[{1}] WHERE [type] LIKE 'table'", (object) strCatalog, (object) str), this))
      {
        using (SQLiteDataReader sqLiteDataReader1 = sqLiteCommand1.ExecuteReader())
        {
          while (sqLiteDataReader1.Read())
          {
            bool flag = false;
            intList.Clear();
            if (!string.IsNullOrEmpty(strTable))
            {
              if (string.Compare(sqLiteDataReader1.GetString(2), strTable, StringComparison.OrdinalIgnoreCase) != 0)
                continue;
            }
            try
            {
              using (SQLiteCommand sqLiteCommand2 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA [{0}].table_info([{1}])", (object) strCatalog, (object) sqLiteDataReader1.GetString(2)), this))
              {
                using (SQLiteDataReader sqLiteDataReader2 = sqLiteCommand2.ExecuteReader())
                {
                  while (sqLiteDataReader2.Read())
                  {
                    if (sqLiteDataReader2.GetInt32(5) != 0)
                    {
                      intList.Add(sqLiteDataReader2.GetInt32(0));
                      if (string.Compare(sqLiteDataReader2.GetString(2), "INTEGER", StringComparison.OrdinalIgnoreCase) == 0)
                        flag = true;
                    }
                  }
                }
              }
            }
            catch (SQLiteException ex)
            {
            }
            if (intList.Count == 1)
            {
              if (flag)
              {
                DataRow row = dataTable.NewRow();
                row["TABLE_CATALOG"] = (object) strCatalog;
                row["TABLE_NAME"] = (object) sqLiteDataReader1.GetString(2);
                row["INDEX_CATALOG"] = (object) strCatalog;
                row["PRIMARY_KEY"] = (object) true;
                row["INDEX_NAME"] = (object) HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "{1}_PK_{0}", (object) sqLiteDataReader1.GetString(2), (object) str);
                row["UNIQUE"] = (object) true;
                if (string.Compare((string) row["INDEX_NAME"], strIndex, StringComparison.OrdinalIgnoreCase) == 0 || strIndex == null)
                  dataTable.Rows.Add(row);
                intList.Clear();
              }
            }
            try
            {
              using (SQLiteCommand sqLiteCommand3 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA [{0}].index_list([{1}])", (object) strCatalog, (object) sqLiteDataReader1.GetString(2)), this))
              {
                using (SQLiteDataReader sqLiteDataReader3 = sqLiteCommand3.ExecuteReader())
                {
                  while (sqLiteDataReader3.Read())
                  {
                    if (string.Compare(sqLiteDataReader3.GetString(1), strIndex, StringComparison.OrdinalIgnoreCase) == 0 || strIndex == null)
                    {
                      DataRow row = dataTable.NewRow();
                      row["TABLE_CATALOG"] = (object) strCatalog;
                      row["TABLE_NAME"] = (object) sqLiteDataReader1.GetString(2);
                      row["INDEX_CATALOG"] = (object) strCatalog;
                      row["INDEX_NAME"] = (object) sqLiteDataReader3.GetString(1);
                      row["UNIQUE"] = (object) SQLiteConvert.ToBoolean(sqLiteDataReader3.GetValue(2), (IFormatProvider) CultureInfo.InvariantCulture, false);
                      row["PRIMARY_KEY"] = (object) false;
                      using (SQLiteCommand sqLiteCommand4 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT * FROM [{0}].[{2}] WHERE [type] LIKE 'index' AND [name] LIKE '{1}'", (object) strCatalog, (object) sqLiteDataReader3.GetString(1).Replace("'", "''"), (object) str), this))
                      {
                        using (SQLiteDataReader sqLiteDataReader4 = sqLiteCommand4.ExecuteReader())
                        {
                          if (sqLiteDataReader4.Read())
                          {
                            if (!sqLiteDataReader4.IsDBNull(4))
                              row["INDEX_DEFINITION"] = (object) sqLiteDataReader4.GetString(4);
                          }
                        }
                      }
                      if (intList.Count > 0 && sqLiteDataReader3.GetString(1).StartsWith("sqlite_autoindex_" + sqLiteDataReader1.GetString(2), StringComparison.InvariantCultureIgnoreCase))
                      {
                        using (SQLiteCommand sqLiteCommand5 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA [{0}].index_info([{1}])", (object) strCatalog, (object) sqLiteDataReader3.GetString(1)), this))
                        {
                          using (SQLiteDataReader sqLiteDataReader5 = sqLiteCommand5.ExecuteReader())
                          {
                            int num = 0;
                            while (sqLiteDataReader5.Read())
                            {
                              if (!intList.Contains(sqLiteDataReader5.GetInt32(1)))
                              {
                                num = 0;
                                break;
                              }
                              ++num;
                            }
                            if (num == intList.Count)
                            {
                              row["PRIMARY_KEY"] = (object) true;
                              intList.Clear();
                            }
                          }
                        }
                      }
                      dataTable.Rows.Add(row);
                    }
                  }
                }
              }
            }
            catch (SQLiteException ex)
            {
            }
          }
        }
      }
      dataTable.AcceptChanges();
      dataTable.EndLoadData();
      return dataTable;
    }

    private DataTable Schema_Triggers(string catalog, string table, string triggerName)
    {
      DataTable dataTable = new DataTable("Triggers");
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add("TABLE_CATALOG", typeof (string));
      dataTable.Columns.Add("TABLE_SCHEMA", typeof (string));
      dataTable.Columns.Add("TABLE_NAME", typeof (string));
      dataTable.Columns.Add("TRIGGER_NAME", typeof (string));
      dataTable.Columns.Add("TRIGGER_DEFINITION", typeof (string));
      dataTable.BeginLoadData();
      if (string.IsNullOrEmpty(table))
        table = (string) null;
      if (string.IsNullOrEmpty(catalog))
        catalog = "main";
      string str = string.Compare(catalog, "temp", StringComparison.OrdinalIgnoreCase) == 0 ? "sqlite_temp_master" : "sqlite_master";
      using (SQLiteCommand sqLiteCommand = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT [type], [name], [tbl_name], [rootpage], [sql], [rowid] FROM [{0}].[{1}] WHERE [type] LIKE 'trigger'", (object) catalog, (object) str), this))
      {
        using (SQLiteDataReader sqLiteDataReader = sqLiteCommand.ExecuteReader())
        {
          while (sqLiteDataReader.Read())
          {
            if ((string.Compare(sqLiteDataReader.GetString(1), triggerName, StringComparison.OrdinalIgnoreCase) == 0 || triggerName == null) && (table == null || string.Compare(table, sqLiteDataReader.GetString(2), StringComparison.OrdinalIgnoreCase) == 0))
            {
              DataRow row = dataTable.NewRow();
              row["TABLE_CATALOG"] = (object) catalog;
              row["TABLE_NAME"] = (object) sqLiteDataReader.GetString(2);
              row["TRIGGER_NAME"] = (object) sqLiteDataReader.GetString(1);
              row["TRIGGER_DEFINITION"] = (object) sqLiteDataReader.GetString(4);
              dataTable.Rows.Add(row);
            }
          }
        }
      }
      dataTable.AcceptChanges();
      dataTable.EndLoadData();
      return dataTable;
    }

    private DataTable Schema_Tables(string strCatalog, string strTable, string strType)
    {
      DataTable dataTable = new DataTable("Tables");
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add("TABLE_CATALOG", typeof (string));
      dataTable.Columns.Add("TABLE_SCHEMA", typeof (string));
      dataTable.Columns.Add("TABLE_NAME", typeof (string));
      dataTable.Columns.Add("TABLE_TYPE", typeof (string));
      dataTable.Columns.Add("TABLE_ID", typeof (long));
      dataTable.Columns.Add("TABLE_ROOTPAGE", typeof (int));
      dataTable.Columns.Add("TABLE_DEFINITION", typeof (string));
      dataTable.BeginLoadData();
      if (string.IsNullOrEmpty(strCatalog))
        strCatalog = "main";
      string str = string.Compare(strCatalog, "temp", StringComparison.OrdinalIgnoreCase) == 0 ? "sqlite_temp_master" : "sqlite_master";
      using (SQLiteCommand sqLiteCommand = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT [type], [name], [tbl_name], [rootpage], [sql], [rowid] FROM [{0}].[{1}] WHERE [type] LIKE 'table'", (object) strCatalog, (object) str), this))
      {
        using (SQLiteDataReader sqLiteDataReader = sqLiteCommand.ExecuteReader())
        {
          while (sqLiteDataReader.Read())
          {
            string strB = sqLiteDataReader.GetString(0);
            if (string.Compare(sqLiteDataReader.GetString(2), 0, "SQLITE_", 0, 7, StringComparison.OrdinalIgnoreCase) == 0)
              strB = "SYSTEM_TABLE";
            if ((string.Compare(strType, strB, StringComparison.OrdinalIgnoreCase) == 0 || strType == null) && (string.Compare(sqLiteDataReader.GetString(2), strTable, StringComparison.OrdinalIgnoreCase) == 0 || strTable == null))
            {
              DataRow row = dataTable.NewRow();
              row["TABLE_CATALOG"] = (object) strCatalog;
              row["TABLE_NAME"] = (object) sqLiteDataReader.GetString(2);
              row["TABLE_TYPE"] = (object) strB;
              row["TABLE_ID"] = (object) sqLiteDataReader.GetInt64(5);
              row["TABLE_ROOTPAGE"] = (object) sqLiteDataReader.GetInt32(3);
              row["TABLE_DEFINITION"] = (object) sqLiteDataReader.GetString(4);
              dataTable.Rows.Add(row);
            }
          }
        }
      }
      dataTable.AcceptChanges();
      dataTable.EndLoadData();
      return dataTable;
    }

    private DataTable Schema_Views(string strCatalog, string strView)
    {
      DataTable dataTable = new DataTable("Views");
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add("TABLE_CATALOG", typeof (string));
      dataTable.Columns.Add("TABLE_SCHEMA", typeof (string));
      dataTable.Columns.Add("TABLE_NAME", typeof (string));
      dataTable.Columns.Add("VIEW_DEFINITION", typeof (string));
      dataTable.Columns.Add("CHECK_OPTION", typeof (bool));
      dataTable.Columns.Add("IS_UPDATABLE", typeof (bool));
      dataTable.Columns.Add("DESCRIPTION", typeof (string));
      dataTable.Columns.Add("DATE_CREATED", typeof (DateTime));
      dataTable.Columns.Add("DATE_MODIFIED", typeof (DateTime));
      dataTable.BeginLoadData();
      if (string.IsNullOrEmpty(strCatalog))
        strCatalog = "main";
      string str1 = string.Compare(strCatalog, "temp", StringComparison.OrdinalIgnoreCase) == 0 ? "sqlite_temp_master" : "sqlite_master";
      using (SQLiteCommand sqLiteCommand = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT * FROM [{0}].[{1}] WHERE [type] LIKE 'view'", (object) strCatalog, (object) str1), this))
      {
        using (SQLiteDataReader sqLiteDataReader = sqLiteCommand.ExecuteReader())
        {
          while (sqLiteDataReader.Read())
          {
            if (string.Compare(sqLiteDataReader.GetString(1), strView, StringComparison.OrdinalIgnoreCase) == 0 || string.IsNullOrEmpty(strView))
            {
              string source = sqLiteDataReader.GetString(4).Replace('\r', ' ').Replace('\n', ' ').Replace('\t', ' ');
              int num = CultureInfo.InvariantCulture.CompareInfo.IndexOf(source, " AS ", CompareOptions.IgnoreCase);
              if (num > -1)
              {
                string str2 = source.Substring(num + 4).Trim();
                DataRow row = dataTable.NewRow();
                row["TABLE_CATALOG"] = (object) strCatalog;
                row["TABLE_NAME"] = (object) sqLiteDataReader.GetString(2);
                row["IS_UPDATABLE"] = (object) false;
                row["VIEW_DEFINITION"] = (object) str2;
                dataTable.Rows.Add(row);
              }
            }
          }
        }
      }
      dataTable.AcceptChanges();
      dataTable.EndLoadData();
      return dataTable;
    }

    private DataTable Schema_Catalogs(string strCatalog)
    {
      DataTable dataTable = new DataTable("Catalogs");
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add("CATALOG_NAME", typeof (string));
      dataTable.Columns.Add("DESCRIPTION", typeof (string));
      dataTable.Columns.Add("ID", typeof (long));
      dataTable.BeginLoadData();
      using (SQLiteCommand sqLiteCommand = new SQLiteCommand("PRAGMA database_list", this))
      {
        using (SQLiteDataReader sqLiteDataReader = sqLiteCommand.ExecuteReader())
        {
          while (sqLiteDataReader.Read())
          {
            if (string.Compare(sqLiteDataReader.GetString(1), strCatalog, StringComparison.OrdinalIgnoreCase) == 0 || strCatalog == null)
            {
              DataRow row = dataTable.NewRow();
              row["CATALOG_NAME"] = (object) sqLiteDataReader.GetString(1);
              row["DESCRIPTION"] = (object) sqLiteDataReader.GetString(2);
              row["ID"] = (object) sqLiteDataReader.GetInt64(0);
              dataTable.Rows.Add(row);
            }
          }
        }
      }
      dataTable.AcceptChanges();
      dataTable.EndLoadData();
      return dataTable;
    }

    private DataTable Schema_DataTypes()
    {
      DataTable dataTable = new DataTable("DataTypes");
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add("TypeName", typeof (string));
      dataTable.Columns.Add("ProviderDbType", typeof (int));
      dataTable.Columns.Add("ColumnSize", typeof (long));
      dataTable.Columns.Add("CreateFormat", typeof (string));
      dataTable.Columns.Add("CreateParameters", typeof (string));
      dataTable.Columns.Add("DataType", typeof (string));
      dataTable.Columns.Add("IsAutoIncrementable", typeof (bool));
      dataTable.Columns.Add("IsBestMatch", typeof (bool));
      dataTable.Columns.Add("IsCaseSensitive", typeof (bool));
      dataTable.Columns.Add("IsFixedLength", typeof (bool));
      dataTable.Columns.Add("IsFixedPrecisionScale", typeof (bool));
      dataTable.Columns.Add("IsLong", typeof (bool));
      dataTable.Columns.Add("IsNullable", typeof (bool));
      dataTable.Columns.Add("IsSearchable", typeof (bool));
      dataTable.Columns.Add("IsSearchableWithLike", typeof (bool));
      dataTable.Columns.Add("IsLiteralSupported", typeof (bool));
      dataTable.Columns.Add("LiteralPrefix", typeof (string));
      dataTable.Columns.Add("LiteralSuffix", typeof (string));
      dataTable.Columns.Add("IsUnsigned", typeof (bool));
      dataTable.Columns.Add("MaximumScale", typeof (short));
      dataTable.Columns.Add("MinimumScale", typeof (short));
      dataTable.Columns.Add("IsConcurrencyType", typeof (bool));
      dataTable.BeginLoadData();
      StringReader reader = new StringReader(SR.DataTypes);
      int num = (int) dataTable.ReadXml((TextReader) reader);
      reader.Close();
      dataTable.AcceptChanges();
      dataTable.EndLoadData();
      return dataTable;
    }

    private DataTable Schema_IndexColumns(
      string strCatalog,
      string strTable,
      string strIndex,
      string strColumn)
    {
      DataTable dataTable = new DataTable("IndexColumns");
      List<KeyValuePair<int, string>> keyValuePairList = new List<KeyValuePair<int, string>>();
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add("CONSTRAINT_CATALOG", typeof (string));
      dataTable.Columns.Add("CONSTRAINT_SCHEMA", typeof (string));
      dataTable.Columns.Add("CONSTRAINT_NAME", typeof (string));
      dataTable.Columns.Add("TABLE_CATALOG", typeof (string));
      dataTable.Columns.Add("TABLE_SCHEMA", typeof (string));
      dataTable.Columns.Add("TABLE_NAME", typeof (string));
      dataTable.Columns.Add("COLUMN_NAME", typeof (string));
      dataTable.Columns.Add("ORDINAL_POSITION", typeof (int));
      dataTable.Columns.Add("INDEX_NAME", typeof (string));
      dataTable.Columns.Add("COLLATION_NAME", typeof (string));
      dataTable.Columns.Add("SORT_MODE", typeof (string));
      dataTable.Columns.Add("CONFLICT_OPTION", typeof (int));
      if (string.IsNullOrEmpty(strCatalog))
        strCatalog = "main";
      string str1 = string.Compare(strCatalog, "temp", StringComparison.OrdinalIgnoreCase) == 0 ? "sqlite_temp_master" : "sqlite_master";
      dataTable.BeginLoadData();
      using (SQLiteCommand sqLiteCommand1 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT * FROM [{0}].[{1}] WHERE [type] LIKE 'table'", (object) strCatalog, (object) str1), this))
      {
        using (SQLiteDataReader sqLiteDataReader1 = sqLiteCommand1.ExecuteReader())
        {
          while (sqLiteDataReader1.Read())
          {
            bool flag = false;
            keyValuePairList.Clear();
            if (!string.IsNullOrEmpty(strTable))
            {
              if (string.Compare(sqLiteDataReader1.GetString(2), strTable, StringComparison.OrdinalIgnoreCase) != 0)
                continue;
            }
            try
            {
              using (SQLiteCommand sqLiteCommand2 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA [{0}].table_info([{1}])", (object) strCatalog, (object) sqLiteDataReader1.GetString(2)), this))
              {
                using (SQLiteDataReader sqLiteDataReader2 = sqLiteCommand2.ExecuteReader())
                {
                  while (sqLiteDataReader2.Read())
                  {
                    if (sqLiteDataReader2.GetInt32(5) == 1)
                    {
                      keyValuePairList.Add(new KeyValuePair<int, string>(sqLiteDataReader2.GetInt32(0), sqLiteDataReader2.GetString(1)));
                      if (string.Compare(sqLiteDataReader2.GetString(2), "INTEGER", StringComparison.OrdinalIgnoreCase) == 0)
                        flag = true;
                    }
                  }
                }
              }
            }
            catch (SQLiteException ex)
            {
            }
            if (keyValuePairList.Count == 1 && flag)
            {
              DataRow row = dataTable.NewRow();
              row["CONSTRAINT_CATALOG"] = (object) strCatalog;
              row["CONSTRAINT_NAME"] = (object) HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "{1}_PK_{0}", (object) sqLiteDataReader1.GetString(2), (object) str1);
              row["TABLE_CATALOG"] = (object) strCatalog;
              row["TABLE_NAME"] = (object) sqLiteDataReader1.GetString(2);
              row["COLUMN_NAME"] = (object) keyValuePairList[0].Value;
              row["INDEX_NAME"] = row["CONSTRAINT_NAME"];
              row["ORDINAL_POSITION"] = (object) 0;
              row["COLLATION_NAME"] = (object) "BINARY";
              row["SORT_MODE"] = (object) "ASC";
              row["CONFLICT_OPTION"] = (object) 2;
              if (string.IsNullOrEmpty(strIndex) || string.Compare(strIndex, (string) row["INDEX_NAME"], StringComparison.OrdinalIgnoreCase) == 0)
                dataTable.Rows.Add(row);
            }
            using (SQLiteCommand sqLiteCommand3 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT * FROM [{0}].[{2}] WHERE [type] LIKE 'index' AND [tbl_name] LIKE '{1}'", (object) strCatalog, (object) sqLiteDataReader1.GetString(2).Replace("'", "''"), (object) str1), this))
            {
              using (SQLiteDataReader sqLiteDataReader3 = sqLiteCommand3.ExecuteReader())
              {
                while (sqLiteDataReader3.Read())
                {
                  int num = 0;
                  if (!string.IsNullOrEmpty(strIndex))
                  {
                    if (string.Compare(strIndex, sqLiteDataReader3.GetString(1), StringComparison.OrdinalIgnoreCase) != 0)
                      continue;
                  }
                  try
                  {
                    using (SQLiteCommand sqLiteCommand4 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA [{0}].index_info([{1}])", (object) strCatalog, (object) sqLiteDataReader3.GetString(1)), this))
                    {
                      using (SQLiteDataReader sqLiteDataReader4 = sqLiteCommand4.ExecuteReader())
                      {
                        while (sqLiteDataReader4.Read())
                        {
                          string str2 = sqLiteDataReader4.IsDBNull(2) ? (string) null : sqLiteDataReader4.GetString(2);
                          DataRow row = dataTable.NewRow();
                          row["CONSTRAINT_CATALOG"] = (object) strCatalog;
                          row["CONSTRAINT_NAME"] = (object) sqLiteDataReader3.GetString(1);
                          row["TABLE_CATALOG"] = (object) strCatalog;
                          row["TABLE_NAME"] = (object) sqLiteDataReader3.GetString(2);
                          row["COLUMN_NAME"] = (object) str2;
                          row["INDEX_NAME"] = (object) sqLiteDataReader3.GetString(1);
                          row["ORDINAL_POSITION"] = (object) num;
                          string collationSequence = (string) null;
                          int sortMode = 0;
                          int onError = 0;
                          if (str2 != null)
                            this._sql.GetIndexColumnExtendedInfo(strCatalog, sqLiteDataReader3.GetString(1), str2, ref sortMode, ref onError, ref collationSequence);
                          if (!string.IsNullOrEmpty(collationSequence))
                            row["COLLATION_NAME"] = (object) collationSequence;
                          row["SORT_MODE"] = sortMode == 0 ? (object) "ASC" : (object) "DESC";
                          row["CONFLICT_OPTION"] = (object) onError;
                          ++num;
                          if (strColumn == null || string.Compare(strColumn, str2, StringComparison.OrdinalIgnoreCase) == 0)
                            dataTable.Rows.Add(row);
                        }
                      }
                    }
                  }
                  catch (SQLiteException ex)
                  {
                  }
                }
              }
            }
          }
        }
      }
      dataTable.EndLoadData();
      dataTable.AcceptChanges();
      return dataTable;
    }

    private DataTable Schema_ViewColumns(string strCatalog, string strView, string strColumn)
    {
      DataTable dataTable = new DataTable("ViewColumns");
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add("VIEW_CATALOG", typeof (string));
      dataTable.Columns.Add("VIEW_SCHEMA", typeof (string));
      dataTable.Columns.Add("VIEW_NAME", typeof (string));
      dataTable.Columns.Add("VIEW_COLUMN_NAME", typeof (string));
      dataTable.Columns.Add("TABLE_CATALOG", typeof (string));
      dataTable.Columns.Add("TABLE_SCHEMA", typeof (string));
      dataTable.Columns.Add("TABLE_NAME", typeof (string));
      dataTable.Columns.Add("COLUMN_NAME", typeof (string));
      dataTable.Columns.Add("ORDINAL_POSITION", typeof (int));
      dataTable.Columns.Add("COLUMN_HASDEFAULT", typeof (bool));
      dataTable.Columns.Add("COLUMN_DEFAULT", typeof (string));
      dataTable.Columns.Add("COLUMN_FLAGS", typeof (long));
      dataTable.Columns.Add("IS_NULLABLE", typeof (bool));
      dataTable.Columns.Add("DATA_TYPE", typeof (string));
      dataTable.Columns.Add("CHARACTER_MAXIMUM_LENGTH", typeof (int));
      dataTable.Columns.Add("NUMERIC_PRECISION", typeof (int));
      dataTable.Columns.Add("NUMERIC_SCALE", typeof (int));
      dataTable.Columns.Add("DATETIME_PRECISION", typeof (long));
      dataTable.Columns.Add("CHARACTER_SET_CATALOG", typeof (string));
      dataTable.Columns.Add("CHARACTER_SET_SCHEMA", typeof (string));
      dataTable.Columns.Add("CHARACTER_SET_NAME", typeof (string));
      dataTable.Columns.Add("COLLATION_CATALOG", typeof (string));
      dataTable.Columns.Add("COLLATION_SCHEMA", typeof (string));
      dataTable.Columns.Add("COLLATION_NAME", typeof (string));
      dataTable.Columns.Add("PRIMARY_KEY", typeof (bool));
      dataTable.Columns.Add("EDM_TYPE", typeof (string));
      dataTable.Columns.Add("AUTOINCREMENT", typeof (bool));
      dataTable.Columns.Add("UNIQUE", typeof (bool));
      if (string.IsNullOrEmpty(strCatalog))
        strCatalog = "main";
      string str = string.Compare(strCatalog, "temp", StringComparison.OrdinalIgnoreCase) == 0 ? "sqlite_temp_master" : "sqlite_master";
      dataTable.BeginLoadData();
      using (SQLiteCommand sqLiteCommand1 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT * FROM [{0}].[{1}] WHERE [type] LIKE 'view'", (object) strCatalog, (object) str), this))
      {
        using (SQLiteDataReader sqLiteDataReader1 = sqLiteCommand1.ExecuteReader())
        {
          while (sqLiteDataReader1.Read())
          {
            if (string.IsNullOrEmpty(strView) || string.Compare(strView, sqLiteDataReader1.GetString(2), StringComparison.OrdinalIgnoreCase) == 0)
            {
              using (SQLiteCommand sqLiteCommand2 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT * FROM [{0}].[{1}]", (object) strCatalog, (object) sqLiteDataReader1.GetString(2)), this))
              {
                string source = sqLiteDataReader1.GetString(4).Replace('\r', ' ').Replace('\n', ' ').Replace('\t', ' ');
                int num = CultureInfo.InvariantCulture.CompareInfo.IndexOf(source, " AS ", CompareOptions.IgnoreCase);
                if (num >= 0)
                {
                  using (SQLiteCommand sqLiteCommand3 = new SQLiteCommand(source.Substring(num + 4), this))
                  {
                    using (SQLiteDataReader sqLiteDataReader2 = sqLiteCommand2.ExecuteReader(CommandBehavior.SchemaOnly))
                    {
                      using (SQLiteDataReader sqLiteDataReader3 = sqLiteCommand3.ExecuteReader(CommandBehavior.SchemaOnly))
                      {
                        using (DataTable schemaTable1 = sqLiteDataReader2.GetSchemaTable(false, false))
                        {
                          using (DataTable schemaTable2 = sqLiteDataReader3.GetSchemaTable(false, false))
                          {
                            for (int index = 0; index < schemaTable2.Rows.Count; ++index)
                            {
                              DataRow row1 = schemaTable1.Rows[index];
                              DataRow row2 = schemaTable2.Rows[index];
                              if (string.Compare(row1[SchemaTableColumn.ColumnName].ToString(), strColumn, StringComparison.OrdinalIgnoreCase) == 0 || strColumn == null)
                              {
                                DataRow row3 = dataTable.NewRow();
                                row3["VIEW_CATALOG"] = (object) strCatalog;
                                row3["VIEW_NAME"] = (object) sqLiteDataReader1.GetString(2);
                                row3["TABLE_CATALOG"] = (object) strCatalog;
                                row3["TABLE_SCHEMA"] = row2[SchemaTableColumn.BaseSchemaName];
                                row3["TABLE_NAME"] = row2[SchemaTableColumn.BaseTableName];
                                row3["COLUMN_NAME"] = row2[SchemaTableColumn.BaseColumnName];
                                row3["VIEW_COLUMN_NAME"] = row1[SchemaTableColumn.ColumnName];
                                row3["COLUMN_HASDEFAULT"] = (object) (row1[SchemaTableOptionalColumn.DefaultValue] != DBNull.Value);
                                row3["COLUMN_DEFAULT"] = row1[SchemaTableOptionalColumn.DefaultValue];
                                row3["ORDINAL_POSITION"] = row1[SchemaTableColumn.ColumnOrdinal];
                                row3["IS_NULLABLE"] = row1[SchemaTableColumn.AllowDBNull];
                                row3["DATA_TYPE"] = row1["DataTypeName"];
                                row3["EDM_TYPE"] = (object) SQLiteConvert.DbTypeToTypeName(this, (DbType) row1[SchemaTableColumn.ProviderType], this._flags).ToString().ToLower(CultureInfo.InvariantCulture);
                                row3["CHARACTER_MAXIMUM_LENGTH"] = row1[SchemaTableColumn.ColumnSize];
                                row3["TABLE_SCHEMA"] = row1[SchemaTableColumn.BaseSchemaName];
                                row3["PRIMARY_KEY"] = row1[SchemaTableColumn.IsKey];
                                row3["AUTOINCREMENT"] = row1[SchemaTableOptionalColumn.IsAutoIncrement];
                                row3["COLLATION_NAME"] = row1["CollationType"];
                                row3["UNIQUE"] = row1[SchemaTableColumn.IsUnique];
                                dataTable.Rows.Add(row3);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      dataTable.EndLoadData();
      dataTable.AcceptChanges();
      return dataTable;
    }

    private DataTable Schema_ForeignKeys(string strCatalog, string strTable, string strKeyName)
    {
      DataTable dataTable = new DataTable("ForeignKeys");
      dataTable.Locale = CultureInfo.InvariantCulture;
      dataTable.Columns.Add("CONSTRAINT_CATALOG", typeof (string));
      dataTable.Columns.Add("CONSTRAINT_SCHEMA", typeof (string));
      dataTable.Columns.Add("CONSTRAINT_NAME", typeof (string));
      dataTable.Columns.Add("TABLE_CATALOG", typeof (string));
      dataTable.Columns.Add("TABLE_SCHEMA", typeof (string));
      dataTable.Columns.Add("TABLE_NAME", typeof (string));
      dataTable.Columns.Add("CONSTRAINT_TYPE", typeof (string));
      dataTable.Columns.Add("IS_DEFERRABLE", typeof (bool));
      dataTable.Columns.Add("INITIALLY_DEFERRED", typeof (bool));
      dataTable.Columns.Add("FKEY_ID", typeof (int));
      dataTable.Columns.Add("FKEY_FROM_COLUMN", typeof (string));
      dataTable.Columns.Add("FKEY_FROM_ORDINAL_POSITION", typeof (int));
      dataTable.Columns.Add("FKEY_TO_CATALOG", typeof (string));
      dataTable.Columns.Add("FKEY_TO_SCHEMA", typeof (string));
      dataTable.Columns.Add("FKEY_TO_TABLE", typeof (string));
      dataTable.Columns.Add("FKEY_TO_COLUMN", typeof (string));
      dataTable.Columns.Add("FKEY_ON_UPDATE", typeof (string));
      dataTable.Columns.Add("FKEY_ON_DELETE", typeof (string));
      dataTable.Columns.Add("FKEY_MATCH", typeof (string));
      if (string.IsNullOrEmpty(strCatalog))
        strCatalog = "main";
      string str = string.Compare(strCatalog, "temp", StringComparison.OrdinalIgnoreCase) == 0 ? "sqlite_temp_master" : "sqlite_master";
      dataTable.BeginLoadData();
      using (SQLiteCommand sqLiteCommand1 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT * FROM [{0}].[{1}] WHERE [type] LIKE 'table'", (object) strCatalog, (object) str), this))
      {
        using (SQLiteDataReader sqLiteDataReader1 = sqLiteCommand1.ExecuteReader())
        {
          while (sqLiteDataReader1.Read())
          {
            if (!string.IsNullOrEmpty(strTable))
            {
              if (string.Compare(strTable, sqLiteDataReader1.GetString(2), StringComparison.OrdinalIgnoreCase) != 0)
                continue;
            }
            try
            {
              using (SQLiteCommandBuilder liteCommandBuilder = new SQLiteCommandBuilder())
              {
                using (SQLiteCommand sqLiteCommand2 = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA [{0}].foreign_key_list([{1}])", (object) strCatalog, (object) sqLiteDataReader1.GetString(2)), this))
                {
                  using (SQLiteDataReader sqLiteDataReader2 = sqLiteCommand2.ExecuteReader())
                  {
                    while (sqLiteDataReader2.Read())
                    {
                      DataRow row = dataTable.NewRow();
                      row["CONSTRAINT_CATALOG"] = (object) strCatalog;
                      row["CONSTRAINT_NAME"] = (object) HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "FK_{0}_{1}_{2}", sqLiteDataReader1[2], (object) sqLiteDataReader2.GetInt32(0), (object) sqLiteDataReader2.GetInt32(1));
                      row["TABLE_CATALOG"] = (object) strCatalog;
                      row["TABLE_NAME"] = (object) liteCommandBuilder.UnquoteIdentifier(sqLiteDataReader1.GetString(2));
                      row["CONSTRAINT_TYPE"] = (object) "FOREIGN KEY";
                      row["IS_DEFERRABLE"] = (object) false;
                      row["INITIALLY_DEFERRED"] = (object) false;
                      row["FKEY_ID"] = sqLiteDataReader2[0];
                      row["FKEY_FROM_COLUMN"] = (object) liteCommandBuilder.UnquoteIdentifier(sqLiteDataReader2[3].ToString());
                      row["FKEY_TO_CATALOG"] = (object) strCatalog;
                      row["FKEY_TO_TABLE"] = (object) liteCommandBuilder.UnquoteIdentifier(sqLiteDataReader2[2].ToString());
                      row["FKEY_TO_COLUMN"] = (object) liteCommandBuilder.UnquoteIdentifier(sqLiteDataReader2[4].ToString());
                      row["FKEY_FROM_ORDINAL_POSITION"] = sqLiteDataReader2[1];
                      row["FKEY_ON_UPDATE"] = sqLiteDataReader2.FieldCount > 5 ? sqLiteDataReader2[5] : (object) string.Empty;
                      row["FKEY_ON_DELETE"] = sqLiteDataReader2.FieldCount > 6 ? sqLiteDataReader2[6] : (object) string.Empty;
                      row["FKEY_MATCH"] = sqLiteDataReader2.FieldCount > 7 ? sqLiteDataReader2[7] : (object) string.Empty;
                      if (string.IsNullOrEmpty(strKeyName) || string.Compare(strKeyName, row["CONSTRAINT_NAME"].ToString(), StringComparison.OrdinalIgnoreCase) == 0)
                        dataTable.Rows.Add(row);
                    }
                  }
                }
              }
            }
            catch (SQLiteException ex)
            {
            }
          }
        }
      }
      dataTable.EndLoadData();
      dataTable.AcceptChanges();
      return dataTable;
    }

    public event SQLiteProgressEventHandler Progress
    {
      add
      {
        this.CheckDisposed();
        if (this._progressHandler == null)
        {
          this._progressCallback = new SQLiteProgressCallback(this.ProgressCallback);
          if (this._sql != null)
            this._sql.SetProgressHook(this._progressOps, this._progressCallback);
        }
        this._progressHandler += value;
      }
      remove
      {
        this.CheckDisposed();
        this._progressHandler -= value;
        if (this._progressHandler != null)
          return;
        if (this._sql != null)
          this._sql.SetProgressHook(0, (SQLiteProgressCallback) null);
        this._progressCallback = (SQLiteProgressCallback) null;
      }
    }

    public event SQLiteAuthorizerEventHandler Authorize
    {
      add
      {
        this.CheckDisposed();
        if (this._authorizerHandler == null)
        {
          this._authorizerCallback = new SQLiteAuthorizerCallback(this.AuthorizerCallback);
          if (this._sql != null)
            this._sql.SetAuthorizerHook(this._authorizerCallback);
        }
        this._authorizerHandler += value;
      }
      remove
      {
        this.CheckDisposed();
        this._authorizerHandler -= value;
        if (this._authorizerHandler != null)
          return;
        if (this._sql != null)
          this._sql.SetAuthorizerHook((SQLiteAuthorizerCallback) null);
        this._authorizerCallback = (SQLiteAuthorizerCallback) null;
      }
    }

    public event SQLiteUpdateEventHandler Update
    {
      add
      {
        this.CheckDisposed();
        if (this._updateHandler == null)
        {
          this._updateCallback = new SQLiteUpdateCallback(this.UpdateCallback);
          if (this._sql != null)
            this._sql.SetUpdateHook(this._updateCallback);
        }
        this._updateHandler += value;
      }
      remove
      {
        this.CheckDisposed();
        this._updateHandler -= value;
        if (this._updateHandler != null)
          return;
        if (this._sql != null)
          this._sql.SetUpdateHook((SQLiteUpdateCallback) null);
        this._updateCallback = (SQLiteUpdateCallback) null;
      }
    }

    private SQLiteProgressReturnCode ProgressCallback(IntPtr pUserData)
    {
      try
      {
        ProgressEventArgs e = new ProgressEventArgs(pUserData, SQLiteProgressReturnCode.Continue);
        if (this._progressHandler != null)
          this._progressHandler((object) this, e);
        return e.ReturnCode;
      }
      catch (Exception ex)
      {
        try
        {
          if ((this._flags & SQLiteConnectionFlags.LogCallbackException) == SQLiteConnectionFlags.LogCallbackException)
            SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"Progress\" method: {1}", (object) ex));
        }
        catch
        {
        }
      }
      return (this._flags & SQLiteConnectionFlags.InterruptOnException) == SQLiteConnectionFlags.InterruptOnException ? SQLiteProgressReturnCode.Interrupt : SQLiteProgressReturnCode.Continue;
    }

    private SQLiteAuthorizerReturnCode AuthorizerCallback(
      IntPtr pUserData,
      SQLiteAuthorizerActionCode actionCode,
      IntPtr pArgument1,
      IntPtr pArgument2,
      IntPtr pDatabase,
      IntPtr pAuthContext)
    {
      try
      {
        AuthorizerEventArgs e = new AuthorizerEventArgs(pUserData, actionCode, SQLiteConvert.UTF8ToString(pArgument1, -1), SQLiteConvert.UTF8ToString(pArgument2, -1), SQLiteConvert.UTF8ToString(pDatabase, -1), SQLiteConvert.UTF8ToString(pAuthContext, -1), SQLiteAuthorizerReturnCode.Ok);
        if (this._authorizerHandler != null)
          this._authorizerHandler((object) this, e);
        return e.ReturnCode;
      }
      catch (Exception ex)
      {
        try
        {
          if ((this._flags & SQLiteConnectionFlags.LogCallbackException) == SQLiteConnectionFlags.LogCallbackException)
            SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"Authorize\" method: {1}", (object) ex));
        }
        catch
        {
        }
      }
      return (this._flags & SQLiteConnectionFlags.DenyOnException) == SQLiteConnectionFlags.DenyOnException ? SQLiteAuthorizerReturnCode.Deny : SQLiteAuthorizerReturnCode.Ok;
    }

    private void UpdateCallback(
      IntPtr puser,
      int type,
      IntPtr database,
      IntPtr table,
      long rowid)
    {
      try
      {
        this._updateHandler((object) this, new UpdateEventArgs(SQLiteConvert.UTF8ToString(database, -1), SQLiteConvert.UTF8ToString(table, -1), (UpdateEventType) type, rowid));
      }
      catch (Exception ex)
      {
        try
        {
          if ((this._flags & SQLiteConnectionFlags.LogCallbackException) != SQLiteConnectionFlags.LogCallbackException)
            return;
          SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"Update\" method: {1}", (object) ex));
        }
        catch
        {
        }
      }
    }

    public event SQLiteCommitHandler Commit
    {
      add
      {
        this.CheckDisposed();
        if (this._commitHandler == null)
        {
          this._commitCallback = new SQLiteCommitCallback(this.CommitCallback);
          if (this._sql != null)
            this._sql.SetCommitHook(this._commitCallback);
        }
        this._commitHandler += value;
      }
      remove
      {
        this.CheckDisposed();
        this._commitHandler -= value;
        if (this._commitHandler != null)
          return;
        if (this._sql != null)
          this._sql.SetCommitHook((SQLiteCommitCallback) null);
        this._commitCallback = (SQLiteCommitCallback) null;
      }
    }

    public event SQLiteTraceEventHandler Trace
    {
      add
      {
        this.CheckDisposed();
        if (this._traceHandler == null)
        {
          this._traceCallback = new SQLiteTraceCallback(this.TraceCallback);
          if (this._sql != null)
            this._sql.SetTraceCallback(this._traceCallback);
        }
        this._traceHandler += value;
      }
      remove
      {
        this.CheckDisposed();
        this._traceHandler -= value;
        if (this._traceHandler != null)
          return;
        if (this._sql != null)
          this._sql.SetTraceCallback((SQLiteTraceCallback) null);
        this._traceCallback = (SQLiteTraceCallback) null;
      }
    }

    private void TraceCallback(IntPtr puser, IntPtr statement)
    {
      try
      {
        if (this._traceHandler == null)
          return;
        this._traceHandler((object) this, new TraceEventArgs(SQLiteConvert.UTF8ToString(statement, -1)));
      }
      catch (Exception ex)
      {
        try
        {
          if ((this._flags & SQLiteConnectionFlags.LogCallbackException) != SQLiteConnectionFlags.LogCallbackException)
            return;
          SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"Trace\" method: {1}", (object) ex));
        }
        catch
        {
        }
      }
    }

    public event EventHandler RollBack
    {
      add
      {
        this.CheckDisposed();
        if (this._rollbackHandler == null)
        {
          this._rollbackCallback = new SQLiteRollbackCallback(this.RollbackCallback);
          if (this._sql != null)
            this._sql.SetRollbackHook(this._rollbackCallback);
        }
        this._rollbackHandler += value;
      }
      remove
      {
        this.CheckDisposed();
        this._rollbackHandler -= value;
        if (this._rollbackHandler != null)
          return;
        if (this._sql != null)
          this._sql.SetRollbackHook((SQLiteRollbackCallback) null);
        this._rollbackCallback = (SQLiteRollbackCallback) null;
      }
    }

    private int CommitCallback(IntPtr parg)
    {
      try
      {
        CommitEventArgs e = new CommitEventArgs();
        if (this._commitHandler != null)
          this._commitHandler((object) this, e);
        return e.AbortTransaction ? 1 : 0;
      }
      catch (Exception ex)
      {
        try
        {
          if ((this._flags & SQLiteConnectionFlags.LogCallbackException) == SQLiteConnectionFlags.LogCallbackException)
            SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"Commit\" method: {1}", (object) ex));
        }
        catch
        {
        }
      }
      return (this._flags & SQLiteConnectionFlags.RollbackOnException) == SQLiteConnectionFlags.RollbackOnException ? 1 : 0;
    }

    private void RollbackCallback(IntPtr parg)
    {
      try
      {
        if (this._rollbackHandler == null)
          return;
        this._rollbackHandler((object) this, EventArgs.Empty);
      }
      catch (Exception ex)
      {
        try
        {
          if ((this._flags & SQLiteConnectionFlags.LogCallbackException) != SQLiteConnectionFlags.LogCallbackException)
            return;
          SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"Rollback\" method: {1}", (object) ex));
        }
        catch
        {
        }
      }
    }

    protected override DbProviderFactory DbProviderFactory
    {
      get => (DbProviderFactory) SQLiteFactory.Instance;
    }
  }
}


--- SQLiteConnectionEventHandler.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteConnectionEventHandler
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate void SQLiteConnectionEventHandler(object sender, ConnectionEventArgs e);
}


--- SQLiteConnectionEventType.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteConnectionEventType
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum SQLiteConnectionEventType
  {
    Invalid = -1, // 0xFFFFFFFF
    Unknown = 0,
    Opening = 1,
    ConnectionString = 2,
    Opened = 3,
    ChangeDatabase = 4,
    NewTransaction = 5,
    EnlistTransaction = 6,
    NewCommand = 7,
    NewDataReader = 8,
    NewCriticalHandle = 9,
    Closing = 10, // 0x0000000A
    Closed = 11, // 0x0000000B
    DisposingCommand = 12, // 0x0000000C
    DisposingDataReader = 13, // 0x0000000D
    ClosingDataReader = 14, // 0x0000000E
    OpenedFromPool = 15, // 0x0000000F
    ClosedToPool = 16, // 0x00000010
  }
}


--- SQLiteConnectionFlags.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteConnectionFlags
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  [Flags]
  public enum SQLiteConnectionFlags : long
  {
    None = 0,
    LogPrepare = 1,
    LogPreBind = 2,
    LogBind = 4,
    LogCallbackException = 8,
    LogBackup = 16, // 0x0000000000000010
    NoExtensionFunctions = 32, // 0x0000000000000020
    BindUInt32AsInt64 = 64, // 0x0000000000000040
    BindAllAsText = 128, // 0x0000000000000080
    GetAllAsText = 256, // 0x0000000000000100
    NoLoadExtension = 512, // 0x0000000000000200
    NoCreateModule = 1024, // 0x0000000000000400
    NoBindFunctions = 2048, // 0x0000000000000800
    NoLogModule = 4096, // 0x0000000000001000
    LogModuleError = 8192, // 0x0000000000002000
    LogModuleException = 16384, // 0x0000000000004000
    TraceWarning = 32768, // 0x0000000000008000
    ConvertInvariantText = 65536, // 0x0000000000010000
    BindInvariantText = 131072, // 0x0000000000020000
    NoConnectionPool = 262144, // 0x0000000000040000
    UseConnectionPool = 524288, // 0x0000000000080000
    UseConnectionTypes = 1048576, // 0x0000000000100000
    NoGlobalTypes = 2097152, // 0x0000000000200000
    StickyHasRows = 4194304, // 0x0000000000400000
    StrictEnlistment = 8388608, // 0x0000000000800000
    MapIsolationLevels = 16777216, // 0x0000000001000000
    DetectTextAffinity = 33554432, // 0x0000000002000000
    DetectStringType = 67108864, // 0x0000000004000000
    NoConvertSettings = 134217728, // 0x0000000008000000
    BindDateTimeWithKind = 268435456, // 0x0000000010000000
    RollbackOnException = 536870912, // 0x0000000020000000
    DenyOnException = 1073741824, // 0x0000000040000000
    InterruptOnException = 2147483648, // 0x0000000080000000
    UnbindFunctionsOnClose = 4294967296, // 0x0000000100000000
    NoVerifyTextAffinity = 8589934592, // 0x0000000200000000
    UseConnectionBindValueCallbacks = 17179869184, // 0x0000000400000000
    UseConnectionReadValueCallbacks = 34359738368, // 0x0000000800000000
    UseParameterNameForTypeName = 68719476736, // 0x0000001000000000
    UseParameterDbTypeForTypeName = 137438953472, // 0x0000002000000000
    NoVerifyTypeAffinity = 274877906944, // 0x0000004000000000
    BindAndGetAllAsText = GetAllAsText | BindAllAsText, // 0x0000000000000180
    ConvertAndBindInvariantText = BindInvariantText | ConvertInvariantText, // 0x0000000000030000
    BindAndGetAllAsInvariantText = BindAndGetAllAsText | BindInvariantText, // 0x0000000000020180
    ConvertAndBindAndGetAllAsInvariantText = BindAndGetAllAsInvariantText | ConvertInvariantText, // 0x0000000000030180
    UseConnectionAllValueCallbacks = UseConnectionReadValueCallbacks | UseConnectionBindValueCallbacks, // 0x0000000C00000000
    UseParameterAnythingForTypeName = UseParameterDbTypeForTypeName | UseParameterNameForTypeName, // 0x0000003000000000
    LogAll = LogModuleException | LogModuleError | LogBackup | LogCallbackException | LogBind | LogPreBind | LogPrepare, // 0x000000000000601F
    Default = LogModuleException | LogCallbackException, // 0x0000000000004008
    DefaultAndLogAll = Default | LogModuleError | LogBackup | LogBind | LogPreBind | LogPrepare, // 0x000000000000601F
  }
}


--- SQLiteConnectionHandle.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteConnectionHandle
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;
using System.Threading;

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLiteConnectionHandle : CriticalHandle
  {
    private bool ownHandle;

    public static implicit operator IntPtr(SQLiteConnectionHandle db)
    {
      return db != null ? db.handle : IntPtr.Zero;
    }

    internal SQLiteConnectionHandle(IntPtr db, bool ownHandle)
      : this(ownHandle)
    {
      this.ownHandle = ownHandle;
      this.SetHandle(db);
    }

    private SQLiteConnectionHandle(bool ownHandle)
      : base(IntPtr.Zero)
    {
    }

    protected override bool ReleaseHandle()
    {
      if (!this.ownHandle)
        return true;
      try
      {
        IntPtr db = Interlocked.Exchange(ref this.handle, IntPtr.Zero);
        if (db != IntPtr.Zero)
          SQLiteBase.CloseConnection(this, db);
      }
      catch (SQLiteException ex)
      {
      }
      finally
      {
        this.SetHandleAsInvalid();
      }
      return true;
    }

    public bool OwnHandle => this.ownHandle;

    public override bool IsInvalid => this.handle == IntPtr.Zero;
  }
}


--- SQLiteConnectionPool.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteConnectionPool
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;
using System.Threading;

#nullable disable
namespace System.Data.SQLite
{
  internal static class SQLiteConnectionPool
  {
    private static readonly object _syncRoot = new object();
    private static ISQLiteConnectionPool _connectionPool = (ISQLiteConnectionPool) null;
    private static SortedList<string, SQLiteConnectionPool.PoolQueue> _queueList = new SortedList<string, SQLiteConnectionPool.PoolQueue>((IComparer<string>) StringComparer.OrdinalIgnoreCase);
    private static int _poolVersion = 1;
    private static int _poolOpened = 0;
    private static int _poolClosed = 0;

    internal static void GetCounts(
      string fileName,
      ref Dictionary<string, int> counts,
      ref int openCount,
      ref int closeCount,
      ref int totalCount)
    {
      ISQLiteConnectionPool connectionPool = SQLiteConnectionPool.GetConnectionPool();
      if (connectionPool != null)
      {
        connectionPool.GetCounts(fileName, ref counts, ref openCount, ref closeCount, ref totalCount);
      }
      else
      {
        lock (SQLiteConnectionPool._syncRoot)
        {
          openCount = SQLiteConnectionPool._poolOpened;
          closeCount = SQLiteConnectionPool._poolClosed;
          if (counts == null)
            counts = new Dictionary<string, int>((IEqualityComparer<string>) StringComparer.OrdinalIgnoreCase);
          if (fileName != null)
          {
            SQLiteConnectionPool.PoolQueue poolQueue;
            if (!SQLiteConnectionPool._queueList.TryGetValue(fileName, out poolQueue))
              return;
            Queue<WeakReference> queue = poolQueue.Queue;
            int count = queue != null ? queue.Count : 0;
            counts.Add(fileName, count);
            totalCount += count;
          }
          else
          {
            foreach (KeyValuePair<string, SQLiteConnectionPool.PoolQueue> queue1 in SQLiteConnectionPool._queueList)
            {
              if (queue1.Value != null)
              {
                Queue<WeakReference> queue2 = queue1.Value.Queue;
                int count = queue2 != null ? queue2.Count : 0;
                counts.Add(queue1.Key, count);
                totalCount += count;
              }
            }
          }
        }
      }
    }

    internal static void ClearPool(string fileName)
    {
      ISQLiteConnectionPool connectionPool = SQLiteConnectionPool.GetConnectionPool();
      if (connectionPool != null)
      {
        connectionPool.ClearPool(fileName);
      }
      else
      {
        lock (SQLiteConnectionPool._syncRoot)
        {
          SQLiteConnectionPool.PoolQueue poolQueue;
          if (!SQLiteConnectionPool._queueList.TryGetValue(fileName, out poolQueue))
            return;
          ++poolQueue.PoolVersion;
          Queue<WeakReference> queue = poolQueue.Queue;
          if (queue == null)
            return;
          while (queue.Count > 0)
          {
            WeakReference weakReference = queue.Dequeue();
            if (weakReference != null)
            {
              if (weakReference.Target is SQLiteConnectionHandle target)
                target.Dispose();
              GC.KeepAlive((object) target);
            }
          }
        }
      }
    }

    internal static void ClearAllPools()
    {
      ISQLiteConnectionPool connectionPool = SQLiteConnectionPool.GetConnectionPool();
      if (connectionPool != null)
      {
        connectionPool.ClearAllPools();
      }
      else
      {
        lock (SQLiteConnectionPool._syncRoot)
        {
          foreach (KeyValuePair<string, SQLiteConnectionPool.PoolQueue> queue1 in SQLiteConnectionPool._queueList)
          {
            if (queue1.Value != null)
            {
              Queue<WeakReference> queue2 = queue1.Value.Queue;
              while (queue2.Count > 0)
              {
                WeakReference weakReference = queue2.Dequeue();
                if (weakReference != null)
                {
                  if (weakReference.Target is SQLiteConnectionHandle target)
                    target.Dispose();
                  GC.KeepAlive((object) target);
                }
              }
              if (SQLiteConnectionPool._poolVersion <= queue1.Value.PoolVersion)
                SQLiteConnectionPool._poolVersion = queue1.Value.PoolVersion + 1;
            }
          }
          SQLiteConnectionPool._queueList.Clear();
        }
      }
    }

    internal static void Add(string fileName, SQLiteConnectionHandle handle, int version)
    {
      ISQLiteConnectionPool connectionPool = SQLiteConnectionPool.GetConnectionPool();
      if (connectionPool != null)
      {
        connectionPool.Add(fileName, (object) handle, version);
      }
      else
      {
        lock (SQLiteConnectionPool._syncRoot)
        {
          SQLiteConnectionPool.PoolQueue queue1;
          if (SQLiteConnectionPool._queueList.TryGetValue(fileName, out queue1) && version == queue1.PoolVersion)
          {
            SQLiteConnectionPool.ResizePool(queue1, true);
            Queue<WeakReference> queue2 = queue1.Queue;
            if (queue2 == null)
              return;
            queue2.Enqueue(new WeakReference((object) handle, false));
            Interlocked.Increment(ref SQLiteConnectionPool._poolClosed);
          }
          else
            handle.Close();
          GC.KeepAlive((object) handle);
        }
      }
    }

    internal static SQLiteConnectionHandle Remove(
      string fileName,
      int maxPoolSize,
      out int version)
    {
      ISQLiteConnectionPool connectionPool = SQLiteConnectionPool.GetConnectionPool();
      if (connectionPool != null)
        return connectionPool.Remove(fileName, maxPoolSize, out version) as SQLiteConnectionHandle;
      int poolVersion;
      Queue<WeakReference> collection;
      lock (SQLiteConnectionPool._syncRoot)
      {
        version = SQLiteConnectionPool._poolVersion;
        SQLiteConnectionPool.PoolQueue queue;
        if (!SQLiteConnectionPool._queueList.TryGetValue(fileName, out queue))
        {
          queue = new SQLiteConnectionPool.PoolQueue(SQLiteConnectionPool._poolVersion, maxPoolSize);
          SQLiteConnectionPool._queueList.Add(fileName, queue);
          return (SQLiteConnectionHandle) null;
        }
        version = poolVersion = queue.PoolVersion;
        queue.MaxPoolSize = maxPoolSize;
        SQLiteConnectionPool.ResizePool(queue, false);
        collection = queue.Queue;
        if (collection == null)
          return (SQLiteConnectionHandle) null;
        SQLiteConnectionPool._queueList.Remove(fileName);
        collection = new Queue<WeakReference>((IEnumerable<WeakReference>) collection);
      }
      try
      {
        while (collection.Count > 0)
        {
          WeakReference weakReference = collection.Dequeue();
          if (weakReference != null && weakReference.Target is SQLiteConnectionHandle target)
          {
            GC.SuppressFinalize((object) target);
            try
            {
              GC.WaitForPendingFinalizers();
              if (!target.IsInvalid)
              {
                if (!target.IsClosed)
                {
                  Interlocked.Increment(ref SQLiteConnectionPool._poolOpened);
                  return target;
                }
              }
            }
            finally
            {
              GC.ReRegisterForFinalize((object) target);
            }
            GC.KeepAlive((object) target);
          }
        }
      }
      finally
      {
        lock (SQLiteConnectionPool._syncRoot)
        {
          SQLiteConnectionPool.PoolQueue queue1;
          bool flag;
          if (SQLiteConnectionPool._queueList.TryGetValue(fileName, out queue1))
          {
            flag = false;
          }
          else
          {
            flag = true;
            queue1 = new SQLiteConnectionPool.PoolQueue(poolVersion, maxPoolSize);
          }
          Queue<WeakReference> queue2 = queue1.Queue;
          while (collection.Count > 0)
            queue2.Enqueue(collection.Dequeue());
          SQLiteConnectionPool.ResizePool(queue1, false);
          if (flag)
            SQLiteConnectionPool._queueList.Add(fileName, queue1);
        }
      }
      return (SQLiteConnectionHandle) null;
    }

    internal static ISQLiteConnectionPool GetConnectionPool()
    {
      lock (SQLiteConnectionPool._syncRoot)
        return SQLiteConnectionPool._connectionPool;
    }

    internal static void SetConnectionPool(ISQLiteConnectionPool connectionPool)
    {
      lock (SQLiteConnectionPool._syncRoot)
        SQLiteConnectionPool._connectionPool = connectionPool;
    }

    private static void ResizePool(SQLiteConnectionPool.PoolQueue queue, bool add)
    {
      int maxPoolSize = queue.MaxPoolSize;
      if (add && maxPoolSize > 0)
        --maxPoolSize;
      Queue<WeakReference> queue1 = queue.Queue;
      if (queue1 == null)
        return;
      while (queue1.Count > maxPoolSize)
      {
        WeakReference weakReference = queue1.Dequeue();
        if (weakReference != null)
        {
          if (weakReference.Target is SQLiteConnectionHandle target)
            target.Dispose();
          GC.KeepAlive((object) target);
        }
      }
    }

    private sealed class PoolQueue
    {
      internal readonly Queue<WeakReference> Queue = new Queue<WeakReference>();
      internal int PoolVersion;
      internal int MaxPoolSize;

      internal PoolQueue(int version, int maxSize)
      {
        this.PoolVersion = version;
        this.MaxPoolSize = maxSize;
      }
    }
  }
}


--- SQLiteConnectionStringBuilder.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteConnectionStringBuilder
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections;
using System.ComponentModel;
using System.Data.Common;
using System.Globalization;
using System.Reflection;

#nullable disable
namespace System.Data.SQLite
{
  [DefaultProperty("DataSource")]
  [DefaultMember("Item")]
  public sealed class SQLiteConnectionStringBuilder : DbConnectionStringBuilder
  {
    private Hashtable _properties;

    public SQLiteConnectionStringBuilder() => this.Initialize((string) null);

    public SQLiteConnectionStringBuilder(string connectionString)
    {
      this.Initialize(connectionString);
    }

    private void Initialize(string cnnString)
    {
      this._properties = new Hashtable((IEqualityComparer) StringComparer.OrdinalIgnoreCase);
      try
      {
        this.GetProperties(this._properties);
      }
      catch (NotImplementedException ex)
      {
        this.FallbackGetProperties(this._properties);
      }
      if (string.IsNullOrEmpty(cnnString))
        return;
      this.ConnectionString = cnnString;
    }

    [Browsable(true)]
    [DefaultValue(3)]
    public int Version
    {
      get
      {
        object obj;
        this.TryGetValue("version", out obj);
        return Convert.ToInt32(obj, (IFormatProvider) CultureInfo.CurrentCulture);
      }
      set => this["version"] = value == 3 ? (object) value : throw new NotSupportedException();
    }

    [DisplayName("Synchronous")]
    [Browsable(true)]
    [DefaultValue(SynchronizationModes.Normal)]
    public SynchronizationModes SyncMode
    {
      get
      {
        object obj;
        this.TryGetValue("synchronous", out obj);
        return obj is string ? (SynchronizationModes) TypeDescriptor.GetConverter(typeof (SynchronizationModes)).ConvertFrom(obj) : (SynchronizationModes) obj;
      }
      set => this["synchronous"] = (object) value;
    }

    [DefaultValue(false)]
    [Browsable(true)]
    [DisplayName("Use UTF-16 Encoding")]
    public bool UseUTF16Encoding
    {
      get
      {
        object source;
        this.TryGetValue("useutf16encoding", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["useutf16encoding"] = (object) value;
    }

    [Browsable(true)]
    [DefaultValue(false)]
    public bool Pooling
    {
      get
      {
        object source;
        this.TryGetValue("pooling", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["pooling"] = (object) value;
    }

    [DefaultValue(true)]
    [Browsable(true)]
    [DisplayName("Binary GUID")]
    public bool BinaryGUID
    {
      get
      {
        object source;
        this.TryGetValue("binaryguid", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["binaryguid"] = (object) value;
    }

    [Browsable(true)]
    [DisplayName("Data Source")]
    [DefaultValue("")]
    public string DataSource
    {
      get
      {
        object obj;
        this.TryGetValue("data source", out obj);
        return obj?.ToString();
      }
      set => this["data source"] = (object) value;
    }

    [DefaultValue(null)]
    [DisplayName("URI")]
    [Browsable(true)]
    public string Uri
    {
      get
      {
        object obj;
        this.TryGetValue("uri", out obj);
        return obj?.ToString();
      }
      set => this["uri"] = (object) value;
    }

    [DisplayName("Full URI")]
    [Browsable(true)]
    [DefaultValue(null)]
    public string FullUri
    {
      get
      {
        object obj;
        this.TryGetValue("fulluri", out obj);
        return obj?.ToString();
      }
      set => this["fulluri"] = (object) value;
    }

    [Browsable(true)]
    [DisplayName("Default Timeout")]
    [DefaultValue(30)]
    public int DefaultTimeout
    {
      get
      {
        object obj;
        this.TryGetValue("default timeout", out obj);
        return Convert.ToInt32(obj, (IFormatProvider) CultureInfo.CurrentCulture);
      }
      set => this["default timeout"] = (object) value;
    }

    [DisplayName("Busy Timeout")]
    [Browsable(true)]
    [DefaultValue(0)]
    public int BusyTimeout
    {
      get
      {
        object obj;
        this.TryGetValue("busytimeout", out obj);
        return Convert.ToInt32(obj, (IFormatProvider) CultureInfo.CurrentCulture);
      }
      set => this["busytimeout"] = (object) value;
    }

    [Browsable(true)]
    [DefaultValue(3)]
    [DisplayName("Prepare Retries")]
    public int PrepareRetries
    {
      get
      {
        object obj;
        this.TryGetValue("prepareretries", out obj);
        return Convert.ToInt32(obj, (IFormatProvider) CultureInfo.CurrentCulture);
      }
      set => this["prepareretries"] = (object) value;
    }

    [DefaultValue(0)]
    [DisplayName("Progress Ops")]
    [Browsable(true)]
    public int ProgressOps
    {
      get
      {
        object obj;
        this.TryGetValue("progressops", out obj);
        return Convert.ToInt32(obj, (IFormatProvider) CultureInfo.CurrentCulture);
      }
      set => this["progressops"] = (object) value;
    }

    [Browsable(true)]
    [DefaultValue(true)]
    public bool Enlist
    {
      get
      {
        object source;
        this.TryGetValue("enlist", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["enlist"] = (object) value;
    }

    [DisplayName("Fail If Missing")]
    [Browsable(true)]
    [DefaultValue(false)]
    public bool FailIfMissing
    {
      get
      {
        object source;
        this.TryGetValue("failifmissing", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["failifmissing"] = (object) value;
    }

    [DefaultValue(false)]
    [DisplayName("Legacy Format")]
    [Browsable(true)]
    public bool LegacyFormat
    {
      get
      {
        object source;
        this.TryGetValue("legacy format", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["legacy format"] = (object) value;
    }

    [DisplayName("Read Only")]
    [DefaultValue(false)]
    [Browsable(true)]
    public bool ReadOnly
    {
      get
      {
        object source;
        this.TryGetValue("read only", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["read only"] = (object) value;
    }

    [DefaultValue("")]
    [Browsable(true)]
    [PasswordPropertyText(true)]
    public string Password
    {
      get
      {
        object obj;
        this.TryGetValue("password", out obj);
        return obj?.ToString();
      }
      set => this["password"] = (object) value;
    }

    [DisplayName("Hexadecimal Password")]
    [PasswordPropertyText(true)]
    [DefaultValue(null)]
    [Browsable(true)]
    public byte[] HexPassword
    {
      get
      {
        object text;
        if (this.TryGetValue("hexpassword", out text))
        {
          if (text is string)
            return SQLiteConnection.FromHexString((string) text);
          if (text != null)
            return (byte[]) text;
        }
        return (byte[]) null;
      }
      set => this["hexpassword"] = (object) SQLiteConnection.ToHexString(value);
    }

    [DefaultValue(4096)]
    [DisplayName("Page Size")]
    [Browsable(true)]
    public int PageSize
    {
      get
      {
        object obj;
        this.TryGetValue("page size", out obj);
        return Convert.ToInt32(obj, (IFormatProvider) CultureInfo.CurrentCulture);
      }
      set => this["page size"] = (object) value;
    }

    [Browsable(true)]
    [DisplayName("Maximum Page Count")]
    [DefaultValue(0)]
    public int MaxPageCount
    {
      get
      {
        object obj;
        this.TryGetValue("max page count", out obj);
        return Convert.ToInt32(obj, (IFormatProvider) CultureInfo.CurrentCulture);
      }
      set => this["max page count"] = (object) value;
    }

    [DisplayName("Cache Size")]
    [Browsable(true)]
    [DefaultValue(-2000)]
    public int CacheSize
    {
      get
      {
        object obj;
        this.TryGetValue("cache size", out obj);
        return Convert.ToInt32(obj, (IFormatProvider) CultureInfo.CurrentCulture);
      }
      set => this["cache size"] = (object) value;
    }

    [DisplayName("DateTime Format")]
    [Browsable(true)]
    [DefaultValue(SQLiteDateFormats.ISO8601)]
    public SQLiteDateFormats DateTimeFormat
    {
      get
      {
        object obj;
        if (this.TryGetValue("datetimeformat", out obj))
        {
          if (obj is SQLiteDateFormats dateTimeFormat)
            return dateTimeFormat;
          if (obj != null)
            return (SQLiteDateFormats) TypeDescriptor.GetConverter(typeof (SQLiteDateFormats)).ConvertFrom(obj);
        }
        return SQLiteDateFormats.ISO8601;
      }
      set => this["datetimeformat"] = (object) value;
    }

    [DisplayName("DateTime Kind")]
    [Browsable(true)]
    [DefaultValue(DateTimeKind.Unspecified)]
    public DateTimeKind DateTimeKind
    {
      get
      {
        object obj;
        if (this.TryGetValue("datetimekind", out obj))
        {
          if (obj is DateTimeKind dateTimeKind)
            return dateTimeKind;
          if (obj != null)
            return (DateTimeKind) TypeDescriptor.GetConverter(typeof (DateTimeKind)).ConvertFrom(obj);
        }
        return DateTimeKind.Unspecified;
      }
      set => this["datetimekind"] = (object) value;
    }

    [Browsable(true)]
    [DisplayName("DateTime Format String")]
    [DefaultValue(null)]
    public string DateTimeFormatString
    {
      get
      {
        object timeFormatString;
        if (this.TryGetValue("datetimeformatstring", out timeFormatString))
        {
          if (timeFormatString is string)
            return (string) timeFormatString;
          if (timeFormatString != null)
            return timeFormatString.ToString();
        }
        return (string) null;
      }
      set => this["datetimeformatstring"] = (object) value;
    }

    [DefaultValue("sqlite_default_schema")]
    [DisplayName("Base Schema Name")]
    [Browsable(true)]
    public string BaseSchemaName
    {
      get
      {
        object baseSchemaName;
        if (this.TryGetValue("baseschemaname", out baseSchemaName))
        {
          if (baseSchemaName is string)
            return (string) baseSchemaName;
          if (baseSchemaName != null)
            return baseSchemaName.ToString();
        }
        return (string) null;
      }
      set => this["baseschemaname"] = (object) value;
    }

    [DefaultValue(SQLiteJournalModeEnum.Default)]
    [Browsable(true)]
    [DisplayName("Journal Mode")]
    public SQLiteJournalModeEnum JournalMode
    {
      get
      {
        object obj;
        this.TryGetValue("journal mode", out obj);
        return obj is string ? (SQLiteJournalModeEnum) TypeDescriptor.GetConverter(typeof (SQLiteJournalModeEnum)).ConvertFrom(obj) : (SQLiteJournalModeEnum) obj;
      }
      set => this["journal mode"] = (object) value;
    }

    [Browsable(true)]
    [DisplayName("Default Isolation Level")]
    [DefaultValue(IsolationLevel.Serializable)]
    public IsolationLevel DefaultIsolationLevel
    {
      get
      {
        object obj;
        this.TryGetValue("default isolationlevel", out obj);
        return obj is string ? (IsolationLevel) TypeDescriptor.GetConverter(typeof (IsolationLevel)).ConvertFrom(obj) : (IsolationLevel) obj;
      }
      set => this["default isolationlevel"] = (object) value;
    }

    [DefaultValue(~DbType.AnsiString)]
    [DisplayName("Default Database Type")]
    [Browsable(true)]
    public DbType DefaultDbType
    {
      get
      {
        object defaultDbType;
        if (this.TryGetValue("defaultdbtype", out defaultDbType))
        {
          if (defaultDbType is string)
            return (DbType) TypeDescriptor.GetConverter(typeof (DbType)).ConvertFrom(defaultDbType);
          if (defaultDbType != null)
            return (DbType) defaultDbType;
        }
        return ~DbType.AnsiString;
      }
      set => this["defaultdbtype"] = (object) value;
    }

    [Browsable(true)]
    [DisplayName("Default Type Name")]
    [DefaultValue(null)]
    public string DefaultTypeName
    {
      get
      {
        object obj;
        this.TryGetValue("defaulttypename", out obj);
        return obj?.ToString();
      }
      set => this["defaulttypename"] = (object) value;
    }

    [DisplayName("VFS Name")]
    [DefaultValue(null)]
    [Browsable(true)]
    public string VfsName
    {
      get
      {
        object obj;
        this.TryGetValue("vfsname", out obj);
        return obj?.ToString();
      }
      set => this["vfsname"] = (object) value;
    }

    [DisplayName("Foreign Keys")]
    [Browsable(true)]
    [DefaultValue(false)]
    public bool ForeignKeys
    {
      get
      {
        object source;
        this.TryGetValue("foreign keys", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["foreign keys"] = (object) value;
    }

    [DisplayName("Recursive Triggers")]
    [Browsable(true)]
    [DefaultValue(false)]
    public bool RecursiveTriggers
    {
      get
      {
        object source;
        this.TryGetValue("recursive triggers", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["recursive triggers"] = (object) value;
    }

    [Browsable(true)]
    [DefaultValue(null)]
    [DisplayName("ZipVFS Version")]
    public string ZipVfsVersion
    {
      get
      {
        object obj;
        this.TryGetValue("zipvfsversion", out obj);
        return obj?.ToString();
      }
      set => this["zipvfsversion"] = (object) value;
    }

    [Browsable(true)]
    [DefaultValue(SQLiteConnectionFlags.Default)]
    public SQLiteConnectionFlags Flags
    {
      get
      {
        object obj;
        if (this.TryGetValue("flags", out obj))
        {
          if (obj is SQLiteConnectionFlags flags)
            return flags;
          if (obj != null)
            return (SQLiteConnectionFlags) TypeDescriptor.GetConverter(typeof (SQLiteConnectionFlags)).ConvertFrom(obj);
        }
        return SQLiteConnectionFlags.Default;
      }
      set => this["flags"] = (object) value;
    }

    [Browsable(true)]
    [DefaultValue(true)]
    [DisplayName("Set Defaults")]
    public bool SetDefaults
    {
      get
      {
        object source;
        this.TryGetValue("setdefaults", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["setdefaults"] = (object) value;
    }

    [DefaultValue(true)]
    [DisplayName("To Full Path")]
    [Browsable(true)]
    public bool ToFullPath
    {
      get
      {
        object source;
        this.TryGetValue("tofullpath", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["tofullpath"] = (object) value;
    }

    [DisplayName("No Default Flags")]
    [Browsable(true)]
    [DefaultValue(false)]
    public bool NoDefaultFlags
    {
      get
      {
        object source;
        this.TryGetValue("nodefaultflags", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["nodefaultflags"] = (object) value;
    }

    [DefaultValue(false)]
    [DisplayName("No Shared Flags")]
    [Browsable(true)]
    public bool NoSharedFlags
    {
      get
      {
        object source;
        this.TryGetValue("nosharedflags", out source);
        return SQLiteConvert.ToBoolean(source);
      }
      set => this["nosharedflags"] = (object) value;
    }

    public override bool TryGetValue(string keyword, out object value)
    {
      bool flag = base.TryGetValue(keyword, out value);
      if (!this._properties.ContainsKey((object) keyword) || !(this._properties[(object) keyword] is PropertyDescriptor property))
        return flag;
      if (flag)
      {
        if (property.PropertyType == typeof (bool))
          value = (object) SQLiteConvert.ToBoolean(value);
        else if (property.PropertyType != typeof (byte[]))
          value = TypeDescriptor.GetConverter(property.PropertyType).ConvertFrom(value);
      }
      else if (property.Attributes[typeof (DefaultValueAttribute)] is DefaultValueAttribute attribute)
      {
        value = attribute.Value;
        flag = true;
      }
      return flag;
    }

    private void FallbackGetProperties(Hashtable propertyList)
    {
      foreach (PropertyDescriptor property in TypeDescriptor.GetProperties((object) this, true))
      {
        if (property.Name != "ConnectionString" && !propertyList.ContainsKey((object) property.DisplayName))
          propertyList.Add((object) property.DisplayName, (object) property);
      }
    }
  }
}


--- SQLiteContext.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteContext
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteContext : ISQLiteNativeHandle
  {
    private IntPtr pContext;

    internal SQLiteContext(IntPtr pContext) => this.pContext = pContext;

    public IntPtr NativeHandle => this.pContext;

    public void SetNull()
    {
      if (this.pContext == IntPtr.Zero)
        throw new InvalidOperationException();
      UnsafeNativeMethods.sqlite3_result_null(this.pContext);
    }

    public void SetDouble(double value)
    {
      if (this.pContext == IntPtr.Zero)
        throw new InvalidOperationException();
      UnsafeNativeMethods.sqlite3_result_double(this.pContext, value);
    }

    public void SetInt(int value)
    {
      if (this.pContext == IntPtr.Zero)
        throw new InvalidOperationException();
      UnsafeNativeMethods.sqlite3_result_int(this.pContext, value);
    }

    public void SetInt64(long value)
    {
      if (this.pContext == IntPtr.Zero)
        throw new InvalidOperationException();
      UnsafeNativeMethods.sqlite3_result_int64(this.pContext, value);
    }

    public void SetString(string value)
    {
      if (this.pContext == IntPtr.Zero)
        throw new InvalidOperationException();
      byte[] utf8BytesFromString = SQLiteString.GetUtf8BytesFromString(value);
      if (utf8BytesFromString == null)
        throw new ArgumentNullException(nameof (value));
      UnsafeNativeMethods.sqlite3_result_text(this.pContext, utf8BytesFromString, utf8BytesFromString.Length, (IntPtr) -1);
    }

    public void SetError(string value)
    {
      if (this.pContext == IntPtr.Zero)
        throw new InvalidOperationException();
      byte[] utf8BytesFromString = SQLiteString.GetUtf8BytesFromString(value);
      if (utf8BytesFromString == null)
        throw new ArgumentNullException(nameof (value));
      UnsafeNativeMethods.sqlite3_result_error(this.pContext, utf8BytesFromString, utf8BytesFromString.Length);
    }

    public void SetErrorCode(SQLiteErrorCode value)
    {
      if (this.pContext == IntPtr.Zero)
        throw new InvalidOperationException();
      UnsafeNativeMethods.sqlite3_result_error_code(this.pContext, value);
    }

    public void SetErrorTooBig()
    {
      if (this.pContext == IntPtr.Zero)
        throw new InvalidOperationException();
      UnsafeNativeMethods.sqlite3_result_error_toobig(this.pContext);
    }

    public void SetErrorNoMemory()
    {
      if (this.pContext == IntPtr.Zero)
        throw new InvalidOperationException();
      UnsafeNativeMethods.sqlite3_result_error_nomem(this.pContext);
    }

    public void SetBlob(byte[] value)
    {
      if (this.pContext == IntPtr.Zero)
        throw new InvalidOperationException();
      if (value == null)
        throw new ArgumentNullException(nameof (value));
      UnsafeNativeMethods.sqlite3_result_blob(this.pContext, value, value.Length, (IntPtr) -1);
    }

    public void SetZeroBlob(int value)
    {
      if (this.pContext == IntPtr.Zero)
        throw new InvalidOperationException();
      UnsafeNativeMethods.sqlite3_result_zeroblob(this.pContext, value);
    }

    public void SetValue(SQLiteValue value)
    {
      if (this.pContext == IntPtr.Zero)
        throw new InvalidOperationException();
      if (value == null)
        throw new ArgumentNullException(nameof (value));
      UnsafeNativeMethods.sqlite3_result_value(this.pContext, value.NativeHandle);
    }
  }
}


--- SQLiteConvert.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteConvert
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Text;

#nullable disable
namespace System.Data.SQLite
{
  public abstract class SQLiteConvert
  {
    private const DbType FallbackDefaultDbType = DbType.Object;
    private const string FullFormat = "yyyy-MM-ddTHH:mm:ss.fffffffK";
    private static readonly string FallbackDefaultTypeName = string.Empty;
    protected static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);
    private static readonly double OleAutomationEpochAsJulianDay = 2415018.5;
    private static readonly long MinimumJd = SQLiteConvert.computeJD(DateTime.MinValue);
    private static readonly long MaximumJd = SQLiteConvert.computeJD(DateTime.MaxValue);
    private static string[] _datetimeFormats = new string[31]
    {
      "THHmmssK",
      "THHmmK",
      "HH:mm:ss.FFFFFFFK",
      "HH:mm:ssK",
      "HH:mmK",
      "yyyy-MM-dd HH:mm:ss.FFFFFFFK",
      "yyyy-MM-dd HH:mm:ssK",
      "yyyy-MM-dd HH:mmK",
      "yyyy-MM-ddTHH:mm:ss.FFFFFFFK",
      "yyyy-MM-ddTHH:mmK",
      "yyyy-MM-ddTHH:mm:ssK",
      "yyyyMMddHHmmssK",
      "yyyyMMddHHmmK",
      "yyyyMMddTHHmmssFFFFFFFK",
      "THHmmss",
      "THHmm",
      "HH:mm:ss.FFFFFFF",
      "HH:mm:ss",
      "HH:mm",
      "yyyy-MM-dd HH:mm:ss.FFFFFFF",
      "yyyy-MM-dd HH:mm:ss",
      "yyyy-MM-dd HH:mm",
      "yyyy-MM-ddTHH:mm:ss.FFFFFFF",
      "yyyy-MM-ddTHH:mm",
      "yyyy-MM-ddTHH:mm:ss",
      "yyyyMMddHHmmss",
      "yyyyMMddHHmm",
      "yyyyMMddTHHmmssFFFFFFF",
      "yyyy-MM-dd",
      "yyyyMMdd",
      "yy-MM-dd"
    };
    private static readonly string _datetimeFormatUtc = SQLiteConvert._datetimeFormats[5];
    private static readonly string _datetimeFormatLocal = SQLiteConvert._datetimeFormats[19];
    private static Encoding _utf8 = (Encoding) new UTF8Encoding();
    internal SQLiteDateFormats _datetimeFormat;
    internal DateTimeKind _datetimeKind;
    internal string _datetimeFormatString;
    private static Type[] _affinitytotype = new Type[8]
    {
      typeof (object),
      typeof (long),
      typeof (double),
      typeof (string),
      typeof (byte[]),
      typeof (object),
      typeof (DateTime),
      typeof (object)
    };
    private static DbType[] _typetodbtype = new DbType[19]
    {
      DbType.Object,
      DbType.Binary,
      DbType.Object,
      DbType.Boolean,
      DbType.SByte,
      DbType.SByte,
      DbType.Byte,
      DbType.Int16,
      DbType.UInt16,
      DbType.Int32,
      DbType.UInt32,
      DbType.Int64,
      DbType.UInt64,
      DbType.Single,
      DbType.Double,
      DbType.Decimal,
      DbType.DateTime,
      DbType.Object,
      DbType.String
    };
    private static int[] _dbtypetocolumnsize = new int[26]
    {
      int.MaxValue,
      int.MaxValue,
      1,
      1,
      8,
      8,
      8,
      8,
      8,
      16,
      2,
      4,
      8,
      int.MaxValue,
      1,
      4,
      int.MaxValue,
      8,
      2,
      4,
      8,
      8,
      int.MaxValue,
      int.MaxValue,
      int.MaxValue,
      int.MaxValue
    };
    private static object[] _dbtypetonumericprecision = new object[26]
    {
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) 3,
      (object) DBNull.Value,
      (object) 19,
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) 53,
      (object) 53,
      (object) DBNull.Value,
      (object) 5,
      (object) 10,
      (object) 19,
      (object) DBNull.Value,
      (object) 3,
      (object) 24,
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) 5,
      (object) 10,
      (object) 19,
      (object) 53,
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) DBNull.Value
    };
    private static object[] _dbtypetonumericscale = new object[26]
    {
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) 0,
      (object) DBNull.Value,
      (object) 4,
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) 0,
      (object) 0,
      (object) 0,
      (object) DBNull.Value,
      (object) 0,
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) 0,
      (object) 0,
      (object) 0,
      (object) 0,
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) DBNull.Value,
      (object) DBNull.Value
    };
    private static Type[] _dbtypeToType = new Type[26]
    {
      typeof (string),
      typeof (byte[]),
      typeof (byte),
      typeof (bool),
      typeof (Decimal),
      typeof (DateTime),
      typeof (DateTime),
      typeof (Decimal),
      typeof (double),
      typeof (Guid),
      typeof (short),
      typeof (int),
      typeof (long),
      typeof (object),
      typeof (sbyte),
      typeof (float),
      typeof (string),
      typeof (DateTime),
      typeof (ushort),
      typeof (uint),
      typeof (ulong),
      typeof (double),
      typeof (string),
      typeof (string),
      typeof (string),
      typeof (string)
    };
    private static TypeAffinity[] _typecodeAffinities = new TypeAffinity[19]
    {
      TypeAffinity.Null,
      TypeAffinity.Blob,
      TypeAffinity.Null,
      TypeAffinity.Int64,
      TypeAffinity.Int64,
      TypeAffinity.Int64,
      TypeAffinity.Int64,
      TypeAffinity.Int64,
      TypeAffinity.Int64,
      TypeAffinity.Int64,
      TypeAffinity.Int64,
      TypeAffinity.Int64,
      TypeAffinity.Int64,
      TypeAffinity.Double,
      TypeAffinity.Double,
      TypeAffinity.Double,
      TypeAffinity.DateTime,
      TypeAffinity.Null,
      TypeAffinity.Text
    };
    private static object _syncRoot = new object();
    private static SQLiteDbTypeMap _typeNames = (SQLiteDbTypeMap) null;

    internal SQLiteConvert(SQLiteDateFormats fmt, DateTimeKind kind, string fmtString)
    {
      this._datetimeFormat = fmt;
      this._datetimeKind = kind;
      this._datetimeFormatString = fmtString;
    }

    public static byte[] ToUTF8(string sourceText)
    {
      if (sourceText == null)
        return (byte[]) null;
      byte[] bytes = new byte[SQLiteConvert._utf8.GetByteCount(sourceText) + 1];
      bytes[SQLiteConvert._utf8.GetBytes(sourceText, 0, sourceText.Length, bytes, 0)] = (byte) 0;
      return bytes;
    }

    public byte[] ToUTF8(DateTime dateTimeValue)
    {
      return SQLiteConvert.ToUTF8(this.ToString(dateTimeValue));
    }

    public virtual string ToString(IntPtr nativestring, int nativestringlen)
    {
      return SQLiteConvert.UTF8ToString(nativestring, nativestringlen);
    }

    public static string UTF8ToString(IntPtr nativestring, int nativestringlen)
    {
      if (nativestring == IntPtr.Zero || nativestringlen == 0)
        return string.Empty;
      if (nativestringlen < 0)
      {
        nativestringlen = 0;
        while (Marshal.ReadByte(nativestring, nativestringlen) != (byte) 0)
          ++nativestringlen;
        if (nativestringlen == 0)
          return string.Empty;
      }
      byte[] numArray = new byte[nativestringlen];
      Marshal.Copy(nativestring, numArray, 0, nativestringlen);
      return SQLiteConvert._utf8.GetString(numArray, 0, nativestringlen);
    }

    private static bool isValidJd(long jd)
    {
      return jd >= SQLiteConvert.MinimumJd && jd <= SQLiteConvert.MaximumJd;
    }

    private static long DoubleToJd(double julianDay) => (long) (julianDay * 86400000.0);

    private static double JdToDouble(long jd) => (double) jd / 86400000.0;

    private static DateTime computeYMD(long jd, DateTime? badValue)
    {
      if (!SQLiteConvert.isValidJd(jd))
        return badValue.HasValue ? badValue.Value : throw new ArgumentException("Not a supported Julian Day value.");
      int num1 = (int) ((jd + 43200000L) / 86400000L);
      int num2 = (int) (((double) num1 - 1867216.25) / 36524.25);
      int num3 = num1 + 1 + num2 - num2 / 4 + 1524;
      int num4 = (int) (((double) num3 - 122.1) / 365.25);
      int num5 = 36525 * num4 / 100;
      int num6 = (int) ((double) (num3 - num5) / 30.6001);
      int num7 = (int) (30.6001 * (double) num6);
      int day = num3 - num5 - num7;
      int month = num6 < 14 ? num6 - 1 : num6 - 13;
      int year = month > 2 ? num4 - 4716 : num4 - 4715;
      try
      {
        return new DateTime(year, month, day);
      }
      catch
      {
        if (badValue.HasValue)
          return badValue.Value;
        throw;
      }
    }

    private static DateTime computeHMS(long jd, DateTime? badValue)
    {
      if (!SQLiteConvert.isValidJd(jd))
        return badValue.HasValue ? badValue.Value : throw new ArgumentException("Not a supported Julian Day value.");
      Decimal num1 = (Decimal) (int) ((jd + 43200000L) % 86400000L) / 1000.0M;
      int num2 = (int) num1;
      int millisecond = (int) ((num1 - (Decimal) num2) * 1000.0M);
      Decimal num3 = num1 - (Decimal) num2;
      int hour = num2 / 3600;
      int num4 = num2 - hour * 3600;
      int minute = num4 / 60;
      int second = (int) (num3 + (Decimal) (num4 - minute * 60));
      try
      {
        DateTime minValue = DateTime.MinValue;
        return new DateTime(minValue.Year, minValue.Month, minValue.Day, hour, minute, second, millisecond);
      }
      catch
      {
        if (badValue.HasValue)
          return badValue.Value;
        throw;
      }
    }

    private static long computeJD(DateTime dateTime)
    {
      int year = dateTime.Year;
      int month = dateTime.Month;
      int day = dateTime.Day;
      if (month <= 2)
      {
        --year;
        month += 12;
      }
      int num1 = year / 100;
      int num2 = 2 - num1 + num1 / 4;
      return (long) (((double) (36525 * (year + 4716) / 100 + 306001 * (month + 1) / 10000 + day + num2) - 1524.5) * 86400000.0) + (long) (dateTime.Hour * 3600000 + dateTime.Minute * 60000 + dateTime.Second * 1000 + dateTime.Millisecond);
    }

    public DateTime ToDateTime(string dateText)
    {
      return SQLiteConvert.ToDateTime(dateText, this._datetimeFormat, this._datetimeKind, this._datetimeFormatString);
    }

    public static DateTime ToDateTime(
      string dateText,
      SQLiteDateFormats format,
      DateTimeKind kind,
      string formatString)
    {
      switch (format)
      {
        case SQLiteDateFormats.Ticks:
          return SQLiteConvert.TicksToDateTime(Convert.ToInt64(dateText, (IFormatProvider) CultureInfo.InvariantCulture), kind);
        case SQLiteDateFormats.JulianDay:
          return SQLiteConvert.ToDateTime(Convert.ToDouble(dateText, (IFormatProvider) CultureInfo.InvariantCulture), kind);
        case SQLiteDateFormats.UnixEpoch:
          return SQLiteConvert.UnixEpochToDateTime(Convert.ToInt64(dateText, (IFormatProvider) CultureInfo.InvariantCulture), kind);
        case SQLiteDateFormats.InvariantCulture:
          return formatString != null ? DateTime.SpecifyKind(DateTime.ParseExact(dateText, formatString, (IFormatProvider) DateTimeFormatInfo.InvariantInfo, kind == DateTimeKind.Utc ? DateTimeStyles.AdjustToUniversal : DateTimeStyles.None), kind) : DateTime.SpecifyKind(DateTime.Parse(dateText, (IFormatProvider) DateTimeFormatInfo.InvariantInfo, kind == DateTimeKind.Utc ? DateTimeStyles.AdjustToUniversal : DateTimeStyles.None), kind);
        case SQLiteDateFormats.CurrentCulture:
          return formatString != null ? DateTime.SpecifyKind(DateTime.ParseExact(dateText, formatString, (IFormatProvider) DateTimeFormatInfo.CurrentInfo, kind == DateTimeKind.Utc ? DateTimeStyles.AdjustToUniversal : DateTimeStyles.None), kind) : DateTime.SpecifyKind(DateTime.Parse(dateText, (IFormatProvider) DateTimeFormatInfo.CurrentInfo, kind == DateTimeKind.Utc ? DateTimeStyles.AdjustToUniversal : DateTimeStyles.None), kind);
        default:
          return formatString != null ? DateTime.SpecifyKind(DateTime.ParseExact(dateText, formatString, (IFormatProvider) DateTimeFormatInfo.InvariantInfo, kind == DateTimeKind.Utc ? DateTimeStyles.AdjustToUniversal : DateTimeStyles.None), kind) : DateTime.SpecifyKind(DateTime.ParseExact(dateText, SQLiteConvert._datetimeFormats, (IFormatProvider) DateTimeFormatInfo.InvariantInfo, kind == DateTimeKind.Utc ? DateTimeStyles.AdjustToUniversal : DateTimeStyles.None), kind);
      }
    }

    public DateTime ToDateTime(double julianDay)
    {
      return SQLiteConvert.ToDateTime(julianDay, this._datetimeKind);
    }

    public static DateTime ToDateTime(double julianDay, DateTimeKind kind)
    {
      long jd = SQLiteConvert.DoubleToJd(julianDay);
      DateTime ymd = SQLiteConvert.computeYMD(jd, new DateTime?());
      DateTime hms = SQLiteConvert.computeHMS(jd, new DateTime?());
      return new DateTime(ymd.Year, ymd.Month, ymd.Day, hms.Hour, hms.Minute, hms.Second, hms.Millisecond, kind);
    }

    internal static DateTime UnixEpochToDateTime(long seconds, DateTimeKind kind)
    {
      return DateTime.SpecifyKind(SQLiteConvert.UnixEpoch.AddSeconds((double) seconds), kind);
    }

    internal static DateTime TicksToDateTime(long ticks, DateTimeKind kind)
    {
      return new DateTime(ticks, kind);
    }

    public static double ToJulianDay(DateTime value)
    {
      return SQLiteConvert.JdToDouble(SQLiteConvert.computeJD(value));
    }

    public static long ToUnixEpoch(DateTime value)
    {
      return value.Subtract(SQLiteConvert.UnixEpoch).Ticks / 10000000L;
    }

    private static string GetDateTimeKindFormat(DateTimeKind kind, string formatString)
    {
      if (formatString != null)
        return formatString;
      return kind != DateTimeKind.Utc ? SQLiteConvert._datetimeFormatLocal : SQLiteConvert._datetimeFormatUtc;
    }

    public string ToString(DateTime dateValue)
    {
      return SQLiteConvert.ToString(dateValue, this._datetimeFormat, this._datetimeKind, this._datetimeFormatString);
    }

    public static string ToString(
      DateTime dateValue,
      SQLiteDateFormats format,
      DateTimeKind kind,
      string formatString)
    {
      switch (format)
      {
        case SQLiteDateFormats.Ticks:
          return dateValue.Ticks.ToString((IFormatProvider) CultureInfo.InvariantCulture);
        case SQLiteDateFormats.JulianDay:
          return SQLiteConvert.ToJulianDay(dateValue).ToString((IFormatProvider) CultureInfo.InvariantCulture);
        case SQLiteDateFormats.UnixEpoch:
          return (dateValue.Subtract(SQLiteConvert.UnixEpoch).Ticks / 10000000L).ToString();
        case SQLiteDateFormats.InvariantCulture:
          return dateValue.ToString(formatString != null ? formatString : "yyyy-MM-ddTHH:mm:ss.fffffffK", (IFormatProvider) CultureInfo.InvariantCulture);
        case SQLiteDateFormats.CurrentCulture:
          return dateValue.ToString(formatString != null ? formatString : "yyyy-MM-ddTHH:mm:ss.fffffffK", (IFormatProvider) CultureInfo.CurrentCulture);
        default:
          return dateValue.Kind != DateTimeKind.Unspecified ? dateValue.ToString(SQLiteConvert.GetDateTimeKindFormat(dateValue.Kind, formatString), (IFormatProvider) CultureInfo.InvariantCulture) : DateTime.SpecifyKind(dateValue, kind).ToString(SQLiteConvert.GetDateTimeKindFormat(kind, formatString), (IFormatProvider) CultureInfo.InvariantCulture);
      }
    }

    internal DateTime ToDateTime(IntPtr ptr, int len) => this.ToDateTime(this.ToString(ptr, len));

    public static string[] Split(string source, char separator)
    {
      char[] anyOf1 = new char[2]{ '"', separator };
      char[] anyOf2 = new char[1]{ '"' };
      int startIndex = 0;
      List<string> stringList = new List<string>();
      while (source.Length > 0)
      {
        int num1 = source.IndexOfAny(anyOf1, startIndex);
        if (num1 != -1)
        {
          if ((int) source[num1] == (int) anyOf1[0])
          {
            int num2 = source.IndexOfAny(anyOf2, num1 + 1);
            if (num2 != -1)
              startIndex = num2 + 1;
            else
              break;
          }
          else
          {
            string str = source.Substring(0, num1).Trim();
            if (str.Length > 1 && (int) str[0] == (int) anyOf2[0] && (int) str[str.Length - 1] == (int) str[0])
              str = str.Substring(1, str.Length - 2);
            source = source.Substring(num1 + 1).Trim();
            if (str.Length > 0)
              stringList.Add(str);
            startIndex = 0;
          }
        }
        else
          break;
      }
      if (source.Length > 0)
      {
        string str = source.Trim();
        if (str.Length > 1 && (int) str[0] == (int) anyOf2[0] && (int) str[str.Length - 1] == (int) str[0])
          str = str.Substring(1, str.Length - 2);
        stringList.Add(str);
      }
      string[] array = new string[stringList.Count];
      stringList.CopyTo(array, 0);
      return array;
    }

    internal static string[] NewSplit(
      string value,
      char separator,
      bool keepQuote,
      ref string error)
    {
      if (separator == '\\' || separator == '"')
      {
        error = "separator character cannot be the escape or quote characters";
        return (string[]) null;
      }
      if (value == null)
      {
        error = "string value to split cannot be null";
        return (string[]) null;
      }
      int length = value.Length;
      if (length == 0)
        return new string[0];
      List<string> stringList = new List<string>();
      StringBuilder stringBuilder = new StringBuilder();
      int num = 0;
      bool flag1 = false;
      bool flag2 = false;
      while (num < length)
      {
        char ch = value[num++];
        if (flag1)
        {
          if (ch != '\\' && ch != '"' && (int) ch != (int) separator)
            stringBuilder.Append('\\');
          stringBuilder.Append(ch);
          flag1 = false;
        }
        else
        {
          switch (ch)
          {
            case '"':
              if (keepQuote)
                stringBuilder.Append(ch);
              flag2 = !flag2;
              continue;
            case '\\':
              flag1 = true;
              continue;
            default:
              if ((int) ch == (int) separator)
              {
                if (flag2)
                {
                  stringBuilder.Append(ch);
                  continue;
                }
                stringList.Add(stringBuilder.ToString());
                stringBuilder.Length = 0;
                continue;
              }
              stringBuilder.Append(ch);
              continue;
          }
        }
      }
      if (flag1 || flag2)
      {
        error = "unbalanced escape or quote character found";
        return (string[]) null;
      }
      if (stringBuilder.Length > 0)
        stringList.Add(stringBuilder.ToString());
      return stringList.ToArray();
    }

    public static string ToStringWithProvider(object obj, IFormatProvider provider)
    {
      switch (obj)
      {
        case null:
          return (string) null;
        case string _:
          return (string) obj;
        case IConvertible convertible:
          return convertible.ToString(provider);
        default:
          return obj.ToString();
      }
    }

    internal static bool ToBoolean(object obj, IFormatProvider provider, bool viaFramework)
    {
      if (obj == null)
        return false;
      TypeCode typeCode = Type.GetTypeCode(obj.GetType());
      switch (typeCode)
      {
        case TypeCode.Empty:
        case TypeCode.DBNull:
          return false;
        case TypeCode.Boolean:
          return (bool) obj;
        case TypeCode.Char:
          return (char) obj != char.MinValue;
        case TypeCode.SByte:
          return (sbyte) obj != (sbyte) 0;
        case TypeCode.Byte:
          return (byte) obj != (byte) 0;
        case TypeCode.Int16:
          return (short) obj != (short) 0;
        case TypeCode.UInt16:
          return (ushort) obj != (ushort) 0;
        case TypeCode.Int32:
          return (int) obj != 0;
        case TypeCode.UInt32:
          return (uint) obj != 0U;
        case TypeCode.Int64:
          return (long) obj != 0L;
        case TypeCode.UInt64:
          return (ulong) obj != 0UL;
        case TypeCode.Single:
          return (double) (float) obj != 0.0;
        case TypeCode.Double:
          return (double) obj != 0.0;
        case TypeCode.Decimal:
          return (Decimal) obj != 0M;
        case TypeCode.String:
          return !viaFramework ? SQLiteConvert.ToBoolean(SQLiteConvert.ToStringWithProvider(obj, provider)) : Convert.ToBoolean(obj, provider);
        default:
          throw new SQLiteException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Cannot convert type {0} to boolean", (object) typeCode));
      }
    }

    public static bool ToBoolean(object source)
    {
      return source is bool flag ? flag : SQLiteConvert.ToBoolean(SQLiteConvert.ToStringWithProvider(source, (IFormatProvider) CultureInfo.InvariantCulture));
    }

    public static bool ToBoolean(string source)
    {
      if (source == null)
        throw new ArgumentNullException(nameof (source));
      if (string.Compare(source, 0, bool.TrueString, 0, source.Length, StringComparison.OrdinalIgnoreCase) == 0)
        return true;
      if (string.Compare(source, 0, bool.FalseString, 0, source.Length, StringComparison.OrdinalIgnoreCase) == 0)
        return false;
      switch (source.ToLower(CultureInfo.InvariantCulture))
      {
        case "y":
        case "yes":
        case "on":
        case "1":
          return true;
        case "n":
        case "no":
        case "off":
        case "0":
          return false;
        default:
          throw new ArgumentException(nameof (source));
      }
    }

    internal static Type SQLiteTypeToType(SQLiteType t)
    {
      return t.Type == DbType.Object ? SQLiteConvert._affinitytotype[(int) t.Affinity] : SQLiteConvert.DbTypeToType(t.Type);
    }

    internal static DbType TypeToDbType(Type typ)
    {
      TypeCode typeCode = Type.GetTypeCode(typ);
      if (typeCode != TypeCode.Object)
        return SQLiteConvert._typetodbtype[(int) typeCode];
      if (typ == typeof (byte[]))
        return DbType.Binary;
      return typ == typeof (Guid) ? DbType.Guid : DbType.String;
    }

    internal static int DbTypeToColumnSize(DbType typ)
    {
      return SQLiteConvert._dbtypetocolumnsize[(int) typ];
    }

    internal static object DbTypeToNumericPrecision(DbType typ)
    {
      return SQLiteConvert._dbtypetonumericprecision[(int) typ];
    }

    internal static object DbTypeToNumericScale(DbType typ)
    {
      return SQLiteConvert._dbtypetonumericscale[(int) typ];
    }

    private static string GetDefaultTypeName(SQLiteConnection connection)
    {
      if (((connection != null ? (long) connection.Flags : 0L) & 134217728L) == 134217728L)
        return SQLiteConvert.FallbackDefaultTypeName;
      string name = "Use_SQLiteConvert_DefaultTypeName";
      object obj = (object) null;
      string @default = (string) null;
      if (connection != null)
      {
        if (connection.TryGetCachedSetting(name, (object) @default, out obj))
          goto label_8;
      }
      try
      {
        obj = (object) UnsafeNativeMethods.GetSettingValue(name, @default) ?? (object) SQLiteConvert.FallbackDefaultTypeName;
      }
      finally
      {
        connection?.SetCachedSetting(name, obj);
      }
label_8:
      return SQLiteConvert.SettingValueToString(obj);
    }

    private static void DefaultTypeNameWarning(
      DbType dbType,
      SQLiteConnectionFlags flags,
      string typeName)
    {
      if ((flags & SQLiteConnectionFlags.TraceWarning) != SQLiteConnectionFlags.TraceWarning)
        return;
      Trace.WriteLine(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "WARNING: Type mapping failed, returning default name \"{0}\" for type {1}.", (object) typeName, (object) dbType));
    }

    private static void DefaultDbTypeWarning(
      string typeName,
      SQLiteConnectionFlags flags,
      DbType? dbType)
    {
      if (string.IsNullOrEmpty(typeName) || (flags & SQLiteConnectionFlags.TraceWarning) != SQLiteConnectionFlags.TraceWarning)
        return;
      Trace.WriteLine(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "WARNING: Type mapping failed, returning default type {0} for name \"{1}\".", (object) dbType, (object) typeName));
    }

    internal static string DbTypeToTypeName(
      SQLiteConnection connection,
      DbType dbType,
      SQLiteConnectionFlags flags)
    {
      string typeName = (string) null;
      if (connection != null)
      {
        flags |= connection.Flags;
        if ((flags & SQLiteConnectionFlags.UseConnectionTypes) == SQLiteConnectionFlags.UseConnectionTypes)
        {
          SQLiteDbTypeMap typeNames = connection._typeNames;
          SQLiteDbTypeMapping liteDbTypeMapping;
          if (typeNames != null && typeNames.TryGetValue(dbType, out liteDbTypeMapping))
            return liteDbTypeMapping.typeName;
        }
        typeName = connection.DefaultTypeName;
      }
      if ((flags & SQLiteConnectionFlags.NoGlobalTypes) == SQLiteConnectionFlags.NoGlobalTypes)
      {
        if (typeName != null)
          return typeName;
        string defaultTypeName = SQLiteConvert.GetDefaultTypeName(connection);
        SQLiteConvert.DefaultTypeNameWarning(dbType, flags, defaultTypeName);
        return defaultTypeName;
      }
      lock (SQLiteConvert._syncRoot)
      {
        if (SQLiteConvert._typeNames == null)
          SQLiteConvert._typeNames = SQLiteConvert.GetSQLiteDbTypeMap();
        SQLiteDbTypeMapping liteDbTypeMapping;
        if (SQLiteConvert._typeNames.TryGetValue(dbType, out liteDbTypeMapping))
          return liteDbTypeMapping.typeName;
      }
      if (typeName != null)
        return typeName;
      string defaultTypeName1 = SQLiteConvert.GetDefaultTypeName(connection);
      SQLiteConvert.DefaultTypeNameWarning(dbType, flags, defaultTypeName1);
      return defaultTypeName1;
    }

    internal static Type DbTypeToType(DbType typ) => SQLiteConvert._dbtypeToType[(int) typ];

    internal static TypeAffinity TypeToAffinity(Type typ)
    {
      TypeCode typeCode = Type.GetTypeCode(typ);
      if (typeCode != TypeCode.Object)
        return SQLiteConvert._typecodeAffinities[(int) typeCode];
      return typ == typeof (byte[]) || typ == typeof (Guid) ? TypeAffinity.Blob : TypeAffinity.Text;
    }

    private static SQLiteDbTypeMap GetSQLiteDbTypeMap()
    {
      return new SQLiteDbTypeMap((IEnumerable<SQLiteDbTypeMapping>) new SQLiteDbTypeMapping[72]
      {
        new SQLiteDbTypeMapping("BIGINT", DbType.Int64, false),
        new SQLiteDbTypeMapping("BIGUINT", DbType.UInt64, false),
        new SQLiteDbTypeMapping("BINARY", DbType.Binary, false),
        new SQLiteDbTypeMapping("BIT", DbType.Boolean, true),
        new SQLiteDbTypeMapping("BLOB", DbType.Binary, true),
        new SQLiteDbTypeMapping("BOOL", DbType.Boolean, false),
        new SQLiteDbTypeMapping("BOOLEAN", DbType.Boolean, false),
        new SQLiteDbTypeMapping("CHAR", DbType.AnsiStringFixedLength, true),
        new SQLiteDbTypeMapping("CLOB", DbType.String, false),
        new SQLiteDbTypeMapping("COUNTER", DbType.Int64, false),
        new SQLiteDbTypeMapping("CURRENCY", DbType.Decimal, false),
        new SQLiteDbTypeMapping("DATE", DbType.DateTime, false),
        new SQLiteDbTypeMapping("DATETIME", DbType.DateTime, true),
        new SQLiteDbTypeMapping("DECIMAL", DbType.Decimal, true),
        new SQLiteDbTypeMapping("DOUBLE", DbType.Double, false),
        new SQLiteDbTypeMapping("FLOAT", DbType.Double, false),
        new SQLiteDbTypeMapping("GENERAL", DbType.Binary, false),
        new SQLiteDbTypeMapping("GUID", DbType.Guid, false),
        new SQLiteDbTypeMapping("IDENTITY", DbType.Int64, false),
        new SQLiteDbTypeMapping("IMAGE", DbType.Binary, false),
        new SQLiteDbTypeMapping("INT", DbType.Int32, true),
        new SQLiteDbTypeMapping("INT8", DbType.SByte, false),
        new SQLiteDbTypeMapping("INT16", DbType.Int16, false),
        new SQLiteDbTypeMapping("INT32", DbType.Int32, false),
        new SQLiteDbTypeMapping("INT64", DbType.Int64, false),
        new SQLiteDbTypeMapping("INTEGER", DbType.Int64, true),
        new SQLiteDbTypeMapping("INTEGER8", DbType.SByte, false),
        new SQLiteDbTypeMapping("INTEGER16", DbType.Int16, false),
        new SQLiteDbTypeMapping("INTEGER32", DbType.Int32, false),
        new SQLiteDbTypeMapping("INTEGER64", DbType.Int64, false),
        new SQLiteDbTypeMapping("LOGICAL", DbType.Boolean, false),
        new SQLiteDbTypeMapping("LONG", DbType.Int64, false),
        new SQLiteDbTypeMapping("LONGCHAR", DbType.String, false),
        new SQLiteDbTypeMapping("LONGTEXT", DbType.String, false),
        new SQLiteDbTypeMapping("LONGVARCHAR", DbType.String, false),
        new SQLiteDbTypeMapping("MEMO", DbType.String, false),
        new SQLiteDbTypeMapping("MONEY", DbType.Decimal, false),
        new SQLiteDbTypeMapping("NCHAR", DbType.StringFixedLength, true),
        new SQLiteDbTypeMapping("NOTE", DbType.String, false),
        new SQLiteDbTypeMapping("NTEXT", DbType.String, false),
        new SQLiteDbTypeMapping("NUMBER", DbType.Decimal, false),
        new SQLiteDbTypeMapping("NUMERIC", DbType.Decimal, false),
        new SQLiteDbTypeMapping("NVARCHAR", DbType.String, true),
        new SQLiteDbTypeMapping("OLEOBJECT", DbType.Binary, false),
        new SQLiteDbTypeMapping("RAW", DbType.Binary, false),
        new SQLiteDbTypeMapping("REAL", DbType.Double, true),
        new SQLiteDbTypeMapping("SINGLE", DbType.Single, true),
        new SQLiteDbTypeMapping("SMALLDATE", DbType.DateTime, false),
        new SQLiteDbTypeMapping("SMALLINT", DbType.Int16, true),
        new SQLiteDbTypeMapping("SMALLUINT", DbType.UInt16, true),
        new SQLiteDbTypeMapping("STRING", DbType.String, false),
        new SQLiteDbTypeMapping("TEXT", DbType.String, false),
        new SQLiteDbTypeMapping("TIME", DbType.DateTime, false),
        new SQLiteDbTypeMapping("TIMESTAMP", DbType.DateTime, false),
        new SQLiteDbTypeMapping("TINYINT", DbType.Byte, true),
        new SQLiteDbTypeMapping("TINYSINT", DbType.SByte, true),
        new SQLiteDbTypeMapping("UINT", DbType.UInt32, true),
        new SQLiteDbTypeMapping("UINT8", DbType.Byte, false),
        new SQLiteDbTypeMapping("UINT16", DbType.UInt16, false),
        new SQLiteDbTypeMapping("UINT32", DbType.UInt32, false),
        new SQLiteDbTypeMapping("UINT64", DbType.UInt64, false),
        new SQLiteDbTypeMapping("ULONG", DbType.UInt64, false),
        new SQLiteDbTypeMapping("UNIQUEIDENTIFIER", DbType.Guid, true),
        new SQLiteDbTypeMapping("UNSIGNEDINTEGER", DbType.UInt64, true),
        new SQLiteDbTypeMapping("UNSIGNEDINTEGER8", DbType.Byte, false),
        new SQLiteDbTypeMapping("UNSIGNEDINTEGER16", DbType.UInt16, false),
        new SQLiteDbTypeMapping("UNSIGNEDINTEGER32", DbType.UInt32, false),
        new SQLiteDbTypeMapping("UNSIGNEDINTEGER64", DbType.UInt64, false),
        new SQLiteDbTypeMapping("VARBINARY", DbType.Binary, false),
        new SQLiteDbTypeMapping("VARCHAR", DbType.AnsiString, true),
        new SQLiteDbTypeMapping("VARCHAR2", DbType.AnsiString, false),
        new SQLiteDbTypeMapping("YESNO", DbType.Boolean, false)
      });
    }

    internal static bool IsStringDbType(DbType type)
    {
      switch (type)
      {
        case DbType.AnsiString:
        case DbType.String:
        case DbType.AnsiStringFixedLength:
        case DbType.StringFixedLength:
          return true;
        default:
          return false;
      }
    }

    private static string SettingValueToString(object value)
    {
      if (value is string)
        return (string) value;
      return value?.ToString();
    }

    private static DbType GetDefaultDbType(SQLiteConnection connection)
    {
      if (((connection != null ? (long) connection.Flags : 0L) & 134217728L) == 134217728L)
        return DbType.Object;
      bool flag = false;
      string name = "Use_SQLiteConvert_DefaultDbType";
      object defaultDbType = (object) null;
      string @default = (string) null;
      if (connection == null || !connection.TryGetCachedSetting(name, (object) @default, out defaultDbType))
        defaultDbType = (object) UnsafeNativeMethods.GetSettingValue(name, @default) ?? (object) DbType.Object;
      else
        flag = true;
      try
      {
        if (!(defaultDbType is DbType))
        {
          defaultDbType = SQLiteConnection.TryParseEnum(typeof (DbType), SQLiteConvert.SettingValueToString(defaultDbType), true);
          if (!(defaultDbType is DbType))
            defaultDbType = (object) DbType.Object;
        }
        return (DbType) defaultDbType;
      }
      finally
      {
        if (!flag && connection != null)
          connection.SetCachedSetting(name, defaultDbType);
      }
    }

    public static string GetStringOrNull(object value)
    {
      if (value == null)
        return (string) null;
      if (value is string)
        return (string) value;
      return value == DBNull.Value ? (string) null : value.ToString();
    }

    internal static bool LooksLikeNull(string text) => text == null;

    internal static bool LooksLikeInt64(string text)
    {
      long result;
      return long.TryParse(text, NumberStyles.Integer, (IFormatProvider) CultureInfo.InvariantCulture, out result) && string.Equals(result.ToString((IFormatProvider) CultureInfo.InvariantCulture), text, StringComparison.Ordinal);
    }

    internal static bool LooksLikeDouble(string text)
    {
      double result;
      return double.TryParse(text, NumberStyles.Float | NumberStyles.AllowThousands, (IFormatProvider) CultureInfo.InvariantCulture, out result) && string.Equals(result.ToString((IFormatProvider) CultureInfo.InvariantCulture), text, StringComparison.Ordinal);
    }

    internal static bool LooksLikeDateTime(SQLiteConvert convert, string text)
    {
      if (convert == null)
        return false;
      try
      {
        DateTime dateTime = convert.ToDateTime(text);
        if (string.Equals(convert.ToString(dateTime), text, StringComparison.Ordinal))
          return true;
      }
      catch
      {
      }
      return false;
    }

    internal static DbType TypeNameToDbType(
      SQLiteConnection connection,
      string typeName,
      SQLiteConnectionFlags flags)
    {
      DbType? dbType = new DbType?();
      if (connection != null)
      {
        flags |= connection.Flags;
        if ((flags & SQLiteConnectionFlags.UseConnectionTypes) == SQLiteConnectionFlags.UseConnectionTypes)
        {
          SQLiteDbTypeMap typeNames = connection._typeNames;
          if (typeNames != null && typeName != null)
          {
            SQLiteDbTypeMapping liteDbTypeMapping;
            if (typeNames.TryGetValue(typeName, out liteDbTypeMapping))
              return liteDbTypeMapping.dataType;
            int length = typeName.IndexOf('(');
            if (length > 0 && typeNames.TryGetValue(typeName.Substring(0, length).TrimEnd(), out liteDbTypeMapping))
              return liteDbTypeMapping.dataType;
          }
        }
        dbType = connection.DefaultDbType;
      }
      if ((flags & SQLiteConnectionFlags.NoGlobalTypes) == SQLiteConnectionFlags.NoGlobalTypes)
      {
        if (dbType.HasValue)
          return dbType.Value;
        dbType = new DbType?(SQLiteConvert.GetDefaultDbType(connection));
        SQLiteConvert.DefaultDbTypeWarning(typeName, flags, dbType);
        return dbType.Value;
      }
      lock (SQLiteConvert._syncRoot)
      {
        if (SQLiteConvert._typeNames == null)
          SQLiteConvert._typeNames = SQLiteConvert.GetSQLiteDbTypeMap();
        if (typeName != null)
        {
          SQLiteDbTypeMapping liteDbTypeMapping;
          if (SQLiteConvert._typeNames.TryGetValue(typeName, out liteDbTypeMapping))
            return liteDbTypeMapping.dataType;
          int length = typeName.IndexOf('(');
          if (length > 0)
          {
            if (SQLiteConvert._typeNames.TryGetValue(typeName.Substring(0, length).TrimEnd(), out liteDbTypeMapping))
              return liteDbTypeMapping.dataType;
          }
        }
      }
      if (dbType.HasValue)
        return dbType.Value;
      dbType = new DbType?(SQLiteConvert.GetDefaultDbType(connection));
      SQLiteConvert.DefaultDbTypeWarning(typeName, flags, dbType);
      return dbType.Value;
    }
  }
}


--- SQLiteDataAdapter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteDataAdapter
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.ComponentModel;
using System.Data.Common;

#nullable disable
namespace System.Data.SQLite
{
  [Designer("Microsoft.VSDesigner.Data.VS.SqlDataAdapterDesigner, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
  [ToolboxItem("SQLite.Designer.SQLiteDataAdapterToolboxItem, SQLite.Designer, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139")]
  [DefaultEvent("RowUpdated")]
  public sealed class SQLiteDataAdapter : DbDataAdapter
  {
    private bool disposeSelect = true;
    private static object _updatingEventPH = new object();
    private static object _updatedEventPH = new object();
    private bool disposed;

    public SQLiteDataAdapter()
    {
    }

    public SQLiteDataAdapter(SQLiteCommand cmd)
    {
      this.SelectCommand = cmd;
      this.disposeSelect = false;
    }

    public SQLiteDataAdapter(string commandText, SQLiteConnection connection)
    {
      this.SelectCommand = new SQLiteCommand(commandText, connection);
    }

    public SQLiteDataAdapter(string commandText, string connectionString)
      : this(commandText, connectionString, false)
    {
    }

    public SQLiteDataAdapter(string commandText, string connectionString, bool parseViaFramework)
    {
      SQLiteConnection connection = new SQLiteConnection(connectionString, parseViaFramework);
      this.SelectCommand = new SQLiteCommand(commandText, connection);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteDataAdapter).Name);
    }

    protected override void Dispose(bool disposing)
    {
      try
      {
        if (this.disposed || !disposing)
          return;
        if (this.disposeSelect && this.SelectCommand != null)
        {
          this.SelectCommand.Dispose();
          this.SelectCommand = (SQLiteCommand) null;
        }
        if (this.InsertCommand != null)
        {
          this.InsertCommand.Dispose();
          this.InsertCommand = (SQLiteCommand) null;
        }
        if (this.UpdateCommand != null)
        {
          this.UpdateCommand.Dispose();
          this.UpdateCommand = (SQLiteCommand) null;
        }
        if (this.DeleteCommand == null)
          return;
        this.DeleteCommand.Dispose();
        this.DeleteCommand = (SQLiteCommand) null;
      }
      finally
      {
        base.Dispose(disposing);
        this.disposed = true;
      }
    }

    public event EventHandler<RowUpdatingEventArgs> RowUpdating
    {
      add
      {
        this.CheckDisposed();
        EventHandler<RowUpdatingEventArgs> mcd = (EventHandler<RowUpdatingEventArgs>) this.Events[SQLiteDataAdapter._updatingEventPH];
        if (mcd != null && value.Target is DbCommandBuilder)
        {
          EventHandler<RowUpdatingEventArgs> builder = (EventHandler<RowUpdatingEventArgs>) SQLiteDataAdapter.FindBuilder((MulticastDelegate) mcd);
          if (builder != null)
            this.Events.RemoveHandler(SQLiteDataAdapter._updatingEventPH, (Delegate) builder);
        }
        this.Events.AddHandler(SQLiteDataAdapter._updatingEventPH, (Delegate) value);
      }
      remove
      {
        this.CheckDisposed();
        this.Events.RemoveHandler(SQLiteDataAdapter._updatingEventPH, (Delegate) value);
      }
    }

    internal static Delegate FindBuilder(MulticastDelegate mcd)
    {
      if ((object) mcd != null)
      {
        Delegate[] invocationList = mcd.GetInvocationList();
        for (int index = 0; index < invocationList.Length; ++index)
        {
          if (invocationList[index].Target is DbCommandBuilder)
            return invocationList[index];
        }
      }
      return (Delegate) null;
    }

    public event EventHandler<RowUpdatedEventArgs> RowUpdated
    {
      add
      {
        this.CheckDisposed();
        this.Events.AddHandler(SQLiteDataAdapter._updatedEventPH, (Delegate) value);
      }
      remove
      {
        this.CheckDisposed();
        this.Events.RemoveHandler(SQLiteDataAdapter._updatedEventPH, (Delegate) value);
      }
    }

    protected override void OnRowUpdating(RowUpdatingEventArgs value)
    {
      if (!(this.Events[SQLiteDataAdapter._updatingEventPH] is EventHandler<RowUpdatingEventArgs> eventHandler))
        return;
      eventHandler((object) this, value);
    }

    protected override void OnRowUpdated(RowUpdatedEventArgs value)
    {
      if (!(this.Events[SQLiteDataAdapter._updatedEventPH] is EventHandler<RowUpdatedEventArgs> eventHandler))
        return;
      eventHandler((object) this, value);
    }

    [Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [DefaultValue(null)]
    public SQLiteCommand SelectCommand
    {
      get
      {
        this.CheckDisposed();
        return (SQLiteCommand) base.SelectCommand;
      }
      set
      {
        this.CheckDisposed();
        this.SelectCommand = (DbCommand) value;
      }
    }

    [DefaultValue(null)]
    [Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    public SQLiteCommand InsertCommand
    {
      get
      {
        this.CheckDisposed();
        return (SQLiteCommand) base.InsertCommand;
      }
      set
      {
        this.CheckDisposed();
        this.InsertCommand = (DbCommand) value;
      }
    }

    [Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [DefaultValue(null)]
    public SQLiteCommand UpdateCommand
    {
      get
      {
        this.CheckDisposed();
        return (SQLiteCommand) base.UpdateCommand;
      }
      set
      {
        this.CheckDisposed();
        this.UpdateCommand = (DbCommand) value;
      }
    }

    [Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
    [DefaultValue(null)]
    public SQLiteCommand DeleteCommand
    {
      get
      {
        this.CheckDisposed();
        return (SQLiteCommand) base.DeleteCommand;
      }
      set
      {
        this.CheckDisposed();
        this.DeleteCommand = (DbCommand) value;
      }
    }
  }
}


--- SQLiteDataReader.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteDataReader
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data.Common;
using System.Globalization;
using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteDataReader : DbDataReader
  {
    private SQLiteCommand _command;
    private SQLiteConnectionFlags _flags;
    private int _activeStatementIndex;
    private SQLiteStatement _activeStatement;
    private int _readingState;
    private int _rowsAffected;
    private int _fieldCount;
    private int _stepCount;
    private Dictionary<string, int> _fieldIndexes;
    private SQLiteType[] _fieldTypeArray;
    private CommandBehavior _commandBehavior;
    internal bool _disposeCommand;
    internal bool _throwOnDisposed;
    private SQLiteKeyReader _keyInfo;
    internal int _version;
    private string _baseSchemaName;
    private bool disposed;

    internal SQLiteDataReader(SQLiteCommand cmd, CommandBehavior behave)
    {
      this._throwOnDisposed = true;
      this._command = cmd;
      this._version = this._command.Connection._version;
      this._baseSchemaName = this._command.Connection._baseSchemaName;
      this._commandBehavior = behave;
      this._activeStatementIndex = -1;
      this._rowsAffected = -1;
      this.RefreshFlags();
      SQLiteConnection.OnChanged(SQLiteDataReader.GetConnection(this), new ConnectionEventArgs(SQLiteConnectionEventType.NewDataReader, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) this._command, (IDataReader) this, (CriticalHandle) null, (string) null, (object) new object[1]
      {
        (object) behave
      }));
      if (this._command == null)
        return;
      this.NextResult();
    }

    private void CheckDisposed()
    {
      if (this.disposed && this._throwOnDisposed)
        throw new ObjectDisposedException(typeof (SQLiteDataReader).Name);
    }

    protected override void Dispose(bool disposing)
    {
      SQLiteConnection.OnChanged(SQLiteDataReader.GetConnection(this), new ConnectionEventArgs(SQLiteConnectionEventType.DisposingDataReader, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) this._command, (IDataReader) this, (CriticalHandle) null, (string) null, (object) new object[9]
      {
        (object) disposing,
        (object) this.disposed,
        (object) this._commandBehavior,
        (object) this._readingState,
        (object) this._rowsAffected,
        (object) this._stepCount,
        (object) this._fieldCount,
        (object) this._disposeCommand,
        (object) this._throwOnDisposed
      }));
      try
      {
        if (this.disposed)
          return;
        this._throwOnDisposed = false;
      }
      finally
      {
        base.Dispose(disposing);
        this.disposed = true;
      }
    }

    internal void Cancel() => this._version = 0;

    public override void Close()
    {
      this.CheckDisposed();
      SQLiteConnection.OnChanged(SQLiteDataReader.GetConnection(this), new ConnectionEventArgs(SQLiteConnectionEventType.ClosingDataReader, (StateChangeEventArgs) null, (IDbTransaction) null, (IDbCommand) this._command, (IDataReader) this, (CriticalHandle) null, (string) null, (object) new object[7]
      {
        (object) this._commandBehavior,
        (object) this._readingState,
        (object) this._rowsAffected,
        (object) this._stepCount,
        (object) this._fieldCount,
        (object) this._disposeCommand,
        (object) this._throwOnDisposed
      }));
      try
      {
        if (this._command != null)
        {
          try
          {
            try
            {
              if (this._version != 0)
              {
                try
                {
                  do
                    ;
                  while (this.NextResult());
                }
                catch (SQLiteException ex)
                {
                }
              }
              this._command.ResetDataReader();
            }
            finally
            {
              if ((this._commandBehavior & CommandBehavior.CloseConnection) != CommandBehavior.Default && this._command.Connection != null)
                this._command.Connection.Close();
            }
          }
          finally
          {
            if (this._disposeCommand)
              this._command.Dispose();
          }
        }
        this._command = (SQLiteCommand) null;
        this._activeStatement = (SQLiteStatement) null;
        this._fieldIndexes = (Dictionary<string, int>) null;
        this._fieldTypeArray = (SQLiteType[]) null;
      }
      finally
      {
        if (this._keyInfo != null)
        {
          this._keyInfo.Dispose();
          this._keyInfo = (SQLiteKeyReader) null;
        }
      }
    }

    private void CheckClosed()
    {
      if (!this._throwOnDisposed)
        return;
      if (this._command == null)
        throw new InvalidOperationException("DataReader has been closed");
      if (this._version == 0)
        throw new SQLiteException("Execution was aborted by the user");
      SQLiteConnection connection = this._command.Connection;
      if (connection._version != this._version || connection.State != ConnectionState.Open)
        throw new InvalidOperationException("Connection was closed, statement was terminated");
    }

    private void CheckValidRow()
    {
      if (this._readingState != 0)
        throw new InvalidOperationException("No current row");
    }

    public override IEnumerator GetEnumerator()
    {
      this.CheckDisposed();
      return (IEnumerator) new DbEnumerator((IDataReader) this, (this._commandBehavior & CommandBehavior.CloseConnection) == CommandBehavior.CloseConnection);
    }

    public override int Depth
    {
      get
      {
        this.CheckDisposed();
        this.CheckClosed();
        return 0;
      }
    }

    public override int FieldCount
    {
      get
      {
        this.CheckDisposed();
        this.CheckClosed();
        return this._keyInfo == null ? this._fieldCount : this._fieldCount + this._keyInfo.Count;
      }
    }

    public void RefreshFlags()
    {
      this.CheckDisposed();
      this._flags = SQLiteCommand.GetFlags(this._command);
    }

    public int StepCount
    {
      get
      {
        this.CheckDisposed();
        this.CheckClosed();
        return this._stepCount;
      }
    }

    private int PrivateVisibleFieldCount => this._fieldCount;

    public override int VisibleFieldCount
    {
      get
      {
        this.CheckDisposed();
        this.CheckClosed();
        return this.PrivateVisibleFieldCount;
      }
    }

    private void VerifyForGet()
    {
      this.CheckClosed();
      this.CheckValidRow();
    }

    private TypeAffinity VerifyType(int i, DbType typ)
    {
      if ((this._flags & SQLiteConnectionFlags.NoVerifyTypeAffinity) == SQLiteConnectionFlags.NoVerifyTypeAffinity)
        return TypeAffinity.None;
      TypeAffinity affinity = this.GetSQLiteType(this._flags, i).Affinity;
      switch (affinity)
      {
        case TypeAffinity.Int64:
          if (typ == DbType.Int64 || typ == DbType.Int32 || typ == DbType.Int16 || typ == DbType.Byte || typ == DbType.SByte || typ == DbType.Boolean || typ == DbType.DateTime || typ == DbType.Double || typ == DbType.Single || typ == DbType.Decimal)
            return affinity;
          break;
        case TypeAffinity.Double:
          if (typ == DbType.Double || typ == DbType.Single || typ == DbType.Decimal || typ == DbType.DateTime)
            return affinity;
          break;
        case TypeAffinity.Text:
          if (typ == DbType.String || typ == DbType.Guid || typ == DbType.DateTime || typ == DbType.Decimal)
            return affinity;
          break;
        case TypeAffinity.Blob:
          if (typ == DbType.Guid || typ == DbType.Binary || typ == DbType.String)
            return affinity;
          break;
      }
      throw new InvalidCastException();
    }

    private void InvokeReadValueCallback(
      int index,
      SQLiteReadEventArgs eventArgs,
      out bool complete)
    {
      complete = false;
      SQLiteConnectionFlags flags = this._flags;
      this._flags &= ~SQLiteConnectionFlags.UseConnectionReadValueCallbacks;
      try
      {
        string dataTypeName = this.GetDataTypeName(index);
        if (dataTypeName == null)
          return;
        SQLiteConnection connection = SQLiteDataReader.GetConnection(this);
        SQLiteTypeCallbacks callbacks;
        if (connection == null || !connection.TryGetTypeCallbacks(dataTypeName, out callbacks) || callbacks == null)
          return;
        SQLiteReadValueCallback readValueCallback = callbacks.ReadValueCallback;
        if (readValueCallback == null)
          return;
        object readValueUserData = callbacks.ReadValueUserData;
        readValueCallback((SQLiteConvert) this._activeStatement._sql, this, flags, eventArgs, dataTypeName, index, readValueUserData, out complete);
      }
      finally
      {
        this._flags |= SQLiteConnectionFlags.UseConnectionReadValueCallbacks;
      }
    }

    internal long? GetRowId(int i)
    {
      this.VerifyForGet();
      if (this._keyInfo == null)
        return new long?();
      int rowIdIndex = this._keyInfo.GetRowIdIndex(this.GetDatabaseName(i), this.GetTableName(i));
      return rowIdIndex == -1 ? new long?() : new long?(this.GetInt64(rowIdIndex));
    }

    public SQLiteBlob GetBlob(int i, bool readOnly)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetBlob), (SQLiteReadEventArgs) new SQLiteReadBlobEventArgs(readOnly), liteDataReaderValue), out complete);
        if (complete)
          return liteDataReaderValue.BlobValue;
      }
      return i >= this.PrivateVisibleFieldCount && this._keyInfo != null ? this._keyInfo.GetBlob(i - this.PrivateVisibleFieldCount, readOnly) : SQLiteBlob.Create(this, i, readOnly);
    }

    public override bool GetBoolean(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetBoolean), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
        {
          if (!liteDataReaderValue.BooleanValue.HasValue)
            throw new SQLiteException("missing boolean return value");
          return liteDataReaderValue.BooleanValue.Value;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetBoolean(i - this.PrivateVisibleFieldCount);
      int num = (int) this.VerifyType(i, DbType.Boolean);
      return Convert.ToBoolean(this.GetValue(i), (IFormatProvider) CultureInfo.CurrentCulture);
    }

    public override byte GetByte(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetByte), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
        {
          byte? byteValue = liteDataReaderValue.ByteValue;
          if (!(byteValue.HasValue ? new int?((int) byteValue.GetValueOrDefault()) : new int?()).HasValue)
            throw new SQLiteException("missing byte return value");
          return liteDataReaderValue.ByteValue.Value;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetByte(i - this.PrivateVisibleFieldCount);
      int num = (int) this.VerifyType(i, DbType.Byte);
      return Convert.ToByte(this._activeStatement._sql.GetInt32(this._activeStatement, i));
    }

    public override long GetBytes(
      int i,
      long fieldOffset,
      byte[] buffer,
      int bufferoffset,
      int length)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteReadArrayEventArgs extraEventArgs = new SQLiteReadArrayEventArgs(fieldOffset, buffer, bufferoffset, length);
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetBytes), (SQLiteReadEventArgs) extraEventArgs, liteDataReaderValue), out complete);
        if (complete)
        {
          byte[] bytesValue = liteDataReaderValue.BytesValue;
          if (bytesValue == null)
            return -1;
          Array.Copy((Array) bytesValue, extraEventArgs.DataOffset, (Array) extraEventArgs.ByteBuffer, (long) extraEventArgs.BufferOffset, (long) extraEventArgs.Length);
          return (long) extraEventArgs.Length;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetBytes(i - this.PrivateVisibleFieldCount, fieldOffset, buffer, bufferoffset, length);
      int num = (int) this.VerifyType(i, DbType.Binary);
      return this._activeStatement._sql.GetBytes(this._activeStatement, i, (int) fieldOffset, buffer, bufferoffset, length);
    }

    public override char GetChar(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetChar), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
        {
          char? charValue = liteDataReaderValue.CharValue;
          if (!(charValue.HasValue ? new int?((int) charValue.GetValueOrDefault()) : new int?()).HasValue)
            throw new SQLiteException("missing character return value");
          return liteDataReaderValue.CharValue.Value;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetChar(i - this.PrivateVisibleFieldCount);
      int num = (int) this.VerifyType(i, DbType.SByte);
      return Convert.ToChar(this._activeStatement._sql.GetInt32(this._activeStatement, i));
    }

    public override long GetChars(
      int i,
      long fieldoffset,
      char[] buffer,
      int bufferoffset,
      int length)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteReadArrayEventArgs extraEventArgs = new SQLiteReadArrayEventArgs(fieldoffset, buffer, bufferoffset, length);
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetChars), (SQLiteReadEventArgs) extraEventArgs, liteDataReaderValue), out complete);
        if (complete)
        {
          char[] charsValue = liteDataReaderValue.CharsValue;
          if (charsValue == null)
            return -1;
          Array.Copy((Array) charsValue, extraEventArgs.DataOffset, (Array) extraEventArgs.CharBuffer, (long) extraEventArgs.BufferOffset, (long) extraEventArgs.Length);
          return (long) extraEventArgs.Length;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetChars(i - this.PrivateVisibleFieldCount, fieldoffset, buffer, bufferoffset, length);
      if ((this._flags & SQLiteConnectionFlags.NoVerifyTextAffinity) != SQLiteConnectionFlags.NoVerifyTextAffinity)
      {
        int num = (int) this.VerifyType(i, DbType.String);
      }
      return this._activeStatement._sql.GetChars(this._activeStatement, i, (int) fieldoffset, buffer, bufferoffset, length);
    }

    public override string GetDataTypeName(int i)
    {
      this.CheckDisposed();
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetDataTypeName(i - this.PrivateVisibleFieldCount);
      TypeAffinity nAffinity = TypeAffinity.Uninitialized;
      return this._activeStatement._sql.ColumnType(this._activeStatement, i, ref nAffinity);
    }

    public override DateTime GetDateTime(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetDateTime), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
        {
          if (!liteDataReaderValue.DateTimeValue.HasValue)
            throw new SQLiteException("missing date/time return value");
          return liteDataReaderValue.DateTimeValue.Value;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetDateTime(i - this.PrivateVisibleFieldCount);
      int num = (int) this.VerifyType(i, DbType.DateTime);
      return this._activeStatement._sql.GetDateTime(this._activeStatement, i);
    }

    public override Decimal GetDecimal(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetDecimal), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
        {
          if (!liteDataReaderValue.DecimalValue.HasValue)
            throw new SQLiteException("missing decimal return value");
          return liteDataReaderValue.DecimalValue.Value;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetDecimal(i - this.PrivateVisibleFieldCount);
      int num = (int) this.VerifyType(i, DbType.Decimal);
      return Decimal.Parse(this._activeStatement._sql.GetText(this._activeStatement, i), NumberStyles.AllowLeadingSign | NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent, (IFormatProvider) CultureInfo.InvariantCulture);
    }

    public override double GetDouble(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetDouble), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
        {
          if (!liteDataReaderValue.DoubleValue.HasValue)
            throw new SQLiteException("missing double return value");
          return liteDataReaderValue.DoubleValue.Value;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetDouble(i - this.PrivateVisibleFieldCount);
      int num = (int) this.VerifyType(i, DbType.Double);
      return this._activeStatement._sql.GetDouble(this._activeStatement, i);
    }

    public override Type GetFieldType(int i)
    {
      this.CheckDisposed();
      return i >= this.PrivateVisibleFieldCount && this._keyInfo != null ? this._keyInfo.GetFieldType(i - this.PrivateVisibleFieldCount) : SQLiteConvert.SQLiteTypeToType(this.GetSQLiteType(this._flags, i));
    }

    public override float GetFloat(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetFloat), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
        {
          if (!liteDataReaderValue.FloatValue.HasValue)
            throw new SQLiteException("missing float return value");
          return liteDataReaderValue.FloatValue.Value;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetFloat(i - this.PrivateVisibleFieldCount);
      int num = (int) this.VerifyType(i, DbType.Single);
      return Convert.ToSingle(this._activeStatement._sql.GetDouble(this._activeStatement, i));
    }

    public override Guid GetGuid(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetGuid), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
        {
          if (!liteDataReaderValue.GuidValue.HasValue)
            throw new SQLiteException("missing guid return value");
          return liteDataReaderValue.GuidValue.Value;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetGuid(i - this.PrivateVisibleFieldCount);
      if (this.VerifyType(i, DbType.Guid) != TypeAffinity.Blob)
        return new Guid(this._activeStatement._sql.GetText(this._activeStatement, i));
      byte[] numArray = new byte[16];
      this._activeStatement._sql.GetBytes(this._activeStatement, i, 0, numArray, 0, 16);
      return new Guid(numArray);
    }

    public override short GetInt16(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetInt16), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
        {
          short? int16Value = liteDataReaderValue.Int16Value;
          if (!(int16Value.HasValue ? new int?((int) int16Value.GetValueOrDefault()) : new int?()).HasValue)
            throw new SQLiteException("missing int16 return value");
          return liteDataReaderValue.Int16Value.Value;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetInt16(i - this.PrivateVisibleFieldCount);
      int num = (int) this.VerifyType(i, DbType.Int16);
      return Convert.ToInt16(this._activeStatement._sql.GetInt32(this._activeStatement, i));
    }

    public override int GetInt32(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetInt32), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
        {
          if (!liteDataReaderValue.Int32Value.HasValue)
            throw new SQLiteException("missing int32 return value");
          return liteDataReaderValue.Int32Value.Value;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetInt32(i - this.PrivateVisibleFieldCount);
      int num = (int) this.VerifyType(i, DbType.Int32);
      return this._activeStatement._sql.GetInt32(this._activeStatement, i);
    }

    public override long GetInt64(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetInt64), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
        {
          if (!liteDataReaderValue.Int64Value.HasValue)
            throw new SQLiteException("missing int64 return value");
          return liteDataReaderValue.Int64Value.Value;
        }
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetInt64(i - this.PrivateVisibleFieldCount);
      int num = (int) this.VerifyType(i, DbType.Int64);
      return this._activeStatement._sql.GetInt64(this._activeStatement, i);
    }

    public override string GetName(int i)
    {
      this.CheckDisposed();
      return i >= this.PrivateVisibleFieldCount && this._keyInfo != null ? this._keyInfo.GetName(i - this.PrivateVisibleFieldCount) : this._activeStatement._sql.ColumnName(this._activeStatement, i);
    }

    public string GetDatabaseName(int i)
    {
      this.CheckDisposed();
      return i >= this.PrivateVisibleFieldCount && this._keyInfo != null ? this._keyInfo.GetName(i - this.PrivateVisibleFieldCount) : this._activeStatement._sql.ColumnDatabaseName(this._activeStatement, i);
    }

    public string GetTableName(int i)
    {
      this.CheckDisposed();
      return i >= this.PrivateVisibleFieldCount && this._keyInfo != null ? this._keyInfo.GetName(i - this.PrivateVisibleFieldCount) : this._activeStatement._sql.ColumnTableName(this._activeStatement, i);
    }

    public string GetOriginalName(int i)
    {
      this.CheckDisposed();
      return i >= this.PrivateVisibleFieldCount && this._keyInfo != null ? this._keyInfo.GetName(i - this.PrivateVisibleFieldCount) : this._activeStatement._sql.ColumnOriginalName(this._activeStatement, i);
    }

    public override int GetOrdinal(string name)
    {
      this.CheckDisposed();
      int num = this._throwOnDisposed ? 1 : 0;
      if (this._fieldIndexes == null)
        this._fieldIndexes = new Dictionary<string, int>((IEqualityComparer<string>) StringComparer.OrdinalIgnoreCase);
      int ordinal;
      if (!this._fieldIndexes.TryGetValue(name, out ordinal))
      {
        ordinal = this._activeStatement._sql.ColumnIndex(this._activeStatement, name);
        if (ordinal == -1 && this._keyInfo != null)
        {
          ordinal = this._keyInfo.GetOrdinal(name);
          if (ordinal > -1)
            ordinal += this.PrivateVisibleFieldCount;
        }
        this._fieldIndexes.Add(name, ordinal);
      }
      return ordinal;
    }

    public override DataTable GetSchemaTable()
    {
      this.CheckDisposed();
      return this.GetSchemaTable(true, false);
    }

    private static void GetStatementColumnParents(
      SQLiteBase sql,
      SQLiteStatement stmt,
      int fieldCount,
      ref Dictionary<SQLiteDataReader.ColumnParent, List<int>> parentToColumns,
      ref Dictionary<int, SQLiteDataReader.ColumnParent> columnToParent)
    {
      if (parentToColumns == null)
        parentToColumns = new Dictionary<SQLiteDataReader.ColumnParent, List<int>>((IEqualityComparer<SQLiteDataReader.ColumnParent>) new SQLiteDataReader.ColumnParent());
      if (columnToParent == null)
        columnToParent = new Dictionary<int, SQLiteDataReader.ColumnParent>();
      for (int index = 0; index < fieldCount; ++index)
      {
        string databaseName = sql.ColumnDatabaseName(stmt, index);
        string tableName = sql.ColumnTableName(stmt, index);
        string columnName = sql.ColumnOriginalName(stmt, index);
        SQLiteDataReader.ColumnParent key = new SQLiteDataReader.ColumnParent(databaseName, tableName, (string) null);
        SQLiteDataReader.ColumnParent columnParent = new SQLiteDataReader.ColumnParent(databaseName, tableName, columnName);
        List<int> intList;
        if (!parentToColumns.TryGetValue(key, out intList))
          parentToColumns.Add(key, new List<int>((IEnumerable<int>) new int[1]
          {
            index
          }));
        else if (intList != null)
          intList.Add(index);
        else
          parentToColumns[key] = new List<int>((IEnumerable<int>) new int[1]
          {
            index
          });
        columnToParent.Add(index, columnParent);
      }
    }

    private static int CountParents(
      Dictionary<SQLiteDataReader.ColumnParent, List<int>> parentToColumns)
    {
      int num = 0;
      if (parentToColumns != null)
      {
        foreach (SQLiteDataReader.ColumnParent key in parentToColumns.Keys)
        {
          if (key != null && !string.IsNullOrEmpty(key.TableName))
            ++num;
        }
      }
      return num;
    }

    internal DataTable GetSchemaTable(bool wantUniqueInfo, bool wantDefaultValue)
    {
      this.CheckClosed();
      int num = this._throwOnDisposed ? 1 : 0;
      Dictionary<SQLiteDataReader.ColumnParent, List<int>> parentToColumns = (Dictionary<SQLiteDataReader.ColumnParent, List<int>>) null;
      Dictionary<int, SQLiteDataReader.ColumnParent> columnToParent = (Dictionary<int, SQLiteDataReader.ColumnParent>) null;
      SQLiteDataReader.GetStatementColumnParents(this._command.Connection._sql, this._activeStatement, this._fieldCount, ref parentToColumns, ref columnToParent);
      DataTable tbl = new DataTable("SchemaTable");
      DataTable dataTable = (DataTable) null;
      string empty1 = string.Empty;
      string empty2 = string.Empty;
      string empty3 = string.Empty;
      tbl.Locale = CultureInfo.InvariantCulture;
      tbl.Columns.Add(SchemaTableColumn.ColumnName, typeof (string));
      tbl.Columns.Add(SchemaTableColumn.ColumnOrdinal, typeof (int));
      tbl.Columns.Add(SchemaTableColumn.ColumnSize, typeof (int));
      tbl.Columns.Add(SchemaTableColumn.NumericPrecision, typeof (int));
      tbl.Columns.Add(SchemaTableColumn.NumericScale, typeof (int));
      tbl.Columns.Add(SchemaTableColumn.IsUnique, typeof (bool));
      tbl.Columns.Add(SchemaTableColumn.IsKey, typeof (bool));
      tbl.Columns.Add(SchemaTableOptionalColumn.BaseServerName, typeof (string));
      tbl.Columns.Add(SchemaTableOptionalColumn.BaseCatalogName, typeof (string));
      tbl.Columns.Add(SchemaTableColumn.BaseColumnName, typeof (string));
      tbl.Columns.Add(SchemaTableColumn.BaseSchemaName, typeof (string));
      tbl.Columns.Add(SchemaTableColumn.BaseTableName, typeof (string));
      tbl.Columns.Add(SchemaTableColumn.DataType, typeof (Type));
      tbl.Columns.Add(SchemaTableColumn.AllowDBNull, typeof (bool));
      tbl.Columns.Add(SchemaTableColumn.ProviderType, typeof (int));
      tbl.Columns.Add(SchemaTableColumn.IsAliased, typeof (bool));
      tbl.Columns.Add(SchemaTableColumn.IsExpression, typeof (bool));
      tbl.Columns.Add(SchemaTableOptionalColumn.IsAutoIncrement, typeof (bool));
      tbl.Columns.Add(SchemaTableOptionalColumn.IsRowVersion, typeof (bool));
      tbl.Columns.Add(SchemaTableOptionalColumn.IsHidden, typeof (bool));
      tbl.Columns.Add(SchemaTableColumn.IsLong, typeof (bool));
      tbl.Columns.Add(SchemaTableOptionalColumn.IsReadOnly, typeof (bool));
      tbl.Columns.Add(SchemaTableOptionalColumn.ProviderSpecificDataType, typeof (Type));
      tbl.Columns.Add(SchemaTableOptionalColumn.DefaultValue, typeof (object));
      tbl.Columns.Add("DataTypeName", typeof (string));
      tbl.Columns.Add("CollationType", typeof (string));
      tbl.BeginLoadData();
      for (int index = 0; index < this._fieldCount; ++index)
      {
        SQLiteType sqLiteType = this.GetSQLiteType(this._flags, index);
        DataRow row1 = tbl.NewRow();
        DbType type = sqLiteType.Type;
        row1[SchemaTableColumn.ColumnName] = (object) this.GetName(index);
        row1[SchemaTableColumn.ColumnOrdinal] = (object) index;
        row1[SchemaTableColumn.ColumnSize] = (object) SQLiteConvert.DbTypeToColumnSize(type);
        row1[SchemaTableColumn.NumericPrecision] = SQLiteConvert.DbTypeToNumericPrecision(type);
        row1[SchemaTableColumn.NumericScale] = SQLiteConvert.DbTypeToNumericScale(type);
        row1[SchemaTableColumn.ProviderType] = (object) sqLiteType.Type;
        row1[SchemaTableColumn.IsLong] = (object) false;
        row1[SchemaTableColumn.AllowDBNull] = (object) true;
        row1[SchemaTableOptionalColumn.IsReadOnly] = (object) false;
        row1[SchemaTableOptionalColumn.IsRowVersion] = (object) false;
        row1[SchemaTableColumn.IsUnique] = (object) false;
        row1[SchemaTableColumn.IsKey] = (object) false;
        row1[SchemaTableOptionalColumn.IsAutoIncrement] = (object) false;
        row1[SchemaTableColumn.DataType] = (object) this.GetFieldType(index);
        row1[SchemaTableOptionalColumn.IsHidden] = (object) false;
        row1[SchemaTableColumn.BaseSchemaName] = (object) this._baseSchemaName;
        string columnName = columnToParent[index].ColumnName;
        if (!string.IsNullOrEmpty(columnName))
          row1[SchemaTableColumn.BaseColumnName] = (object) columnName;
        row1[SchemaTableColumn.IsExpression] = (object) string.IsNullOrEmpty(columnName);
        row1[SchemaTableColumn.IsAliased] = (object) (string.Compare(this.GetName(index), columnName, StringComparison.OrdinalIgnoreCase) != 0);
        string tableName = columnToParent[index].TableName;
        if (!string.IsNullOrEmpty(tableName))
          row1[SchemaTableColumn.BaseTableName] = (object) tableName;
        string databaseName = columnToParent[index].DatabaseName;
        if (!string.IsNullOrEmpty(databaseName))
          row1[SchemaTableOptionalColumn.BaseCatalogName] = (object) databaseName;
        string dataType = (string) null;
        if (!string.IsNullOrEmpty(columnName))
        {
          string collateSequence = (string) null;
          bool notNull = false;
          bool primaryKey = false;
          bool autoIncrement = false;
          this._command.Connection._sql.ColumnMetaData((string) row1[SchemaTableOptionalColumn.BaseCatalogName], (string) row1[SchemaTableColumn.BaseTableName], columnName, ref dataType, ref collateSequence, ref notNull, ref primaryKey, ref autoIncrement);
          if (notNull || primaryKey)
            row1[SchemaTableColumn.AllowDBNull] = (object) false;
          row1[SchemaTableColumn.IsKey] = (object) (bool) (!primaryKey ? 0 : (SQLiteDataReader.CountParents(parentToColumns) <= 1 ? 1 : 0));
          row1[SchemaTableOptionalColumn.IsAutoIncrement] = (object) autoIncrement;
          row1["CollationType"] = (object) collateSequence;
          string[] strArray1 = dataType.Split('(');
          if (strArray1.Length > 1)
          {
            dataType = strArray1[0];
            string[] strArray2 = strArray1[1].Split(')');
            if (strArray2.Length > 1)
            {
              string[] strArray3 = strArray2[0].Split(',', '.');
              if (sqLiteType.Type == DbType.Binary || SQLiteConvert.IsStringDbType(sqLiteType.Type))
              {
                row1[SchemaTableColumn.ColumnSize] = (object) Convert.ToInt32(strArray3[0], (IFormatProvider) CultureInfo.InvariantCulture);
              }
              else
              {
                row1[SchemaTableColumn.NumericPrecision] = (object) Convert.ToInt32(strArray3[0], (IFormatProvider) CultureInfo.InvariantCulture);
                if (strArray3.Length > 1)
                  row1[SchemaTableColumn.NumericScale] = (object) Convert.ToInt32(strArray3[1], (IFormatProvider) CultureInfo.InvariantCulture);
              }
            }
          }
          if (wantDefaultValue)
          {
            using (SQLiteCommand sqLiteCommand = new SQLiteCommand(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "PRAGMA [{0}].TABLE_INFO([{1}])", row1[SchemaTableOptionalColumn.BaseCatalogName], row1[SchemaTableColumn.BaseTableName]), this._command.Connection))
            {
              using (DbDataReader dbDataReader = (DbDataReader) sqLiteCommand.ExecuteReader())
              {
                while (dbDataReader.Read())
                {
                  if (string.Compare((string) row1[SchemaTableColumn.BaseColumnName], dbDataReader.GetString(1), StringComparison.OrdinalIgnoreCase) == 0)
                  {
                    if (!dbDataReader.IsDBNull(4))
                    {
                      row1[SchemaTableOptionalColumn.DefaultValue] = dbDataReader[4];
                      break;
                    }
                    break;
                  }
                }
              }
            }
          }
          if (wantUniqueInfo)
          {
            if ((string) row1[SchemaTableOptionalColumn.BaseCatalogName] != empty1 || (string) row1[SchemaTableColumn.BaseTableName] != empty2)
            {
              empty1 = (string) row1[SchemaTableOptionalColumn.BaseCatalogName];
              empty2 = (string) row1[SchemaTableColumn.BaseTableName];
              dataTable = this._command.Connection.GetSchema("Indexes", new string[4]
              {
                (string) row1[SchemaTableOptionalColumn.BaseCatalogName],
                null,
                (string) row1[SchemaTableColumn.BaseTableName],
                null
              });
            }
            foreach (DataRow row2 in (InternalDataCollectionBase) dataTable.Rows)
            {
              DataTable schema = this._command.Connection.GetSchema("IndexColumns", new string[5]
              {
                (string) row1[SchemaTableOptionalColumn.BaseCatalogName],
                null,
                (string) row1[SchemaTableColumn.BaseTableName],
                (string) row2["INDEX_NAME"],
                null
              });
              foreach (DataRow row3 in (InternalDataCollectionBase) schema.Rows)
              {
                if (string.Compare(SQLiteConvert.GetStringOrNull(row3["COLUMN_NAME"]), columnName, StringComparison.OrdinalIgnoreCase) == 0)
                {
                  if (parentToColumns.Count == 1 && schema.Rows.Count == 1 && !(bool) row1[SchemaTableColumn.AllowDBNull])
                    row1[SchemaTableColumn.IsUnique] = row2["UNIQUE"];
                  if (schema.Rows.Count == 1)
                  {
                    if ((bool) row2["PRIMARY_KEY"])
                    {
                      if (!string.IsNullOrEmpty(dataType))
                      {
                        if (string.Compare(dataType, "integer", StringComparison.OrdinalIgnoreCase) != 0)
                          break;
                        break;
                      }
                      break;
                    }
                    break;
                  }
                  break;
                }
              }
            }
          }
          if (string.IsNullOrEmpty(dataType))
          {
            TypeAffinity nAffinity = TypeAffinity.Uninitialized;
            dataType = this._activeStatement._sql.ColumnType(this._activeStatement, index, ref nAffinity);
          }
          if (!string.IsNullOrEmpty(dataType))
            row1["DataTypeName"] = (object) dataType;
        }
        tbl.Rows.Add(row1);
      }
      if (this._keyInfo != null)
        this._keyInfo.AppendSchemaTable(tbl);
      tbl.AcceptChanges();
      tbl.EndLoadData();
      return tbl;
    }

    public override string GetString(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetString), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
          return liteDataReaderValue.StringValue;
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetString(i - this.PrivateVisibleFieldCount);
      if ((this._flags & SQLiteConnectionFlags.NoVerifyTextAffinity) != SQLiteConnectionFlags.NoVerifyTextAffinity)
      {
        int num = (int) this.VerifyType(i, DbType.String);
      }
      return this._activeStatement._sql.GetText(this._activeStatement, i);
    }

    public override object GetValue(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      if ((this._flags & SQLiteConnectionFlags.UseConnectionReadValueCallbacks) == SQLiteConnectionFlags.UseConnectionReadValueCallbacks)
      {
        SQLiteDataReaderValue liteDataReaderValue = new SQLiteDataReaderValue();
        bool complete;
        this.InvokeReadValueCallback(i, (SQLiteReadEventArgs) new SQLiteReadValueEventArgs(nameof (GetValue), (SQLiteReadEventArgs) null, liteDataReaderValue), out complete);
        if (complete)
          return liteDataReaderValue.Value;
      }
      if (i >= this.PrivateVisibleFieldCount && this._keyInfo != null)
        return this._keyInfo.GetValue(i - this.PrivateVisibleFieldCount);
      SQLiteType sqLiteType = this.GetSQLiteType(this._flags, i);
      if ((this._flags & SQLiteConnectionFlags.DetectTextAffinity) == SQLiteConnectionFlags.DetectTextAffinity && (sqLiteType == null || sqLiteType.Affinity == TypeAffinity.Text))
        sqLiteType = this.GetSQLiteType(sqLiteType, this._activeStatement._sql.GetText(this._activeStatement, i));
      else if ((this._flags & SQLiteConnectionFlags.DetectStringType) == SQLiteConnectionFlags.DetectStringType && (sqLiteType == null || SQLiteConvert.IsStringDbType(sqLiteType.Type)))
        sqLiteType = this.GetSQLiteType(sqLiteType, this._activeStatement._sql.GetText(this._activeStatement, i));
      return this._activeStatement._sql.GetValue(this._activeStatement, this._flags, i, sqLiteType);
    }

    public override int GetValues(object[] values)
    {
      this.CheckDisposed();
      int values1 = this.FieldCount;
      if (values.Length < values1)
        values1 = values.Length;
      for (int ordinal = 0; ordinal < values1; ++ordinal)
        values[ordinal] = this.GetValue(ordinal);
      return values1;
    }

    public NameValueCollection GetValues()
    {
      this.CheckDisposed();
      if (this._activeStatement == null || this._activeStatement._sql == null)
        throw new InvalidOperationException();
      int visibleFieldCount = this.PrivateVisibleFieldCount;
      NameValueCollection values = new NameValueCollection(visibleFieldCount);
      for (int index = 0; index < visibleFieldCount; ++index)
      {
        string name = this._activeStatement._sql.ColumnName(this._activeStatement, index);
        string text = this._activeStatement._sql.GetText(this._activeStatement, index);
        values.Add(name, text);
      }
      return values;
    }

    public override bool HasRows
    {
      get
      {
        this.CheckDisposed();
        this.CheckClosed();
        if ((this._flags & SQLiteConnectionFlags.StickyHasRows) != SQLiteConnectionFlags.StickyHasRows)
          return this._readingState != 1;
        return this._readingState != 1 || this._stepCount > 0;
      }
    }

    public override bool IsClosed
    {
      get
      {
        this.CheckDisposed();
        return this._command == null;
      }
    }

    public override bool IsDBNull(int i)
    {
      this.CheckDisposed();
      this.VerifyForGet();
      return i >= this.PrivateVisibleFieldCount && this._keyInfo != null ? this._keyInfo.IsDBNull(i - this.PrivateVisibleFieldCount) : this._activeStatement._sql.IsNull(this._activeStatement, i);
    }

    public override bool NextResult()
    {
      this.CheckDisposed();
      this.CheckClosed();
      int num1 = this._throwOnDisposed ? 1 : 0;
      SQLiteStatement stmt = (SQLiteStatement) null;
      bool flag = (this._commandBehavior & CommandBehavior.SchemaOnly) != CommandBehavior.Default;
      int num2;
      while (true)
      {
        do
        {
          if (stmt == null && this._activeStatement != null && this._activeStatement._sql != null && this._activeStatement._sql.IsOpen())
          {
            if (!flag)
            {
              int num3 = (int) this._activeStatement._sql.Reset(this._activeStatement);
            }
            if ((this._commandBehavior & CommandBehavior.SingleResult) != CommandBehavior.Default)
            {
              while (true)
              {
                SQLiteStatement statement;
                do
                {
                  statement = this._command.GetStatement(this._activeStatementIndex + 1);
                  if (statement != null)
                  {
                    ++this._activeStatementIndex;
                    if (!flag && statement._sql.Step(statement))
                      ++this._stepCount;
                    if (statement._sql.ColumnCount(statement) == 0)
                    {
                      int changes = 0;
                      bool readOnly = false;
                      if (!statement.TryGetChanges(ref changes, ref readOnly))
                        return false;
                      if (!readOnly)
                      {
                        if (this._rowsAffected == -1)
                          this._rowsAffected = 0;
                        this._rowsAffected += changes;
                      }
                    }
                  }
                  else
                    goto label_17;
                }
                while (flag);
                int num4 = (int) statement._sql.Reset(statement);
              }
label_17:
              return false;
            }
          }
          stmt = this._command.GetStatement(this._activeStatementIndex + 1);
          if (stmt == null)
            return false;
          if (this._readingState < 1)
            this._readingState = 1;
          ++this._activeStatementIndex;
          num2 = stmt._sql.ColumnCount(stmt);
          if (!flag || num2 == 0)
          {
            if (!flag && stmt._sql.Step(stmt))
            {
              ++this._stepCount;
              this._readingState = -1;
              goto label_35;
            }
            else if (num2 == 0)
            {
              int changes = 0;
              bool readOnly = false;
              if (!stmt.TryGetChanges(ref changes, ref readOnly))
                return false;
              if (!readOnly)
              {
                if (this._rowsAffected == -1)
                  this._rowsAffected = 0;
                this._rowsAffected += changes;
              }
            }
            else
              goto label_34;
          }
          else
            goto label_35;
        }
        while (flag);
        int num5 = (int) stmt._sql.Reset(stmt);
      }
label_34:
      this._readingState = 1;
label_35:
      this._activeStatement = stmt;
      this._fieldCount = num2;
      this._fieldIndexes = new Dictionary<string, int>((IEqualityComparer<string>) StringComparer.OrdinalIgnoreCase);
      this._fieldTypeArray = new SQLiteType[this.PrivateVisibleFieldCount];
      if ((this._commandBehavior & CommandBehavior.KeyInfo) != CommandBehavior.Default)
        this.LoadKeyInfo();
      return true;
    }

    internal static SQLiteConnection GetConnection(SQLiteDataReader dataReader)
    {
      try
      {
        if (dataReader != null)
        {
          SQLiteCommand command = dataReader._command;
          if (command != null)
          {
            SQLiteConnection connection = command.Connection;
            if (connection != null)
              return connection;
          }
        }
      }
      catch (ObjectDisposedException ex)
      {
      }
      return (SQLiteConnection) null;
    }

    private SQLiteType GetSQLiteType(SQLiteType oldType, string text)
    {
      if (SQLiteConvert.LooksLikeNull(text))
        return new SQLiteType(TypeAffinity.Null, DbType.Object);
      if (SQLiteConvert.LooksLikeInt64(text))
        return new SQLiteType(TypeAffinity.Int64, DbType.Int64);
      if (SQLiteConvert.LooksLikeDouble(text))
        return new SQLiteType(TypeAffinity.Double, DbType.Double);
      return this._activeStatement != null && SQLiteConvert.LooksLikeDateTime((SQLiteConvert) this._activeStatement._sql, text) ? new SQLiteType(TypeAffinity.DateTime, DbType.DateTime) : oldType;
    }

    private SQLiteType GetSQLiteType(SQLiteConnectionFlags flags, int i)
    {
      SQLiteType sqLiteType = this._fieldTypeArray[i] ?? (this._fieldTypeArray[i] = new SQLiteType());
      if (sqLiteType.Affinity == TypeAffinity.Uninitialized)
        sqLiteType.Type = SQLiteConvert.TypeNameToDbType(SQLiteDataReader.GetConnection(this), this._activeStatement._sql.ColumnType(this._activeStatement, i, ref sqLiteType.Affinity), flags);
      else
        sqLiteType.Affinity = this._activeStatement._sql.ColumnAffinity(this._activeStatement, i);
      return sqLiteType;
    }

    public override bool Read()
    {
      this.CheckDisposed();
      this.CheckClosed();
      int num = this._throwOnDisposed ? 1 : 0;
      if ((this._commandBehavior & CommandBehavior.SchemaOnly) != CommandBehavior.Default)
        return false;
      if (this._readingState == -1)
      {
        this._readingState = 0;
        return true;
      }
      if (this._readingState == 0)
      {
        if ((this._commandBehavior & CommandBehavior.SingleRow) == CommandBehavior.Default && this._activeStatement._sql.Step(this._activeStatement))
        {
          ++this._stepCount;
          if (this._keyInfo != null)
            this._keyInfo.Reset();
          return true;
        }
        this._readingState = 1;
      }
      return false;
    }

    public override int RecordsAffected
    {
      get
      {
        this.CheckDisposed();
        return this._rowsAffected;
      }
    }

    public override object this[string name]
    {
      get
      {
        this.CheckDisposed();
        return this.GetValue(this.GetOrdinal(name));
      }
    }

    public override object this[int i]
    {
      get
      {
        this.CheckDisposed();
        return this.GetValue(i);
      }
    }

    private void LoadKeyInfo()
    {
      if (this._keyInfo != null)
      {
        this._keyInfo.Dispose();
        this._keyInfo = (SQLiteKeyReader) null;
      }
      this._keyInfo = new SQLiteKeyReader(this._command.Connection, this, this._activeStatement);
    }

    private sealed class ColumnParent : IEqualityComparer<SQLiteDataReader.ColumnParent>
    {
      public string DatabaseName;
      public string TableName;
      public string ColumnName;

      public ColumnParent()
      {
      }

      public ColumnParent(string databaseName, string tableName, string columnName)
        : this()
      {
        this.DatabaseName = databaseName;
        this.TableName = tableName;
        this.ColumnName = columnName;
      }

      public bool Equals(SQLiteDataReader.ColumnParent x, SQLiteDataReader.ColumnParent y)
      {
        return x == null && y == null || x != null && y != null && string.Equals(x.DatabaseName, y.DatabaseName, StringComparison.OrdinalIgnoreCase) && string.Equals(x.TableName, y.TableName, StringComparison.OrdinalIgnoreCase) && string.Equals(x.ColumnName, y.ColumnName, StringComparison.OrdinalIgnoreCase);
      }

      public int GetHashCode(SQLiteDataReader.ColumnParent obj)
      {
        int hashCode = 0;
        if (obj != null && obj.DatabaseName != null)
          hashCode ^= obj.DatabaseName.GetHashCode();
        if (obj != null && obj.TableName != null)
          hashCode ^= obj.TableName.GetHashCode();
        if (obj != null && obj.ColumnName != null)
          hashCode ^= obj.ColumnName.GetHashCode();
        return hashCode;
      }
    }
  }
}


--- SQLiteDataReaderValue.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteDataReaderValue
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteDataReaderValue
  {
    public SQLiteBlob BlobValue;
    public bool? BooleanValue;
    public byte? ByteValue;
    public byte[] BytesValue;
    public char? CharValue;
    public char[] CharsValue;
    public DateTime? DateTimeValue;
    public Decimal? DecimalValue;
    public double? DoubleValue;
    public float? FloatValue;
    public Guid? GuidValue;
    public short? Int16Value;
    public int? Int32Value;
    public long? Int64Value;
    public string StringValue;
    public object Value;
  }
}


--- SQLiteDateFormats.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteDateFormats
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum SQLiteDateFormats
  {
    Ticks = 0,
    Default = 1,
    ISO8601 = 1,
    JulianDay = 2,
    UnixEpoch = 3,
    InvariantCulture = 4,
    CurrentCulture = 5,
  }
}


--- SQLiteDbTypeMap.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteDbTypeMap
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLiteDbTypeMap : Dictionary<string, SQLiteDbTypeMapping>
  {
    private Dictionary<DbType, SQLiteDbTypeMapping> reverse;

    public SQLiteDbTypeMap()
      : base((IEqualityComparer<string>) new TypeNameStringComparer())
    {
      this.reverse = new Dictionary<DbType, SQLiteDbTypeMapping>();
    }

    public SQLiteDbTypeMap(IEnumerable<SQLiteDbTypeMapping> collection)
      : this()
    {
      this.Add(collection);
    }

    public int Clear()
    {
      int num1 = 0;
      if (this.reverse != null)
      {
        num1 += this.reverse.Count;
        this.reverse.Clear();
      }
      int num2 = num1 + this.Count;
      base.Clear();
      return num2;
    }

    public void Add(IEnumerable<SQLiteDbTypeMapping> collection)
    {
      if (collection == null)
        throw new ArgumentNullException(nameof (collection));
      foreach (SQLiteDbTypeMapping liteDbTypeMapping in collection)
        this.Add(liteDbTypeMapping);
    }

    public void Add(SQLiteDbTypeMapping item)
    {
      if (item == null)
        throw new ArgumentNullException(nameof (item));
      if (item.typeName == null)
        throw new ArgumentException("item type name cannot be null");
      this.Add(item.typeName, item);
      if (!item.primary)
        return;
      this.reverse.Add(item.dataType, item);
    }

    public bool ContainsKey(DbType key) => this.reverse != null && this.reverse.ContainsKey(key);

    public bool TryGetValue(DbType key, out SQLiteDbTypeMapping value)
    {
      if (this.reverse != null)
        return this.reverse.TryGetValue(key, out value);
      value = (SQLiteDbTypeMapping) null;
      return false;
    }

    public bool Remove(DbType key) => this.reverse != null && this.reverse.Remove(key);
  }
}


--- SQLiteDbTypeMapping.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteDbTypeMapping
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLiteDbTypeMapping
  {
    internal string typeName;
    internal DbType dataType;
    internal bool primary;

    internal SQLiteDbTypeMapping(string newTypeName, DbType newDataType, bool newPrimary)
    {
      this.typeName = newTypeName;
      this.dataType = newDataType;
      this.primary = newPrimary;
    }
  }
}


--- SQLiteDefineConstants.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteDefineConstants
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;

#nullable disable
namespace System.Data.SQLite
{
  internal static class SQLiteDefineConstants
  {
    public static readonly IList<string> OptionList = (IList<string>) new List<string>((IEnumerable<string>) new string[19]
    {
      "INTEROP_CODEC",
      "INTEROP_EXTENSION_FUNCTIONS",
      "INTEROP_FTS5_EXTENSION",
      "INTEROP_JSON1_EXTENSION",
      "INTEROP_PERCENTILE_EXTENSION",
      "INTEROP_REGEXP_EXTENSION",
      "INTEROP_TOTYPE_EXTENSION",
      "INTEROP_VIRTUAL_TABLE",
      "NET_45",
      "PRELOAD_NATIVE_LIBRARY",
      "THROW_ON_DISPOSED",
      "TRACE",
      "TRACE_PRELOAD",
      "TRACE_SHARED",
      "TRACE_WARNING",
      "USE_INTEROP_DLL",
      "USE_PREPARE_V2",
      "WINDOWS",
      null
    });
  }
}


--- SQLiteDelegateFunction.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteDelegateFunction
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Globalization;

#nullable disable
namespace System.Data.SQLite
{
  public class SQLiteDelegateFunction : SQLiteFunction
  {
    private const string NoCallbackError = "No \"{0}\" callback is set.";
    private const string ResultInt32Error = "\"{0}\" result must be Int32.";
    private Delegate callback1;
    private Delegate callback2;

    public SQLiteDelegateFunction()
      : this((Delegate) null, (Delegate) null)
    {
    }

    public SQLiteDelegateFunction(Delegate callback1, Delegate callback2)
    {
      this.callback1 = callback1;
      this.callback2 = callback2;
    }

    protected virtual object[] GetInvokeArgs(object[] args, bool earlyBound)
    {
      object[] invokeArgs = new object[2]
      {
        (object) "Invoke",
        (object) args
      };
      if (!earlyBound)
        invokeArgs = new object[1]{ (object) invokeArgs };
      return invokeArgs;
    }

    protected virtual object[] GetStepArgs(
      object[] args,
      int stepNumber,
      object contextData,
      bool earlyBound)
    {
      object[] stepArgs = new object[4]
      {
        (object) "Step",
        (object) args,
        (object) stepNumber,
        contextData
      };
      if (!earlyBound)
        stepArgs = new object[1]{ (object) stepArgs };
      return stepArgs;
    }

    protected virtual void UpdateStepArgs(object[] args, ref object contextData, bool earlyBound)
    {
      object[] objArray = !earlyBound ? args[0] as object[] : args;
      if (objArray == null)
        return;
      contextData = objArray[objArray.Length - 1];
    }

    protected virtual object[] GetFinalArgs(object contextData, bool earlyBound)
    {
      object[] finalArgs = new object[2]
      {
        (object) "Final",
        contextData
      };
      if (!earlyBound)
        finalArgs = new object[1]{ (object) finalArgs };
      return finalArgs;
    }

    protected virtual object[] GetCompareArgs(string param1, string param2, bool earlyBound)
    {
      object[] compareArgs = new object[3]
      {
        (object) "Compare",
        (object) param1,
        (object) param2
      };
      if (!earlyBound)
        compareArgs = new object[1]{ (object) compareArgs };
      return compareArgs;
    }

    public virtual Delegate Callback1
    {
      get => this.callback1;
      set => this.callback1 = value;
    }

    public virtual Delegate Callback2
    {
      get => this.callback2;
      set => this.callback2 = value;
    }

    public override object Invoke(object[] args)
    {
      if ((object) this.callback1 == null)
        throw new InvalidOperationException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "No \"{0}\" callback is set.", (object) nameof (Invoke)));
      return this.callback1 is SQLiteInvokeDelegate callback1 ? callback1(nameof (Invoke), args) : this.callback1.DynamicInvoke(this.GetInvokeArgs(args, false));
    }

    public override void Step(object[] args, int stepNumber, ref object contextData)
    {
      if ((object) this.callback1 == null)
        throw new InvalidOperationException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "No \"{0}\" callback is set.", (object) nameof (Step)));
      if (this.callback1 is SQLiteStepDelegate callback1)
      {
        callback1(nameof (Step), args, stepNumber, ref contextData);
      }
      else
      {
        object[] stepArgs = this.GetStepArgs(args, stepNumber, contextData, false);
        this.callback1.DynamicInvoke(stepArgs);
        this.UpdateStepArgs(stepArgs, ref contextData, false);
      }
    }

    public override object Final(object contextData)
    {
      if ((object) this.callback2 == null)
        throw new InvalidOperationException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "No \"{0}\" callback is set.", (object) nameof (Final)));
      return this.callback2 is SQLiteFinalDelegate callback2 ? callback2(nameof (Final), contextData) : this.callback1.DynamicInvoke(this.GetFinalArgs(contextData, false));
    }

    public override int Compare(string param1, string param2)
    {
      if ((object) this.callback1 == null)
        throw new InvalidOperationException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "No \"{0}\" callback is set.", (object) nameof (Compare)));
      if (this.callback1 is SQLiteCompareDelegate callback1)
        return callback1(nameof (Compare), param1, param2);
      if (this.callback1.DynamicInvoke(this.GetCompareArgs(param1, param2, false)) is int num)
        return num;
      throw new InvalidOperationException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "\"{0}\" result must be Int32.", (object) nameof (Compare)));
    }
  }
}


--- SQLiteEnlistment.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteEnlistment
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Globalization;
using System.Transactions;

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLiteEnlistment : IDisposable, IEnlistmentNotification
  {
    internal SQLiteTransaction _transaction;
    internal Transaction _scope;
    internal bool _disposeConnection;
    private bool disposed;

    internal SQLiteEnlistment(
      SQLiteConnection cnn,
      Transaction scope,
      System.Data.IsolationLevel defaultIsolationLevel,
      bool throwOnUnavailable,
      bool throwOnUnsupported)
    {
      this._transaction = cnn.BeginTransaction(this.GetSystemDataIsolationLevel(cnn, scope, defaultIsolationLevel, throwOnUnavailable, throwOnUnsupported));
      this._scope = scope;
      this._scope.EnlistVolatile((IEnlistmentNotification) this, EnlistmentOptions.None);
    }

    private System.Data.IsolationLevel GetSystemDataIsolationLevel(
      SQLiteConnection connection,
      Transaction transaction,
      System.Data.IsolationLevel defaultIsolationLevel,
      bool throwOnUnavailable,
      bool throwOnUnsupported)
    {
      if (transaction == (Transaction) null)
      {
        if (connection != null)
          return connection.GetDefaultIsolationLevel();
        if (throwOnUnavailable)
          throw new InvalidOperationException("isolation level is unavailable");
        return defaultIsolationLevel;
      }
      System.Transactions.IsolationLevel isolationLevel = transaction.IsolationLevel;
      switch (isolationLevel)
      {
        case System.Transactions.IsolationLevel.Serializable:
          return System.Data.IsolationLevel.Serializable;
        case System.Transactions.IsolationLevel.RepeatableRead:
          return System.Data.IsolationLevel.RepeatableRead;
        case System.Transactions.IsolationLevel.ReadCommitted:
          return System.Data.IsolationLevel.ReadCommitted;
        case System.Transactions.IsolationLevel.ReadUncommitted:
          return System.Data.IsolationLevel.ReadUncommitted;
        case System.Transactions.IsolationLevel.Snapshot:
          return System.Data.IsolationLevel.Snapshot;
        case System.Transactions.IsolationLevel.Chaos:
          return System.Data.IsolationLevel.Chaos;
        case System.Transactions.IsolationLevel.Unspecified:
          return System.Data.IsolationLevel.Unspecified;
        default:
          if (throwOnUnsupported)
            throw new InvalidOperationException(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "unsupported isolation level {0}", (object) isolationLevel));
          return defaultIsolationLevel;
      }
    }

    private void Cleanup(SQLiteConnection cnn)
    {
      if (this._disposeConnection)
        cnn.Dispose();
      this._transaction = (SQLiteTransaction) null;
      this._scope = (Transaction) null;
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteEnlistment).Name);
    }

    private void Dispose(bool disposing)
    {
      if (this.disposed)
        return;
      if (disposing)
      {
        if (this._transaction != null)
        {
          this._transaction.Dispose();
          this._transaction = (SQLiteTransaction) null;
        }
        if (this._scope != (Transaction) null)
          this._scope = (Transaction) null;
      }
      this.disposed = true;
    }

    ~SQLiteEnlistment() => this.Dispose(false);

    public void Commit(Enlistment enlistment)
    {
      this.CheckDisposed();
      SQLiteConnection connection = this._transaction.Connection;
      connection._enlistment = (SQLiteEnlistment) null;
      try
      {
        this._transaction.IsValid(true);
        this._transaction.Connection._transactionLevel = 1;
        this._transaction.Commit();
        enlistment.Done();
      }
      finally
      {
        this.Cleanup(connection);
      }
    }

    public void InDoubt(Enlistment enlistment)
    {
      this.CheckDisposed();
      enlistment.Done();
    }

    public void Prepare(PreparingEnlistment preparingEnlistment)
    {
      this.CheckDisposed();
      if (!this._transaction.IsValid(false))
        preparingEnlistment.ForceRollback();
      else
        preparingEnlistment.Prepared();
    }

    public void Rollback(Enlistment enlistment)
    {
      this.CheckDisposed();
      SQLiteConnection connection = this._transaction.Connection;
      connection._enlistment = (SQLiteEnlistment) null;
      try
      {
        this._transaction.Rollback();
        enlistment.Done();
      }
      finally
      {
        this.Cleanup(connection);
      }
    }
  }
}


--- SQLiteErrorCode.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteErrorCode
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum SQLiteErrorCode
  {
    Unknown = -1, // 0xFFFFFFFF
    Ok = 0,
    Error = 1,
    Internal = 2,
    Perm = 3,
    Abort = 4,
    Busy = 5,
    Locked = 6,
    NoMem = 7,
    ReadOnly = 8,
    Interrupt = 9,
    IoErr = 10, // 0x0000000A
    Corrupt = 11, // 0x0000000B
    NotFound = 12, // 0x0000000C
    Full = 13, // 0x0000000D
    CantOpen = 14, // 0x0000000E
    Protocol = 15, // 0x0000000F
    Empty = 16, // 0x00000010
    Schema = 17, // 0x00000011
    TooBig = 18, // 0x00000012
    Constraint = 19, // 0x00000013
    Mismatch = 20, // 0x00000014
    Misuse = 21, // 0x00000015
    NoLfs = 22, // 0x00000016
    Auth = 23, // 0x00000017
    Format = 24, // 0x00000018
    Range = 25, // 0x00000019
    NotADb = 26, // 0x0000001A
    Notice = 27, // 0x0000001B
    Warning = 28, // 0x0000001C
    Row = 100, // 0x00000064
    Done = 101, // 0x00000065
    NonExtendedMask = 255, // 0x000000FF
    Ok_Load_Permanently = 256, // 0x00000100
    Busy_Recovery = 261, // 0x00000105
    Locked_SharedCache = 262, // 0x00000106
    ReadOnly_Recovery = 264, // 0x00000108
    IoErr_Read = 266, // 0x0000010A
    Corrupt_Vtab = 267, // 0x0000010B
    CantOpen_NoTempDir = 270, // 0x0000010E
    Constraint_Check = 275, // 0x00000113
    Auth_User = 279, // 0x00000117
    Notice_Recover_Wal = 283, // 0x0000011B
    Warning_AutoIndex = 284, // 0x0000011C
    Abort_Rollback = 516, // 0x00000204
    Busy_Snapshot = 517, // 0x00000205
    ReadOnly_CantLock = 520, // 0x00000208
    IoErr_Short_Read = 522, // 0x0000020A
    CantOpen_IsDir = 526, // 0x0000020E
    Constraint_CommitHook = 531, // 0x00000213
    Notice_Recover_Rollback = 539, // 0x0000021B
    ReadOnly_Rollback = 776, // 0x00000308
    IoErr_Write = 778, // 0x0000030A
    CantOpen_FullPath = 782, // 0x0000030E
    Constraint_ForeignKey = 787, // 0x00000313
    ReadOnly_DbMoved = 1032, // 0x00000408
    IoErr_Fsync = 1034, // 0x0000040A
    CantOpen_ConvPath = 1038, // 0x0000040E
    Constraint_Function = 1043, // 0x00000413
    IoErr_Dir_Fsync = 1290, // 0x0000050A
    Constraint_NotNull = 1299, // 0x00000513
    IoErr_Truncate = 1546, // 0x0000060A
    Constraint_PrimaryKey = 1555, // 0x00000613
    IoErr_Fstat = 1802, // 0x0000070A
    Constraint_Trigger = 1811, // 0x00000713
    IoErr_Unlock = 2058, // 0x0000080A
    Constraint_Unique = 2067, // 0x00000813
    IoErr_RdLock = 2314, // 0x0000090A
    Constraint_Vtab = 2323, // 0x00000913
    IoErr_Delete = 2570, // 0x00000A0A
    Constraint_RowId = 2579, // 0x00000A13
    IoErr_Blocked = 2826, // 0x00000B0A
    IoErr_NoMem = 3082, // 0x00000C0A
    IoErr_Access = 3338, // 0x00000D0A
    IoErr_CheckReservedLock = 3594, // 0x00000E0A
    IoErr_Lock = 3850, // 0x00000F0A
    IoErr_Close = 4106, // 0x0000100A
    IoErr_Dir_Close = 4362, // 0x0000110A
    IoErr_ShmOpen = 4618, // 0x0000120A
    IoErr_ShmSize = 4874, // 0x0000130A
    IoErr_ShmLock = 5130, // 0x0000140A
    IoErr_ShmMap = 5386, // 0x0000150A
    IoErr_Seek = 5642, // 0x0000160A
    IoErr_Delete_NoEnt = 5898, // 0x0000170A
    IoErr_Mmap = 6154, // 0x0000180A
    IoErr_GetTempPath = 6410, // 0x0000190A
    IoErr_ConvPath = 6666, // 0x00001A0A
    IoErr_VNode = 6922, // 0x00001B0A
    IoErr_Auth = 7178, // 0x00001C0A
  }
}


--- SQLiteException.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteException
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Data.Common;
using System.Globalization;
using System.Reflection;
using System.Runtime.Serialization;
using System.Security.Permissions;

#nullable disable
namespace System.Data.SQLite
{
  [Serializable]
  public sealed class SQLiteException : DbException, ISerializable
  {
    private SQLiteErrorCode _errorCode;

    private SQLiteException(SerializationInfo info, StreamingContext context)
      : base(info, context)
    {
      this._errorCode = (SQLiteErrorCode) info.GetInt32("errorCode");
    }

    public SQLiteException(SQLiteErrorCode errorCode, string message)
      : base(SQLiteException.GetStockErrorMessage(errorCode, message))
    {
      this._errorCode = errorCode;
    }

    public SQLiteException(string message)
      : this(SQLiteErrorCode.Unknown, message)
    {
    }

    public SQLiteException()
    {
    }

    public SQLiteException(string message, Exception innerException)
      : base(message, innerException)
    {
    }

    [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
    public override void GetObjectData(SerializationInfo info, StreamingContext context)
    {
      info?.AddValue("errorCode", (object) this._errorCode);
      base.GetObjectData(info, context);
    }

    public SQLiteErrorCode ResultCode => this._errorCode;

    public override int ErrorCode => (int) this._errorCode;

    private static string GetErrorString(SQLiteErrorCode errorCode)
    {
      return typeof (SQLite3).InvokeMember(nameof (GetErrorString), BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.InvokeMethod, (Binder) null, (object) null, new object[1]
      {
        (object) errorCode
      }) as string;
    }

    private static string GetStockErrorMessage(SQLiteErrorCode errorCode, string message)
    {
      return HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "{0}{1}{2}", (object) SQLiteException.GetErrorString(errorCode), (object) Environment.NewLine, (object) message).Trim();
    }
  }
}


--- SQLiteExecuteType.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteExecuteType
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum SQLiteExecuteType
  {
    None = 0,
    Default = 1,
    NonQuery = 1,
    Scalar = 2,
    Reader = 3,
  }
}


--- SQLiteFactory.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteFactory
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Data.Common;
using System.Globalization;
using System.Reflection;
using System.Security.Permissions;

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteFactory : DbProviderFactory, IDisposable, IServiceProvider
  {
    private bool disposed;
    public static readonly SQLiteFactory Instance = new SQLiteFactory();
    private static readonly string DefaultTypeName = "System.Data.SQLite.Linq.SQLiteProviderServices, System.Data.SQLite.Linq, Version={0}, Culture=neutral, PublicKeyToken=db937bc2d44ff139";
    private static readonly BindingFlags DefaultBindingFlags = BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic;
    private static Type _dbProviderServicesType;
    private static object _sqliteServices;

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteFactory).Name);
    }

    private void Dispose(bool disposing)
    {
      if (this.disposed)
        return;
      this.disposed = true;
    }

    ~SQLiteFactory() => this.Dispose(false);

    public event SQLiteLogEventHandler Log
    {
      add
      {
        this.CheckDisposed();
        SQLiteLog.Log += value;
      }
      remove
      {
        this.CheckDisposed();
        SQLiteLog.Log -= value;
      }
    }

    public override DbCommand CreateCommand()
    {
      this.CheckDisposed();
      return (DbCommand) new SQLiteCommand();
    }

    public override DbCommandBuilder CreateCommandBuilder()
    {
      this.CheckDisposed();
      return (DbCommandBuilder) new SQLiteCommandBuilder();
    }

    public override DbConnection CreateConnection()
    {
      this.CheckDisposed();
      return (DbConnection) new SQLiteConnection();
    }

    public override DbConnectionStringBuilder CreateConnectionStringBuilder()
    {
      this.CheckDisposed();
      return (DbConnectionStringBuilder) new SQLiteConnectionStringBuilder();
    }

    public override DbDataAdapter CreateDataAdapter()
    {
      this.CheckDisposed();
      return (DbDataAdapter) new SQLiteDataAdapter();
    }

    public override DbParameter CreateParameter()
    {
      this.CheckDisposed();
      return (DbParameter) new SQLiteParameter();
    }

    static SQLiteFactory()
    {
      UnsafeNativeMethods.Initialize();
      SQLiteLog.Initialize();
      SQLiteFactory._dbProviderServicesType = Type.GetType(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "System.Data.Common.DbProviderServices, System.Data.Entity, Version={0}, Culture=neutral, PublicKeyToken=b77a5c561934e089", (object) "4.0.0.0"), false);
    }

    object IServiceProvider.GetService(Type serviceType)
    {
      return serviceType == typeof (ISQLiteSchemaExtensions) || SQLiteFactory._dbProviderServicesType != (Type) null && serviceType == SQLiteFactory._dbProviderServicesType ? this.GetSQLiteProviderServicesInstance() : (object) null;
    }

    [ReflectionPermission(SecurityAction.Assert, MemberAccess = true)]
    private object GetSQLiteProviderServicesInstance()
    {
      if (SQLiteFactory._sqliteServices == null)
      {
        string settingValue = UnsafeNativeMethods.GetSettingValue("TypeName_SQLiteProviderServices", (string) null);
        Version version = this.GetType().Assembly.GetName().Version;
        string typeName;
        if (settingValue != null)
          typeName = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, settingValue, (object) version);
        else
          typeName = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, SQLiteFactory.DefaultTypeName, (object) version);
        Type type = Type.GetType(typeName, false);
        if (type != (Type) null)
        {
          FieldInfo field = type.GetField("Instance", SQLiteFactory.DefaultBindingFlags);
          if (field != (FieldInfo) null)
            SQLiteFactory._sqliteServices = field.GetValue((object) null);
        }
      }
      return SQLiteFactory._sqliteServices;
    }
  }
}


--- SQLiteFinalCallback.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteFinalCallback
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  internal delegate void SQLiteFinalCallback(IntPtr context);
}


--- SQLiteFinalDelegate.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteFinalDelegate
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate object SQLiteFinalDelegate(string param0, object contextData);
}


--- SQLiteFunction.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteFunction
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Permissions;

#nullable disable
namespace System.Data.SQLite
{
  public abstract class SQLiteFunction : IDisposable
  {
    internal SQLiteBase _base;
    private Dictionary<IntPtr, SQLiteFunction.AggregateData> _contextDataList;
    private SQLiteConnectionFlags _flags;
    private SQLiteCallback _InvokeFunc;
    private SQLiteCallback _StepFunc;
    private SQLiteFinalCallback _FinalFunc;
    private SQLiteCollation _CompareFunc;
    private SQLiteCollation _CompareFunc16;
    internal IntPtr _context;
    private static IDictionary<SQLiteFunctionAttribute, object> _registeredFunctions = (IDictionary<SQLiteFunctionAttribute, object>) new Dictionary<SQLiteFunctionAttribute, object>();
    private bool disposed;

    protected SQLiteFunction()
    {
      this._contextDataList = new Dictionary<IntPtr, SQLiteFunction.AggregateData>();
    }

    protected SQLiteFunction(
      SQLiteDateFormats format,
      DateTimeKind kind,
      string formatString,
      bool utf16)
      : this()
    {
      if (utf16)
        this._base = (SQLiteBase) new SQLite3_UTF16(format, kind, formatString, IntPtr.Zero, (string) null, false);
      else
        this._base = (SQLiteBase) new SQLite3(format, kind, formatString, IntPtr.Zero, (string) null, false);
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteFunction).Name);
    }

    protected virtual void Dispose(bool disposing)
    {
      if (this.disposed)
        return;
      if (disposing)
      {
        foreach (KeyValuePair<IntPtr, SQLiteFunction.AggregateData> contextData in this._contextDataList)
        {
          if (contextData.Value._data is IDisposable data)
            data.Dispose();
        }
        this._contextDataList.Clear();
        this._contextDataList = (Dictionary<IntPtr, SQLiteFunction.AggregateData>) null;
        this._flags = SQLiteConnectionFlags.None;
        this._InvokeFunc = (SQLiteCallback) null;
        this._StepFunc = (SQLiteCallback) null;
        this._FinalFunc = (SQLiteFinalCallback) null;
        this._CompareFunc = (SQLiteCollation) null;
        this._base = (SQLiteBase) null;
      }
      this.disposed = true;
    }

    ~SQLiteFunction() => this.Dispose(false);

    public SQLiteConvert SQLiteConvert
    {
      get
      {
        this.CheckDisposed();
        return (SQLiteConvert) this._base;
      }
    }

    public virtual object Invoke(object[] args)
    {
      this.CheckDisposed();
      return (object) null;
    }

    public virtual void Step(object[] args, int stepNumber, ref object contextData)
    {
      this.CheckDisposed();
    }

    public virtual object Final(object contextData)
    {
      this.CheckDisposed();
      return (object) null;
    }

    public virtual int Compare(string param1, string param2)
    {
      this.CheckDisposed();
      return 0;
    }

    internal object[] ConvertParams(int nArgs, IntPtr argsptr)
    {
      object[] objArray = new object[nArgs];
      IntPtr[] destination = new IntPtr[nArgs];
      Marshal.Copy(argsptr, destination, 0, nArgs);
      for (int index = 0; index < nArgs; ++index)
      {
        switch (this._base.GetParamValueType(destination[index]))
        {
          case TypeAffinity.Int64:
            objArray[index] = (object) this._base.GetParamValueInt64(destination[index]);
            break;
          case TypeAffinity.Double:
            objArray[index] = (object) this._base.GetParamValueDouble(destination[index]);
            break;
          case TypeAffinity.Text:
            objArray[index] = (object) this._base.GetParamValueText(destination[index]);
            break;
          case TypeAffinity.Blob:
            int paramValueBytes = (int) this._base.GetParamValueBytes(destination[index], 0, (byte[]) null, 0, 0);
            byte[] bDest = new byte[paramValueBytes];
            this._base.GetParamValueBytes(destination[index], 0, bDest, 0, paramValueBytes);
            objArray[index] = (object) bDest;
            break;
          case TypeAffinity.Null:
            objArray[index] = (object) DBNull.Value;
            break;
          case TypeAffinity.DateTime:
            objArray[index] = (object) this._base.ToDateTime(this._base.GetParamValueText(destination[index]));
            break;
        }
      }
      return objArray;
    }

    private void SetReturnValue(IntPtr context, object returnValue)
    {
      if (returnValue == null || returnValue == DBNull.Value)
      {
        this._base.ReturnNull(context);
      }
      else
      {
        Type type = returnValue.GetType();
        if (type == typeof (DateTime))
          this._base.ReturnText(context, this._base.ToString((DateTime) returnValue));
        else if (returnValue is Exception exception)
        {
          this._base.ReturnError(context, exception.Message);
        }
        else
        {
          switch (SQLiteConvert.TypeToAffinity(type))
          {
            case TypeAffinity.Int64:
              this._base.ReturnInt64(context, Convert.ToInt64(returnValue, (IFormatProvider) CultureInfo.CurrentCulture));
              break;
            case TypeAffinity.Double:
              this._base.ReturnDouble(context, Convert.ToDouble(returnValue, (IFormatProvider) CultureInfo.CurrentCulture));
              break;
            case TypeAffinity.Text:
              this._base.ReturnText(context, returnValue.ToString());
              break;
            case TypeAffinity.Blob:
              this._base.ReturnBlob(context, (byte[]) returnValue);
              break;
            case TypeAffinity.Null:
              this._base.ReturnNull(context);
              break;
          }
        }
      }
    }

    internal void ScalarCallback(IntPtr context, int nArgs, IntPtr argsptr)
    {
      try
      {
        this._context = context;
        this.SetReturnValue(context, this.Invoke(this.ConvertParams(nArgs, argsptr)));
      }
      catch (Exception ex)
      {
        try
        {
          if ((this._flags & SQLiteConnectionFlags.LogCallbackException) != SQLiteConnectionFlags.LogCallbackException)
            return;
          SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"Invoke\" method: {0}", (object) ex));
        }
        catch
        {
        }
      }
    }

    internal int CompareCallback(IntPtr ptr, int len1, IntPtr ptr1, int len2, IntPtr ptr2)
    {
      try
      {
        return this.Compare(SQLiteConvert.UTF8ToString(ptr1, len1), SQLiteConvert.UTF8ToString(ptr2, len2));
      }
      catch (Exception ex)
      {
        try
        {
          if ((this._flags & SQLiteConnectionFlags.LogCallbackException) == SQLiteConnectionFlags.LogCallbackException)
            SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"Compare\" (UTF8) method: {0}", (object) ex));
        }
        catch
        {
        }
      }
      if (this._base != null && this._base.IsOpen())
        this._base.Cancel();
      return 0;
    }

    internal int CompareCallback16(IntPtr ptr, int len1, IntPtr ptr1, int len2, IntPtr ptr2)
    {
      try
      {
        return this.Compare(SQLite3_UTF16.UTF16ToString(ptr1, len1), SQLite3_UTF16.UTF16ToString(ptr2, len2));
      }
      catch (Exception ex)
      {
        try
        {
          if ((this._flags & SQLiteConnectionFlags.LogCallbackException) == SQLiteConnectionFlags.LogCallbackException)
            SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"Compare\" (UTF16) method: {0}", (object) ex));
        }
        catch
        {
        }
      }
      if (this._base != null && this._base.IsOpen())
        this._base.Cancel();
      return 0;
    }

    internal void StepCallback(IntPtr context, int nArgs, IntPtr argsptr)
    {
      try
      {
        SQLiteFunction.AggregateData aggregateData = (SQLiteFunction.AggregateData) null;
        if (this._base != null)
        {
          IntPtr key = this._base.AggregateContext(context);
          if (this._contextDataList != null && !this._contextDataList.TryGetValue(key, out aggregateData))
          {
            aggregateData = new SQLiteFunction.AggregateData();
            this._contextDataList[key] = aggregateData;
          }
        }
        if (aggregateData == null)
          aggregateData = new SQLiteFunction.AggregateData();
        try
        {
          this._context = context;
          this.Step(this.ConvertParams(nArgs, argsptr), aggregateData._count, ref aggregateData._data);
        }
        finally
        {
          ++aggregateData._count;
        }
      }
      catch (Exception ex)
      {
        try
        {
          if ((this._flags & SQLiteConnectionFlags.LogCallbackException) != SQLiteConnectionFlags.LogCallbackException)
            return;
          SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"Step\" method: {1}", (object) ex));
        }
        catch
        {
        }
      }
    }

    internal void FinalCallback(IntPtr context)
    {
      try
      {
        object contextData = (object) null;
        if (this._base != null)
        {
          IntPtr key = this._base.AggregateContext(context);
          if (this._contextDataList != null)
          {
            SQLiteFunction.AggregateData aggregateData;
            if (this._contextDataList.TryGetValue(key, out aggregateData))
            {
              contextData = aggregateData._data;
              this._contextDataList.Remove(key);
            }
          }
        }
        try
        {
          this._context = context;
          this.SetReturnValue(context, this.Final(contextData));
        }
        finally
        {
          if (contextData is IDisposable disposable)
            disposable.Dispose();
        }
      }
      catch (Exception ex)
      {
        try
        {
          if ((this._flags & SQLiteConnectionFlags.LogCallbackException) != SQLiteConnectionFlags.LogCallbackException)
            return;
          SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"Final\" method: {1}", (object) ex));
        }
        catch
        {
        }
      }
    }

    [FileIOPermission(SecurityAction.Assert, AllFiles = FileIOPermissionAccess.PathDiscovery)]
    static SQLiteFunction()
    {
      try
      {
        if (UnsafeNativeMethods.GetSettingValue("No_SQLiteFunctions", (string) null) != null)
          return;
        Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
        int length1 = assemblies.Length;
        AssemblyName name = Assembly.GetExecutingAssembly().GetName();
        for (int index1 = 0; index1 < length1; ++index1)
        {
          bool flag = false;
          Type[] types;
          try
          {
            AssemblyName[] referencedAssemblies = assemblies[index1].GetReferencedAssemblies();
            int length2 = referencedAssemblies.Length;
            for (int index2 = 0; index2 < length2; ++index2)
            {
              if (referencedAssemblies[index2].Name == name.Name)
              {
                flag = true;
                break;
              }
            }
            if (flag)
              types = assemblies[index1].GetTypes();
            else
              continue;
          }
          catch (ReflectionTypeLoadException ex)
          {
            types = ex.Types;
          }
          int length3 = types.Length;
          for (int index3 = 0; index3 < length3; ++index3)
          {
            if (!(types[index3] == (Type) null))
            {
              object[] customAttributes = types[index3].GetCustomAttributes(typeof (SQLiteFunctionAttribute), false);
              int length4 = customAttributes.Length;
              for (int index4 = 0; index4 < length4; ++index4)
              {
                if (customAttributes[index4] is SQLiteFunctionAttribute at)
                {
                  at.InstanceType = types[index3];
                  SQLiteFunction.ReplaceFunction(at, (object) null);
                }
              }
            }
          }
        }
      }
      catch
      {
      }
    }

    public static void RegisterFunction(Type typ)
    {
      foreach (object customAttribute in typ.GetCustomAttributes(typeof (SQLiteFunctionAttribute), false))
      {
        if (customAttribute is SQLiteFunctionAttribute functionAttribute)
          SQLiteFunction.RegisterFunction(functionAttribute.Name, functionAttribute.Arguments, functionAttribute.FuncType, typ, functionAttribute.Callback1, functionAttribute.Callback2);
      }
    }

    public static void RegisterFunction(
      string name,
      int argumentCount,
      FunctionType functionType,
      Type instanceType,
      Delegate callback1,
      Delegate callback2)
    {
      SQLiteFunction.ReplaceFunction(new SQLiteFunctionAttribute(name, argumentCount, functionType)
      {
        InstanceType = instanceType,
        Callback1 = callback1,
        Callback2 = callback2
      }, (object) null);
    }

    private static bool ReplaceFunction(SQLiteFunctionAttribute at, object newValue)
    {
      object obj;
      if (SQLiteFunction._registeredFunctions.TryGetValue(at, out obj))
      {
        if (obj is IDisposable disposable)
          disposable.Dispose();
        SQLiteFunction._registeredFunctions[at] = newValue;
        return true;
      }
      SQLiteFunction._registeredFunctions.Add(at, newValue);
      return false;
    }

    private static bool CreateFunction(
      SQLiteFunctionAttribute functionAttribute,
      out SQLiteFunction function)
    {
      if (functionAttribute == null)
      {
        function = (SQLiteFunction) null;
        return false;
      }
      if ((object) functionAttribute.Callback1 != null || (object) functionAttribute.Callback2 != null)
      {
        function = (SQLiteFunction) new SQLiteDelegateFunction(functionAttribute.Callback1, functionAttribute.Callback2);
        return true;
      }
      if (functionAttribute.InstanceType != (Type) null)
      {
        function = (SQLiteFunction) Activator.CreateInstance(functionAttribute.InstanceType);
        return true;
      }
      function = (SQLiteFunction) null;
      return false;
    }

    internal static IDictionary<SQLiteFunctionAttribute, SQLiteFunction> BindFunctions(
      SQLiteBase sqlbase,
      SQLiteConnectionFlags flags)
    {
      IDictionary<SQLiteFunctionAttribute, SQLiteFunction> dictionary = (IDictionary<SQLiteFunctionAttribute, SQLiteFunction>) new Dictionary<SQLiteFunctionAttribute, SQLiteFunction>();
      foreach (KeyValuePair<SQLiteFunctionAttribute, object> registeredFunction in (IEnumerable<KeyValuePair<SQLiteFunctionAttribute, object>>) SQLiteFunction._registeredFunctions)
      {
        SQLiteFunctionAttribute key = registeredFunction.Key;
        if (key != null)
        {
          SQLiteFunction function;
          if (SQLiteFunction.CreateFunction(key, out function))
          {
            SQLiteFunction.BindFunction(sqlbase, key, function, flags);
            dictionary[key] = function;
          }
          else
            dictionary[key] = (SQLiteFunction) null;
        }
      }
      return dictionary;
    }

    internal static bool UnbindAllFunctions(
      SQLiteBase sqlbase,
      SQLiteConnectionFlags flags,
      bool registered)
    {
      if (sqlbase == null)
        return false;
      IDictionary<SQLiteFunctionAttribute, SQLiteFunction> functions = sqlbase.Functions;
      if (functions == null)
        return false;
      bool flag = true;
      if (registered)
      {
        foreach (KeyValuePair<SQLiteFunctionAttribute, object> registeredFunction in (IEnumerable<KeyValuePair<SQLiteFunctionAttribute, object>>) SQLiteFunction._registeredFunctions)
        {
          SQLiteFunctionAttribute key = registeredFunction.Key;
          SQLiteFunction function;
          if (key != null && (!functions.TryGetValue(key, out function) || function == null || !SQLiteFunction.UnbindFunction(sqlbase, key, function, flags)))
            flag = false;
        }
      }
      else
      {
        foreach (KeyValuePair<SQLiteFunctionAttribute, SQLiteFunction> keyValuePair in (IEnumerable<KeyValuePair<SQLiteFunctionAttribute, SQLiteFunction>>) new Dictionary<SQLiteFunctionAttribute, SQLiteFunction>(functions))
        {
          SQLiteFunctionAttribute key = keyValuePair.Key;
          if (key != null)
          {
            SQLiteFunction function = keyValuePair.Value;
            if (function == null || !SQLiteFunction.UnbindFunction(sqlbase, key, function, flags))
              flag = false;
          }
        }
      }
      return flag;
    }

    internal static void BindFunction(
      SQLiteBase sqliteBase,
      SQLiteFunctionAttribute functionAttribute,
      SQLiteFunction function,
      SQLiteConnectionFlags flags)
    {
      if (sqliteBase == null)
        throw new ArgumentNullException(nameof (sqliteBase));
      if (functionAttribute == null)
        throw new ArgumentNullException(nameof (functionAttribute));
      if (function == null)
        throw new ArgumentNullException(nameof (function));
      FunctionType funcType = functionAttribute.FuncType;
      function._base = sqliteBase;
      function._flags = flags;
      function._InvokeFunc = funcType == FunctionType.Scalar ? new SQLiteCallback(function.ScalarCallback) : (SQLiteCallback) null;
      function._StepFunc = funcType == FunctionType.Aggregate ? new SQLiteCallback(function.StepCallback) : (SQLiteCallback) null;
      function._FinalFunc = funcType == FunctionType.Aggregate ? new SQLiteFinalCallback(function.FinalCallback) : (SQLiteFinalCallback) null;
      function._CompareFunc = funcType == FunctionType.Collation ? new SQLiteCollation(function.CompareCallback) : (SQLiteCollation) null;
      function._CompareFunc16 = funcType == FunctionType.Collation ? new SQLiteCollation(function.CompareCallback16) : (SQLiteCollation) null;
      string name = functionAttribute.Name;
      if (funcType != FunctionType.Collation)
      {
        bool needCollSeq = function is SQLiteFunctionEx;
        int function1 = (int) sqliteBase.CreateFunction(name, functionAttribute.Arguments, needCollSeq, function._InvokeFunc, function._StepFunc, function._FinalFunc, true);
      }
      else
      {
        int collation = (int) sqliteBase.CreateCollation(name, function._CompareFunc, function._CompareFunc16, true);
      }
    }

    internal static bool UnbindFunction(
      SQLiteBase sqliteBase,
      SQLiteFunctionAttribute functionAttribute,
      SQLiteFunction function,
      SQLiteConnectionFlags flags)
    {
      if (sqliteBase == null)
        throw new ArgumentNullException(nameof (sqliteBase));
      if (functionAttribute == null)
        throw new ArgumentNullException(nameof (functionAttribute));
      if (function == null)
        throw new ArgumentNullException(nameof (function));
      FunctionType funcType = functionAttribute.FuncType;
      string name = functionAttribute.Name;
      if (funcType == FunctionType.Collation)
        return sqliteBase.CreateCollation(name, (SQLiteCollation) null, (SQLiteCollation) null, false) == SQLiteErrorCode.Ok;
      bool needCollSeq = function is SQLiteFunctionEx;
      return sqliteBase.CreateFunction(name, functionAttribute.Arguments, needCollSeq, (SQLiteCallback) null, (SQLiteCallback) null, (SQLiteFinalCallback) null, false) == SQLiteErrorCode.Ok;
    }

    private class AggregateData
    {
      internal int _count = 1;
      internal object _data;
    }
  }
}


--- SQLiteFunctionAttribute.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteFunctionAttribute
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = true)]
  public sealed class SQLiteFunctionAttribute : Attribute
  {
    private string _name;
    private int _argumentCount;
    private FunctionType _functionType;
    private Type _instanceType;
    private Delegate _callback1;
    private Delegate _callback2;

    public SQLiteFunctionAttribute()
      : this((string) null, -1, FunctionType.Scalar)
    {
    }

    public SQLiteFunctionAttribute(string name, int argumentCount, FunctionType functionType)
    {
      this._name = name;
      this._argumentCount = argumentCount;
      this._functionType = functionType;
      this._instanceType = (Type) null;
      this._callback1 = (Delegate) null;
      this._callback2 = (Delegate) null;
    }

    public string Name
    {
      get => this._name;
      set => this._name = value;
    }

    public int Arguments
    {
      get => this._argumentCount;
      set => this._argumentCount = value;
    }

    public FunctionType FuncType
    {
      get => this._functionType;
      set => this._functionType = value;
    }

    internal Type InstanceType
    {
      get => this._instanceType;
      set => this._instanceType = value;
    }

    internal Delegate Callback1
    {
      get => this._callback1;
      set => this._callback1 = value;
    }

    internal Delegate Callback2
    {
      get => this._callback2;
      set => this._callback2 = value;
    }
  }
}


--- SQLiteFunctionEx.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteFunctionEx
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public class SQLiteFunctionEx : SQLiteFunction
  {
    private bool disposed;

    protected CollationSequence GetCollationSequence()
    {
      return this._base.GetCollationSequence((SQLiteFunction) this, this._context);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteFunctionEx).Name);
    }

    protected override void Dispose(bool disposing)
    {
      try
      {
        int num = this.disposed ? 1 : 0;
      }
      finally
      {
        base.Dispose(disposing);
        this.disposed = true;
      }
    }
  }
}


--- SQLiteIndex.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteIndex
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteIndex
  {
    private SQLiteIndexInputs inputs;
    private SQLiteIndexOutputs outputs;

    internal SQLiteIndex(int nConstraint, int nOrderBy)
    {
      this.inputs = new SQLiteIndexInputs(nConstraint, nOrderBy);
      this.outputs = new SQLiteIndexOutputs(nConstraint);
    }

    private static void SizeOfNative(
      out int sizeOfInfoType,
      out int sizeOfConstraintType,
      out int sizeOfOrderByType,
      out int sizeOfConstraintUsageType)
    {
      sizeOfInfoType = Marshal.SizeOf(typeof (UnsafeNativeMethods.sqlite3_index_info));
      sizeOfConstraintType = Marshal.SizeOf(typeof (UnsafeNativeMethods.sqlite3_index_constraint));
      sizeOfOrderByType = Marshal.SizeOf(typeof (UnsafeNativeMethods.sqlite3_index_orderby));
      sizeOfConstraintUsageType = Marshal.SizeOf(typeof (UnsafeNativeMethods.sqlite3_index_constraint_usage));
    }

    private static IntPtr AllocateAndInitializeNative(int nConstraint, int nOrderBy)
    {
      IntPtr num1 = IntPtr.Zero;
      IntPtr num2 = IntPtr.Zero;
      IntPtr pMemory1 = IntPtr.Zero;
      IntPtr pMemory2 = IntPtr.Zero;
      IntPtr pMemory3 = IntPtr.Zero;
      try
      {
        int sizeOfInfoType;
        int sizeOfConstraintType;
        int sizeOfOrderByType;
        int sizeOfConstraintUsageType;
        SQLiteIndex.SizeOfNative(out sizeOfInfoType, out sizeOfConstraintType, out sizeOfOrderByType, out sizeOfConstraintUsageType);
        if (sizeOfInfoType > 0)
        {
          if (sizeOfConstraintType > 0)
          {
            if (sizeOfOrderByType > 0)
            {
              if (sizeOfConstraintUsageType > 0)
              {
                num2 = SQLiteMemory.Allocate(sizeOfInfoType);
                pMemory1 = SQLiteMemory.Allocate(sizeOfConstraintType * nConstraint);
                pMemory2 = SQLiteMemory.Allocate(sizeOfOrderByType * nOrderBy);
                pMemory3 = SQLiteMemory.Allocate(sizeOfConstraintUsageType * nConstraint);
                if (num2 != IntPtr.Zero)
                {
                  if (pMemory1 != IntPtr.Zero)
                  {
                    if (pMemory2 != IntPtr.Zero)
                    {
                      if (pMemory3 != IntPtr.Zero)
                      {
                        int offset1 = 0;
                        SQLiteMarshal.WriteInt32(num2, offset1, nConstraint);
                        int offset2 = SQLiteMarshal.NextOffsetOf(offset1, 4, IntPtr.Size);
                        SQLiteMarshal.WriteIntPtr(num2, offset2, pMemory1);
                        int offset3 = SQLiteMarshal.NextOffsetOf(offset2, IntPtr.Size, 4);
                        SQLiteMarshal.WriteInt32(num2, offset3, nOrderBy);
                        int offset4 = SQLiteMarshal.NextOffsetOf(offset3, 4, IntPtr.Size);
                        SQLiteMarshal.WriteIntPtr(num2, offset4, pMemory2);
                        int offset5 = SQLiteMarshal.NextOffsetOf(offset4, IntPtr.Size, IntPtr.Size);
                        SQLiteMarshal.WriteIntPtr(num2, offset5, pMemory3);
                        num1 = num2;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      finally
      {
        if (num1 == IntPtr.Zero)
        {
          if (pMemory3 != IntPtr.Zero)
          {
            SQLiteMemory.Free(pMemory3);
            IntPtr zero = IntPtr.Zero;
          }
          if (pMemory2 != IntPtr.Zero)
          {
            SQLiteMemory.Free(pMemory2);
            IntPtr zero = IntPtr.Zero;
          }
          if (pMemory1 != IntPtr.Zero)
          {
            SQLiteMemory.Free(pMemory1);
            IntPtr zero = IntPtr.Zero;
          }
          if (num2 != IntPtr.Zero)
          {
            SQLiteMemory.Free(num2);
            IntPtr zero = IntPtr.Zero;
          }
        }
      }
      return num1;
    }

    private static void FreeNative(IntPtr pIndex)
    {
      if (pIndex == IntPtr.Zero)
        return;
      int offset1 = SQLiteMarshal.NextOffsetOf(0, 4, IntPtr.Size);
      IntPtr pMemory1 = SQLiteMarshal.ReadIntPtr(pIndex, offset1);
      int offset2 = SQLiteMarshal.NextOffsetOf(SQLiteMarshal.NextOffsetOf(offset1, IntPtr.Size, 4), 4, IntPtr.Size);
      IntPtr pMemory2 = SQLiteMarshal.ReadIntPtr(pIndex, offset2);
      int offset3 = SQLiteMarshal.NextOffsetOf(offset2, IntPtr.Size, IntPtr.Size);
      IntPtr pMemory3 = SQLiteMarshal.ReadIntPtr(pIndex, offset3);
      if (pMemory3 != IntPtr.Zero)
      {
        SQLiteMemory.Free(pMemory3);
        IntPtr zero = IntPtr.Zero;
      }
      if (pMemory2 != IntPtr.Zero)
      {
        SQLiteMemory.Free(pMemory2);
        IntPtr zero = IntPtr.Zero;
      }
      if (pMemory1 != IntPtr.Zero)
      {
        SQLiteMemory.Free(pMemory1);
        IntPtr zero = IntPtr.Zero;
      }
      if (!(pIndex != IntPtr.Zero))
        return;
      SQLiteMemory.Free(pIndex);
      pIndex = IntPtr.Zero;
    }

    internal static void FromIntPtr(IntPtr pIndex, bool includeOutput, ref SQLiteIndex index)
    {
      if (pIndex == IntPtr.Zero)
        return;
      int offset1 = 0;
      int nConstraint = SQLiteMarshal.ReadInt32(pIndex, offset1);
      int offset2 = SQLiteMarshal.NextOffsetOf(offset1, 4, IntPtr.Size);
      IntPtr pointer1 = SQLiteMarshal.ReadIntPtr(pIndex, offset2);
      int offset3 = SQLiteMarshal.NextOffsetOf(offset2, IntPtr.Size, 4);
      int nOrderBy = SQLiteMarshal.ReadInt32(pIndex, offset3);
      int offset4 = SQLiteMarshal.NextOffsetOf(offset3, 4, IntPtr.Size);
      IntPtr pointer2 = SQLiteMarshal.ReadIntPtr(pIndex, offset4);
      IntPtr pointer3 = IntPtr.Zero;
      if (includeOutput)
      {
        offset4 = SQLiteMarshal.NextOffsetOf(offset4, IntPtr.Size, IntPtr.Size);
        pointer3 = SQLiteMarshal.ReadIntPtr(pIndex, offset4);
      }
      index = new SQLiteIndex(nConstraint, nOrderBy);
      SQLiteIndexInputs inputs = index.Inputs;
      if (inputs == null)
        return;
      SQLiteIndexConstraint[] constraints = inputs.Constraints;
      if (constraints == null)
        return;
      SQLiteIndexOrderBy[] orderBys = inputs.OrderBys;
      if (orderBys == null)
        return;
      Type type1 = typeof (UnsafeNativeMethods.sqlite3_index_constraint);
      int num1 = Marshal.SizeOf(type1);
      for (int index1 = 0; index1 < nConstraint; ++index1)
      {
        UnsafeNativeMethods.sqlite3_index_constraint structure = (UnsafeNativeMethods.sqlite3_index_constraint) Marshal.PtrToStructure(SQLiteMarshal.IntPtrForOffset(pointer1, index1 * num1), type1);
        constraints[index1] = new SQLiteIndexConstraint(structure);
      }
      Type type2 = typeof (UnsafeNativeMethods.sqlite3_index_orderby);
      int num2 = Marshal.SizeOf(type2);
      for (int index2 = 0; index2 < nOrderBy; ++index2)
      {
        UnsafeNativeMethods.sqlite3_index_orderby structure = (UnsafeNativeMethods.sqlite3_index_orderby) Marshal.PtrToStructure(SQLiteMarshal.IntPtrForOffset(pointer2, index2 * num2), type2);
        orderBys[index2] = new SQLiteIndexOrderBy(structure);
      }
      if (!includeOutput)
        return;
      SQLiteIndexOutputs outputs = index.Outputs;
      if (outputs == null)
        return;
      SQLiteIndexConstraintUsage[] constraintUsages = outputs.ConstraintUsages;
      if (constraintUsages == null)
        return;
      Type type3 = typeof (UnsafeNativeMethods.sqlite3_index_constraint_usage);
      int num3 = Marshal.SizeOf(type3);
      for (int index3 = 0; index3 < nConstraint; ++index3)
      {
        UnsafeNativeMethods.sqlite3_index_constraint_usage structure = (UnsafeNativeMethods.sqlite3_index_constraint_usage) Marshal.PtrToStructure(SQLiteMarshal.IntPtrForOffset(pointer3, index3 * num3), type3);
        constraintUsages[index3] = new SQLiteIndexConstraintUsage(structure);
      }
      int offset5 = SQLiteMarshal.NextOffsetOf(offset4, IntPtr.Size, 4);
      outputs.IndexNumber = SQLiteMarshal.ReadInt32(pIndex, offset5);
      int offset6 = SQLiteMarshal.NextOffsetOf(offset5, 4, IntPtr.Size);
      outputs.IndexString = SQLiteString.StringFromUtf8IntPtr(SQLiteMarshal.ReadIntPtr(pIndex, offset6));
      int offset7 = SQLiteMarshal.NextOffsetOf(offset6, IntPtr.Size, 4);
      outputs.NeedToFreeIndexString = SQLiteMarshal.ReadInt32(pIndex, offset7);
      int offset8 = SQLiteMarshal.NextOffsetOf(offset7, 4, 4);
      outputs.OrderByConsumed = SQLiteMarshal.ReadInt32(pIndex, offset8);
      int offset9 = SQLiteMarshal.NextOffsetOf(offset8, 4, 8);
      outputs.EstimatedCost = new double?(SQLiteMarshal.ReadDouble(pIndex, offset9));
      int offset10 = SQLiteMarshal.NextOffsetOf(offset9, 8, 8);
      if (outputs.CanUseEstimatedRows())
        outputs.EstimatedRows = new long?(SQLiteMarshal.ReadInt64(pIndex, offset10));
      int offset11 = SQLiteMarshal.NextOffsetOf(offset10, 8, 4);
      if (outputs.CanUseIndexFlags())
        outputs.IndexFlags = new SQLiteIndexFlags?((SQLiteIndexFlags) SQLiteMarshal.ReadInt32(pIndex, offset11));
      int offset12 = SQLiteMarshal.NextOffsetOf(offset11, 4, 8);
      if (!outputs.CanUseColumnsUsed())
        return;
      outputs.ColumnsUsed = new long?(SQLiteMarshal.ReadInt64(pIndex, offset12));
    }

    internal static void ToIntPtr(SQLiteIndex index, IntPtr pIndex, bool includeInput)
    {
      if (index == null)
        return;
      SQLiteIndexOutputs outputs = index.Outputs;
      if (outputs == null)
        return;
      SQLiteIndexConstraintUsage[] constraintUsages = outputs.ConstraintUsages;
      if (constraintUsages == null)
        return;
      SQLiteIndexConstraint[] liteIndexConstraintArray = (SQLiteIndexConstraint[]) null;
      SQLiteIndexOrderBy[] liteIndexOrderByArray = (SQLiteIndexOrderBy[]) null;
      if (includeInput)
      {
        SQLiteIndexInputs inputs = index.Inputs;
        if (inputs == null)
          return;
        liteIndexConstraintArray = inputs.Constraints;
        if (liteIndexConstraintArray == null)
          return;
        liteIndexOrderByArray = inputs.OrderBys;
        if (liteIndexOrderByArray == null)
          return;
      }
      if (pIndex == IntPtr.Zero)
        return;
      int offset1 = 0;
      int num1 = SQLiteMarshal.ReadInt32(pIndex, offset1);
      if (includeInput && num1 != liteIndexConstraintArray.Length || num1 != constraintUsages.Length)
        return;
      int offset2 = SQLiteMarshal.NextOffsetOf(offset1, 4, IntPtr.Size);
      if (includeInput)
      {
        IntPtr pointer = SQLiteMarshal.ReadIntPtr(pIndex, offset2);
        int num2 = Marshal.SizeOf(typeof (UnsafeNativeMethods.sqlite3_index_constraint));
        for (int index1 = 0; index1 < num1; ++index1)
          Marshal.StructureToPtr((object) new UnsafeNativeMethods.sqlite3_index_constraint(liteIndexConstraintArray[index1]), SQLiteMarshal.IntPtrForOffset(pointer, index1 * num2), false);
      }
      int offset3 = SQLiteMarshal.NextOffsetOf(offset2, IntPtr.Size, 4);
      int num3 = includeInput ? SQLiteMarshal.ReadInt32(pIndex, offset3) : 0;
      if (includeInput && num3 != liteIndexOrderByArray.Length)
        return;
      int offset4 = SQLiteMarshal.NextOffsetOf(offset3, 4, IntPtr.Size);
      if (includeInput)
      {
        IntPtr pointer = SQLiteMarshal.ReadIntPtr(pIndex, offset4);
        int num4 = Marshal.SizeOf(typeof (UnsafeNativeMethods.sqlite3_index_orderby));
        for (int index2 = 0; index2 < num3; ++index2)
          Marshal.StructureToPtr((object) new UnsafeNativeMethods.sqlite3_index_orderby(liteIndexOrderByArray[index2]), SQLiteMarshal.IntPtrForOffset(pointer, index2 * num4), false);
      }
      int offset5 = SQLiteMarshal.NextOffsetOf(offset4, IntPtr.Size, IntPtr.Size);
      IntPtr pointer1 = SQLiteMarshal.ReadIntPtr(pIndex, offset5);
      int num5 = Marshal.SizeOf(typeof (UnsafeNativeMethods.sqlite3_index_constraint_usage));
      for (int index3 = 0; index3 < num1; ++index3)
        Marshal.StructureToPtr((object) new UnsafeNativeMethods.sqlite3_index_constraint_usage(constraintUsages[index3]), SQLiteMarshal.IntPtrForOffset(pointer1, index3 * num5), false);
      int offset6 = SQLiteMarshal.NextOffsetOf(offset5, IntPtr.Size, 4);
      SQLiteMarshal.WriteInt32(pIndex, offset6, outputs.IndexNumber);
      int offset7 = SQLiteMarshal.NextOffsetOf(offset6, 4, IntPtr.Size);
      SQLiteMarshal.WriteIntPtr(pIndex, offset7, SQLiteString.Utf8IntPtrFromString(outputs.IndexString));
      int offset8 = SQLiteMarshal.NextOffsetOf(offset7, IntPtr.Size, 4);
      int num6 = outputs.NeedToFreeIndexString != 0 ? outputs.NeedToFreeIndexString : 1;
      SQLiteMarshal.WriteInt32(pIndex, offset8, num6);
      int offset9 = SQLiteMarshal.NextOffsetOf(offset8, 4, 4);
      SQLiteMarshal.WriteInt32(pIndex, offset9, outputs.OrderByConsumed);
      int offset10 = SQLiteMarshal.NextOffsetOf(offset9, 4, 8);
      if (outputs.EstimatedCost.HasValue)
        SQLiteMarshal.WriteDouble(pIndex, offset10, outputs.EstimatedCost.GetValueOrDefault());
      int offset11 = SQLiteMarshal.NextOffsetOf(offset10, 8, 8);
      if (outputs.CanUseEstimatedRows() && outputs.EstimatedRows.HasValue)
        SQLiteMarshal.WriteInt64(pIndex, offset11, outputs.EstimatedRows.GetValueOrDefault());
      int offset12 = SQLiteMarshal.NextOffsetOf(offset11, 8, 4);
      if (outputs.CanUseIndexFlags() && outputs.IndexFlags.HasValue)
        SQLiteMarshal.WriteInt32(pIndex, offset12, (int) outputs.IndexFlags.GetValueOrDefault());
      int offset13 = SQLiteMarshal.NextOffsetOf(offset12, 4, 8);
      if (!outputs.CanUseColumnsUsed() || !outputs.ColumnsUsed.HasValue)
        return;
      SQLiteMarshal.WriteInt64(pIndex, offset13, outputs.ColumnsUsed.GetValueOrDefault());
    }

    public SQLiteIndexInputs Inputs => this.inputs;

    public SQLiteIndexOutputs Outputs => this.outputs;
  }
}


--- SQLiteIndexConstraint.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteIndexConstraint
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteIndexConstraint
  {
    public int iColumn;
    public SQLiteIndexConstraintOp op;
    public byte usable;
    public int iTermOffset;

    internal SQLiteIndexConstraint(
      UnsafeNativeMethods.sqlite3_index_constraint constraint)
      : this(constraint.iColumn, constraint.op, constraint.usable, constraint.iTermOffset)
    {
    }

    private SQLiteIndexConstraint(
      int iColumn,
      SQLiteIndexConstraintOp op,
      byte usable,
      int iTermOffset)
    {
      this.iColumn = iColumn;
      this.op = op;
      this.usable = usable;
      this.iTermOffset = iTermOffset;
    }
  }
}


--- SQLiteIndexConstraintOp.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteIndexConstraintOp
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum SQLiteIndexConstraintOp : byte
  {
    EqualTo = 2,
    GreaterThan = 4,
    LessThanOrEqualTo = 8,
    LessThan = 16, // 0x10
    GreaterThanOrEqualTo = 32, // 0x20
    Match = 64, // 0x40
    Like = 65, // 0x41
    Glob = 66, // 0x42
    Regexp = 67, // 0x43
  }
}


--- SQLiteIndexConstraintUsage.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteIndexConstraintUsage
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteIndexConstraintUsage
  {
    public int argvIndex;
    public byte omit;

    internal SQLiteIndexConstraintUsage()
    {
    }

    internal SQLiteIndexConstraintUsage(
      UnsafeNativeMethods.sqlite3_index_constraint_usage constraintUsage)
      : this(constraintUsage.argvIndex, constraintUsage.omit)
    {
    }

    private SQLiteIndexConstraintUsage(int argvIndex, byte omit)
    {
      this.argvIndex = argvIndex;
      this.omit = omit;
    }
  }
}


--- SQLiteIndexFlags.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteIndexFlags
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  [Flags]
  public enum SQLiteIndexFlags
  {
    None = 0,
    ScanUnique = 1,
  }
}


--- SQLiteIndexInputs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteIndexInputs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteIndexInputs
  {
    private SQLiteIndexConstraint[] constraints;
    private SQLiteIndexOrderBy[] orderBys;

    internal SQLiteIndexInputs(int nConstraint, int nOrderBy)
    {
      this.constraints = new SQLiteIndexConstraint[nConstraint];
      this.orderBys = new SQLiteIndexOrderBy[nOrderBy];
    }

    public SQLiteIndexConstraint[] Constraints => this.constraints;

    public SQLiteIndexOrderBy[] OrderBys => this.orderBys;
  }
}


--- SQLiteIndexOrderBy.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteIndexOrderBy
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteIndexOrderBy
  {
    public int iColumn;
    public byte desc;

    internal SQLiteIndexOrderBy(UnsafeNativeMethods.sqlite3_index_orderby orderBy)
      : this(orderBy.iColumn, orderBy.desc)
    {
    }

    private SQLiteIndexOrderBy(int iColumn, byte desc)
    {
      this.iColumn = iColumn;
      this.desc = desc;
    }
  }
}


--- SQLiteIndexOutputs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteIndexOutputs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteIndexOutputs
  {
    private SQLiteIndexConstraintUsage[] constraintUsages;
    private int indexNumber;
    private string indexString;
    private int needToFreeIndexString;
    private int orderByConsumed;
    private double? estimatedCost;
    private long? estimatedRows;
    private SQLiteIndexFlags? indexFlags;
    private long? columnsUsed;

    internal SQLiteIndexOutputs(int nConstraint)
    {
      this.constraintUsages = new SQLiteIndexConstraintUsage[nConstraint];
      for (int index = 0; index < nConstraint; ++index)
        this.constraintUsages[index] = new SQLiteIndexConstraintUsage();
    }

    public bool CanUseEstimatedRows() => UnsafeNativeMethods.sqlite3_libversion_number() >= 3008002;

    public bool CanUseIndexFlags() => UnsafeNativeMethods.sqlite3_libversion_number() >= 3009000;

    public bool CanUseColumnsUsed() => UnsafeNativeMethods.sqlite3_libversion_number() >= 3010000;

    public SQLiteIndexConstraintUsage[] ConstraintUsages => this.constraintUsages;

    public int IndexNumber
    {
      get => this.indexNumber;
      set => this.indexNumber = value;
    }

    public string IndexString
    {
      get => this.indexString;
      set => this.indexString = value;
    }

    public int NeedToFreeIndexString
    {
      get => this.needToFreeIndexString;
      set => this.needToFreeIndexString = value;
    }

    public int OrderByConsumed
    {
      get => this.orderByConsumed;
      set => this.orderByConsumed = value;
    }

    public double? EstimatedCost
    {
      get => this.estimatedCost;
      set => this.estimatedCost = value;
    }

    public long? EstimatedRows
    {
      get => this.estimatedRows;
      set => this.estimatedRows = value;
    }

    public SQLiteIndexFlags? IndexFlags
    {
      get => this.indexFlags;
      set => this.indexFlags = value;
    }

    public long? ColumnsUsed
    {
      get => this.columnsUsed;
      set => this.columnsUsed = value;
    }
  }
}


--- SQLiteInvokeDelegate.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteInvokeDelegate
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate object SQLiteInvokeDelegate(string param0, object[] args);
}


--- SQLiteJournalModeEnum.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteJournalModeEnum
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum SQLiteJournalModeEnum
  {
    Default = -1, // 0xFFFFFFFF
    Delete = 0,
    Persist = 1,
    Off = 2,
    Truncate = 3,
    Memory = 4,
    Wal = 5,
  }
}


--- SQLiteKeyReader.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteKeyReader
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;
using System.Data.Common;
using System.Globalization;

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLiteKeyReader : IDisposable
  {
    private SQLiteKeyReader.KeyInfo[] _keyInfo;
    private SQLiteStatement _stmt;
    private bool _isValid;
    private SQLiteKeyReader.RowIdInfo[] _rowIdInfo;
    private bool disposed;

    internal SQLiteKeyReader(SQLiteConnection cnn, SQLiteDataReader reader, SQLiteStatement stmt)
    {
      Dictionary<string, int> dictionary1 = new Dictionary<string, int>();
      Dictionary<string, List<string>> dictionary2 = new Dictionary<string, List<string>>();
      List<SQLiteKeyReader.KeyInfo> keyInfoList = new List<SQLiteKeyReader.KeyInfo>();
      List<SQLiteKeyReader.RowIdInfo> rowIdInfoList = new List<SQLiteKeyReader.RowIdInfo>();
      this._stmt = stmt;
      using (DataTable schema = cnn.GetSchema("Catalogs"))
      {
        foreach (DataRow row in (InternalDataCollectionBase) schema.Rows)
          dictionary1.Add((string) row["CATALOG_NAME"], Convert.ToInt32(row["ID"], (IFormatProvider) CultureInfo.InvariantCulture));
      }
      using (DataTable schemaTable = reader.GetSchemaTable(false, false))
      {
        foreach (DataRow row in (InternalDataCollectionBase) schemaTable.Rows)
        {
          if (row[SchemaTableOptionalColumn.BaseCatalogName] != DBNull.Value)
          {
            string key = (string) row[SchemaTableOptionalColumn.BaseCatalogName];
            string str = (string) row[SchemaTableColumn.BaseTableName];
            List<string> stringList;
            if (!dictionary2.ContainsKey(key))
            {
              stringList = new List<string>();
              dictionary2.Add(key, stringList);
            }
            else
              stringList = dictionary2[key];
            if (!stringList.Contains(str))
              stringList.Add(str);
          }
        }
        foreach (KeyValuePair<string, List<string>> keyValuePair in dictionary2)
        {
          for (int index1 = 0; index1 < keyValuePair.Value.Count; ++index1)
          {
            string table = keyValuePair.Value[index1];
            DataRow dataRow = (DataRow) null;
            using (DataTable schema1 = cnn.GetSchema("Indexes", new string[3]
            {
              keyValuePair.Key,
              null,
              table
            }))
            {
              for (int index2 = 0; index2 < 2 && dataRow == null; ++index2)
              {
                foreach (DataRow row in (InternalDataCollectionBase) schema1.Rows)
                {
                  if (index2 == 0 && (bool) row["PRIMARY_KEY"])
                  {
                    dataRow = row;
                    break;
                  }
                  if (index2 == 1 && (bool) row["UNIQUE"])
                  {
                    dataRow = row;
                    break;
                  }
                }
              }
              if (dataRow == null)
              {
                keyValuePair.Value.RemoveAt(index1);
                --index1;
              }
              else
              {
                using (DataTable schema2 = cnn.GetSchema("Tables", new string[3]
                {
                  keyValuePair.Key,
                  null,
                  table
                }))
                {
                  int database = dictionary1[keyValuePair.Key];
                  int int32 = Convert.ToInt32(schema2.Rows[0]["TABLE_ROOTPAGE"], (IFormatProvider) CultureInfo.InvariantCulture);
                  int cursorForTable = stmt._sql.GetCursorForTable(stmt, database, int32);
                  using (DataTable schema3 = cnn.GetSchema("IndexColumns", new string[4]
                  {
                    keyValuePair.Key,
                    null,
                    table,
                    (string) dataRow["INDEX_NAME"]
                  }))
                  {
                    bool flag1 = (string) dataRow["INDEX_NAME"] == "sqlite_master_PK_" + table;
                    SQLiteKeyReader.KeyQuery keyQuery = (SQLiteKeyReader.KeyQuery) null;
                    List<string> stringList = new List<string>();
                    for (int index3 = 0; index3 < schema3.Rows.Count; ++index3)
                    {
                      string stringOrNull = SQLiteConvert.GetStringOrNull(schema3.Rows[index3]["COLUMN_NAME"]);
                      bool flag2 = true;
                      foreach (DataRow row in (InternalDataCollectionBase) schemaTable.Rows)
                      {
                        if (!row.IsNull(SchemaTableColumn.BaseColumnName) && (string) row[SchemaTableColumn.BaseColumnName] == stringOrNull && (string) row[SchemaTableColumn.BaseTableName] == table && (string) row[SchemaTableOptionalColumn.BaseCatalogName] == keyValuePair.Key)
                        {
                          if (flag1)
                            rowIdInfoList.Add(new SQLiteKeyReader.RowIdInfo()
                            {
                              databaseName = keyValuePair.Key,
                              tableName = table,
                              column = (int) row[SchemaTableColumn.ColumnOrdinal]
                            });
                          schema3.Rows.RemoveAt(index3);
                          --index3;
                          flag2 = false;
                          break;
                        }
                      }
                      if (flag2)
                        stringList.Add(stringOrNull);
                    }
                    if (!flag1 && stringList.Count > 0)
                    {
                      string[] array = new string[stringList.Count];
                      stringList.CopyTo(array);
                      keyQuery = new SQLiteKeyReader.KeyQuery(cnn, keyValuePair.Key, table, array);
                    }
                    for (int index4 = 0; index4 < schema3.Rows.Count; ++index4)
                    {
                      string stringOrNull = SQLiteConvert.GetStringOrNull(schema3.Rows[index4]["COLUMN_NAME"]);
                      keyInfoList.Add(new SQLiteKeyReader.KeyInfo()
                      {
                        rootPage = int32,
                        cursor = cursorForTable,
                        database = database,
                        databaseName = keyValuePair.Key,
                        tableName = table,
                        columnName = stringOrNull,
                        query = keyQuery,
                        column = index4
                      });
                    }
                  }
                }
              }
            }
          }
        }
      }
      this._keyInfo = new SQLiteKeyReader.KeyInfo[keyInfoList.Count];
      keyInfoList.CopyTo(this._keyInfo);
      this._rowIdInfo = new SQLiteKeyReader.RowIdInfo[rowIdInfoList.Count];
      rowIdInfoList.CopyTo(this._rowIdInfo);
    }

    internal int GetRowIdIndex(string databaseName, string tableName)
    {
      if (this._rowIdInfo != null && databaseName != null && tableName != null)
      {
        for (int index = 0; index < this._rowIdInfo.Length; ++index)
        {
          if (this._rowIdInfo[index].databaseName == databaseName && this._rowIdInfo[index].tableName == tableName)
            return this._rowIdInfo[index].column;
        }
      }
      return -1;
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteKeyReader).Name);
    }

    private void Dispose(bool disposing)
    {
      if (this.disposed)
        return;
      if (disposing)
      {
        this._stmt = (SQLiteStatement) null;
        if (this._keyInfo != null)
        {
          for (int index = 0; index < this._keyInfo.Length; ++index)
          {
            if (this._keyInfo[index].query != null)
              this._keyInfo[index].query.Dispose();
          }
          this._keyInfo = (SQLiteKeyReader.KeyInfo[]) null;
        }
      }
      this.disposed = true;
    }

    ~SQLiteKeyReader() => this.Dispose(false);

    internal int Count => this._keyInfo != null ? this._keyInfo.Length : 0;

    internal void Sync(int i)
    {
      this.Sync();
      if (this._keyInfo[i].cursor == -1)
        throw new InvalidCastException();
    }

    internal void Sync()
    {
      if (this._isValid)
        return;
      SQLiteKeyReader.KeyQuery keyQuery = (SQLiteKeyReader.KeyQuery) null;
      for (int index = 0; index < this._keyInfo.Length; ++index)
      {
        if (this._keyInfo[index].query == null || this._keyInfo[index].query != keyQuery)
        {
          keyQuery = this._keyInfo[index].query;
          keyQuery?.Sync(this._stmt._sql.GetRowIdForCursor(this._stmt, this._keyInfo[index].cursor));
        }
      }
      this._isValid = true;
    }

    internal void Reset()
    {
      this._isValid = false;
      if (this._keyInfo == null)
        return;
      for (int index = 0; index < this._keyInfo.Length; ++index)
      {
        if (this._keyInfo[index].query != null)
          this._keyInfo[index].query.IsValid = false;
      }
    }

    internal string GetDataTypeName(int i)
    {
      this.Sync();
      return this._keyInfo[i].query != null ? this._keyInfo[i].query._reader.GetDataTypeName(this._keyInfo[i].column) : "integer";
    }

    internal Type GetFieldType(int i)
    {
      this.Sync();
      return this._keyInfo[i].query != null ? this._keyInfo[i].query._reader.GetFieldType(this._keyInfo[i].column) : typeof (long);
    }

    internal string GetName(int i) => this._keyInfo[i].columnName;

    internal int GetOrdinal(string name)
    {
      for (int ordinal = 0; ordinal < this._keyInfo.Length; ++ordinal)
      {
        if (string.Compare(name, this._keyInfo[ordinal].columnName, StringComparison.OrdinalIgnoreCase) == 0)
          return ordinal;
      }
      return -1;
    }

    internal SQLiteBlob GetBlob(int i, bool readOnly)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetBlob(this._keyInfo[i].column, readOnly);
      throw new InvalidCastException();
    }

    internal bool GetBoolean(int i)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetBoolean(this._keyInfo[i].column);
      throw new InvalidCastException();
    }

    internal byte GetByte(int i)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetByte(this._keyInfo[i].column);
      throw new InvalidCastException();
    }

    internal long GetBytes(int i, long fieldOffset, byte[] buffer, int bufferoffset, int length)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetBytes(this._keyInfo[i].column, fieldOffset, buffer, bufferoffset, length);
      throw new InvalidCastException();
    }

    internal char GetChar(int i)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetChar(this._keyInfo[i].column);
      throw new InvalidCastException();
    }

    internal long GetChars(int i, long fieldOffset, char[] buffer, int bufferoffset, int length)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetChars(this._keyInfo[i].column, fieldOffset, buffer, bufferoffset, length);
      throw new InvalidCastException();
    }

    internal DateTime GetDateTime(int i)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetDateTime(this._keyInfo[i].column);
      throw new InvalidCastException();
    }

    internal Decimal GetDecimal(int i)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetDecimal(this._keyInfo[i].column);
      throw new InvalidCastException();
    }

    internal double GetDouble(int i)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetDouble(this._keyInfo[i].column);
      throw new InvalidCastException();
    }

    internal float GetFloat(int i)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetFloat(this._keyInfo[i].column);
      throw new InvalidCastException();
    }

    internal Guid GetGuid(int i)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetGuid(this._keyInfo[i].column);
      throw new InvalidCastException();
    }

    internal short GetInt16(int i)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetInt16(this._keyInfo[i].column);
      long rowIdForCursor = this._stmt._sql.GetRowIdForCursor(this._stmt, this._keyInfo[i].cursor);
      return rowIdForCursor != 0L ? Convert.ToInt16(rowIdForCursor) : throw new InvalidCastException();
    }

    internal int GetInt32(int i)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetInt32(this._keyInfo[i].column);
      long rowIdForCursor = this._stmt._sql.GetRowIdForCursor(this._stmt, this._keyInfo[i].cursor);
      return rowIdForCursor != 0L ? Convert.ToInt32(rowIdForCursor) : throw new InvalidCastException();
    }

    internal long GetInt64(int i)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetInt64(this._keyInfo[i].column);
      long rowIdForCursor = this._stmt._sql.GetRowIdForCursor(this._stmt, this._keyInfo[i].cursor);
      return rowIdForCursor != 0L ? rowIdForCursor : throw new InvalidCastException();
    }

    internal string GetString(int i)
    {
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetString(this._keyInfo[i].column);
      throw new InvalidCastException();
    }

    internal object GetValue(int i)
    {
      if (this._keyInfo[i].cursor == -1)
        return (object) DBNull.Value;
      this.Sync(i);
      if (this._keyInfo[i].query != null)
        return this._keyInfo[i].query._reader.GetValue(this._keyInfo[i].column);
      return this.IsDBNull(i) ? (object) DBNull.Value : (object) this.GetInt64(i);
    }

    internal bool IsDBNull(int i)
    {
      if (this._keyInfo[i].cursor == -1)
        return true;
      this.Sync(i);
      return this._keyInfo[i].query != null ? this._keyInfo[i].query._reader.IsDBNull(this._keyInfo[i].column) : this._stmt._sql.GetRowIdForCursor(this._stmt, this._keyInfo[i].cursor) == 0L;
    }

    internal void AppendSchemaTable(DataTable tbl)
    {
      SQLiteKeyReader.KeyQuery keyQuery = (SQLiteKeyReader.KeyQuery) null;
      for (int index = 0; index < this._keyInfo.Length; ++index)
      {
        if (this._keyInfo[index].query == null || this._keyInfo[index].query != keyQuery)
        {
          keyQuery = this._keyInfo[index].query;
          if (keyQuery == null)
          {
            DataRow row = tbl.NewRow();
            row[SchemaTableColumn.ColumnName] = (object) this._keyInfo[index].columnName;
            row[SchemaTableColumn.ColumnOrdinal] = (object) tbl.Rows.Count;
            row[SchemaTableColumn.ColumnSize] = (object) 8;
            row[SchemaTableColumn.NumericPrecision] = (object) (int) byte.MaxValue;
            row[SchemaTableColumn.NumericScale] = (object) (int) byte.MaxValue;
            row[SchemaTableColumn.ProviderType] = (object) DbType.Int64;
            row[SchemaTableColumn.IsLong] = (object) false;
            row[SchemaTableColumn.AllowDBNull] = (object) false;
            row[SchemaTableOptionalColumn.IsReadOnly] = (object) false;
            row[SchemaTableOptionalColumn.IsRowVersion] = (object) false;
            row[SchemaTableColumn.IsUnique] = (object) false;
            row[SchemaTableColumn.IsKey] = (object) true;
            row[SchemaTableColumn.DataType] = (object) typeof (long);
            row[SchemaTableOptionalColumn.IsHidden] = (object) true;
            row[SchemaTableColumn.BaseColumnName] = (object) this._keyInfo[index].columnName;
            row[SchemaTableColumn.IsExpression] = (object) false;
            row[SchemaTableColumn.IsAliased] = (object) false;
            row[SchemaTableColumn.BaseTableName] = (object) this._keyInfo[index].tableName;
            row[SchemaTableOptionalColumn.BaseCatalogName] = (object) this._keyInfo[index].databaseName;
            row[SchemaTableOptionalColumn.IsAutoIncrement] = (object) true;
            row["DataTypeName"] = (object) "integer";
            tbl.Rows.Add(row);
          }
          else
          {
            keyQuery.Sync(0L);
            using (DataTable schemaTable = keyQuery._reader.GetSchemaTable())
            {
              foreach (DataRow row in (InternalDataCollectionBase) schemaTable.Rows)
              {
                object[] itemArray = row.ItemArray;
                DataRow dataRow = tbl.Rows.Add(itemArray);
                dataRow[SchemaTableOptionalColumn.IsHidden] = (object) true;
                dataRow[SchemaTableColumn.ColumnOrdinal] = (object) (tbl.Rows.Count - 1);
              }
            }
          }
        }
      }
    }

    private struct KeyInfo
    {
      internal string databaseName;
      internal string tableName;
      internal string columnName;
      internal int database;
      internal int rootPage;
      internal int cursor;
      internal SQLiteKeyReader.KeyQuery query;
      internal int column;
    }

    private struct RowIdInfo
    {
      internal string databaseName;
      internal string tableName;
      internal int column;
    }

    private sealed class KeyQuery : IDisposable
    {
      private SQLiteCommand _command;
      internal SQLiteDataReader _reader;
      private bool disposed;

      internal KeyQuery(
        SQLiteConnection cnn,
        string database,
        string table,
        params string[] columns)
      {
        using (SQLiteCommandBuilder liteCommandBuilder = new SQLiteCommandBuilder())
        {
          this._command = cnn.CreateCommand();
          for (int index = 0; index < columns.Length; ++index)
            columns[index] = liteCommandBuilder.QuoteIdentifier(columns[index]);
        }
        this._command.CommandText = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "SELECT {0} FROM [{1}].[{2}] WHERE ROWID = ?", (object) string.Join(",", columns), (object) database, (object) table);
        this._command.Parameters.AddWithValue((string) null, (object) 0L);
      }

      internal bool IsValid
      {
        set
        {
          if (value)
            throw new ArgumentException();
          if (this._reader == null)
            return;
          this._reader.Dispose();
          this._reader = (SQLiteDataReader) null;
        }
      }

      internal void Sync(long rowid)
      {
        this.IsValid = false;
        this._command.Parameters[0].Value = (object) rowid;
        this._reader = this._command.ExecuteReader();
        this._reader.Read();
      }

      public void Dispose()
      {
        this.Dispose(true);
        GC.SuppressFinalize((object) this);
      }

      private void CheckDisposed()
      {
        if (this.disposed)
          throw new ObjectDisposedException(typeof (SQLiteKeyReader.KeyQuery).Name);
      }

      private void Dispose(bool disposing)
      {
        if (this.disposed)
          return;
        if (disposing)
        {
          this.IsValid = false;
          if (this._command != null)
            this._command.Dispose();
          this._command = (SQLiteCommand) null;
        }
        this.disposed = true;
      }

      ~KeyQuery() => this.Dispose(false);
    }
  }
}


--- SQLiteLog.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteLog
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Diagnostics;
using System.Globalization;

#nullable disable
namespace System.Data.SQLite
{
  public static class SQLiteLog
  {
    private static object syncRoot = new object();
    private static EventHandler _domainUnload;
    private static SQLiteLogEventHandler _defaultHandler;
    private static SQLiteLogCallback _callback;
    private static SQLiteBase _sql;
    private static bool _enabled;

    private static event SQLiteLogEventHandler _handlers;

    public static void Initialize()
    {
      if (SQLite3.StaticIsInitialized() || !AppDomain.CurrentDomain.IsDefaultAppDomain() && UnsafeNativeMethods.GetSettingValue("Force_SQLiteLog", (string) null) == null)
        return;
      lock (SQLiteLog.syncRoot)
      {
        if (SQLiteLog._domainUnload == null)
        {
          SQLiteLog._domainUnload = new EventHandler(SQLiteLog.DomainUnload);
          AppDomain.CurrentDomain.DomainUnload += SQLiteLog._domainUnload;
        }
        if (SQLiteLog._sql == null)
          SQLiteLog._sql = (SQLiteBase) new SQLite3(SQLiteDateFormats.ISO8601, DateTimeKind.Unspecified, (string) null, IntPtr.Zero, (string) null, false);
        if (SQLiteLog._callback == null)
        {
          SQLiteLog._callback = new SQLiteLogCallback(SQLiteLog.LogCallback);
          SQLiteErrorCode errorCode = SQLiteLog._sql.SetLogCallback(SQLiteLog._callback);
          if (errorCode != SQLiteErrorCode.Ok)
            throw new SQLiteException(errorCode, "Failed to initialize logging.");
        }
        SQLiteLog._enabled = true;
        SQLiteLog.AddDefaultHandler();
      }
    }

    private static void DomainUnload(object sender, EventArgs e)
    {
      lock (SQLiteLog.syncRoot)
      {
        SQLiteLog.RemoveDefaultHandler();
        SQLiteLog._enabled = false;
        if (SQLiteLog._sql != null)
        {
          SQLiteErrorCode errorCode1 = SQLiteLog._sql.Shutdown();
          if (errorCode1 != SQLiteErrorCode.Ok)
            throw new SQLiteException(errorCode1, "Failed to shutdown interface.");
          SQLiteErrorCode errorCode2 = SQLiteLog._sql.SetLogCallback((SQLiteLogCallback) null);
          if (errorCode2 != SQLiteErrorCode.Ok)
            throw new SQLiteException(errorCode2, "Failed to shutdown logging.");
        }
        if (SQLiteLog._callback != null)
          SQLiteLog._callback = (SQLiteLogCallback) null;
        if (SQLiteLog._domainUnload == null)
          return;
        AppDomain.CurrentDomain.DomainUnload -= SQLiteLog._domainUnload;
        SQLiteLog._domainUnload = (EventHandler) null;
      }
    }

    public static event SQLiteLogEventHandler Log
    {
      add
      {
        lock (SQLiteLog.syncRoot)
        {
          SQLiteLog._handlers -= value;
          SQLiteLog._handlers += value;
        }
      }
      remove
      {
        lock (SQLiteLog.syncRoot)
          SQLiteLog._handlers -= value;
      }
    }

    public static bool Enabled
    {
      get
      {
        lock (SQLiteLog.syncRoot)
          return SQLiteLog._enabled;
      }
      set
      {
        lock (SQLiteLog.syncRoot)
          SQLiteLog._enabled = value;
      }
    }

    public static void LogMessage(string message) => SQLiteLog.LogMessage((object) null, message);

    public static void LogMessage(SQLiteErrorCode errorCode, string message)
    {
      SQLiteLog.LogMessage((object) errorCode, message);
    }

    public static void LogMessage(int errorCode, string message)
    {
      SQLiteLog.LogMessage((object) errorCode, message);
    }

    private static void LogMessage(object errorCode, string message)
    {
      bool enabled;
      SQLiteLogEventHandler liteLogEventHandler;
      lock (SQLiteLog.syncRoot)
      {
        enabled = SQLiteLog._enabled;
        liteLogEventHandler = SQLiteLog._handlers == null ? (SQLiteLogEventHandler) null : SQLiteLog._handlers.Clone() as SQLiteLogEventHandler;
      }
      if (!enabled || liteLogEventHandler == null)
        return;
      liteLogEventHandler((object) null, new LogEventArgs(IntPtr.Zero, errorCode, message, (object) null));
    }

    private static void InitializeDefaultHandler()
    {
      lock (SQLiteLog.syncRoot)
      {
        if (SQLiteLog._defaultHandler != null)
          return;
        SQLiteLog._defaultHandler = new SQLiteLogEventHandler(SQLiteLog.LogEventHandler);
      }
    }

    public static void AddDefaultHandler()
    {
      SQLiteLog.InitializeDefaultHandler();
      SQLiteLog.Log += SQLiteLog._defaultHandler;
    }

    public static void RemoveDefaultHandler()
    {
      SQLiteLog.InitializeDefaultHandler();
      SQLiteLog.Log -= SQLiteLog._defaultHandler;
    }

    private static void LogCallback(IntPtr pUserData, int errorCode, IntPtr pMessage)
    {
      bool enabled;
      SQLiteLogEventHandler liteLogEventHandler;
      lock (SQLiteLog.syncRoot)
      {
        enabled = SQLiteLog._enabled;
        liteLogEventHandler = SQLiteLog._handlers == null ? (SQLiteLogEventHandler) null : SQLiteLog._handlers.Clone() as SQLiteLogEventHandler;
      }
      if (!enabled || liteLogEventHandler == null)
        return;
      liteLogEventHandler((object) null, new LogEventArgs(pUserData, (object) errorCode, SQLiteConvert.UTF8ToString(pMessage, -1), (object) null));
    }

    private static void LogEventHandler(object sender, LogEventArgs e)
    {
      if (e == null)
        return;
      string message = e.Message;
      string str1;
      if (message == null)
      {
        str1 = "<null>";
      }
      else
      {
        str1 = message.Trim();
        if (str1.Length == 0)
          str1 = "<empty>";
      }
      object errorCode = e.ErrorCode;
      string str2 = "error";
      if (errorCode is SQLiteErrorCode || errorCode is int)
      {
        switch ((SQLiteErrorCode) ((int) errorCode & (int) byte.MaxValue))
        {
          case SQLiteErrorCode.Ok:
            str2 = "message";
            break;
          case SQLiteErrorCode.Notice:
            str2 = "notice";
            break;
          case SQLiteErrorCode.Warning:
            str2 = "warning";
            break;
          case SQLiteErrorCode.Row:
          case SQLiteErrorCode.Done:
            str2 = "data";
            break;
        }
      }
      else if (errorCode == null)
        str2 = "trace";
      if (errorCode != null && !object.ReferenceEquals(errorCode, (object) string.Empty))
        Trace.WriteLine(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "SQLite {0} ({1}): {2}", (object) str2, errorCode, (object) str1));
      else
        Trace.WriteLine(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "SQLite {0}: {1}", (object) str2, (object) str1));
    }
  }
}


--- SQLiteLogCallback.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteLogCallback
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  internal delegate void SQLiteLogCallback(IntPtr pUserData, int errorCode, IntPtr pMessage);
}


--- SQLiteLogEventHandler.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteLogEventHandler
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate void SQLiteLogEventHandler(object sender, LogEventArgs e);
}


--- SQLiteMarshal.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteMarshal
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  internal static class SQLiteMarshal
  {
    public static IntPtr IntPtrForOffset(IntPtr pointer, int offset)
    {
      return new IntPtr(pointer.ToInt64() + (long) offset);
    }

    public static int RoundUp(int size, int alignment)
    {
      int num = alignment - 1;
      return size + num & ~num;
    }

    public static int NextOffsetOf(int offset, int size, int alignment)
    {
      return SQLiteMarshal.RoundUp(offset + size, alignment);
    }

    public static int ReadInt32(IntPtr pointer, int offset) => Marshal.ReadInt32(pointer, offset);

    public static long ReadInt64(IntPtr pointer, int offset) => Marshal.ReadInt64(pointer, offset);

    public static double ReadDouble(IntPtr pointer, int offset)
    {
      return BitConverter.Int64BitsToDouble(Marshal.ReadInt64(pointer, offset));
    }

    public static IntPtr ReadIntPtr(IntPtr pointer, int offset)
    {
      return Marshal.ReadIntPtr(pointer, offset);
    }

    public static void WriteInt32(IntPtr pointer, int offset, int value)
    {
      Marshal.WriteInt32(pointer, offset, value);
    }

    public static void WriteInt64(IntPtr pointer, int offset, long value)
    {
      Marshal.WriteInt64(pointer, offset, value);
    }

    public static void WriteDouble(IntPtr pointer, int offset, double value)
    {
      Marshal.WriteInt64(pointer, offset, BitConverter.DoubleToInt64Bits(value));
    }

    public static void WriteIntPtr(IntPtr pointer, int offset, IntPtr value)
    {
      Marshal.WriteIntPtr(pointer, offset, value);
    }

    public static int GetHashCode(object value, bool identity)
    {
      if (identity)
        return RuntimeHelpers.GetHashCode(value);
      return value == null ? 0 : value.GetHashCode();
    }
  }
}


--- SQLiteMemory.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteMemory
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  internal static class SQLiteMemory
  {
    public static IntPtr Allocate(int size) => UnsafeNativeMethods.sqlite3_malloc(size);

    public static int Size(IntPtr pMemory)
    {
      return UnsafeNativeMethods.sqlite3_malloc_size_interop(pMemory);
    }

    public static void Free(IntPtr pMemory) => UnsafeNativeMethods.sqlite3_free(pMemory);
  }
}


--- SQLiteMetaDataCollectionNames.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteMetaDataCollectionNames
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public static class SQLiteMetaDataCollectionNames
  {
    public static readonly string Catalogs = nameof (Catalogs);
    public static readonly string Columns = nameof (Columns);
    public static readonly string Indexes = nameof (Indexes);
    public static readonly string IndexColumns = nameof (IndexColumns);
    public static readonly string Tables = nameof (Tables);
    public static readonly string Views = nameof (Views);
    public static readonly string ViewColumns = nameof (ViewColumns);
    public static readonly string ForeignKeys = nameof (ForeignKeys);
    public static readonly string Triggers = nameof (Triggers);
  }
}


--- SQLiteModule.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteModule
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  public abstract class SQLiteModule : ISQLiteManagedModule, IDisposable
  {
    private static readonly int DefaultModuleVersion = 2;
    private UnsafeNativeMethods.sqlite3_module nativeModule;
    private UnsafeNativeMethods.xDestroyModule destroyModule;
    private IntPtr disposableModule;
    private Dictionary<IntPtr, SQLiteVirtualTable> tables;
    private Dictionary<IntPtr, SQLiteVirtualTableCursor> cursors;
    private Dictionary<string, SQLiteFunction> functions;
    private bool logErrors;
    private bool logExceptions;
    private bool declared;
    private string name;
    private bool disposed;

    public SQLiteModule(string name)
    {
      this.name = name != null ? name : throw new ArgumentNullException(nameof (name));
      this.tables = new Dictionary<IntPtr, SQLiteVirtualTable>();
      this.cursors = new Dictionary<IntPtr, SQLiteVirtualTableCursor>();
      this.functions = new Dictionary<string, SQLiteFunction>();
    }

    internal bool CreateDisposableModule(IntPtr pDb)
    {
      if (this.disposableModule != IntPtr.Zero)
        return true;
      IntPtr num = IntPtr.Zero;
      try
      {
        num = SQLiteString.Utf8IntPtrFromString(this.name);
        UnsafeNativeMethods.sqlite3_module module = this.AllocateNativeModule();
        this.destroyModule = new UnsafeNativeMethods.xDestroyModule(this.xDestroyModule);
        this.disposableModule = UnsafeNativeMethods.sqlite3_create_disposable_module(pDb, num, ref module, IntPtr.Zero, this.destroyModule);
        return this.disposableModule != IntPtr.Zero;
      }
      finally
      {
        if (num != IntPtr.Zero)
        {
          SQLiteMemory.Free(num);
          IntPtr zero = IntPtr.Zero;
        }
      }
    }

    private void xDestroyModule(IntPtr pClientData) => this.disposableModule = IntPtr.Zero;

    private UnsafeNativeMethods.sqlite3_module AllocateNativeModule()
    {
      return this.AllocateNativeModule(this.GetNativeModuleImpl());
    }

    private UnsafeNativeMethods.sqlite3_module AllocateNativeModule(ISQLiteNativeModule module)
    {
      this.nativeModule = new UnsafeNativeMethods.sqlite3_module();
      this.nativeModule.iVersion = SQLiteModule.DefaultModuleVersion;
      if (module != null)
      {
        this.nativeModule.xCreate = new UnsafeNativeMethods.xCreate(module.xCreate);
        this.nativeModule.xConnect = new UnsafeNativeMethods.xConnect(module.xConnect);
        this.nativeModule.xBestIndex = new UnsafeNativeMethods.xBestIndex(module.xBestIndex);
        this.nativeModule.xDisconnect = new UnsafeNativeMethods.xDisconnect(module.xDisconnect);
        this.nativeModule.xDestroy = new UnsafeNativeMethods.xDestroy(module.xDestroy);
        this.nativeModule.xOpen = new UnsafeNativeMethods.xOpen(module.xOpen);
        this.nativeModule.xClose = new UnsafeNativeMethods.xClose(module.xClose);
        this.nativeModule.xFilter = new UnsafeNativeMethods.xFilter(module.xFilter);
        this.nativeModule.xNext = new UnsafeNativeMethods.xNext(module.xNext);
        this.nativeModule.xEof = new UnsafeNativeMethods.xEof(module.xEof);
        this.nativeModule.xColumn = new UnsafeNativeMethods.xColumn(module.xColumn);
        this.nativeModule.xRowId = new UnsafeNativeMethods.xRowId(module.xRowId);
        this.nativeModule.xUpdate = new UnsafeNativeMethods.xUpdate(module.xUpdate);
        this.nativeModule.xBegin = new UnsafeNativeMethods.xBegin(module.xBegin);
        this.nativeModule.xSync = new UnsafeNativeMethods.xSync(module.xSync);
        this.nativeModule.xCommit = new UnsafeNativeMethods.xCommit(module.xCommit);
        this.nativeModule.xRollback = new UnsafeNativeMethods.xRollback(module.xRollback);
        this.nativeModule.xFindFunction = new UnsafeNativeMethods.xFindFunction(module.xFindFunction);
        this.nativeModule.xRename = new UnsafeNativeMethods.xRename(module.xRename);
        this.nativeModule.xSavepoint = new UnsafeNativeMethods.xSavepoint(module.xSavepoint);
        this.nativeModule.xRelease = new UnsafeNativeMethods.xRelease(module.xRelease);
        this.nativeModule.xRollbackTo = new UnsafeNativeMethods.xRollbackTo(module.xRollbackTo);
      }
      else
      {
        this.nativeModule.xCreate = new UnsafeNativeMethods.xCreate(this.xCreate);
        this.nativeModule.xConnect = new UnsafeNativeMethods.xConnect(this.xConnect);
        this.nativeModule.xBestIndex = new UnsafeNativeMethods.xBestIndex(this.xBestIndex);
        this.nativeModule.xDisconnect = new UnsafeNativeMethods.xDisconnect(this.xDisconnect);
        this.nativeModule.xDestroy = new UnsafeNativeMethods.xDestroy(this.xDestroy);
        this.nativeModule.xOpen = new UnsafeNativeMethods.xOpen(this.xOpen);
        this.nativeModule.xClose = new UnsafeNativeMethods.xClose(this.xClose);
        this.nativeModule.xFilter = new UnsafeNativeMethods.xFilter(this.xFilter);
        this.nativeModule.xNext = new UnsafeNativeMethods.xNext(this.xNext);
        this.nativeModule.xEof = new UnsafeNativeMethods.xEof(this.xEof);
        this.nativeModule.xColumn = new UnsafeNativeMethods.xColumn(this.xColumn);
        this.nativeModule.xRowId = new UnsafeNativeMethods.xRowId(this.xRowId);
        this.nativeModule.xUpdate = new UnsafeNativeMethods.xUpdate(this.xUpdate);
        this.nativeModule.xBegin = new UnsafeNativeMethods.xBegin(this.xBegin);
        this.nativeModule.xSync = new UnsafeNativeMethods.xSync(this.xSync);
        this.nativeModule.xCommit = new UnsafeNativeMethods.xCommit(this.xCommit);
        this.nativeModule.xRollback = new UnsafeNativeMethods.xRollback(this.xRollback);
        this.nativeModule.xFindFunction = new UnsafeNativeMethods.xFindFunction(this.xFindFunction);
        this.nativeModule.xRename = new UnsafeNativeMethods.xRename(this.xRename);
        this.nativeModule.xSavepoint = new UnsafeNativeMethods.xSavepoint(this.xSavepoint);
        this.nativeModule.xRelease = new UnsafeNativeMethods.xRelease(this.xRelease);
        this.nativeModule.xRollbackTo = new UnsafeNativeMethods.xRollbackTo(this.xRollbackTo);
      }
      return this.nativeModule;
    }

    private UnsafeNativeMethods.sqlite3_module CopyNativeModule(
      UnsafeNativeMethods.sqlite3_module module)
    {
      return new UnsafeNativeMethods.sqlite3_module()
      {
        iVersion = module.iVersion,
        xCreate = new UnsafeNativeMethods.xCreate((module.xCreate != null ? module.xCreate : new UnsafeNativeMethods.xCreate(this.xCreate)).Invoke),
        xConnect = new UnsafeNativeMethods.xConnect((module.xConnect != null ? module.xConnect : new UnsafeNativeMethods.xConnect(this.xConnect)).Invoke),
        xBestIndex = new UnsafeNativeMethods.xBestIndex((module.xBestIndex != null ? module.xBestIndex : new UnsafeNativeMethods.xBestIndex(this.xBestIndex)).Invoke),
        xDisconnect = new UnsafeNativeMethods.xDisconnect((module.xDisconnect != null ? module.xDisconnect : new UnsafeNativeMethods.xDisconnect(this.xDisconnect)).Invoke),
        xDestroy = new UnsafeNativeMethods.xDestroy((module.xDestroy != null ? module.xDestroy : new UnsafeNativeMethods.xDestroy(this.xDestroy)).Invoke),
        xOpen = new UnsafeNativeMethods.xOpen((module.xOpen != null ? module.xOpen : new UnsafeNativeMethods.xOpen(this.xOpen)).Invoke),
        xClose = new UnsafeNativeMethods.xClose((module.xClose != null ? module.xClose : new UnsafeNativeMethods.xClose(this.xClose)).Invoke),
        xFilter = new UnsafeNativeMethods.xFilter((module.xFilter != null ? module.xFilter : new UnsafeNativeMethods.xFilter(this.xFilter)).Invoke),
        xNext = new UnsafeNativeMethods.xNext((module.xNext != null ? module.xNext : new UnsafeNativeMethods.xNext(this.xNext)).Invoke),
        xEof = new UnsafeNativeMethods.xEof((module.xEof != null ? module.xEof : new UnsafeNativeMethods.xEof(this.xEof)).Invoke),
        xColumn = new UnsafeNativeMethods.xColumn((module.xColumn != null ? module.xColumn : new UnsafeNativeMethods.xColumn(this.xColumn)).Invoke),
        xRowId = new UnsafeNativeMethods.xRowId((module.xRowId != null ? module.xRowId : new UnsafeNativeMethods.xRowId(this.xRowId)).Invoke),
        xUpdate = new UnsafeNativeMethods.xUpdate((module.xUpdate != null ? module.xUpdate : new UnsafeNativeMethods.xUpdate(this.xUpdate)).Invoke),
        xBegin = new UnsafeNativeMethods.xBegin((module.xBegin != null ? module.xBegin : new UnsafeNativeMethods.xBegin(this.xBegin)).Invoke),
        xSync = new UnsafeNativeMethods.xSync((module.xSync != null ? module.xSync : new UnsafeNativeMethods.xSync(this.xSync)).Invoke),
        xCommit = new UnsafeNativeMethods.xCommit((module.xCommit != null ? module.xCommit : new UnsafeNativeMethods.xCommit(this.xCommit)).Invoke),
        xRollback = new UnsafeNativeMethods.xRollback((module.xRollback != null ? module.xRollback : new UnsafeNativeMethods.xRollback(this.xRollback)).Invoke),
        xFindFunction = new UnsafeNativeMethods.xFindFunction((module.xFindFunction != null ? module.xFindFunction : new UnsafeNativeMethods.xFindFunction(this.xFindFunction)).Invoke),
        xRename = new UnsafeNativeMethods.xRename((module.xRename != null ? module.xRename : new UnsafeNativeMethods.xRename(this.xRename)).Invoke),
        xSavepoint = new UnsafeNativeMethods.xSavepoint((module.xSavepoint != null ? module.xSavepoint : new UnsafeNativeMethods.xSavepoint(this.xSavepoint)).Invoke),
        xRelease = new UnsafeNativeMethods.xRelease((module.xRelease != null ? module.xRelease : new UnsafeNativeMethods.xRelease(this.xRelease)).Invoke),
        xRollbackTo = new UnsafeNativeMethods.xRollbackTo((module.xRollbackTo != null ? module.xRollbackTo : new UnsafeNativeMethods.xRollbackTo(this.xRollbackTo)).Invoke)
      };
    }

    private SQLiteErrorCode CreateOrConnect(
      bool create,
      IntPtr pDb,
      IntPtr pAux,
      int argc,
      IntPtr argv,
      ref IntPtr pVtab,
      ref IntPtr pError)
    {
      try
      {
        string fileName = SQLiteString.StringFromUtf8IntPtr(UnsafeNativeMethods.sqlite3_db_filename(pDb, IntPtr.Zero));
        using (SQLiteConnection connection = new SQLiteConnection(pDb, fileName, false))
        {
          SQLiteVirtualTable table = (SQLiteVirtualTable) null;
          string error = (string) null;
          if (create && this.Create(connection, pAux, SQLiteString.StringArrayFromUtf8SizeAndIntPtr(argc, argv), ref table, ref error) == SQLiteErrorCode.Ok || !create && this.Connect(connection, pAux, SQLiteString.StringArrayFromUtf8SizeAndIntPtr(argc, argv), ref table, ref error) == SQLiteErrorCode.Ok)
          {
            if (table != null)
            {
              pVtab = this.TableToIntPtr(table);
              return SQLiteErrorCode.Ok;
            }
            pError = SQLiteString.Utf8IntPtrFromString("no table was created");
          }
          else
            pError = SQLiteString.Utf8IntPtrFromString(error);
        }
      }
      catch (Exception ex)
      {
        pError = SQLiteString.Utf8IntPtrFromString(ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode DestroyOrDisconnect(bool destroy, IntPtr pVtab)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
        {
          if (!destroy || this.Destroy(table) != SQLiteErrorCode.Ok)
          {
            if (!destroy)
            {
              if (this.Disconnect(table) != SQLiteErrorCode.Ok)
                goto label_12;
            }
            else
              goto label_12;
          }
          if (this.tables != null)
            this.tables.Remove(pVtab);
          return SQLiteErrorCode.Ok;
        }
      }
      catch (Exception ex)
      {
        try
        {
          if (this.LogExceptionsNoThrow)
            SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"{0}\" method: {1}", destroy ? (object) "xDestroy" : (object) "xDisconnect", (object) ex));
        }
        catch
        {
        }
      }
      finally
      {
        this.FreeTable(pVtab);
      }
label_12:
      return SQLiteErrorCode.Error;
    }

    private static bool SetTableError(
      SQLiteModule module,
      IntPtr pVtab,
      bool logErrors,
      bool logExceptions,
      string error)
    {
      try
      {
        if (logErrors)
          SQLiteLog.LogMessage(SQLiteErrorCode.Error, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Virtual table error: {0}", (object) error));
      }
      catch
      {
      }
      bool flag = false;
      IntPtr pMemory1 = IntPtr.Zero;
      try
      {
        if (pVtab == IntPtr.Zero)
          return false;
        int offset = SQLiteMarshal.NextOffsetOf(SQLiteMarshal.NextOffsetOf(0, IntPtr.Size, 4), 4, IntPtr.Size);
        IntPtr pMemory2 = SQLiteMarshal.ReadIntPtr(pVtab, offset);
        if (pMemory2 != IntPtr.Zero)
        {
          SQLiteMemory.Free(pMemory2);
          IntPtr zero = IntPtr.Zero;
          SQLiteMarshal.WriteIntPtr(pVtab, offset, zero);
        }
        if (error == null)
          return true;
        pMemory1 = SQLiteString.Utf8IntPtrFromString(error);
        SQLiteMarshal.WriteIntPtr(pVtab, offset, pMemory1);
        flag = true;
      }
      catch (Exception ex)
      {
        try
        {
          if (logExceptions)
            SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"SetTableError\" method: {0}", (object) ex));
        }
        catch
        {
        }
      }
      finally
      {
        if (!flag && pMemory1 != IntPtr.Zero)
        {
          SQLiteMemory.Free(pMemory1);
          IntPtr zero = IntPtr.Zero;
        }
      }
      return flag;
    }

    private static bool SetTableError(
      SQLiteModule module,
      SQLiteVirtualTable table,
      bool logErrors,
      bool logExceptions,
      string error)
    {
      if (table == null)
        return false;
      IntPtr nativeHandle = table.NativeHandle;
      return !(nativeHandle == IntPtr.Zero) && SQLiteModule.SetTableError(module, nativeHandle, logErrors, logExceptions, error);
    }

    private static bool SetCursorError(
      SQLiteModule module,
      IntPtr pCursor,
      bool logErrors,
      bool logExceptions,
      string error)
    {
      if (pCursor == IntPtr.Zero)
        return false;
      IntPtr pVtab = SQLiteModule.TableFromCursor(module, pCursor);
      return !(pVtab == IntPtr.Zero) && SQLiteModule.SetTableError(module, pVtab, logErrors, logExceptions, error);
    }

    private static bool SetCursorError(
      SQLiteModule module,
      SQLiteVirtualTableCursor cursor,
      bool logErrors,
      bool logExceptions,
      string error)
    {
      if (cursor == null)
        return false;
      IntPtr nativeHandle = cursor.NativeHandle;
      return !(nativeHandle == IntPtr.Zero) && SQLiteModule.SetCursorError(module, nativeHandle, logErrors, logExceptions, error);
    }

    protected virtual ISQLiteNativeModule GetNativeModuleImpl() => (ISQLiteNativeModule) null;

    protected virtual ISQLiteNativeModule CreateNativeModuleImpl()
    {
      return (ISQLiteNativeModule) new SQLiteModule.SQLiteNativeModule(this);
    }

    protected virtual IntPtr AllocateTable()
    {
      return SQLiteMemory.Allocate(Marshal.SizeOf(typeof (UnsafeNativeMethods.sqlite3_vtab)));
    }

    protected virtual void ZeroTable(IntPtr pVtab)
    {
      if (pVtab == IntPtr.Zero)
        return;
      int offset1 = 0;
      SQLiteMarshal.WriteIntPtr(pVtab, offset1, IntPtr.Zero);
      int offset2 = SQLiteMarshal.NextOffsetOf(offset1, IntPtr.Size, 4);
      SQLiteMarshal.WriteInt32(pVtab, offset2, 0);
      int offset3 = SQLiteMarshal.NextOffsetOf(offset2, 4, IntPtr.Size);
      SQLiteMarshal.WriteIntPtr(pVtab, offset3, IntPtr.Zero);
    }

    protected virtual void FreeTable(IntPtr pVtab)
    {
      this.SetTableError(pVtab, (string) null);
      SQLiteMemory.Free(pVtab);
    }

    protected virtual IntPtr AllocateCursor()
    {
      return SQLiteMemory.Allocate(Marshal.SizeOf(typeof (UnsafeNativeMethods.sqlite3_vtab_cursor)));
    }

    protected virtual void FreeCursor(IntPtr pCursor) => SQLiteMemory.Free(pCursor);

    private static IntPtr TableFromCursor(SQLiteModule module, IntPtr pCursor)
    {
      return pCursor == IntPtr.Zero ? IntPtr.Zero : Marshal.ReadIntPtr(pCursor);
    }

    protected virtual IntPtr TableFromCursor(IntPtr pCursor)
    {
      return SQLiteModule.TableFromCursor(this, pCursor);
    }

    protected virtual SQLiteVirtualTable TableFromIntPtr(IntPtr pVtab)
    {
      if (pVtab == IntPtr.Zero)
      {
        this.SetTableError(pVtab, "invalid native table");
        return (SQLiteVirtualTable) null;
      }
      SQLiteVirtualTable liteVirtualTable;
      if (this.tables != null && this.tables.TryGetValue(pVtab, out liteVirtualTable))
        return liteVirtualTable;
      this.SetTableError(pVtab, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "managed table for {0} not found", (object) pVtab));
      return (SQLiteVirtualTable) null;
    }

    protected virtual IntPtr TableToIntPtr(SQLiteVirtualTable table)
    {
      if (table == null || this.tables == null)
        return IntPtr.Zero;
      IntPtr intPtr = IntPtr.Zero;
      bool flag = false;
      try
      {
        intPtr = this.AllocateTable();
        if (intPtr != IntPtr.Zero)
        {
          this.ZeroTable(intPtr);
          table.NativeHandle = intPtr;
          this.tables.Add(intPtr, table);
          flag = true;
        }
      }
      finally
      {
        if (!flag && intPtr != IntPtr.Zero)
        {
          this.FreeTable(intPtr);
          intPtr = IntPtr.Zero;
        }
      }
      return intPtr;
    }

    protected virtual SQLiteVirtualTableCursor CursorFromIntPtr(IntPtr pVtab, IntPtr pCursor)
    {
      if (pCursor == IntPtr.Zero)
      {
        this.SetTableError(pVtab, "invalid native cursor");
        return (SQLiteVirtualTableCursor) null;
      }
      SQLiteVirtualTableCursor virtualTableCursor;
      if (this.cursors != null && this.cursors.TryGetValue(pCursor, out virtualTableCursor))
        return virtualTableCursor;
      this.SetTableError(pVtab, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "managed cursor for {0} not found", (object) pCursor));
      return (SQLiteVirtualTableCursor) null;
    }

    protected virtual IntPtr CursorToIntPtr(SQLiteVirtualTableCursor cursor)
    {
      if (cursor == null || this.cursors == null)
        return IntPtr.Zero;
      IntPtr intPtr = IntPtr.Zero;
      bool flag = false;
      try
      {
        intPtr = this.AllocateCursor();
        if (intPtr != IntPtr.Zero)
        {
          cursor.NativeHandle = intPtr;
          this.cursors.Add(intPtr, cursor);
          flag = true;
        }
      }
      finally
      {
        if (!flag && intPtr != IntPtr.Zero)
        {
          this.FreeCursor(intPtr);
          intPtr = IntPtr.Zero;
        }
      }
      return intPtr;
    }

    protected virtual string GetFunctionKey(
      int argumentCount,
      string name,
      SQLiteFunction function)
    {
      return HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "{0}:{1}", (object) argumentCount, (object) name);
    }

    protected virtual SQLiteErrorCode DeclareTable(
      SQLiteConnection connection,
      string sql,
      ref string error)
    {
      if (connection == null)
      {
        error = "invalid connection";
        return SQLiteErrorCode.Error;
      }
      SQLiteBase sql1 = connection._sql;
      if (sql1 == null)
      {
        error = "connection has invalid handle";
        return SQLiteErrorCode.Error;
      }
      if (sql != null)
        return sql1.DeclareVirtualTable(this, sql, ref error);
      error = "invalid SQL statement";
      return SQLiteErrorCode.Error;
    }

    protected virtual SQLiteErrorCode DeclareFunction(
      SQLiteConnection connection,
      int argumentCount,
      string name,
      ref string error)
    {
      if (connection == null)
      {
        error = "invalid connection";
        return SQLiteErrorCode.Error;
      }
      SQLiteBase sql = connection._sql;
      if (sql != null)
        return sql.DeclareVirtualFunction(this, argumentCount, name, ref error);
      error = "connection has invalid handle";
      return SQLiteErrorCode.Error;
    }

    protected virtual bool LogErrorsNoThrow
    {
      get => this.logErrors;
      set => this.logErrors = value;
    }

    protected virtual bool LogExceptionsNoThrow
    {
      get => this.logExceptions;
      set => this.logExceptions = value;
    }

    protected virtual bool SetTableError(IntPtr pVtab, string error)
    {
      return SQLiteModule.SetTableError(this, pVtab, this.LogErrorsNoThrow, this.LogExceptionsNoThrow, error);
    }

    protected virtual bool SetTableError(SQLiteVirtualTable table, string error)
    {
      return SQLiteModule.SetTableError(this, table, this.LogErrorsNoThrow, this.LogExceptionsNoThrow, error);
    }

    protected virtual bool SetCursorError(SQLiteVirtualTableCursor cursor, string error)
    {
      return SQLiteModule.SetCursorError(this, cursor, this.LogErrorsNoThrow, this.LogExceptionsNoThrow, error);
    }

    protected virtual bool SetEstimatedCost(SQLiteIndex index, double? estimatedCost)
    {
      if (index == null || index.Outputs == null)
        return false;
      index.Outputs.EstimatedCost = estimatedCost;
      return true;
    }

    protected virtual bool SetEstimatedCost(SQLiteIndex index)
    {
      return this.SetEstimatedCost(index, new double?());
    }

    protected virtual bool SetEstimatedRows(SQLiteIndex index, long? estimatedRows)
    {
      if (index == null || index.Outputs == null)
        return false;
      index.Outputs.EstimatedRows = estimatedRows;
      return true;
    }

    protected virtual bool SetEstimatedRows(SQLiteIndex index)
    {
      return this.SetEstimatedRows(index, new long?());
    }

    protected virtual bool SetIndexFlags(SQLiteIndex index, SQLiteIndexFlags? indexFlags)
    {
      if (index == null || index.Outputs == null)
        return false;
      index.Outputs.IndexFlags = indexFlags;
      return true;
    }

    protected virtual bool SetIndexFlags(SQLiteIndex index)
    {
      return this.SetIndexFlags(index, new SQLiteIndexFlags?());
    }

    public virtual bool LogErrors
    {
      get
      {
        this.CheckDisposed();
        return this.LogErrorsNoThrow;
      }
      set
      {
        this.CheckDisposed();
        this.LogErrorsNoThrow = value;
      }
    }

    public virtual bool LogExceptions
    {
      get
      {
        this.CheckDisposed();
        return this.LogExceptionsNoThrow;
      }
      set
      {
        this.CheckDisposed();
        this.LogExceptionsNoThrow = value;
      }
    }

    private SQLiteErrorCode xCreate(
      IntPtr pDb,
      IntPtr pAux,
      int argc,
      IntPtr argv,
      ref IntPtr pVtab,
      ref IntPtr pError)
    {
      return this.CreateOrConnect(true, pDb, pAux, argc, argv, ref pVtab, ref pError);
    }

    private SQLiteErrorCode xConnect(
      IntPtr pDb,
      IntPtr pAux,
      int argc,
      IntPtr argv,
      ref IntPtr pVtab,
      ref IntPtr pError)
    {
      return this.CreateOrConnect(false, pDb, pAux, argc, argv, ref pVtab, ref pError);
    }

    private SQLiteErrorCode xBestIndex(IntPtr pVtab, IntPtr pIndex)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
        {
          SQLiteIndex index = (SQLiteIndex) null;
          SQLiteIndex.FromIntPtr(pIndex, true, ref index);
          if (this.BestIndex(table, index) == SQLiteErrorCode.Ok)
          {
            SQLiteIndex.ToIntPtr(index, pIndex, true);
            return SQLiteErrorCode.Ok;
          }
        }
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xDisconnect(IntPtr pVtab) => this.DestroyOrDisconnect(false, pVtab);

    private SQLiteErrorCode xDestroy(IntPtr pVtab) => this.DestroyOrDisconnect(true, pVtab);

    private SQLiteErrorCode xOpen(IntPtr pVtab, ref IntPtr pCursor)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
        {
          SQLiteVirtualTableCursor cursor = (SQLiteVirtualTableCursor) null;
          if (this.Open(table, ref cursor) == SQLiteErrorCode.Ok)
          {
            if (cursor != null)
            {
              pCursor = this.CursorToIntPtr(cursor);
              if (pCursor != IntPtr.Zero)
                return SQLiteErrorCode.Ok;
              this.SetTableError(pVtab, "no native cursor was created");
            }
            else
              this.SetTableError(pVtab, "no managed cursor was created");
          }
        }
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xClose(IntPtr pCursor)
    {
      IntPtr pVtab = IntPtr.Zero;
      try
      {
        pVtab = this.TableFromCursor(pCursor);
        SQLiteVirtualTableCursor cursor = this.CursorFromIntPtr(pVtab, pCursor);
        if (cursor != null)
        {
          if (this.Close(cursor) == SQLiteErrorCode.Ok)
          {
            if (this.cursors != null)
              this.cursors.Remove(pCursor);
            return SQLiteErrorCode.Ok;
          }
        }
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      finally
      {
        this.FreeCursor(pCursor);
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xFilter(
      IntPtr pCursor,
      int idxNum,
      IntPtr idxStr,
      int argc,
      IntPtr argv)
    {
      IntPtr pVtab = IntPtr.Zero;
      try
      {
        pVtab = this.TableFromCursor(pCursor);
        SQLiteVirtualTableCursor cursor = this.CursorFromIntPtr(pVtab, pCursor);
        if (cursor != null)
        {
          if (this.Filter(cursor, idxNum, SQLiteString.StringFromUtf8IntPtr(idxStr), SQLiteValue.ArrayFromSizeAndIntPtr(argc, argv)) == SQLiteErrorCode.Ok)
            return SQLiteErrorCode.Ok;
        }
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xNext(IntPtr pCursor)
    {
      IntPtr pVtab = IntPtr.Zero;
      try
      {
        pVtab = this.TableFromCursor(pCursor);
        SQLiteVirtualTableCursor cursor = this.CursorFromIntPtr(pVtab, pCursor);
        if (cursor != null)
        {
          if (this.Next(cursor) == SQLiteErrorCode.Ok)
            return SQLiteErrorCode.Ok;
        }
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private int xEof(IntPtr pCursor)
    {
      IntPtr pVtab = IntPtr.Zero;
      try
      {
        pVtab = this.TableFromCursor(pCursor);
        SQLiteVirtualTableCursor cursor = this.CursorFromIntPtr(pVtab, pCursor);
        if (cursor != null)
          return this.Eof(cursor) ? 1 : 0;
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return 1;
    }

    private SQLiteErrorCode xColumn(IntPtr pCursor, IntPtr pContext, int index)
    {
      IntPtr pVtab = IntPtr.Zero;
      try
      {
        pVtab = this.TableFromCursor(pCursor);
        SQLiteVirtualTableCursor cursor = this.CursorFromIntPtr(pVtab, pCursor);
        if (cursor != null)
        {
          SQLiteContext context = new SQLiteContext(pContext);
          return this.Column(cursor, context, index);
        }
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xRowId(IntPtr pCursor, ref long rowId)
    {
      IntPtr pVtab = IntPtr.Zero;
      try
      {
        pVtab = this.TableFromCursor(pCursor);
        SQLiteVirtualTableCursor cursor = this.CursorFromIntPtr(pVtab, pCursor);
        if (cursor != null)
          return this.RowId(cursor, ref rowId);
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xUpdate(IntPtr pVtab, int argc, IntPtr argv, ref long rowId)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
          return this.Update(table, SQLiteValue.ArrayFromSizeAndIntPtr(argc, argv), ref rowId);
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xBegin(IntPtr pVtab)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
          return this.Begin(table);
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xSync(IntPtr pVtab)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
          return this.Sync(table);
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xCommit(IntPtr pVtab)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
          return this.Commit(table);
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xRollback(IntPtr pVtab)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
          return this.Rollback(table);
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private int xFindFunction(
      IntPtr pVtab,
      int nArg,
      IntPtr zName,
      ref SQLiteCallback callback,
      ref IntPtr pClientData)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
        {
          string name = SQLiteString.StringFromUtf8IntPtr(zName);
          SQLiteFunction function = (SQLiteFunction) null;
          if (this.FindFunction(table, nArg, name, ref function, ref pClientData))
          {
            if (function != null)
            {
              this.functions[this.GetFunctionKey(nArg, name, function)] = function;
              callback = new SQLiteCallback(function.ScalarCallback);
              return 1;
            }
            this.SetTableError(pVtab, "no function was created");
          }
        }
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return 0;
    }

    private SQLiteErrorCode xRename(IntPtr pVtab, IntPtr zNew)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
          return this.Rename(table, SQLiteString.StringFromUtf8IntPtr(zNew));
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xSavepoint(IntPtr pVtab, int iSavepoint)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
          return this.Savepoint(table, iSavepoint);
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xRelease(IntPtr pVtab, int iSavepoint)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
          return this.Release(table, iSavepoint);
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    private SQLiteErrorCode xRollbackTo(IntPtr pVtab, int iSavepoint)
    {
      try
      {
        SQLiteVirtualTable table = this.TableFromIntPtr(pVtab);
        if (table != null)
          return this.RollbackTo(table, iSavepoint);
      }
      catch (Exception ex)
      {
        this.SetTableError(pVtab, ex.ToString());
      }
      return SQLiteErrorCode.Error;
    }

    public virtual bool Declared
    {
      get
      {
        this.CheckDisposed();
        return this.declared;
      }
      internal set => this.declared = value;
    }

    public virtual string Name
    {
      get
      {
        this.CheckDisposed();
        return this.name;
      }
    }

    public abstract SQLiteErrorCode Create(
      SQLiteConnection connection,
      IntPtr pClientData,
      string[] arguments,
      ref SQLiteVirtualTable table,
      ref string error);

    public abstract SQLiteErrorCode Connect(
      SQLiteConnection connection,
      IntPtr pClientData,
      string[] arguments,
      ref SQLiteVirtualTable table,
      ref string error);

    public abstract SQLiteErrorCode BestIndex(SQLiteVirtualTable table, SQLiteIndex index);

    public abstract SQLiteErrorCode Disconnect(SQLiteVirtualTable table);

    public abstract SQLiteErrorCode Destroy(SQLiteVirtualTable table);

    public abstract SQLiteErrorCode Open(
      SQLiteVirtualTable table,
      ref SQLiteVirtualTableCursor cursor);

    public abstract SQLiteErrorCode Close(SQLiteVirtualTableCursor cursor);

    public abstract SQLiteErrorCode Filter(
      SQLiteVirtualTableCursor cursor,
      int indexNumber,
      string indexString,
      SQLiteValue[] values);

    public abstract SQLiteErrorCode Next(SQLiteVirtualTableCursor cursor);

    public abstract bool Eof(SQLiteVirtualTableCursor cursor);

    public abstract SQLiteErrorCode Column(
      SQLiteVirtualTableCursor cursor,
      SQLiteContext context,
      int index);

    public abstract SQLiteErrorCode RowId(SQLiteVirtualTableCursor cursor, ref long rowId);

    public abstract SQLiteErrorCode Update(
      SQLiteVirtualTable table,
      SQLiteValue[] values,
      ref long rowId);

    public abstract SQLiteErrorCode Begin(SQLiteVirtualTable table);

    public abstract SQLiteErrorCode Sync(SQLiteVirtualTable table);

    public abstract SQLiteErrorCode Commit(SQLiteVirtualTable table);

    public abstract SQLiteErrorCode Rollback(SQLiteVirtualTable table);

    public abstract bool FindFunction(
      SQLiteVirtualTable table,
      int argumentCount,
      string name,
      ref SQLiteFunction function,
      ref IntPtr pClientData);

    public abstract SQLiteErrorCode Rename(SQLiteVirtualTable table, string newName);

    public abstract SQLiteErrorCode Savepoint(SQLiteVirtualTable table, int savepoint);

    public abstract SQLiteErrorCode Release(SQLiteVirtualTable table, int savepoint);

    public abstract SQLiteErrorCode RollbackTo(SQLiteVirtualTable table, int savepoint);

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteModule).Name);
    }

    protected virtual void Dispose(bool disposing)
    {
      if (this.disposed)
        return;
      if (disposing)
      {
        if (this.functions != null)
          this.functions.Clear();
      }
      try
      {
        if (this.disposableModule != IntPtr.Zero)
        {
          UnsafeNativeMethods.sqlite3_dispose_module(this.disposableModule);
          this.disposableModule = IntPtr.Zero;
        }
      }
      catch (Exception ex)
      {
        try
        {
          if (this.LogExceptionsNoThrow)
            SQLiteLog.LogMessage(-2146233088, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Caught exception in \"Dispose\" method: {0}", (object) ex));
        }
        catch
        {
        }
      }
      this.disposed = true;
    }

    ~SQLiteModule() => this.Dispose(false);

    private sealed class SQLiteNativeModule : ISQLiteNativeModule, IDisposable
    {
      private const bool DefaultLogErrors = true;
      private const bool DefaultLogExceptions = true;
      private const string ModuleNotAvailableErrorMessage = "native module implementation not available";
      private SQLiteModule module;
      private bool disposed;

      public SQLiteNativeModule(SQLiteModule module) => this.module = module;

      private static SQLiteErrorCode ModuleNotAvailableTableError(IntPtr pVtab)
      {
        SQLiteModule.SetTableError((SQLiteModule) null, pVtab, true, true, "native module implementation not available");
        return SQLiteErrorCode.Error;
      }

      private static SQLiteErrorCode ModuleNotAvailableCursorError(IntPtr pCursor)
      {
        SQLiteModule.SetCursorError((SQLiteModule) null, pCursor, true, true, "native module implementation not available");
        return SQLiteErrorCode.Error;
      }

      public SQLiteErrorCode xCreate(
        IntPtr pDb,
        IntPtr pAux,
        int argc,
        IntPtr argv,
        ref IntPtr pVtab,
        ref IntPtr pError)
      {
        if (this.module != null)
          return this.module.xCreate(pDb, pAux, argc, argv, ref pVtab, ref pError);
        pError = SQLiteString.Utf8IntPtrFromString("native module implementation not available");
        return SQLiteErrorCode.Error;
      }

      public SQLiteErrorCode xConnect(
        IntPtr pDb,
        IntPtr pAux,
        int argc,
        IntPtr argv,
        ref IntPtr pVtab,
        ref IntPtr pError)
      {
        if (this.module != null)
          return this.module.xConnect(pDb, pAux, argc, argv, ref pVtab, ref pError);
        pError = SQLiteString.Utf8IntPtrFromString("native module implementation not available");
        return SQLiteErrorCode.Error;
      }

      public SQLiteErrorCode xBestIndex(IntPtr pVtab, IntPtr pIndex)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xBestIndex(pVtab, pIndex);
      }

      public SQLiteErrorCode xDisconnect(IntPtr pVtab)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xDisconnect(pVtab);
      }

      public SQLiteErrorCode xDestroy(IntPtr pVtab)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xDestroy(pVtab);
      }

      public SQLiteErrorCode xOpen(IntPtr pVtab, ref IntPtr pCursor)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xOpen(pVtab, ref pCursor);
      }

      public SQLiteErrorCode xClose(IntPtr pCursor)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableCursorError(pCursor) : this.module.xClose(pCursor);
      }

      public SQLiteErrorCode xFilter(
        IntPtr pCursor,
        int idxNum,
        IntPtr idxStr,
        int argc,
        IntPtr argv)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableCursorError(pCursor) : this.module.xFilter(pCursor, idxNum, idxStr, argc, argv);
      }

      public SQLiteErrorCode xNext(IntPtr pCursor)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableCursorError(pCursor) : this.module.xNext(pCursor);
      }

      public int xEof(IntPtr pCursor)
      {
        if (this.module != null)
          return this.module.xEof(pCursor);
        int num = (int) SQLiteModule.SQLiteNativeModule.ModuleNotAvailableCursorError(pCursor);
        return 1;
      }

      public SQLiteErrorCode xColumn(IntPtr pCursor, IntPtr pContext, int index)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableCursorError(pCursor) : this.module.xColumn(pCursor, pContext, index);
      }

      public SQLiteErrorCode xRowId(IntPtr pCursor, ref long rowId)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableCursorError(pCursor) : this.module.xRowId(pCursor, ref rowId);
      }

      public SQLiteErrorCode xUpdate(IntPtr pVtab, int argc, IntPtr argv, ref long rowId)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xUpdate(pVtab, argc, argv, ref rowId);
      }

      public SQLiteErrorCode xBegin(IntPtr pVtab)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xBegin(pVtab);
      }

      public SQLiteErrorCode xSync(IntPtr pVtab)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xSync(pVtab);
      }

      public SQLiteErrorCode xCommit(IntPtr pVtab)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xCommit(pVtab);
      }

      public SQLiteErrorCode xRollback(IntPtr pVtab)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xRollback(pVtab);
      }

      public int xFindFunction(
        IntPtr pVtab,
        int nArg,
        IntPtr zName,
        ref SQLiteCallback callback,
        ref IntPtr pClientData)
      {
        if (this.module != null)
          return this.module.xFindFunction(pVtab, nArg, zName, ref callback, ref pClientData);
        int num = (int) SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab);
        return 0;
      }

      public SQLiteErrorCode xRename(IntPtr pVtab, IntPtr zNew)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xRename(pVtab, zNew);
      }

      public SQLiteErrorCode xSavepoint(IntPtr pVtab, int iSavepoint)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xSavepoint(pVtab, iSavepoint);
      }

      public SQLiteErrorCode xRelease(IntPtr pVtab, int iSavepoint)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xRelease(pVtab, iSavepoint);
      }

      public SQLiteErrorCode xRollbackTo(IntPtr pVtab, int iSavepoint)
      {
        return this.module == null ? SQLiteModule.SQLiteNativeModule.ModuleNotAvailableTableError(pVtab) : this.module.xRollbackTo(pVtab, iSavepoint);
      }

      public void Dispose()
      {
        this.Dispose(true);
        GC.SuppressFinalize((object) this);
      }

      private void CheckDisposed()
      {
        if (this.disposed)
          throw new ObjectDisposedException(typeof (SQLiteModule.SQLiteNativeModule).Name);
      }

      private void Dispose(bool disposing)
      {
        if (this.disposed)
          return;
        if (this.module != null)
          this.module = (SQLiteModule) null;
        this.disposed = true;
      }

      ~SQLiteNativeModule() => this.Dispose(false);
    }
  }
}


--- SQLiteModuleCommon.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteModuleCommon
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Globalization;

#nullable disable
namespace System.Data.SQLite
{
  public class SQLiteModuleCommon : SQLiteModuleNoop
  {
    private static readonly string declareSql = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "CREATE TABLE {0}(x);", (object) typeof (SQLiteModuleCommon).Name);
    private bool objectIdentity;
    private bool disposed;

    public SQLiteModuleCommon(string name)
      : this(name, false)
    {
    }

    public SQLiteModuleCommon(string name, bool objectIdentity)
      : base(name)
    {
      this.objectIdentity = objectIdentity;
    }

    protected virtual string GetSqlForDeclareTable() => SQLiteModuleCommon.declareSql;

    protected virtual SQLiteErrorCode CursorTypeMismatchError(
      SQLiteVirtualTableCursor cursor,
      Type type)
    {
      if (type != (Type) null)
        this.SetCursorError(cursor, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "not a \"{0}\" cursor", (object) type));
      else
        this.SetCursorError(cursor, "cursor type mismatch");
      return SQLiteErrorCode.Error;
    }

    protected virtual string GetStringFromObject(SQLiteVirtualTableCursor cursor, object value)
    {
      if (value == null)
        return (string) null;
      return value is string ? (string) value : value.ToString();
    }

    protected virtual long MakeRowId(int rowIndex, int hashCode)
    {
      return (long) rowIndex << 32 | (long) (uint) hashCode;
    }

    protected virtual long GetRowIdFromObject(SQLiteVirtualTableCursor cursor, object value)
    {
      return this.MakeRowId(cursor != null ? cursor.GetRowIndex() : 0, SQLiteMarshal.GetHashCode(value, this.objectIdentity));
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteModuleCommon).Name);
    }

    protected override void Dispose(bool disposing)
    {
      try
      {
        int num = this.disposed ? 1 : 0;
      }
      finally
      {
        base.Dispose(disposing);
        this.disposed = true;
      }
    }
  }
}


--- SQLiteModuleEnumerable.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteModuleEnumerable
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections;
using System.Globalization;

#nullable disable
namespace System.Data.SQLite
{
  public class SQLiteModuleEnumerable : SQLiteModuleCommon
  {
    private IEnumerable enumerable;
    private bool objectIdentity;
    private bool disposed;

    public SQLiteModuleEnumerable(string name, IEnumerable enumerable)
      : this(name, enumerable, false)
    {
    }

    public SQLiteModuleEnumerable(string name, IEnumerable enumerable, bool objectIdentity)
      : base(name)
    {
      this.enumerable = enumerable != null ? enumerable : throw new ArgumentNullException(nameof (enumerable));
      this.objectIdentity = objectIdentity;
    }

    protected virtual SQLiteErrorCode CursorEndOfEnumeratorError(SQLiteVirtualTableCursor cursor)
    {
      this.SetCursorError(cursor, "already hit end of enumerator");
      return SQLiteErrorCode.Error;
    }

    public override SQLiteErrorCode Create(
      SQLiteConnection connection,
      IntPtr pClientData,
      string[] arguments,
      ref SQLiteVirtualTable table,
      ref string error)
    {
      this.CheckDisposed();
      if (this.DeclareTable(connection, this.GetSqlForDeclareTable(), ref error) != SQLiteErrorCode.Ok)
        return SQLiteErrorCode.Error;
      table = new SQLiteVirtualTable(arguments);
      return SQLiteErrorCode.Ok;
    }

    public override SQLiteErrorCode Connect(
      SQLiteConnection connection,
      IntPtr pClientData,
      string[] arguments,
      ref SQLiteVirtualTable table,
      ref string error)
    {
      this.CheckDisposed();
      if (this.DeclareTable(connection, this.GetSqlForDeclareTable(), ref error) != SQLiteErrorCode.Ok)
        return SQLiteErrorCode.Error;
      table = new SQLiteVirtualTable(arguments);
      return SQLiteErrorCode.Ok;
    }

    public override SQLiteErrorCode BestIndex(SQLiteVirtualTable table, SQLiteIndex index)
    {
      this.CheckDisposed();
      if (table.BestIndex(index))
        return SQLiteErrorCode.Ok;
      this.SetTableError(table, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "failed to select best index for virtual table \"{0}\"", (object) table.TableName));
      return SQLiteErrorCode.Error;
    }

    public override SQLiteErrorCode Disconnect(SQLiteVirtualTable table)
    {
      this.CheckDisposed();
      table.Dispose();
      return SQLiteErrorCode.Ok;
    }

    public override SQLiteErrorCode Destroy(SQLiteVirtualTable table)
    {
      this.CheckDisposed();
      table.Dispose();
      return SQLiteErrorCode.Ok;
    }

    public override SQLiteErrorCode Open(
      SQLiteVirtualTable table,
      ref SQLiteVirtualTableCursor cursor)
    {
      this.CheckDisposed();
      cursor = (SQLiteVirtualTableCursor) new SQLiteVirtualTableCursorEnumerator(table, this.enumerable.GetEnumerator());
      return SQLiteErrorCode.Ok;
    }

    public override SQLiteErrorCode Close(SQLiteVirtualTableCursor cursor)
    {
      this.CheckDisposed();
      if (!(cursor is SQLiteVirtualTableCursorEnumerator cursorEnumerator))
        return this.CursorTypeMismatchError(cursor, typeof (SQLiteVirtualTableCursorEnumerator));
      cursorEnumerator.Close();
      return SQLiteErrorCode.Ok;
    }

    public override SQLiteErrorCode Filter(
      SQLiteVirtualTableCursor cursor,
      int indexNumber,
      string indexString,
      SQLiteValue[] values)
    {
      this.CheckDisposed();
      if (!(cursor is SQLiteVirtualTableCursorEnumerator cursorEnumerator))
        return this.CursorTypeMismatchError(cursor, typeof (SQLiteVirtualTableCursorEnumerator));
      cursorEnumerator.Filter(indexNumber, indexString, values);
      cursorEnumerator.Reset();
      cursorEnumerator.MoveNext();
      return SQLiteErrorCode.Ok;
    }

    public override SQLiteErrorCode Next(SQLiteVirtualTableCursor cursor)
    {
      this.CheckDisposed();
      if (!(cursor is SQLiteVirtualTableCursorEnumerator cursorEnumerator))
        return this.CursorTypeMismatchError(cursor, typeof (SQLiteVirtualTableCursorEnumerator));
      if (cursorEnumerator.EndOfEnumerator)
        return this.CursorEndOfEnumeratorError(cursor);
      cursorEnumerator.MoveNext();
      return SQLiteErrorCode.Ok;
    }

    public override bool Eof(SQLiteVirtualTableCursor cursor)
    {
      this.CheckDisposed();
      return !(cursor is SQLiteVirtualTableCursorEnumerator cursorEnumerator) ? this.ResultCodeToEofResult(this.CursorTypeMismatchError(cursor, typeof (SQLiteVirtualTableCursorEnumerator))) : cursorEnumerator.EndOfEnumerator;
    }

    public override SQLiteErrorCode Column(
      SQLiteVirtualTableCursor cursor,
      SQLiteContext context,
      int index)
    {
      this.CheckDisposed();
      if (!(cursor is SQLiteVirtualTableCursorEnumerator cursorEnumerator))
        return this.CursorTypeMismatchError(cursor, typeof (SQLiteVirtualTableCursorEnumerator));
      if (cursorEnumerator.EndOfEnumerator)
        return this.CursorEndOfEnumeratorError(cursor);
      object current = cursorEnumerator.Current;
      if (current != null)
        context.SetString(this.GetStringFromObject(cursor, current));
      else
        context.SetNull();
      return SQLiteErrorCode.Ok;
    }

    public override SQLiteErrorCode RowId(SQLiteVirtualTableCursor cursor, ref long rowId)
    {
      this.CheckDisposed();
      if (!(cursor is SQLiteVirtualTableCursorEnumerator cursorEnumerator))
        return this.CursorTypeMismatchError(cursor, typeof (SQLiteVirtualTableCursorEnumerator));
      if (cursorEnumerator.EndOfEnumerator)
        return this.CursorEndOfEnumeratorError(cursor);
      object current = cursorEnumerator.Current;
      rowId = this.GetRowIdFromObject(cursor, current);
      return SQLiteErrorCode.Ok;
    }

    public override SQLiteErrorCode Update(
      SQLiteVirtualTable table,
      SQLiteValue[] values,
      ref long rowId)
    {
      this.CheckDisposed();
      this.SetTableError(table, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "virtual table \"{0}\" is read-only", (object) table.TableName));
      return SQLiteErrorCode.Error;
    }

    public override SQLiteErrorCode Rename(SQLiteVirtualTable table, string newName)
    {
      this.CheckDisposed();
      if (table.Rename(newName))
        return SQLiteErrorCode.Ok;
      this.SetTableError(table, HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "failed to rename virtual table from \"{0}\" to \"{1}\"", (object) table.TableName, (object) newName));
      return SQLiteErrorCode.Error;
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteModuleEnumerable).Name);
    }

    protected override void Dispose(bool disposing)
    {
      try
      {
        int num = this.disposed ? 1 : 0;
      }
      finally
      {
        base.Dispose(disposing);
        this.disposed = true;
      }
    }
  }
}


--- SQLiteModuleNoop.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteModuleNoop
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;

#nullable disable
namespace System.Data.SQLite
{
  public class SQLiteModuleNoop : SQLiteModule
  {
    private Dictionary<string, SQLiteErrorCode> resultCodes;
    private bool disposed;

    public SQLiteModuleNoop(string name)
      : base(name)
    {
      this.resultCodes = new Dictionary<string, SQLiteErrorCode>();
    }

    protected virtual SQLiteErrorCode GetDefaultResultCode() => SQLiteErrorCode.Ok;

    protected virtual bool ResultCodeToEofResult(SQLiteErrorCode resultCode)
    {
      return resultCode != SQLiteErrorCode.Ok;
    }

    protected virtual bool ResultCodeToFindFunctionResult(SQLiteErrorCode resultCode)
    {
      return resultCode == SQLiteErrorCode.Ok;
    }

    protected virtual SQLiteErrorCode GetMethodResultCode(string methodName)
    {
      SQLiteErrorCode sqLiteErrorCode;
      return methodName == null || this.resultCodes == null || this.resultCodes == null || !this.resultCodes.TryGetValue(methodName, out sqLiteErrorCode) ? this.GetDefaultResultCode() : sqLiteErrorCode;
    }

    protected virtual bool SetMethodResultCode(string methodName, SQLiteErrorCode resultCode)
    {
      if (methodName == null || this.resultCodes == null)
        return false;
      this.resultCodes[methodName] = resultCode;
      return true;
    }

    public override SQLiteErrorCode Create(
      SQLiteConnection connection,
      IntPtr pClientData,
      string[] arguments,
      ref SQLiteVirtualTable table,
      ref string error)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Create));
    }

    public override SQLiteErrorCode Connect(
      SQLiteConnection connection,
      IntPtr pClientData,
      string[] arguments,
      ref SQLiteVirtualTable table,
      ref string error)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Connect));
    }

    public override SQLiteErrorCode BestIndex(SQLiteVirtualTable table, SQLiteIndex index)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (BestIndex));
    }

    public override SQLiteErrorCode Disconnect(SQLiteVirtualTable table)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Disconnect));
    }

    public override SQLiteErrorCode Destroy(SQLiteVirtualTable table)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Destroy));
    }

    public override SQLiteErrorCode Open(
      SQLiteVirtualTable table,
      ref SQLiteVirtualTableCursor cursor)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Open));
    }

    public override SQLiteErrorCode Close(SQLiteVirtualTableCursor cursor)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Close));
    }

    public override SQLiteErrorCode Filter(
      SQLiteVirtualTableCursor cursor,
      int indexNumber,
      string indexString,
      SQLiteValue[] values)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Filter));
    }

    public override SQLiteErrorCode Next(SQLiteVirtualTableCursor cursor)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Next));
    }

    public override bool Eof(SQLiteVirtualTableCursor cursor)
    {
      this.CheckDisposed();
      return this.ResultCodeToEofResult(this.GetMethodResultCode(nameof (Eof)));
    }

    public override SQLiteErrorCode Column(
      SQLiteVirtualTableCursor cursor,
      SQLiteContext context,
      int index)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Column));
    }

    public override SQLiteErrorCode RowId(SQLiteVirtualTableCursor cursor, ref long rowId)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (RowId));
    }

    public override SQLiteErrorCode Update(
      SQLiteVirtualTable table,
      SQLiteValue[] values,
      ref long rowId)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Update));
    }

    public override SQLiteErrorCode Begin(SQLiteVirtualTable table)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Begin));
    }

    public override SQLiteErrorCode Sync(SQLiteVirtualTable table)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Sync));
    }

    public override SQLiteErrorCode Commit(SQLiteVirtualTable table)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Commit));
    }

    public override SQLiteErrorCode Rollback(SQLiteVirtualTable table)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Rollback));
    }

    public override bool FindFunction(
      SQLiteVirtualTable table,
      int argumentCount,
      string name,
      ref SQLiteFunction function,
      ref IntPtr pClientData)
    {
      this.CheckDisposed();
      return this.ResultCodeToFindFunctionResult(this.GetMethodResultCode(nameof (FindFunction)));
    }

    public override SQLiteErrorCode Rename(SQLiteVirtualTable table, string newName)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Rename));
    }

    public override SQLiteErrorCode Savepoint(SQLiteVirtualTable table, int savepoint)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Savepoint));
    }

    public override SQLiteErrorCode Release(SQLiteVirtualTable table, int savepoint)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (Release));
    }

    public override SQLiteErrorCode RollbackTo(SQLiteVirtualTable table, int savepoint)
    {
      this.CheckDisposed();
      return this.GetMethodResultCode(nameof (RollbackTo));
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteModuleNoop).Name);
    }

    protected override void Dispose(bool disposing)
    {
      try
      {
        int num = this.disposed ? 1 : 0;
      }
      finally
      {
        base.Dispose(disposing);
        this.disposed = true;
      }
    }
  }
}


--- SQLiteOpenFlagsEnum.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteOpenFlagsEnum
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  [Flags]
  internal enum SQLiteOpenFlagsEnum
  {
    None = 0,
    ReadOnly = 1,
    ReadWrite = 2,
    Create = 4,
    Uri = 64, // 0x00000040
    SharedCache = 16777216, // 0x01000000
    Default = Create | ReadWrite, // 0x00000006
  }
}


--- SQLiteParameter.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteParameter
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.ComponentModel;
using System.Data.Common;

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteParameter : DbParameter, ICloneable
  {
    private const DbType UnknownDbType = ~DbType.AnsiString;
    private IDbCommand _command;
    internal DbType _dbType;
    private DataRowVersion _rowVersion;
    private object _objValue;
    private string _sourceColumn;
    private string _parameterName;
    private int _dataSize;
    private bool _nullable;
    private bool _nullMapping;
    private string _typeName;

    internal SQLiteParameter(IDbCommand command)
      : this()
    {
      this._command = command;
    }

    public SQLiteParameter()
      : this((string) null, ~DbType.AnsiString, 0, (string) null, DataRowVersion.Current)
    {
    }

    public SQLiteParameter(string parameterName)
      : this(parameterName, ~DbType.AnsiString, 0, (string) null, DataRowVersion.Current)
    {
    }

    public SQLiteParameter(string parameterName, object value)
      : this(parameterName, ~DbType.AnsiString, 0, (string) null, DataRowVersion.Current)
    {
      this.Value = value;
    }

    public SQLiteParameter(string parameterName, DbType dbType)
      : this(parameterName, dbType, 0, (string) null, DataRowVersion.Current)
    {
    }

    public SQLiteParameter(string parameterName, DbType dbType, string sourceColumn)
      : this(parameterName, dbType, 0, sourceColumn, DataRowVersion.Current)
    {
    }

    public SQLiteParameter(
      string parameterName,
      DbType dbType,
      string sourceColumn,
      DataRowVersion rowVersion)
      : this(parameterName, dbType, 0, sourceColumn, rowVersion)
    {
    }

    public SQLiteParameter(DbType dbType)
      : this((string) null, dbType, 0, (string) null, DataRowVersion.Current)
    {
    }

    public SQLiteParameter(DbType dbType, object value)
      : this((string) null, dbType, 0, (string) null, DataRowVersion.Current)
    {
      this.Value = value;
    }

    public SQLiteParameter(DbType dbType, string sourceColumn)
      : this((string) null, dbType, 0, sourceColumn, DataRowVersion.Current)
    {
    }

    public SQLiteParameter(DbType dbType, string sourceColumn, DataRowVersion rowVersion)
      : this((string) null, dbType, 0, sourceColumn, rowVersion)
    {
    }

    public SQLiteParameter(string parameterName, DbType parameterType, int parameterSize)
      : this(parameterName, parameterType, parameterSize, (string) null, DataRowVersion.Current)
    {
    }

    public SQLiteParameter(
      string parameterName,
      DbType parameterType,
      int parameterSize,
      string sourceColumn)
      : this(parameterName, parameterType, parameterSize, sourceColumn, DataRowVersion.Current)
    {
    }

    public SQLiteParameter(
      string parameterName,
      DbType parameterType,
      int parameterSize,
      string sourceColumn,
      DataRowVersion rowVersion)
    {
      this._parameterName = parameterName;
      this._dbType = parameterType;
      this._sourceColumn = sourceColumn;
      this._rowVersion = rowVersion;
      this._dataSize = parameterSize;
      this._nullable = true;
    }

    private SQLiteParameter(SQLiteParameter source)
      : this(source.ParameterName, source._dbType, 0, source.Direction, source.IsNullable, (byte) 0, (byte) 0, source.SourceColumn, source.SourceVersion, source.Value)
    {
      this._nullMapping = source._nullMapping;
    }

    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public SQLiteParameter(
      string parameterName,
      DbType parameterType,
      int parameterSize,
      ParameterDirection direction,
      bool isNullable,
      byte precision,
      byte scale,
      string sourceColumn,
      DataRowVersion rowVersion,
      object value)
      : this(parameterName, parameterType, parameterSize, sourceColumn, rowVersion)
    {
      this.Direction = direction;
      this.IsNullable = isNullable;
      this.Value = value;
    }

    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public SQLiteParameter(
      string parameterName,
      DbType parameterType,
      int parameterSize,
      ParameterDirection direction,
      byte precision,
      byte scale,
      string sourceColumn,
      DataRowVersion rowVersion,
      bool sourceColumnNullMapping,
      object value)
      : this(parameterName, parameterType, parameterSize, sourceColumn, rowVersion)
    {
      this.Direction = direction;
      this.SourceColumnNullMapping = sourceColumnNullMapping;
      this.Value = value;
    }

    public SQLiteParameter(DbType parameterType, int parameterSize)
      : this((string) null, parameterType, parameterSize, (string) null, DataRowVersion.Current)
    {
    }

    public SQLiteParameter(DbType parameterType, int parameterSize, string sourceColumn)
      : this((string) null, parameterType, parameterSize, sourceColumn, DataRowVersion.Current)
    {
    }

    public SQLiteParameter(
      DbType parameterType,
      int parameterSize,
      string sourceColumn,
      DataRowVersion rowVersion)
      : this((string) null, parameterType, parameterSize, sourceColumn, rowVersion)
    {
    }

    public IDbCommand Command
    {
      get => this._command;
      set => this._command = value;
    }

    public override bool IsNullable
    {
      get => this._nullable;
      set => this._nullable = value;
    }

    [DbProviderSpecificTypeProperty(true)]
    [RefreshProperties(RefreshProperties.All)]
    public override DbType DbType
    {
      get
      {
        if (this._dbType != ~DbType.AnsiString)
          return this._dbType;
        return this._objValue != null && this._objValue != DBNull.Value ? SQLiteConvert.TypeToDbType(this._objValue.GetType()) : DbType.String;
      }
      set => this._dbType = value;
    }

    public override ParameterDirection Direction
    {
      get => ParameterDirection.Input;
      set
      {
        if (value != ParameterDirection.Input)
          throw new NotSupportedException();
      }
    }

    public override string ParameterName
    {
      get => this._parameterName;
      set => this._parameterName = value;
    }

    public override void ResetDbType() => this._dbType = ~DbType.AnsiString;

    [DefaultValue(0)]
    public override int Size
    {
      get => this._dataSize;
      set => this._dataSize = value;
    }

    public override string SourceColumn
    {
      get => this._sourceColumn;
      set => this._sourceColumn = value;
    }

    public override bool SourceColumnNullMapping
    {
      get => this._nullMapping;
      set => this._nullMapping = value;
    }

    public override DataRowVersion SourceVersion
    {
      get => this._rowVersion;
      set => this._rowVersion = value;
    }

    [RefreshProperties(RefreshProperties.All)]
    [TypeConverter(typeof (StringConverter))]
    public override object Value
    {
      get => this._objValue;
      set
      {
        this._objValue = value;
        if (this._dbType != ~DbType.AnsiString || this._objValue == null || this._objValue == DBNull.Value)
          return;
        this._dbType = SQLiteConvert.TypeToDbType(this._objValue.GetType());
      }
    }

    public string TypeName
    {
      get => this._typeName;
      set => this._typeName = value;
    }

    public object Clone() => (object) new SQLiteParameter(this);
  }
}


--- SQLiteParameterCollection.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteParameterCollection
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data.Common;
using System.Globalization;

#nullable disable
namespace System.Data.SQLite
{
  [ListBindable(false)]
  [Editor("Microsoft.VSDesigner.Data.Design.DBParametersEditor, Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
  public sealed class SQLiteParameterCollection : DbParameterCollection
  {
    private SQLiteCommand _command;
    private List<SQLiteParameter> _parameterList;
    private bool _unboundFlag;

    internal SQLiteParameterCollection(SQLiteCommand cmd)
    {
      this._command = cmd;
      this._parameterList = new List<SQLiteParameter>();
      this._unboundFlag = true;
    }

    public override bool IsSynchronized => false;

    public override bool IsFixedSize => false;

    public override bool IsReadOnly => false;

    public override object SyncRoot => (object) null;

    public override IEnumerator GetEnumerator()
    {
      return (IEnumerator) this._parameterList.GetEnumerator();
    }

    public SQLiteParameter Add(
      string parameterName,
      DbType parameterType,
      int parameterSize,
      string sourceColumn)
    {
      SQLiteParameter parameter = new SQLiteParameter(parameterName, parameterType, parameterSize, sourceColumn);
      this.Add(parameter);
      return parameter;
    }

    public SQLiteParameter Add(string parameterName, DbType parameterType, int parameterSize)
    {
      SQLiteParameter parameter = new SQLiteParameter(parameterName, parameterType, parameterSize);
      this.Add(parameter);
      return parameter;
    }

    public SQLiteParameter Add(string parameterName, DbType parameterType)
    {
      SQLiteParameter parameter = new SQLiteParameter(parameterName, parameterType);
      this.Add(parameter);
      return parameter;
    }

    public int Add(SQLiteParameter parameter)
    {
      int index = -1;
      if (!string.IsNullOrEmpty(parameter.ParameterName))
        index = this.IndexOf(parameter.ParameterName);
      if (index == -1)
      {
        index = this._parameterList.Count;
        this._parameterList.Add(parameter);
      }
      this.SetParameter(index, (DbParameter) parameter);
      return index;
    }

    [EditorBrowsable(EditorBrowsableState.Never)]
    public override int Add(object value) => this.Add((SQLiteParameter) value);

    public SQLiteParameter AddWithValue(string parameterName, object value)
    {
      SQLiteParameter parameter = new SQLiteParameter(parameterName, value);
      this.Add(parameter);
      return parameter;
    }

    public void AddRange(SQLiteParameter[] values)
    {
      int length = values.Length;
      for (int index = 0; index < length; ++index)
        this.Add(values[index]);
    }

    public override void AddRange(Array values)
    {
      int length = values.Length;
      for (int index = 0; index < length; ++index)
        this.Add((SQLiteParameter) values.GetValue(index));
    }

    public override void Clear()
    {
      this._unboundFlag = true;
      this._parameterList.Clear();
    }

    public override bool Contains(string parameterName) => this.IndexOf(parameterName) != -1;

    public override bool Contains(object value)
    {
      return this._parameterList.Contains((SQLiteParameter) value);
    }

    public override void CopyTo(Array array, int index) => throw new NotImplementedException();

    public override int Count => this._parameterList.Count;

    public SQLiteParameter this[string parameterName]
    {
      get => (SQLiteParameter) this.GetParameter(parameterName);
      set => this.SetParameter(parameterName, (DbParameter) value);
    }

    public SQLiteParameter this[int index]
    {
      get => (SQLiteParameter) this.GetParameter(index);
      set => this.SetParameter(index, (DbParameter) value);
    }

    protected override DbParameter GetParameter(string parameterName)
    {
      return this.GetParameter(this.IndexOf(parameterName));
    }

    protected override DbParameter GetParameter(int index)
    {
      return (DbParameter) this._parameterList[index];
    }

    public override int IndexOf(string parameterName)
    {
      int count = this._parameterList.Count;
      for (int index = 0; index < count; ++index)
      {
        if (string.Compare(parameterName, this._parameterList[index].ParameterName, StringComparison.OrdinalIgnoreCase) == 0)
          return index;
      }
      return -1;
    }

    public override int IndexOf(object value)
    {
      return this._parameterList.IndexOf((SQLiteParameter) value);
    }

    public override void Insert(int index, object value)
    {
      this._unboundFlag = true;
      this._parameterList.Insert(index, (SQLiteParameter) value);
    }

    public override void Remove(object value)
    {
      this._unboundFlag = true;
      this._parameterList.Remove((SQLiteParameter) value);
    }

    public override void RemoveAt(string parameterName)
    {
      this.RemoveAt(this.IndexOf(parameterName));
    }

    public override void RemoveAt(int index)
    {
      this._unboundFlag = true;
      this._parameterList.RemoveAt(index);
    }

    protected override void SetParameter(string parameterName, DbParameter value)
    {
      this.SetParameter(this.IndexOf(parameterName), value);
    }

    protected override void SetParameter(int index, DbParameter value)
    {
      this._unboundFlag = true;
      this._parameterList[index] = (SQLiteParameter) value;
    }

    internal void Unbind() => this._unboundFlag = true;

    internal void MapParameters(SQLiteStatement activeStatement)
    {
      if (!this._unboundFlag || this._parameterList.Count == 0 || this._command._statementList == null)
        return;
      int num1 = 0;
      int num2 = -1;
      foreach (SQLiteParameter parameter in this._parameterList)
      {
        ++num2;
        string s1 = parameter.ParameterName;
        if (s1 == null)
        {
          s1 = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, ";{0}", (object) num1);
          ++num1;
        }
        bool flag = false;
        int num3 = activeStatement != null ? 1 : this._command._statementList.Count;
        SQLiteStatement sqLiteStatement1 = activeStatement;
        for (int index = 0; index < num3; ++index)
        {
          flag = false;
          if (sqLiteStatement1 == null)
            sqLiteStatement1 = this._command._statementList[index];
          if (sqLiteStatement1._paramNames != null && sqLiteStatement1.MapParameter(s1, parameter))
            flag = true;
          sqLiteStatement1 = (SQLiteStatement) null;
        }
        if (!flag)
        {
          string s2 = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, ";{0}", (object) num2);
          SQLiteStatement sqLiteStatement2 = activeStatement;
          for (int index = 0; index < num3; ++index)
          {
            if (sqLiteStatement2 == null)
              sqLiteStatement2 = this._command._statementList[index];
            if (sqLiteStatement2._paramNames != null && sqLiteStatement2.MapParameter(s2, parameter))
              ;
            sqLiteStatement2 = (SQLiteStatement) null;
          }
        }
      }
      if (activeStatement != null)
        return;
      this._unboundFlag = false;
    }
  }
}


--- SQLiteProgressCallback.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteProgressCallback
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  internal delegate SQLiteProgressReturnCode SQLiteProgressCallback(IntPtr pUserData);
}


--- SQLiteProgressEventHandler.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteProgressEventHandler
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate void SQLiteProgressEventHandler(object sender, ProgressEventArgs e);
}


--- SQLiteProgressReturnCode.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteProgressReturnCode
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum SQLiteProgressReturnCode
  {
    Continue,
    Interrupt,
  }
}


--- SQLiteReadArrayEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteReadArrayEventArgs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public class SQLiteReadArrayEventArgs : SQLiteReadEventArgs
  {
    private long dataOffset;
    private byte[] byteBuffer;
    private char[] charBuffer;
    private int bufferOffset;
    private int length;

    internal SQLiteReadArrayEventArgs(
      long dataOffset,
      byte[] byteBuffer,
      int bufferOffset,
      int length)
    {
      this.dataOffset = dataOffset;
      this.byteBuffer = byteBuffer;
      this.bufferOffset = bufferOffset;
      this.length = length;
    }

    internal SQLiteReadArrayEventArgs(
      long dataOffset,
      char[] charBuffer,
      int bufferOffset,
      int length)
    {
      this.dataOffset = dataOffset;
      this.charBuffer = charBuffer;
      this.bufferOffset = bufferOffset;
      this.length = length;
    }

    public long DataOffset
    {
      get => this.dataOffset;
      set => this.dataOffset = value;
    }

    public byte[] ByteBuffer => this.byteBuffer;

    public char[] CharBuffer => this.charBuffer;

    public int BufferOffset
    {
      get => this.bufferOffset;
      set => this.bufferOffset = value;
    }

    public int Length
    {
      get => this.length;
      set => this.length = value;
    }
  }
}


--- SQLiteReadBlobEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteReadBlobEventArgs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public class SQLiteReadBlobEventArgs : SQLiteReadEventArgs
  {
    private bool readOnly;

    internal SQLiteReadBlobEventArgs(bool readOnly) => this.readOnly = readOnly;

    public bool ReadOnly
    {
      get => this.readOnly;
      set => this.readOnly = value;
    }
  }
}


--- SQLiteReadEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteReadEventArgs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public abstract class SQLiteReadEventArgs : EventArgs
  {
  }
}


--- SQLiteReadValueCallback.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteReadValueCallback
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate void SQLiteReadValueCallback(
    SQLiteConvert convert,
    SQLiteDataReader dataReader,
    SQLiteConnectionFlags flags,
    SQLiteReadEventArgs eventArgs,
    string typeName,
    int index,
    object userData,
    out bool complete);
}


--- SQLiteReadValueEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteReadValueEventArgs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public class SQLiteReadValueEventArgs : SQLiteReadEventArgs
  {
    private string methodName;
    private SQLiteReadEventArgs extraEventArgs;
    private SQLiteDataReaderValue value;

    internal SQLiteReadValueEventArgs(
      string methodName,
      SQLiteReadEventArgs extraEventArgs,
      SQLiteDataReaderValue value)
    {
      this.methodName = methodName;
      this.extraEventArgs = extraEventArgs;
      this.value = value;
    }

    public string MethodName => this.methodName;

    public SQLiteReadEventArgs ExtraEventArgs => this.extraEventArgs;

    public SQLiteDataReaderValue Value => this.value;
  }
}


--- SQLiteRollbackCallback.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteRollbackCallback
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  internal delegate void SQLiteRollbackCallback(IntPtr puser);
}


--- SQLiteStatement.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteStatement
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Globalization;

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLiteStatement : IDisposable
  {
    internal SQLiteBase _sql;
    internal string _sqlStatement;
    internal SQLiteStatementHandle _sqlite_stmt;
    internal int _unnamedParameters;
    internal string[] _paramNames;
    internal SQLiteParameter[] _paramValues;
    internal SQLiteCommand _command;
    private SQLiteConnectionFlags _flags;
    private string[] _types;
    private bool disposed;

    internal SQLiteStatement(
      SQLiteBase sqlbase,
      SQLiteConnectionFlags flags,
      SQLiteStatementHandle stmt,
      string strCommand,
      SQLiteStatement previous)
    {
      this._sql = sqlbase;
      this._sqlite_stmt = stmt;
      this._sqlStatement = strCommand;
      this._flags = flags;
      int num = 0;
      int length = this._sql.Bind_ParamCount(this, this._flags);
      if (length <= 0)
        return;
      if (previous != null)
        num = previous._unnamedParameters;
      this._paramNames = new string[length];
      this._paramValues = new SQLiteParameter[length];
      for (int index = 0; index < length; ++index)
      {
        string str = this._sql.Bind_ParamName(this, this._flags, index + 1);
        if (string.IsNullOrEmpty(str))
        {
          str = HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, ";{0}", (object) num);
          ++num;
          ++this._unnamedParameters;
        }
        this._paramNames[index] = str;
        this._paramValues[index] = (SQLiteParameter) null;
      }
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteStatement).Name);
    }

    private void Dispose(bool disposing)
    {
      if (this.disposed)
        return;
      if (disposing)
      {
        if (this._sqlite_stmt != null)
        {
          this._sqlite_stmt.Dispose();
          this._sqlite_stmt = (SQLiteStatementHandle) null;
        }
        this._paramNames = (string[]) null;
        this._paramValues = (SQLiteParameter[]) null;
        this._sql = (SQLiteBase) null;
        this._sqlStatement = (string) null;
      }
      this.disposed = true;
    }

    ~SQLiteStatement() => this.Dispose(false);

    internal bool TryGetChanges(ref int changes, ref bool readOnly)
    {
      if (this._sql == null || !this._sql.IsOpen())
        return false;
      changes = this._sql.Changes;
      readOnly = this._sql.IsReadOnly(this);
      return true;
    }

    internal bool MapParameter(string s, SQLiteParameter p)
    {
      if (this._paramNames == null)
        return false;
      int indexA = 0;
      if (s.Length > 0 && ":$@;".IndexOf(s[0]) == -1)
        indexA = 1;
      int length = this._paramNames.Length;
      for (int index = 0; index < length; ++index)
      {
        if (string.Compare(this._paramNames[index], indexA, s, 0, Math.Max(this._paramNames[index].Length - indexA, s.Length), StringComparison.OrdinalIgnoreCase) == 0)
        {
          this._paramValues[index] = p;
          return true;
        }
      }
      return false;
    }

    internal void BindParameters()
    {
      if (this._paramNames == null)
        return;
      int length = this._paramNames.Length;
      for (int index = 0; index < length; ++index)
        this.BindParameter(index + 1, this._paramValues[index]);
    }

    private static SQLiteConnection GetConnection(SQLiteStatement statement)
    {
      try
      {
        if (statement != null)
        {
          SQLiteCommand command = statement._command;
          if (command != null)
          {
            SQLiteConnection connection = command.Connection;
            if (connection != null)
              return connection;
          }
        }
      }
      catch (ObjectDisposedException ex)
      {
      }
      return (SQLiteConnection) null;
    }

    private void InvokeBindValueCallback(int index, SQLiteParameter parameter, out bool complete)
    {
      complete = false;
      SQLiteConnectionFlags flags = this._flags;
      this._flags &= ~SQLiteConnectionFlags.UseConnectionBindValueCallbacks;
      try
      {
        if (parameter == null)
          return;
        SQLiteConnection connection = SQLiteStatement.GetConnection(this);
        if (connection == null)
          return;
        string typeName = parameter.TypeName;
        if (typeName == null && (this._flags & SQLiteConnectionFlags.UseParameterNameForTypeName) == SQLiteConnectionFlags.UseParameterNameForTypeName)
          typeName = parameter.ParameterName;
        if (typeName == null && (this._flags & SQLiteConnectionFlags.UseParameterDbTypeForTypeName) == SQLiteConnectionFlags.UseParameterDbTypeForTypeName)
          typeName = SQLiteConvert.DbTypeToTypeName(connection, parameter.DbType, this._flags);
        SQLiteTypeCallbacks callbacks;
        if (typeName == null || !connection.TryGetTypeCallbacks(typeName, out callbacks) || callbacks == null)
          return;
        SQLiteBindValueCallback bindValueCallback = callbacks.BindValueCallback;
        if (bindValueCallback == null)
          return;
        object bindValueUserData = callbacks.BindValueUserData;
        bindValueCallback((SQLiteConvert) this._sql, this._command, flags, parameter, typeName, index, bindValueUserData, out complete);
      }
      finally
      {
        this._flags |= SQLiteConnectionFlags.UseConnectionBindValueCallbacks;
      }
    }

    private void BindParameter(int index, SQLiteParameter param)
    {
      if (param == null)
        throw new SQLiteException("Insufficient parameters supplied to the command");
      if ((this._flags & SQLiteConnectionFlags.UseConnectionBindValueCallbacks) == SQLiteConnectionFlags.UseConnectionBindValueCallbacks)
      {
        bool complete;
        this.InvokeBindValueCallback(index, param, out complete);
        if (complete)
          return;
      }
      object obj = param.Value;
      DbType dbType = param.DbType;
      if (obj != null && dbType == DbType.Object)
        dbType = SQLiteConvert.TypeToDbType(obj.GetType());
      if ((this._flags & SQLiteConnectionFlags.LogPreBind) == SQLiteConnectionFlags.LogPreBind)
        SQLiteLog.LogMessage(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Binding statement {0} paramter #{1} with database type {2} and raw value {{{3}}}...", (object) (IntPtr) this._sqlite_stmt, (object) index, (object) dbType, obj));
      if (obj == null || Convert.IsDBNull(obj))
      {
        this._sql.Bind_Null(this, this._flags, index);
      }
      else
      {
        CultureInfo invariantCulture = CultureInfo.InvariantCulture;
        bool flag = (this._flags & SQLiteConnectionFlags.BindInvariantText) == SQLiteConnectionFlags.BindInvariantText;
        if ((this._flags & SQLiteConnectionFlags.BindAllAsText) == SQLiteConnectionFlags.BindAllAsText)
        {
          if (obj is DateTime dt)
            this._sql.Bind_DateTime(this, this._flags, index, dt);
          else
            this._sql.Bind_Text(this, this._flags, index, flag ? SQLiteConvert.ToStringWithProvider(obj, (IFormatProvider) invariantCulture) : obj.ToString());
        }
        else
        {
          CultureInfo provider = CultureInfo.CurrentCulture;
          if ((this._flags & SQLiteConnectionFlags.ConvertInvariantText) == SQLiteConnectionFlags.ConvertInvariantText)
            provider = invariantCulture;
          switch (dbType)
          {
            case DbType.Binary:
              this._sql.Bind_Blob(this, this._flags, index, (byte[]) obj);
              break;
            case DbType.Byte:
              this._sql.Bind_UInt32(this, this._flags, index, (uint) Convert.ToByte(obj, (IFormatProvider) provider));
              break;
            case DbType.Boolean:
              this._sql.Bind_Boolean(this, this._flags, index, SQLiteConvert.ToBoolean(obj, (IFormatProvider) provider, true));
              break;
            case DbType.Currency:
            case DbType.Double:
            case DbType.Single:
              this._sql.Bind_Double(this, this._flags, index, Convert.ToDouble(obj, (IFormatProvider) provider));
              break;
            case DbType.Date:
            case DbType.DateTime:
            case DbType.Time:
              this._sql.Bind_DateTime(this, this._flags, index, obj is string ? this._sql.ToDateTime((string) obj) : Convert.ToDateTime(obj, (IFormatProvider) provider));
              break;
            case DbType.Decimal:
              this._sql.Bind_Text(this, this._flags, index, Convert.ToDecimal(obj, (IFormatProvider) provider).ToString((IFormatProvider) invariantCulture));
              break;
            case DbType.Guid:
              if (this._command.Connection._binaryGuid)
              {
                this._sql.Bind_Blob(this, this._flags, index, ((Guid) obj).ToByteArray());
                break;
              }
              this._sql.Bind_Text(this, this._flags, index, flag ? SQLiteConvert.ToStringWithProvider(obj, (IFormatProvider) invariantCulture) : obj.ToString());
              break;
            case DbType.Int16:
              this._sql.Bind_Int32(this, this._flags, index, (int) Convert.ToInt16(obj, (IFormatProvider) provider));
              break;
            case DbType.Int32:
              this._sql.Bind_Int32(this, this._flags, index, Convert.ToInt32(obj, (IFormatProvider) provider));
              break;
            case DbType.Int64:
              this._sql.Bind_Int64(this, this._flags, index, Convert.ToInt64(obj, (IFormatProvider) provider));
              break;
            case DbType.SByte:
              this._sql.Bind_Int32(this, this._flags, index, (int) Convert.ToSByte(obj, (IFormatProvider) provider));
              break;
            case DbType.UInt16:
              this._sql.Bind_UInt32(this, this._flags, index, (uint) Convert.ToUInt16(obj, (IFormatProvider) provider));
              break;
            case DbType.UInt32:
              this._sql.Bind_UInt32(this, this._flags, index, Convert.ToUInt32(obj, (IFormatProvider) provider));
              break;
            case DbType.UInt64:
              this._sql.Bind_UInt64(this, this._flags, index, Convert.ToUInt64(obj, (IFormatProvider) provider));
              break;
            default:
              this._sql.Bind_Text(this, this._flags, index, flag ? SQLiteConvert.ToStringWithProvider(obj, (IFormatProvider) invariantCulture) : obj.ToString());
              break;
          }
        }
      }
    }

    internal string[] TypeDefinitions => this._types;

    internal void SetTypes(string typedefs)
    {
      int num = typedefs.IndexOf("TYPES", 0, StringComparison.OrdinalIgnoreCase);
      if (num == -1)
        throw new ArgumentOutOfRangeException();
      string[] strArray = typedefs.Substring(num + 6).Replace(" ", string.Empty).Replace(";", string.Empty).Replace("\"", string.Empty).Replace("[", string.Empty).Replace("]", string.Empty).Replace("`", string.Empty).Split(',', '\r', '\n', '\t');
      for (int index = 0; index < strArray.Length; ++index)
      {
        if (string.IsNullOrEmpty(strArray[index]))
          strArray[index] = (string) null;
      }
      this._types = strArray;
    }
  }
}


--- SQLiteStatementHandle.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteStatementHandle
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;
using System.Threading;

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLiteStatementHandle : CriticalHandle
  {
    private SQLiteConnectionHandle cnn;

    public static implicit operator IntPtr(SQLiteStatementHandle stmt)
    {
      return stmt != null ? stmt.handle : IntPtr.Zero;
    }

    internal SQLiteStatementHandle(SQLiteConnectionHandle cnn, IntPtr stmt)
      : this()
    {
      this.cnn = cnn;
      this.SetHandle(stmt);
    }

    private SQLiteStatementHandle()
      : base(IntPtr.Zero)
    {
    }

    protected override bool ReleaseHandle()
    {
      try
      {
        IntPtr stmt = Interlocked.Exchange(ref this.handle, IntPtr.Zero);
        if (stmt != IntPtr.Zero)
          SQLiteBase.FinalizeStatement(this.cnn, stmt);
      }
      catch (SQLiteException ex)
      {
      }
      finally
      {
        this.SetHandleAsInvalid();
      }
      return true;
    }

    public override bool IsInvalid => this.handle == IntPtr.Zero;
  }
}


--- SQLiteStepDelegate.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteStepDelegate
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate void SQLiteStepDelegate(
    string param0,
    object[] args,
    int stepNumber,
    ref object contextData);
}


--- SQLiteString.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteString
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;
using System.Text;

#nullable disable
namespace System.Data.SQLite
{
  internal static class SQLiteString
  {
    private static int ThirtyBits = 1073741823;
    private static readonly Encoding Utf8Encoding = Encoding.UTF8;

    public static byte[] GetUtf8BytesFromString(string value)
    {
      return value == null ? (byte[]) null : SQLiteString.Utf8Encoding.GetBytes(value);
    }

    public static string GetStringFromUtf8Bytes(byte[] bytes)
    {
      return bytes == null ? (string) null : SQLiteString.Utf8Encoding.GetString(bytes);
    }

    public static int ProbeForUtf8ByteLength(IntPtr pValue, int limit)
    {
      int ofs = 0;
      if (pValue != IntPtr.Zero && limit > 0)
      {
        while (Marshal.ReadByte(pValue, ofs) != (byte) 0 && ofs < limit)
          ++ofs;
      }
      return ofs;
    }

    public static string StringFromUtf8IntPtr(IntPtr pValue)
    {
      return SQLiteString.StringFromUtf8IntPtr(pValue, SQLiteString.ProbeForUtf8ByteLength(pValue, SQLiteString.ThirtyBits));
    }

    public static string StringFromUtf8IntPtr(IntPtr pValue, int length)
    {
      if (pValue == IntPtr.Zero)
        return (string) null;
      if (length <= 0)
        return string.Empty;
      byte[] numArray = new byte[length];
      Marshal.Copy(pValue, numArray, 0, length);
      return SQLiteString.GetStringFromUtf8Bytes(numArray);
    }

    public static IntPtr Utf8IntPtrFromString(string value)
    {
      if (value == null)
        return IntPtr.Zero;
      IntPtr zero = IntPtr.Zero;
      byte[] utf8BytesFromString = SQLiteString.GetUtf8BytesFromString(value);
      if (utf8BytesFromString == null)
        return IntPtr.Zero;
      int length = utf8BytesFromString.Length;
      IntPtr num = SQLiteMemory.Allocate(length + 1);
      if (num == IntPtr.Zero)
        return IntPtr.Zero;
      Marshal.Copy(utf8BytesFromString, 0, num, length);
      Marshal.WriteByte(num, length, (byte) 0);
      return num;
    }

    public static string[] StringArrayFromUtf8SizeAndIntPtr(int argc, IntPtr argv)
    {
      if (argc < 0)
        return (string[]) null;
      if (argv == IntPtr.Zero)
        return (string[]) null;
      string[] strArray = new string[argc];
      int index = 0;
      int offset = 0;
      while (index < strArray.Length)
      {
        IntPtr pValue = SQLiteMarshal.ReadIntPtr(argv, offset);
        strArray[index] = pValue != IntPtr.Zero ? SQLiteString.StringFromUtf8IntPtr(pValue) : (string) null;
        ++index;
        offset += IntPtr.Size;
      }
      return strArray;
    }

    public static IntPtr[] Utf8IntPtrArrayFromStringArray(string[] values)
    {
      if (values == null)
        return (IntPtr[]) null;
      IntPtr[] numArray = new IntPtr[values.Length];
      for (int index = 0; index < numArray.Length; ++index)
        numArray[index] = SQLiteString.Utf8IntPtrFromString(values[index]);
      return numArray;
    }
  }
}


--- SQLiteSynchronousEnum.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteSynchronousEnum
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  internal enum SQLiteSynchronousEnum
  {
    Default = -1, // 0xFFFFFFFF
    Off = 0,
    Normal = 1,
    Full = 2,
  }
}


--- SQLiteTraceCallback.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteTraceCallback
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  internal delegate void SQLiteTraceCallback(IntPtr puser, IntPtr statement);
}


--- SQLiteTraceEventHandler.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteTraceEventHandler
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate void SQLiteTraceEventHandler(object sender, TraceEventArgs e);
}


--- SQLiteTransaction.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteTransaction
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Data.Common;
using System.Threading;

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteTransaction : DbTransaction
  {
    internal SQLiteConnection _cnn;
    internal int _version;
    private IsolationLevel _level;
    private bool disposed;

    internal SQLiteTransaction(SQLiteConnection connection, bool deferredLock)
    {
      this._cnn = connection;
      this._version = this._cnn._version;
      this._level = deferredLock ? IsolationLevel.ReadCommitted : IsolationLevel.Serializable;
      if (this._cnn._transactionLevel++ != 0)
        return;
      try
      {
        using (SQLiteCommand command = this._cnn.CreateCommand())
        {
          if (!deferredLock)
            command.CommandText = "BEGIN IMMEDIATE";
          else
            command.CommandText = "BEGIN";
          command.ExecuteNonQuery();
        }
      }
      catch (SQLiteException ex)
      {
        --this._cnn._transactionLevel;
        this._cnn = (SQLiteConnection) null;
        throw;
      }
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteTransaction).Name);
    }

    protected override void Dispose(bool disposing)
    {
      try
      {
        if (this.disposed || !disposing || !this.IsValid(false))
          return;
        this.IssueRollback(false);
      }
      finally
      {
        base.Dispose(disposing);
        this.disposed = true;
      }
    }

    public override void Commit()
    {
      this.CheckDisposed();
      this.IsValid(true);
      if (this._cnn._transactionLevel - 1 == 0)
      {
        using (SQLiteCommand command = this._cnn.CreateCommand())
        {
          command.CommandText = "COMMIT";
          command.ExecuteNonQuery();
        }
      }
      --this._cnn._transactionLevel;
      this._cnn = (SQLiteConnection) null;
    }

    public SQLiteConnection Connection
    {
      get
      {
        this.CheckDisposed();
        return this._cnn;
      }
    }

    protected override DbConnection DbConnection => (DbConnection) this.Connection;

    public override IsolationLevel IsolationLevel
    {
      get
      {
        this.CheckDisposed();
        return this._level;
      }
    }

    public override void Rollback()
    {
      this.CheckDisposed();
      this.IsValid(true);
      this.IssueRollback(true);
    }

    internal void IssueRollback(bool throwError)
    {
      SQLiteConnection sqLiteConnection = Interlocked.Exchange<SQLiteConnection>(ref this._cnn, (SQLiteConnection) null);
      if (sqLiteConnection == null)
        return;
      try
      {
        using (SQLiteCommand command = sqLiteConnection.CreateCommand())
        {
          command.CommandText = "ROLLBACK";
          command.ExecuteNonQuery();
        }
      }
      catch
      {
        if (throwError)
          throw;
      }
      sqLiteConnection._transactionLevel = 0;
    }

    internal bool IsValid(bool throwError)
    {
      if (this._cnn == null)
      {
        if (throwError)
          throw new ArgumentNullException("No connection associated with this transaction");
        return false;
      }
      if (this._cnn._version != this._version)
      {
        if (throwError)
          throw new SQLiteException("The connection was closed and re-opened, changes were already rolled back");
        return false;
      }
      if (this._cnn.State != ConnectionState.Open)
      {
        if (throwError)
          throw new SQLiteException("Connection was closed");
        return false;
      }
      if (this._cnn._transactionLevel != 0 && !this._cnn._sql.AutoCommit)
        return true;
      this._cnn._transactionLevel = 0;
      if (throwError)
        throw new SQLiteException("No transaction is active on this connection");
      return false;
    }
  }
}


--- SQLiteType.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteType
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLiteType
  {
    internal DbType Type;
    internal TypeAffinity Affinity;

    public SQLiteType()
    {
    }

    public SQLiteType(TypeAffinity affinity, DbType type)
      : this()
    {
      this.Affinity = affinity;
      this.Type = type;
    }
  }
}


--- SQLiteTypeCallbacks.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteTypeCallbacks
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteTypeCallbacks
  {
    private string typeName;
    private SQLiteBindValueCallback bindValueCallback;
    private SQLiteReadValueCallback readValueCallback;
    private object bindValueUserData;
    private object readValueUserData;

    private SQLiteTypeCallbacks(
      SQLiteBindValueCallback bindValueCallback,
      SQLiteReadValueCallback readValueCallback,
      object bindValueUserData,
      object readValueUserData)
    {
      this.bindValueCallback = bindValueCallback;
      this.readValueCallback = readValueCallback;
      this.bindValueUserData = bindValueUserData;
      this.readValueUserData = readValueUserData;
    }

    public static SQLiteTypeCallbacks Create(
      SQLiteBindValueCallback bindValueCallback,
      SQLiteReadValueCallback readValueCallback,
      object bindValueUserData,
      object readValueUserData)
    {
      return new SQLiteTypeCallbacks(bindValueCallback, readValueCallback, bindValueUserData, readValueUserData);
    }

    public string TypeName
    {
      get => this.typeName;
      internal set => this.typeName = value;
    }

    public SQLiteBindValueCallback BindValueCallback => this.bindValueCallback;

    public SQLiteReadValueCallback ReadValueCallback => this.readValueCallback;

    public object BindValueUserData => this.bindValueUserData;

    public object ReadValueUserData => this.readValueUserData;
  }
}


--- SQLiteTypeCallbacksMap.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteTypeCallbacksMap
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class SQLiteTypeCallbacksMap : Dictionary<string, SQLiteTypeCallbacks>
  {
    public SQLiteTypeCallbacksMap()
      : base((IEqualityComparer<string>) new TypeNameStringComparer())
    {
    }
  }
}


--- SQLiteUpdateCallback.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteUpdateCallback
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;

#nullable disable
namespace System.Data.SQLite
{
  [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
  internal delegate void SQLiteUpdateCallback(
    IntPtr puser,
    int type,
    IntPtr database,
    IntPtr table,
    long rowid);
}


--- SQLiteUpdateEventHandler.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteUpdateEventHandler
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public delegate void SQLiteUpdateEventHandler(object sender, UpdateEventArgs e);
}


--- SQLiteValue.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteValue
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public sealed class SQLiteValue : ISQLiteNativeHandle
  {
    private IntPtr pValue;
    private bool persisted;
    private object value;

    private SQLiteValue(IntPtr pValue) => this.pValue = pValue;

    private void PreventNativeAccess() => this.pValue = IntPtr.Zero;

    internal static SQLiteValue[] ArrayFromSizeAndIntPtr(int argc, IntPtr argv)
    {
      if (argc < 0)
        return (SQLiteValue[]) null;
      if (argv == IntPtr.Zero)
        return (SQLiteValue[]) null;
      SQLiteValue[] sqLiteValueArray = new SQLiteValue[argc];
      int index = 0;
      int offset = 0;
      while (index < sqLiteValueArray.Length)
      {
        IntPtr pValue = SQLiteMarshal.ReadIntPtr(argv, offset);
        sqLiteValueArray[index] = pValue != IntPtr.Zero ? new SQLiteValue(pValue) : (SQLiteValue) null;
        ++index;
        offset += IntPtr.Size;
      }
      return sqLiteValueArray;
    }

    public IntPtr NativeHandle => this.pValue;

    public bool Persisted => this.persisted;

    public object Value
    {
      get
      {
        if (!this.persisted)
          throw new InvalidOperationException("value was not persisted");
        return this.value;
      }
    }

    public TypeAffinity GetTypeAffinity()
    {
      return this.pValue == IntPtr.Zero ? TypeAffinity.None : UnsafeNativeMethods.sqlite3_value_type(this.pValue);
    }

    public int GetBytes()
    {
      return this.pValue == IntPtr.Zero ? 0 : UnsafeNativeMethods.sqlite3_value_bytes(this.pValue);
    }

    public int GetInt()
    {
      return this.pValue == IntPtr.Zero ? 0 : UnsafeNativeMethods.sqlite3_value_int(this.pValue);
    }

    public long GetInt64()
    {
      return this.pValue == IntPtr.Zero ? 0L : UnsafeNativeMethods.sqlite3_value_int64(this.pValue);
    }

    public double GetDouble()
    {
      return this.pValue == IntPtr.Zero ? 0.0 : UnsafeNativeMethods.sqlite3_value_double(this.pValue);
    }

    public string GetString()
    {
      if (this.pValue == IntPtr.Zero)
        return (string) null;
      int len = 0;
      return SQLiteString.StringFromUtf8IntPtr(UnsafeNativeMethods.sqlite3_value_text_interop(this.pValue, ref len), len);
    }

    public byte[] GetBlob()
    {
      return this.pValue == IntPtr.Zero ? (byte[]) null : SQLiteBytes.FromIntPtr(UnsafeNativeMethods.sqlite3_value_blob(this.pValue), this.GetBytes());
    }

    public bool Persist()
    {
      switch (this.GetTypeAffinity())
      {
        case TypeAffinity.Uninitialized:
          this.value = (object) null;
          this.PreventNativeAccess();
          return this.persisted = true;
        case TypeAffinity.Int64:
          this.value = (object) this.GetInt64();
          this.PreventNativeAccess();
          return this.persisted = true;
        case TypeAffinity.Double:
          this.value = (object) this.GetDouble();
          this.PreventNativeAccess();
          return this.persisted = true;
        case TypeAffinity.Text:
          this.value = (object) this.GetString();
          this.PreventNativeAccess();
          return this.persisted = true;
        case TypeAffinity.Blob:
          this.value = (object) this.GetBytes();
          this.PreventNativeAccess();
          return this.persisted = true;
        case TypeAffinity.Null:
          this.value = (object) DBNull.Value;
          this.PreventNativeAccess();
          return this.persisted = true;
        default:
          return false;
      }
    }
  }
}


--- SQLiteVirtualTable.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteVirtualTable
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public class SQLiteVirtualTable : ISQLiteNativeHandle, IDisposable
  {
    private const int ModuleNameIndex = 0;
    private const int DatabaseNameIndex = 1;
    private const int TableNameIndex = 2;
    private string[] arguments;
    private SQLiteIndex index;
    private IntPtr nativeHandle;
    private bool disposed;

    public SQLiteVirtualTable(string[] arguments) => this.arguments = arguments;

    public virtual string[] Arguments
    {
      get
      {
        this.CheckDisposed();
        return this.arguments;
      }
    }

    public virtual string ModuleName
    {
      get
      {
        this.CheckDisposed();
        string[] arguments = this.Arguments;
        return arguments != null && arguments.Length > 0 ? arguments[0] : (string) null;
      }
    }

    public virtual string DatabaseName
    {
      get
      {
        this.CheckDisposed();
        string[] arguments = this.Arguments;
        return arguments != null && arguments.Length > 1 ? arguments[1] : (string) null;
      }
    }

    public virtual string TableName
    {
      get
      {
        this.CheckDisposed();
        string[] arguments = this.Arguments;
        return arguments != null && arguments.Length > 2 ? arguments[2] : (string) null;
      }
    }

    public virtual SQLiteIndex Index
    {
      get
      {
        this.CheckDisposed();
        return this.index;
      }
    }

    public virtual bool BestIndex(SQLiteIndex index)
    {
      this.CheckDisposed();
      this.index = index;
      return true;
    }

    public virtual bool Rename(string name)
    {
      this.CheckDisposed();
      if (this.arguments == null || this.arguments.Length <= 2)
        return false;
      this.arguments[2] = name;
      return true;
    }

    public virtual IntPtr NativeHandle
    {
      get
      {
        this.CheckDisposed();
        return this.nativeHandle;
      }
      internal set => this.nativeHandle = value;
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteVirtualTable).Name);
    }

    protected virtual void Dispose(bool disposing)
    {
      if (this.disposed)
        return;
      this.disposed = true;
    }

    ~SQLiteVirtualTable() => this.Dispose(false);
  }
}


--- SQLiteVirtualTableCursor.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteVirtualTableCursor
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public class SQLiteVirtualTableCursor : ISQLiteNativeHandle, IDisposable
  {
    protected static readonly int InvalidRowIndex;
    private int rowIndex;
    private SQLiteVirtualTable table;
    private int indexNumber;
    private string indexString;
    private SQLiteValue[] values;
    private IntPtr nativeHandle;
    private bool disposed;

    public SQLiteVirtualTableCursor(SQLiteVirtualTable table)
      : this()
    {
      this.table = table;
    }

    private SQLiteVirtualTableCursor() => this.rowIndex = SQLiteVirtualTableCursor.InvalidRowIndex;

    public virtual SQLiteVirtualTable Table
    {
      get
      {
        this.CheckDisposed();
        return this.table;
      }
    }

    public virtual int IndexNumber
    {
      get
      {
        this.CheckDisposed();
        return this.indexNumber;
      }
    }

    public virtual string IndexString
    {
      get
      {
        this.CheckDisposed();
        return this.indexString;
      }
    }

    public virtual SQLiteValue[] Values
    {
      get
      {
        this.CheckDisposed();
        return this.values;
      }
    }

    protected virtual int TryPersistValues(SQLiteValue[] values)
    {
      int num = 0;
      if (values != null)
      {
        foreach (SQLiteValue sqLiteValue in values)
        {
          if (sqLiteValue != null && sqLiteValue.Persist())
            ++num;
        }
      }
      return num;
    }

    public virtual void Filter(int indexNumber, string indexString, SQLiteValue[] values)
    {
      this.CheckDisposed();
      if (values != null && this.TryPersistValues(values) != values.Length)
        throw new SQLiteException("failed to persist one or more values");
      this.indexNumber = indexNumber;
      this.indexString = indexString;
      this.values = values;
    }

    public virtual int GetRowIndex() => this.rowIndex;

    public virtual void NextRowIndex() => ++this.rowIndex;

    public virtual IntPtr NativeHandle
    {
      get
      {
        this.CheckDisposed();
        return this.nativeHandle;
      }
      internal set => this.nativeHandle = value;
    }

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteVirtualTableCursor).Name);
    }

    protected virtual void Dispose(bool disposing)
    {
      if (this.disposed)
        return;
      this.disposed = true;
    }

    ~SQLiteVirtualTableCursor() => this.Dispose(false);
  }
}


--- SQLiteVirtualTableCursorEnumerator.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SQLiteVirtualTableCursorEnumerator
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections;

#nullable disable
namespace System.Data.SQLite
{
  public class SQLiteVirtualTableCursorEnumerator : SQLiteVirtualTableCursor, IEnumerator
  {
    private IEnumerator enumerator;
    private bool endOfEnumerator;
    private bool disposed;

    public SQLiteVirtualTableCursorEnumerator(SQLiteVirtualTable table, IEnumerator enumerator)
      : base(table)
    {
      this.enumerator = enumerator;
      this.endOfEnumerator = true;
    }

    public virtual bool MoveNext()
    {
      this.CheckDisposed();
      this.CheckClosed();
      if (this.enumerator == null)
        return false;
      this.endOfEnumerator = !this.enumerator.MoveNext();
      if (!this.endOfEnumerator)
        this.NextRowIndex();
      return !this.endOfEnumerator;
    }

    public virtual object Current
    {
      get
      {
        this.CheckDisposed();
        this.CheckClosed();
        return this.enumerator == null ? (object) null : this.enumerator.Current;
      }
    }

    public virtual void Reset()
    {
      this.CheckDisposed();
      this.CheckClosed();
      if (this.enumerator == null)
        return;
      this.enumerator.Reset();
    }

    public virtual bool EndOfEnumerator
    {
      get
      {
        this.CheckDisposed();
        this.CheckClosed();
        return this.endOfEnumerator;
      }
    }

    public virtual bool IsOpen
    {
      get
      {
        this.CheckDisposed();
        return this.enumerator != null;
      }
    }

    public virtual void Close()
    {
      if (this.enumerator == null)
        return;
      this.enumerator = (IEnumerator) null;
    }

    public virtual void CheckClosed()
    {
      this.CheckDisposed();
      if (!this.IsOpen)
        throw new InvalidOperationException("virtual table cursor is closed");
    }

    private void CheckDisposed()
    {
      if (this.disposed)
        throw new ObjectDisposedException(typeof (SQLiteVirtualTableCursorEnumerator).Name);
    }

    protected override void Dispose(bool disposing)
    {
      try
      {
        if (this.disposed)
          return;
        this.Close();
      }
      finally
      {
        base.Dispose(disposing);
        this.disposed = true;
      }
    }
  }
}


--- SR.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SR
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Resources;
using System.Runtime.CompilerServices;

#nullable disable
namespace System.Data.SQLite
{
  [GeneratedCode("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
  [DebuggerNonUserCode]
  [CompilerGenerated]
  internal sealed class SR
  {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;

    internal SR()
    {
    }

    [EditorBrowsable(EditorBrowsableState.Advanced)]
    internal static ResourceManager ResourceManager
    {
      get
      {
        if (object.ReferenceEquals((object) SR.resourceMan, (object) null))
          SR.resourceMan = new ResourceManager("System.Data.SQLite.SR", typeof (SR).Assembly);
        return SR.resourceMan;
      }
    }

    [EditorBrowsable(EditorBrowsableState.Advanced)]
    internal static CultureInfo Culture
    {
      get => SR.resourceCulture;
      set => SR.resourceCulture = value;
    }

    internal static string DataTypes
    {
      get => SR.ResourceManager.GetString(nameof (DataTypes), SR.resourceCulture);
    }

    internal static string Keywords
    {
      get => SR.ResourceManager.GetString(nameof (Keywords), SR.resourceCulture);
    }

    internal static string MetaDataCollections
    {
      get => SR.ResourceManager.GetString(nameof (MetaDataCollections), SR.resourceCulture);
    }
  }
}


--- SynchronizationModes.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.SynchronizationModes
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum SynchronizationModes
  {
    Normal,
    Full,
    Off,
  }
}


--- TraceEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.TraceEventArgs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public class TraceEventArgs : EventArgs
  {
    public readonly string Statement;

    internal TraceEventArgs(string statement) => this.Statement = statement;
  }
}


--- TypeAffinity.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.TypeAffinity
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum TypeAffinity
  {
    Uninitialized = 0,
    Int64 = 1,
    Double = 2,
    Text = 3,
    Blob = 4,
    Null = 5,
    DateTime = 10, // 0x0000000A
    None = 11, // 0x0000000B
  }
}


--- TypeNameStringComparer.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.TypeNameStringComparer
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;

#nullable disable
namespace System.Data.SQLite
{
  internal sealed class TypeNameStringComparer : IEqualityComparer<string>, IComparer<string>
  {
    public bool Equals(string left, string right)
    {
      return string.Equals(left, right, StringComparison.OrdinalIgnoreCase);
    }

    public int GetHashCode(string value)
    {
      return value != null ? value.ToLowerInvariant().GetHashCode() : throw new ArgumentNullException(nameof (value));
    }

    public int Compare(string x, string y)
    {
      if (x == null && y == null)
        return 0;
      if (x == null)
        return -1;
      return y == null ? 1 : x.CompareTo(y);
    }
  }
}


--- UnsafeNativeMethods.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.UnsafeNativeMethods
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security;
using System.Text;
using System.Xml;

#nullable disable
namespace System.Data.SQLite
{
  [SuppressUnmanagedCodeSecurity]
  internal static class UnsafeNativeMethods
  {
    internal const string SQLITE_DLL = "SQLite.Interop.dll";
    private static readonly string DllFileExtension = ".dll";
    private static readonly string ConfigFileExtension = ".config";
    private static readonly string XmlConfigFileName = typeof (UnsafeNativeMethods).Namespace + UnsafeNativeMethods.DllFileExtension + UnsafeNativeMethods.ConfigFileExtension;
    private static readonly object staticSyncRoot = new object();
    private static Dictionary<string, string> processorArchitecturePlatforms;
    private static readonly string PROCESSOR_ARCHITECTURE = nameof (PROCESSOR_ARCHITECTURE);
    internal static string _SQLiteNativeModuleFileName = (string) null;
    private static IntPtr _SQLiteNativeModuleHandle = IntPtr.Zero;

    static UnsafeNativeMethods() => UnsafeNativeMethods.Initialize();

    internal static void Initialize()
    {
      if (UnsafeNativeMethods.GetSettingValue("No_PreLoadSQLite", (string) null) != null)
        return;
      lock (UnsafeNativeMethods.staticSyncRoot)
      {
        if (UnsafeNativeMethods.processorArchitecturePlatforms == null)
        {
          UnsafeNativeMethods.processorArchitecturePlatforms = new Dictionary<string, string>((IEqualityComparer<string>) StringComparer.OrdinalIgnoreCase);
          UnsafeNativeMethods.processorArchitecturePlatforms.Add("x86", "Win32");
          UnsafeNativeMethods.processorArchitecturePlatforms.Add("AMD64", "x64");
          UnsafeNativeMethods.processorArchitecturePlatforms.Add("IA64", "Itanium");
          UnsafeNativeMethods.processorArchitecturePlatforms.Add("ARM", "WinCE");
        }
        if (!(UnsafeNativeMethods._SQLiteNativeModuleHandle == IntPtr.Zero))
          return;
        string baseDirectory = (string) null;
        string processorArchitecture = (string) null;
        UnsafeNativeMethods.SearchForDirectory(ref baseDirectory, ref processorArchitecture);
        UnsafeNativeMethods.PreLoadSQLiteDll(baseDirectory, processorArchitecture, ref UnsafeNativeMethods._SQLiteNativeModuleFileName, ref UnsafeNativeMethods._SQLiteNativeModuleHandle);
      }
    }

    private static string MaybeCombinePath(string path1, string path2)
    {
      return path1 != null ? (path2 != null ? Path.Combine(path1, path2) : path1) : (path2 != null ? path2 : (string) null);
    }

    private static string GetXmlConfigFileName()
    {
      string path1 = UnsafeNativeMethods.MaybeCombinePath(AppDomain.CurrentDomain.BaseDirectory, UnsafeNativeMethods.XmlConfigFileName);
      if (File.Exists(path1))
        return path1;
      string path2 = UnsafeNativeMethods.MaybeCombinePath(UnsafeNativeMethods.GetAssemblyDirectory(), UnsafeNativeMethods.XmlConfigFileName);
      return File.Exists(path2) ? path2 : (string) null;
    }

    private static string GetSettingValueViaXmlConfigFile(
      string fileName,
      string name,
      string @default,
      bool expand)
    {
      try
      {
        if (fileName == null || name == null)
          return @default;
        XmlDocument xmlDocument = new XmlDocument();
        xmlDocument.Load(fileName);
        if (xmlDocument.SelectSingleNode(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "/configuration/appSettings/add[@key='{0}']", (object) name)) is XmlElement xmlElement)
        {
          string name1 = (string) null;
          if (xmlElement.HasAttribute("value"))
            name1 = xmlElement.GetAttribute("value");
          if (expand && !string.IsNullOrEmpty(name1))
            name1 = Environment.ExpandEnvironmentVariables(name1);
          if (name1 != null)
            return name1;
        }
      }
      catch (Exception ex)
      {
        try
        {
          Trace.WriteLine(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Native library pre-loader failed to get setting \"{0}\" value from XML configuration file \"{1}\": {2}", (object) name, (object) fileName, (object) ex));
        }
        catch
        {
        }
      }
      return @default;
    }

    internal static string GetSettingValue(string name, string @default)
    {
      if (Environment.GetEnvironmentVariable("No_SQLiteGetSettingValue") != null || name == null)
        return @default;
      bool expand = true;
      if (Environment.GetEnvironmentVariable("No_Expand") != null)
        expand = false;
      else if (Environment.GetEnvironmentVariable(HelperMethods.StringFormat((IFormatProvider) CultureInfo.InvariantCulture, "No_Expand_{0}", (object) name)) != null)
        expand = false;
      string name1 = Environment.GetEnvironmentVariable(name);
      if (expand && !string.IsNullOrEmpty(name1))
        name1 = Environment.ExpandEnvironmentVariables(name1);
      if (name1 != null)
        return name1;
      return Environment.GetEnvironmentVariable("No_SQLiteXmlConfigFile") != null ? @default : UnsafeNativeMethods.GetSettingValueViaXmlConfigFile(UnsafeNativeMethods.GetXmlConfigFileName(), name, @default, expand);
    }

    private static string ListToString(IList<string> list)
    {
      if (list == null)
        return (string) null;
      StringBuilder stringBuilder = new StringBuilder();
      foreach (string str in (IEnumerable<string>) list)
      {
        if (str != null)
        {
          if (stringBuilder.Length > 0)
            stringBuilder.Append(' ');
          stringBuilder.Append(str);
        }
      }
      return stringBuilder.ToString();
    }

    private static int CheckForArchitecturesAndPlatforms(string directory, ref List<string> matches)
    {
      int num = 0;
      if (matches == null)
        matches = new List<string>();
      lock (UnsafeNativeMethods.staticSyncRoot)
      {
        if (!string.IsNullOrEmpty(directory))
        {
          if (UnsafeNativeMethods.processorArchitecturePlatforms != null)
          {
            foreach (KeyValuePair<string, string> architecturePlatform in UnsafeNativeMethods.processorArchitecturePlatforms)
            {
              if (Directory.Exists(UnsafeNativeMethods.MaybeCombinePath(directory, architecturePlatform.Key)))
              {
                matches.Add(architecturePlatform.Key);
                ++num;
              }
              string path2 = architecturePlatform.Value;
              if (path2 != null && Directory.Exists(UnsafeNativeMethods.MaybeCombinePath(directory, path2)))
              {
                matches.Add(path2);
                ++num;
              }
            }
          }
        }
      }
      return num;
    }

    private static bool CheckAssemblyCodeBase(Assembly assembly, ref string fileName)
    {
      try
      {
        if (assembly == (Assembly) null)
          return false;
        string codeBase = assembly.CodeBase;
        if (string.IsNullOrEmpty(codeBase))
          return false;
        string localPath = new Uri(codeBase).LocalPath;
        if (!File.Exists(localPath))
          return false;
        string directoryName = Path.GetDirectoryName(localPath);
        if (File.Exists(UnsafeNativeMethods.MaybeCombinePath(directoryName, UnsafeNativeMethods.XmlConfigFileName)))
        {
          fileName = localPath;
          return true;
        }
        List<string> matches = (List<string>) null;
        if (UnsafeNativeMethods.CheckForArchitecturesAndPlatforms(directoryName, ref matches) <= 0)
          return false;
        fileName = localPath;
        return true;
      }
      catch (Exception ex)
      {
        try
        {
          Trace.WriteLine(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Native library pre-loader failed to check code base for currently executing assembly: {0}", (object) ex));
        }
        catch
        {
        }
      }
      return false;
    }

    private static string GetAssemblyDirectory()
    {
      try
      {
        Assembly executingAssembly = Assembly.GetExecutingAssembly();
        if (executingAssembly == (Assembly) null)
          return (string) null;
        string fileName = (string) null;
        if (!UnsafeNativeMethods.CheckAssemblyCodeBase(executingAssembly, ref fileName))
          fileName = executingAssembly.Location;
        if (string.IsNullOrEmpty(fileName))
          return (string) null;
        string directoryName = Path.GetDirectoryName(fileName);
        return string.IsNullOrEmpty(directoryName) ? (string) null : directoryName;
      }
      catch (Exception ex)
      {
        try
        {
          Trace.WriteLine(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Native library pre-loader failed to get directory for currently executing assembly: {0}", (object) ex));
        }
        catch
        {
        }
      }
      return (string) null;
    }

    internal static string GetNativeLibraryFileNameOnly()
    {
      return UnsafeNativeMethods.GetSettingValue("PreLoadSQLite_LibraryFileNameOnly", (string) null) ?? "SQLite.Interop.dll";
    }

    private static bool SearchForDirectory(
      ref string baseDirectory,
      ref string processorArchitecture)
    {
      if (UnsafeNativeMethods.GetSettingValue("PreLoadSQLite_NoSearchForDirectory", (string) null) != null)
        return false;
      string libraryFileNameOnly = UnsafeNativeMethods.GetNativeLibraryFileNameOnly();
      if (libraryFileNameOnly == null)
        return false;
      string[] strArray1 = new string[2]
      {
        UnsafeNativeMethods.GetAssemblyDirectory(),
        AppDomain.CurrentDomain.BaseDirectory
      };
      string[] strArray2 = new string[2]
      {
        UnsafeNativeMethods.GetProcessorArchitecture(),
        UnsafeNativeMethods.GetPlatformName((string) null)
      };
      foreach (string path1 in strArray1)
      {
        if (path1 != null)
        {
          foreach (string path2 in strArray2)
          {
            if (path2 != null && File.Exists(UnsafeNativeMethods.FixUpDllFileName(UnsafeNativeMethods.MaybeCombinePath(UnsafeNativeMethods.MaybeCombinePath(path1, path2), libraryFileNameOnly))))
            {
              baseDirectory = path1;
              processorArchitecture = path2;
              return true;
            }
          }
        }
      }
      return false;
    }

    private static string GetBaseDirectory()
    {
      string settingValue = UnsafeNativeMethods.GetSettingValue("PreLoadSQLite_BaseDirectory", (string) null);
      if (settingValue != null)
        return settingValue;
      if (UnsafeNativeMethods.GetSettingValue("PreLoadSQLite_UseAssemblyDirectory", (string) null) != null)
      {
        string assemblyDirectory = UnsafeNativeMethods.GetAssemblyDirectory();
        if (assemblyDirectory != null)
          return assemblyDirectory;
      }
      return AppDomain.CurrentDomain.BaseDirectory;
    }

    private static string FixUpDllFileName(string fileName)
    {
      return !string.IsNullOrEmpty(fileName) && HelperMethods.IsWindows() && !fileName.EndsWith(UnsafeNativeMethods.DllFileExtension, StringComparison.OrdinalIgnoreCase) ? fileName + UnsafeNativeMethods.DllFileExtension : fileName;
    }

    private static string GetProcessorArchitecture()
    {
      string settingValue = UnsafeNativeMethods.GetSettingValue("PreLoadSQLite_ProcessorArchitecture", (string) null);
      if (settingValue != null)
        return settingValue;
      string a = UnsafeNativeMethods.GetSettingValue(UnsafeNativeMethods.PROCESSOR_ARCHITECTURE, (string) null);
      if (IntPtr.Size == 4 && string.Equals(a, "AMD64", StringComparison.OrdinalIgnoreCase))
        a = "x86";
      return a;
    }

    private static string GetPlatformName(string processorArchitecture)
    {
      if (processorArchitecture == null)
        processorArchitecture = UnsafeNativeMethods.GetProcessorArchitecture();
      if (string.IsNullOrEmpty(processorArchitecture))
        return (string) null;
      lock (UnsafeNativeMethods.staticSyncRoot)
      {
        if (UnsafeNativeMethods.processorArchitecturePlatforms == null)
          return (string) null;
        string platformName;
        if (UnsafeNativeMethods.processorArchitecturePlatforms.TryGetValue(processorArchitecture, out platformName))
          return platformName;
      }
      return (string) null;
    }

    private static bool PreLoadSQLiteDll(
      string baseDirectory,
      string processorArchitecture,
      ref string nativeModuleFileName,
      ref IntPtr nativeModuleHandle)
    {
      if (baseDirectory == null)
        baseDirectory = UnsafeNativeMethods.GetBaseDirectory();
      if (baseDirectory == null)
        return false;
      string libraryFileNameOnly = UnsafeNativeMethods.GetNativeLibraryFileNameOnly();
      if (libraryFileNameOnly == null || File.Exists(UnsafeNativeMethods.FixUpDllFileName(UnsafeNativeMethods.MaybeCombinePath(baseDirectory, libraryFileNameOnly))))
        return false;
      if (processorArchitecture == null)
        processorArchitecture = UnsafeNativeMethods.GetProcessorArchitecture();
      if (processorArchitecture == null)
        return false;
      string str = UnsafeNativeMethods.FixUpDllFileName(UnsafeNativeMethods.MaybeCombinePath(UnsafeNativeMethods.MaybeCombinePath(baseDirectory, processorArchitecture), libraryFileNameOnly));
      if (!File.Exists(str))
      {
        string platformName = UnsafeNativeMethods.GetPlatformName(processorArchitecture);
        if (platformName == null)
          return false;
        str = UnsafeNativeMethods.FixUpDllFileName(UnsafeNativeMethods.MaybeCombinePath(UnsafeNativeMethods.MaybeCombinePath(baseDirectory, platformName), libraryFileNameOnly));
        if (!File.Exists(str))
          return false;
      }
      try
      {
        try
        {
          Trace.WriteLine(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Native library pre-loader is trying to load native SQLite library \"{0}\"...", (object) str));
        }
        catch
        {
        }
        nativeModuleFileName = str;
        nativeModuleHandle = NativeLibraryHelper.LoadLibrary(str);
        return nativeModuleHandle != IntPtr.Zero;
      }
      catch (Exception ex)
      {
        try
        {
          int lastWin32Error = Marshal.GetLastWin32Error();
          Trace.WriteLine(HelperMethods.StringFormat((IFormatProvider) CultureInfo.CurrentCulture, "Native library pre-loader failed to load native SQLite library \"{0}\" (getLastError = {1}): {2}", (object) str, (object) lastWin32Error, (object) ex));
        }
        catch
        {
        }
      }
      return false;
    }

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_bind_parameter_name_interop(
      IntPtr stmt,
      int index,
      ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_column_database_name_interop(
      IntPtr stmt,
      int index,
      ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_column_database_name16_interop(
      IntPtr stmt,
      int index,
      ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_column_decltype_interop(
      IntPtr stmt,
      int index,
      ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_column_decltype16_interop(
      IntPtr stmt,
      int index,
      ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_column_name_interop(IntPtr stmt, int index, ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_column_name16_interop(
      IntPtr stmt,
      int index,
      ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_column_origin_name_interop(
      IntPtr stmt,
      int index,
      ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_column_origin_name16_interop(
      IntPtr stmt,
      int index,
      ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_column_table_name_interop(
      IntPtr stmt,
      int index,
      ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_column_table_name16_interop(
      IntPtr stmt,
      int index,
      ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_column_text_interop(IntPtr stmt, int index, ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_column_text16_interop(
      IntPtr stmt,
      int index,
      ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_errmsg_interop(IntPtr db, ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern SQLiteErrorCode sqlite3_prepare_interop(
      IntPtr db,
      IntPtr pSql,
      int nBytes,
      ref IntPtr stmt,
      ref IntPtr ptrRemain,
      ref int nRemain);

    [DllImport("SQLite.Interop.dll")]
    internal static extern SQLiteErrorCode sqlite3_table_column_metadata_interop(
      IntPtr db,
      byte[] dbName,
      byte[] tblName,
      byte[] colName,
      ref IntPtr ptrDataType,
      ref IntPtr ptrCollSeq,
      ref int notNull,
      ref int primaryKey,
      ref int autoInc,
      ref int dtLen,
      ref int csLen);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_value_text_interop(IntPtr p, ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_value_text16_interop(IntPtr p, ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern int sqlite3_malloc_size_interop(IntPtr p);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr interop_libversion();

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr interop_sourceid();

    [DllImport("SQLite.Interop.dll")]
    internal static extern int interop_compileoption_used(IntPtr zOptName);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr interop_compileoption_get(int N);

    [DllImport("SQLite.Interop.dll")]
    internal static extern SQLiteErrorCode sqlite3_close_interop(IntPtr db);

    [DllImport("SQLite.Interop.dll")]
    internal static extern SQLiteErrorCode sqlite3_create_function_interop(
      IntPtr db,
      byte[] strName,
      int nArgs,
      int nType,
      IntPtr pvUser,
      SQLiteCallback func,
      SQLiteCallback fstep,
      SQLiteFinalCallback ffinal,
      int needCollSeq);

    [DllImport("SQLite.Interop.dll")]
    internal static extern SQLiteErrorCode sqlite3_finalize_interop(IntPtr stmt);

    [DllImport("SQLite.Interop.dll")]
    internal static extern SQLiteErrorCode sqlite3_backup_finish_interop(IntPtr backup);

    [DllImport("SQLite.Interop.dll")]
    internal static extern SQLiteErrorCode sqlite3_blob_close_interop(IntPtr blob);

    [DllImport("SQLite.Interop.dll")]
    internal static extern SQLiteErrorCode sqlite3_open_interop(
      byte[] utf8Filename,
      byte[] vfsName,
      SQLiteOpenFlagsEnum flags,
      int extFuncs,
      ref IntPtr db);

    [DllImport("SQLite.Interop.dll")]
    internal static extern SQLiteErrorCode sqlite3_open16_interop(
      byte[] utf8Filename,
      byte[] vfsName,
      SQLiteOpenFlagsEnum flags,
      int extFuncs,
      ref IntPtr db);

    [DllImport("SQLite.Interop.dll")]
    internal static extern SQLiteErrorCode sqlite3_reset_interop(IntPtr stmt);

    [DllImport("SQLite.Interop.dll")]
    internal static extern int sqlite3_changes_interop(IntPtr db);

    [DllImport("SQLite.Interop.dll")]
    internal static extern IntPtr sqlite3_context_collseq_interop(
      IntPtr context,
      ref int type,
      ref int enc,
      ref int len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern int sqlite3_context_collcompare_interop(
      IntPtr context,
      byte[] p1,
      int p1len,
      byte[] p2,
      int p2len);

    [DllImport("SQLite.Interop.dll")]
    internal static extern SQLiteErrorCode sqlite3_cursor_rowid_interop(
      IntPtr stmt,
      int cursor,
      ref long rowid);

    [DllImport("SQLite.Interop.dll")]
    internal static extern SQLiteErrorCode sqlite3_index_column_info_interop(
      IntPtr db,
      byte[] catalog,
      byte[] IndexName,
      byte[] ColumnName,
      ref int sortOrder,
      ref int onError,
      ref IntPtr Collation,
      ref int colllen);

    [DllImport("SQLite.Interop.dll")]
    internal static extern int sqlite3_table_cursor_interop(IntPtr stmt, int db, int tableRootPage);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_libversion();

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_libversion_number();

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_sourceid();

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_compileoption_used(IntPtr zOptName);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_compileoption_get(int N);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_enable_shared_cache(int enable);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_enable_load_extension(IntPtr db, int enable);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_load_extension(
      IntPtr db,
      byte[] fileName,
      byte[] procName,
      ref IntPtr pError);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_overload_function(
      IntPtr db,
      IntPtr zName,
      int nArgs);

    [DllImport("SQLite.Interop.dll", CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_win32_set_directory(uint type, string value);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_win32_reset_heap();

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_win32_compact_heap(ref uint largest);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_malloc(int n);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_realloc(IntPtr p, int n);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_free(IntPtr p);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_open_v2(
      byte[] utf8Filename,
      ref IntPtr db,
      SQLiteOpenFlagsEnum flags,
      byte[] vfsName);

    [DllImport("SQLite.Interop.dll", CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_open16(string fileName, ref IntPtr db);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_interrupt(IntPtr db);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern long sqlite3_last_insert_rowid(IntPtr db);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_changes(IntPtr db);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern long sqlite3_memory_used();

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern long sqlite3_memory_highwater(int resetFlag);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_shutdown();

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_busy_timeout(IntPtr db, int ms);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_clear_bindings(IntPtr stmt);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_bind_blob(
      IntPtr stmt,
      int index,
      byte[] value,
      int nSize,
      IntPtr nTransient);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_bind_double(
      IntPtr stmt,
      int index,
      double value);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_bind_int(IntPtr stmt, int index, int value);

    [DllImport("SQLite.Interop.dll", EntryPoint = "sqlite3_bind_int", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_bind_uint(IntPtr stmt, int index, uint value);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_bind_int64(IntPtr stmt, int index, long value);

    [DllImport("SQLite.Interop.dll", EntryPoint = "sqlite3_bind_int64", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_bind_uint64(IntPtr stmt, int index, ulong value);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_bind_null(IntPtr stmt, int index);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_bind_text(
      IntPtr stmt,
      int index,
      byte[] value,
      int nlen,
      IntPtr pvReserved);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_bind_parameter_count(IntPtr stmt);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_bind_parameter_index(IntPtr stmt, byte[] strName);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_column_count(IntPtr stmt);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_step(IntPtr stmt);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_stmt_readonly(IntPtr stmt);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern double sqlite3_column_double(IntPtr stmt, int index);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_column_int(IntPtr stmt, int index);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern long sqlite3_column_int64(IntPtr stmt, int index);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_column_blob(IntPtr stmt, int index);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_column_bytes(IntPtr stmt, int index);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_column_bytes16(IntPtr stmt, int index);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern TypeAffinity sqlite3_column_type(IntPtr stmt, int index);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_create_collation(
      IntPtr db,
      byte[] strName,
      int nType,
      IntPtr pvUser,
      SQLiteCollation func);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_aggregate_count(IntPtr context);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_value_blob(IntPtr p);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_value_bytes(IntPtr p);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_value_bytes16(IntPtr p);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern double sqlite3_value_double(IntPtr p);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_value_int(IntPtr p);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern long sqlite3_value_int64(IntPtr p);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern TypeAffinity sqlite3_value_type(IntPtr p);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_blob(
      IntPtr context,
      byte[] value,
      int nSize,
      IntPtr pvReserved);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_double(IntPtr context, double value);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_error(IntPtr context, byte[] strErr, int nLen);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_error_code(IntPtr context, SQLiteErrorCode value);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_error_toobig(IntPtr context);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_error_nomem(IntPtr context);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_value(IntPtr context, IntPtr value);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_zeroblob(IntPtr context, int nLen);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_int(IntPtr context, int value);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_int64(IntPtr context, long value);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_null(IntPtr context);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_text(
      IntPtr context,
      byte[] value,
      int nLen,
      IntPtr pvReserved);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_aggregate_context(IntPtr context, int nBytes);

    [DllImport("SQLite.Interop.dll", CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_bind_text16(
      IntPtr stmt,
      int index,
      string value,
      int nlen,
      IntPtr pvReserved);

    [DllImport("SQLite.Interop.dll", CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_error16(IntPtr context, string strName, int nLen);

    [DllImport("SQLite.Interop.dll", CharSet = CharSet.Unicode, CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_result_text16(
      IntPtr context,
      string strName,
      int nLen,
      IntPtr pvReserved);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_key(IntPtr db, byte[] key, int keylen);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_rekey(IntPtr db, byte[] key, int keylen);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_progress_handler(
      IntPtr db,
      int ops,
      SQLiteProgressCallback func,
      IntPtr pvUser);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_set_authorizer(
      IntPtr db,
      SQLiteAuthorizerCallback func,
      IntPtr pvUser);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_update_hook(
      IntPtr db,
      SQLiteUpdateCallback func,
      IntPtr pvUser);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_commit_hook(
      IntPtr db,
      SQLiteCommitCallback func,
      IntPtr pvUser);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_trace(IntPtr db, SQLiteTraceCallback func, IntPtr pvUser);

    [DllImport("SQLite.Interop.dll", EntryPoint = "sqlite3_config", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_config_none(SQLiteConfigOpsEnum op);

    [DllImport("SQLite.Interop.dll", EntryPoint = "sqlite3_config", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_config_int(SQLiteConfigOpsEnum op, int value);

    [DllImport("SQLite.Interop.dll", EntryPoint = "sqlite3_config", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_config_log(
      SQLiteConfigOpsEnum op,
      SQLiteLogCallback func,
      IntPtr pvUser);

    [DllImport("SQLite.Interop.dll", EntryPoint = "sqlite3_db_config", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_db_config_int_refint(
      IntPtr db,
      SQLiteConfigDbOpsEnum op,
      int value,
      ref int result);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_rollback_hook(
      IntPtr db,
      SQLiteRollbackCallback func,
      IntPtr pvUser);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_db_handle(IntPtr stmt);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_db_release_memory(IntPtr db);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_db_filename(IntPtr db, IntPtr dbName);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_db_readonly(IntPtr db, IntPtr dbName);

    [DllImport("SQLite.Interop.dll", EntryPoint = "sqlite3_db_filename", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_db_filename_bytes(IntPtr db, byte[] dbName);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_next_stmt(IntPtr db, IntPtr stmt);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_exec(
      IntPtr db,
      byte[] strSql,
      IntPtr pvCallback,
      IntPtr pvParam,
      ref IntPtr errMsg);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_release_memory(int nBytes);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_get_autocommit(IntPtr db);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_extended_result_codes(IntPtr db, int onoff);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_errcode(IntPtr db);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_extended_errcode(IntPtr db);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_errstr(SQLiteErrorCode rc);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_log(SQLiteErrorCode iErrCode, byte[] zFormat);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_file_control(
      IntPtr db,
      byte[] zDbName,
      int op,
      IntPtr pArg);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_backup_init(
      IntPtr destDb,
      byte[] zDestName,
      IntPtr sourceDb,
      byte[] zSourceName);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_backup_step(IntPtr backup, int nPage);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_backup_remaining(IntPtr backup);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_backup_pagecount(IntPtr backup);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_blob_close(IntPtr blob);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern int sqlite3_blob_bytes(IntPtr blob);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_blob_open(
      IntPtr db,
      byte[] dbName,
      byte[] tblName,
      byte[] colName,
      long rowId,
      int flags,
      ref IntPtr ptrBlob);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_blob_read(
      IntPtr blob,
      [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
      int count,
      int offset);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_blob_reopen(IntPtr blob, long rowId);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_blob_write(
      IntPtr blob,
      [MarshalAs(UnmanagedType.LPArray)] byte[] buffer,
      int count,
      int offset);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern SQLiteErrorCode sqlite3_declare_vtab(IntPtr db, IntPtr zSQL);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_mprintf(IntPtr format, __arglist);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern IntPtr sqlite3_create_disposable_module(
      IntPtr db,
      IntPtr name,
      ref UnsafeNativeMethods.sqlite3_module module,
      IntPtr pClientData,
      UnsafeNativeMethods.xDestroyModule xDestroy);

    [DllImport("SQLite.Interop.dll", CallingConvention = CallingConvention.Cdecl)]
    internal static extern void sqlite3_dispose_module(IntPtr pModule);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xCreate(
      IntPtr pDb,
      IntPtr pAux,
      int argc,
      IntPtr argv,
      ref IntPtr pVtab,
      ref IntPtr pError);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xConnect(
      IntPtr pDb,
      IntPtr pAux,
      int argc,
      IntPtr argv,
      ref IntPtr pVtab,
      ref IntPtr pError);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xBestIndex(IntPtr pVtab, IntPtr pIndex);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xDisconnect(IntPtr pVtab);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xDestroy(IntPtr pVtab);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xOpen(IntPtr pVtab, ref IntPtr pCursor);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xClose(IntPtr pCursor);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xFilter(
      IntPtr pCursor,
      int idxNum,
      IntPtr idxStr,
      int argc,
      IntPtr argv);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xNext(IntPtr pCursor);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate int xEof(IntPtr pCursor);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xColumn(IntPtr pCursor, IntPtr pContext, int index);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xRowId(IntPtr pCursor, ref long rowId);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xUpdate(IntPtr pVtab, int argc, IntPtr argv, ref long rowId);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xBegin(IntPtr pVtab);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xSync(IntPtr pVtab);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xCommit(IntPtr pVtab);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xRollback(IntPtr pVtab);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate int xFindFunction(
      IntPtr pVtab,
      int nArg,
      IntPtr zName,
      ref SQLiteCallback callback,
      ref IntPtr pUserData);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xRename(IntPtr pVtab, IntPtr zNew);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xSavepoint(IntPtr pVtab, int iSavepoint);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xRelease(IntPtr pVtab, int iSavepoint);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate SQLiteErrorCode xRollbackTo(IntPtr pVtab, int iSavepoint);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void xDestroyModule(IntPtr pClientData);

    internal struct sqlite3_module
    {
      public int iVersion;
      public UnsafeNativeMethods.xCreate xCreate;
      public UnsafeNativeMethods.xConnect xConnect;
      public UnsafeNativeMethods.xBestIndex xBestIndex;
      public UnsafeNativeMethods.xDisconnect xDisconnect;
      public UnsafeNativeMethods.xDestroy xDestroy;
      public UnsafeNativeMethods.xOpen xOpen;
      public UnsafeNativeMethods.xClose xClose;
      public UnsafeNativeMethods.xFilter xFilter;
      public UnsafeNativeMethods.xNext xNext;
      public UnsafeNativeMethods.xEof xEof;
      public UnsafeNativeMethods.xColumn xColumn;
      public UnsafeNativeMethods.xRowId xRowId;
      public UnsafeNativeMethods.xUpdate xUpdate;
      public UnsafeNativeMethods.xBegin xBegin;
      public UnsafeNativeMethods.xSync xSync;
      public UnsafeNativeMethods.xCommit xCommit;
      public UnsafeNativeMethods.xRollback xRollback;
      public UnsafeNativeMethods.xFindFunction xFindFunction;
      public UnsafeNativeMethods.xRename xRename;
      public UnsafeNativeMethods.xSavepoint xSavepoint;
      public UnsafeNativeMethods.xRelease xRelease;
      public UnsafeNativeMethods.xRollbackTo xRollbackTo;
    }

    internal struct sqlite3_vtab
    {
      public IntPtr pModule;
      public int nRef;
      public IntPtr zErrMsg;
    }

    internal struct sqlite3_vtab_cursor
    {
      public IntPtr pVTab;
    }

    internal struct sqlite3_index_constraint
    {
      public int iColumn;
      public SQLiteIndexConstraintOp op;
      public byte usable;
      public int iTermOffset;

      public sqlite3_index_constraint(SQLiteIndexConstraint constraint)
        : this()
      {
        if (constraint == null)
          return;
        this.iColumn = constraint.iColumn;
        this.op = constraint.op;
        this.usable = constraint.usable;
        this.iTermOffset = constraint.iTermOffset;
      }
    }

    internal struct sqlite3_index_orderby
    {
      public int iColumn;
      public byte desc;

      public sqlite3_index_orderby(SQLiteIndexOrderBy orderBy)
        : this()
      {
        if (orderBy == null)
          return;
        this.iColumn = orderBy.iColumn;
        this.desc = orderBy.desc;
      }
    }

    internal struct sqlite3_index_constraint_usage
    {
      public int argvIndex;
      public byte omit;

      public sqlite3_index_constraint_usage(SQLiteIndexConstraintUsage constraintUsage)
        : this()
      {
        if (constraintUsage == null)
          return;
        this.argvIndex = constraintUsage.argvIndex;
        this.omit = constraintUsage.omit;
      }
    }

    internal struct sqlite3_index_info
    {
      public int nConstraint;
      public IntPtr aConstraint;
      public int nOrderBy;
      public IntPtr aOrderBy;
      public IntPtr aConstraintUsage;
      public int idxNum;
      public string idxStr;
      public int needToFreeIdxStr;
      public int orderByConsumed;
      public double estimatedCost;
      public long estimatedRows;
      public SQLiteIndexFlags idxFlags;
      public long colUsed;
    }
  }
}


--- UnsafeNativeMethodsPosix.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.UnsafeNativeMethodsPosix
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;
using System.Security;

#nullable disable
namespace System.Data.SQLite
{
  [SuppressUnmanagedCodeSecurity]
  internal static class UnsafeNativeMethodsPosix
  {
    internal const int RTLD_LAZY = 1;
    internal const int RTLD_NOW = 2;
    internal const int RTLD_GLOBAL = 256;
    internal const int RTLD_LOCAL = 0;
    internal const int RTLD_DEFAULT = 258;

    [DllImport("__Internal", CharSet = CharSet.Ansi, CallingConvention = CallingConvention.Cdecl, SetLastError = true, ThrowOnUnmappableChar = true, BestFitMapping = false)]
    internal static extern IntPtr dlopen(string fileName, int mode);
  }
}


--- UnsafeNativeMethodsWin32.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.UnsafeNativeMethodsWin32
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

using System.Runtime.InteropServices;
using System.Security;

#nullable disable
namespace System.Data.SQLite
{
  [SuppressUnmanagedCodeSecurity]
  internal static class UnsafeNativeMethodsWin32
  {
    [DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true, ThrowOnUnmappableChar = true, BestFitMapping = false)]
    internal static extern IntPtr LoadLibrary(string fileName);
  }
}


--- UpdateEventArgs.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.UpdateEventArgs
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public class UpdateEventArgs : EventArgs
  {
    public readonly string Database;
    public readonly string Table;
    public readonly UpdateEventType Event;
    public readonly long RowId;

    internal UpdateEventArgs(string database, string table, UpdateEventType eventType, long rowid)
    {
      this.Database = database;
      this.Table = table;
      this.Event = eventType;
      this.RowId = rowid;
    }
  }
}


--- UpdateEventType.cs ---

﻿// Decompiled with JetBrains decompiler
// Type: System.Data.SQLite.UpdateEventType
// Assembly: System.Data.SQLite, Version=1.0.103.0, Culture=neutral, PublicKeyToken=db937bc2d44ff139
// MVID: 386C6C7E-4AF4-46DD-83BA-B8B7485E47C2
// Assembly location: F:\tekst\DoingTomorrow\Zenner_Software\program_filer\System.Data.SQLite.dll

#nullable disable
namespace System.Data.SQLite
{
  public enum UpdateEventType
  {
    Delete = 9,
    Insert = 18, // 0x00000012
    Update = 23, // 0x00000017
  }
}

